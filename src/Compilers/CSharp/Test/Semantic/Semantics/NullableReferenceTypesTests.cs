// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Test.Utilities;
using Microsoft.CodeAnalysis.Test.Utilities;
using Roslyn.Test.Utilities;
using Xunit;
using static Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations;

namespace Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics
{
    public class NullableReferenceTypesTests : CSharpTestBase
    {
        [Fact]
        public void Test0()
        {
            var source = @"
class C
{
    static void Main()
    {
        string? x = null;
    }
}
";
            var c = CreateCompilation(source, parseOptions: TestOptions.Regular7);
            c.VerifyDiagnostics(
                // (6,15): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         string? x = null;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(6, 15),
                // (6,17): warning CS0219: The variable 'x' is assigned but its value is never used
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x").WithArguments("x").WithLocation(6, 17)
                );

            var c2 = CreateCompilation(source, parseOptions: TestOptions.Regular8);
            c2.VerifyDiagnostics(
                // (6,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 15),
                // (6,17): warning CS0219: The variable 'x' is assigned but its value is never used
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x").WithArguments("x").WithLocation(6, 17)
                );
        }

        [Fact]
        public void Directive_Qualifiers()
        {
            var source =
@"#nullable
#nullable enable
#nullable disable
#nullable restore
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (1,10): error CS8637: Expected enable or disable
                // #nullable
                Diagnostic(ErrorCode.ERR_NullableDirectiveQualifierExpected, "").WithLocation(1, 10),
                // (4,11): error CS8637: Expected enable or disable
                // #nullable restore
                Diagnostic(ErrorCode.ERR_NullableDirectiveQualifierExpected, "restore").WithLocation(4, 11));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableDefault()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object, string?>*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object, string?>*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object, string?>*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (5,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F1;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 28),
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableFalse()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object, string?>*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object, string?>*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object, string?>*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullable(false));
            comp.VerifyDiagnostics(
                // (5,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F1;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 28),
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableTrue()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object!, string?>!*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object!, string?>!*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object!, string?>!*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullable(true));
            comp.VerifyDiagnostics(
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_PartialClasses()
        {
            var source0 =
@"class Base<T> { }
class Program
{
#nullable enable
    static void F(Base<object?> b)
    {
    }
    static void Main()
    {
        F(new C1());
        F(new C2());
        F(new C3());
        F(new C4());
        F(new C5());
        F(new C6());
        F(new C7());
        F(new C8());
        F(new C9());
    }
}";
            var source1 =
@"#pragma warning disable 8632
partial class C1 : Base<object> { }
partial class C2 { }
partial class C3 : Base<object> { }
#nullable disable
partial class C4 { }
partial class C5 : Base<object> { }
partial class C6 { }
#nullable enable
partial class C7 : Base<object> { }
partial class C8 { }
partial class C9 : Base<object> { }
";
            var source2 =
@"#pragma warning disable 8632
partial class C1 { }
partial class C4 : Base<object> { }
partial class C7 { }
#nullable disable
partial class C2 : Base<object> { }
partial class C5 { }
partial class C8 : Base<object> { }
#nullable enable
partial class C3 { }
partial class C6 : Base<object> { }
partial class C9 { }
";

            // -nullable (default):
            var comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'C3' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C3());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C3()").WithArguments("C3", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(12, 11),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (17,11): warning CS8620: Nullability of reference types in argument of type 'C8' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C8());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C8()").WithArguments("C8", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(17, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));

            // -nullable-:
            comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll.WithNullable(false));
            comp.VerifyDiagnostics(
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'C3' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C3());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C3()").WithArguments("C3", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(12, 11),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (17,11): warning CS8620: Nullability of reference types in argument of type 'C8' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C8());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C8()").WithArguments("C8", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(17, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));

            // -nullable+:
            comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll.WithNullable(true));
            comp.VerifyDiagnostics(
                // (10,11): warning CS8620: Nullability of reference types in argument of type 'C1' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C1());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C1()").WithArguments("C1", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(10, 11),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'C3' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C3());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C3()").WithArguments("C3", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(12, 11),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (17,11): warning CS8620: Nullability of reference types in argument of type 'C8' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C8());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C8()").WithArguments("C8", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(17, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_01()
        {
            var source =
@"#nullable enable
class Program
{
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
#nullable disable
    static void G()
    {
        F(null);
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (7,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(7, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_02()
        {
            var source =
@"class Program
{
#nullable disable
    static void G()
    {
        F(null);
    }
#nullable enable
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (12,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(12, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_03()
        {
            var source =
@"class Program
{
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
#nullable disable
    static void G()
    {
        F(null);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(6, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_04()
        {
            var source =
@"class Program
{
    static void G()
    {
        F(null);
    }
#nullable enable
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesFalse());
            comp.VerifyDiagnostics(
                // (11,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(11, 11));
        }

        [WorkItem(30862, "https://github.com/dotnet/roslyn/issues/30862")]
        [Fact]
        public void DirectiveDisableWarningEnable()
        {
            var source =
@"#nullable enable
class Program
{
    static void F(object x)
    {
    }
#nullable disable
    static void F1(object? y, object? z)
    {
        F(y);
#pragma warning restore 8604
        F(z); // 1
    }
    static void F2(object? w)
    {
        F(w); // 2
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (8,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F1(object? y, object? z)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 26),
                // (8,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F1(object? y, object? z)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 37),
                // (14,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F2(object? w)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 26));
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnNonNullExpression()
        {
            var source = @"
class C
{
    void M(object o)
    {
        if (o is string)
        {
            o.ToString();
        }
        else
        {
            o.ToString();
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnMaybeNullExpression()
        {
            var source = @"
class C
{
    static void Main(object? o)
    {
        if (o is string)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // 1
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnUnconstrainedType()
        {
            var source = @"
class C
{
    static void M<T>(T t)
    {
        if (t is string)
        {
            t.ToString();
        }
        else
        {
            t.ToString(); // 1
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(12, 13)
                );
        }

        [Fact]
        public void OmittedCall()
        {
            var source = @"
partial class C
{
    void M(string? x)
    {
        OmittedMethod(x);
    }
    partial void OmittedMethod(string x);
}
";

            var c = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular8, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (6,23): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.OmittedMethod(string x)'.
                //         OmittedMethod(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "void C.OmittedMethod(string x)").WithLocation(6, 23)
                );
        }

        [Fact]
        public void OmittedInitializerCall()
        {
            var source = @"
using System.Collections;
partial class Collection : IEnumerable
{
    void M(string? x)
    {
        _ = new Collection() { x };
    }
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    partial void Add(string x);
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,32): warning CS8604: Possible null reference argument for parameter 'x' in 'void Collection.Add(string x)'.
                //         _ = new Collection() { x };
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "void Collection.Add(string x)").WithLocation(7, 32)
                );
        }

        [Fact]
        public void UpdateArrayRankSpecifier()
        {
            var source = @"
class C
{
    static void Main()
    {
        object[]? x = null;
    }
}
";
            var tree = Parse(source);
            var specifier = tree.GetRoot().DescendantNodes().OfType<ArrayRankSpecifierSyntax>().Single();
            Assert.Equal("[]?", specifier.ToString());

            var newSpecifier = specifier.Update(
                specifier.OpenBracketToken,
                SyntaxFactory.SeparatedList<ExpressionSyntax>(
                    new[] { SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(3)) }),
                specifier.CloseBracketToken);
            Assert.Equal("[3]?", newSpecifier.ToString());
        }

        [Fact]
        public void TestUnaryNegation()
        {
            // This test verifies that we no longer crash hitting an assertion
            var source = @"
public class C<T>
{
    C(C<object> c) => throw null;
    void M(bool b)
    {
        _ = new C<object>(!b);
    }
    public static implicit operator C<T>(T x) => throw null;
}
";

            var c = CreateCompilation(source, parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics();
        }

        [Fact]
        public void UnconstrainedAndErrorNullableFields()
        {
            var source = @"
public class C<T>
{
    public T? field;
    public Unknown? field2;
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (5,12): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     public Unknown? field2;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(5, 12),
                // (4,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? field;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 12),
                // (2,14): warning CS8618: Non-nullable field 'field' is uninitialized.
                // public class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "field").WithLocation(2, 14)
                );
        }

        [Fact]
        public void NoNullableAnalysisWithoutNonNullTypes()
        {
            var source = @"
class C
{
    void M(string z)
    {
        z = null;
        z.ToString();
    }
}
" + NonNullTypesOn() + @"
class C2
{
    void M(string z)
    {
        z = null; // 1
        z.ToString(); // 2
    }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics(
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = null; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(15, 13),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(16, 9)
                );

            var c2 = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            c2.VerifyDiagnostics(
                // (10,2): error CS8370: Feature 'nullable reference types' is not available in C# 7.3. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(10, 2)
                );
        }

        [Fact]
        public void NonNullTypesOnPartialSymbol()
        {
            var source = @"
" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial void M();
}
" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial void M() { }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics(
                );
        }

        [Fact(Skip = "Hits assertion in CheckValueKind")]
        public void SuppressionAsLValue()
        {
            var source = @"
class C
{
    void M(string? x)
    {
        ref string y = ref x;
        ref string y2 = ref x;
        (y2! = ref y) = ref y;
    }
}
";
            // https://github.com/dotnet/roslyn/issues/29710 should we produce an error for misuse of suppression on an L-value?
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressionOnUnconstrainedTypeParameter()
        {
            var source = @"
class C
{
    void M<T>(T t)
    {
        t!.ToString();
    }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics(
                // (6,10): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         t!.ToString();
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 10)
                );

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressionWithoutNonNullTypes()
        {
            var source = @"
[System.Obsolete("""", true!)] // 1, 2
class C
{
    string x = null!; // 3, 4
    static void Main(string z = null!) // 5
    {
        string y = null!; // 6, 7
    }
}
";
            var c = CreateCompilation(source);
            c.VerifyEmitDiagnostics(
                // (2,26): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                // [System.Obsolete("", true!)] // 1, 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(2, 26),
                // (2,22): error CS8624: The suppression operator (!) can only be applied to reference types.
                // [System.Obsolete("", true!)] // 1, 2
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "true!").WithLocation(2, 22),
                // (6,37): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //     static void Main(string z = null!) // 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 37),
                // (5,20): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //     string x = null!; // 3, 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(5, 20),
                // (8,24): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         string y = null!; // 6, 7
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 24),
                // (8,16): warning CS0219: The variable 'y' is assigned but its value is never used
                //         string y = null!; // 6, 7
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "y").WithArguments("y").WithLocation(8, 16),
                // (5,12): warning CS0414: The field 'C.x' is assigned but its value is never used
                //     string x = null!; // 3, 4
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "x").WithArguments("C.x").WithLocation(5, 12)
                );
        }

        [Fact, WorkItem(26812, "https://github.com/dotnet/roslyn/issues/26812")]
        public void DoubleAssignment()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using static System.Console;
class C
{
    static void Main()
    {
        string? x;
        x = x = """";
        WriteLine(x.Length);
        string? y;
        x = y = """";
        WriteLine(x.Length);
        WriteLine(y.Length);
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithConversionFromExpression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C 
{
    public void M() 
    {
        uint a = 0;
        uint x = true ? a : 1;
        uint y = true ? 1 : a;
    }
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_ConstantTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = new C();
        C x = true ? c : 1;
        C y = true ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (8,22): warning CS8601: Possible null reference assignment.
                //         C y = true ? 1 : c;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "1").WithLocation(8, 22)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_ConstantFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = new C();
        C x = false ? c : 1;
        C y = false ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,27): warning CS8601: Possible null reference assignment.
                //         C x = false ? c : 1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "1").WithLocation(7, 27)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_NotConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M(bool b)
    {
        C c = new C();
        C x = b ? c : 1;
        C y = b ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,23): warning CS8601: Possible null reference assignment.
                //         C x = b ? c : 1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "1").WithLocation(7, 23),
                // (8,19): warning CS8601: Possible null reference assignment.
                //         C y = b ? 1 : c;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "1").WithLocation(8, 19)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion2()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = null!;
        int x = true ? c : 1;
        int y = true ? 1 : c;

        C? c2 = null;
        int x2 = true ? c2 : 1;
        int y2 = true ? 1 : c2;
    }
    public static implicit operator int(C i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (11,25): warning CS8604: Possible null reference argument for parameter 'i' in 'C.implicit operator int(C i)'.
                //         int x2 = true ? c2 : 1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "c2").WithArguments("i", "C.implicit operator int(C i)").WithLocation(11, 25)
                );
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes()
        {
            var source = @"
class C<T> where T : class
{
    static string? field = M2(out string? x1); // warn 1 and 2
    static string? P // warn 3
    {
        get
        {
            string? x2 = null; // warn 4
            return x2;
        }
    }
    static string? MethodWithLocalFunction() // warn 5
    {
        string? x3 = local(null); // warn 6
        return x3;

        string? local(C<string?>? x) // warn 7, 8 and 9
        {
            string? x4 = null; // warn 10
            return x4;
        }
    }
    static string? Lambda() // warn 11
    {
        System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
        {
            string? x6 = null; // warn 15
            return x6;
        };
        return x5(null);
    }
    static string M2(out string? x4) => throw null; // warn 16
    static string M3(C<string?> x, C<string> y) => throw null; // warn 17
    delegate string? MyDelegate(C<string?> x); // warn 18 and 19
    event MyDelegate? Event; // warn 20
    void M4() { Event(new C<string?>()); } // warn 21
    class D<T2> where T2 : T? { } // warn 22
    class D2 : C<string?> { } // warn 23
    public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
    class D3
    {
        D3(C<T?> x) => throw null; // warn 26
    }
    public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
}
";
            var expectedDiagnostics = new[] {
                // (5,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? P // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 18),
                // (13,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? MethodWithLocalFunction() // warn 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 18),
                // (24,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? Lambda() // warn 11
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(24, 18),
                // (33,32): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string M2(out string? x4) => throw null; // warn 16
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 32),
                // (34,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string M3(C<string?> x, C<string> y) => throw null; // warn 17
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(34, 30),
                // (36,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     event MyDelegate? Event; // warn 20
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(36, 21),
                // (40,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(40, 47),
                // (40,46): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(40, 46),
                // (40,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(40, 22),
                // (40,21): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(40, 21),
                // (45,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(45, 33),
                // (45,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(45, 18),
                // (4,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? field = M2(out string? x1); // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 18),
                // (43,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(43, 15),
                // (43,14): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(43, 14),
                // (35,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(35, 20),
                // (35,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(35, 41),
                // (38,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     class D<T2> where T2 : T? { } // warn 22
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 29),
                // (38,28): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     class D<T2> where T2 : T? { } // warn 22
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(38, 28),
                // (39,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     class D2 : C<string?> { } // warn 23
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 24),
                // (4,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? field = M2(out string? x1); // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 41),
                // (9,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x2 = null; // warn 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 19),
                // (15,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? x3 = local(null); // warn 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 15),
                // (20,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x4 = null; // warn 10
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 19),
                // (18,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 31),
                // (18,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 33),
                // (18,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 15),
                // (26,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 27),
                // (26,36): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 36),
                // (26,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 51),
                // (28,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x6 = null; // warn 15
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(28, 19),
                // (37,35): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void M4() { Event(new C<string?>()); } // warn 21
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(37, 35)
            };

            // https://github.com/dotnet/roslyn/issues/29839: are annotations on events meaningful/allowed?

            var c = CreateCompilation(source);
            c.VerifyDiagnostics(expectedDiagnostics);

            var c2 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c2.VerifyDiagnostics(
                // (43,14): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("C<T>", "T", "T?").WithLocation(43, 14),
                // (35,35): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(35, 35),
                // (18,25): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(18, 25),
                // (37,29): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //     void M4() { Event(new C<string?>()); } // warn 21
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(37, 29),
                // (37,17): warning CS8602: Possible dereference of a null reference.
                //     void M4() { Event(new C<string?>()); } // warn 21 and 22
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "Event").WithLocation(37, 17)
                );

            var c3 = CreateCompilation(new[] { source }, options: WithNonNullTypesFalse());
            c3.VerifyDiagnostics(expectedDiagnostics);
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes_GenericType()
        {
            var source = @"
public class C<T> where T : class
{
    public T? M(T? x1) // warn 1 and 2
    {
        T? y1 = x1; // warn 3
        return y1;
    }
}
public class E<T> where T : struct
{
    public T? M(T? x2)
    {
        T? y2 = x2;
        return y2;
    }
}
";
            CSharpCompilation c = CreateCompilation(source);
            c.VerifyDiagnostics(
                // (4,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 18),
                // (4,17): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 17),
                // (4,13): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 13),
                // (4,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 12),
                // (6,10): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         T? y1 = x1; // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 10),
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? y1 = x1; // warn 3
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9)
                );

            var client = @"
class Client
{
    void M(C<string> c)
    {
        c.M("""").ToString();
    }
}
";
            var comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.ToMetadataReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();

            comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.EmitToImageReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );

            comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.ToMetadataReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes_AttributeArgument()
        {
            var source =
@"class AAttribute : System.Attribute
{
    internal AAttribute(object o) { }
}
class B<T> { }
[A(typeof(object?))] // 1
class C1 { }
[A(typeof(int?))]
class C2 { }
[A(typeof(B<object?>))] // 2
class C3 { }
[A(typeof(B<int?>))]
class C4 { }";

            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (6,17): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // [A(typeof(object?))] // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 17),
                // (10,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // [A(typeof(B<object?>))] // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 19));

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void EmbeddedAttribute_Injected()
        {
            var source = @"
" + NonNullTypesOn() + @"
[module: Microsoft.CodeAnalysis.Embedded]

[Microsoft.CodeAnalysis.Embedded]
public class C
{
    [Microsoft.CodeAnalysis.Embedded]
    public int field = 0;
    [Microsoft.CodeAnalysis.Embedded]
    void M() { }
}
[Microsoft.CodeAnalysis.Embedded]
interface I { }
";
            var comp = CreateCompilation(source);
            comp.VerifyEmitDiagnostics();

            var type = (NamedTypeSymbol)comp.GlobalNamespace.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute");
            Assert.NotNull(type);
            Assert.Equal(0, type.Arity);
            Assert.Equal("System.Attribute", type.BaseTypeNoUseSiteDiagnostics.ToTestDisplayString());
            Assert.True(type.CanBeReferencedByName);
            Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute..ctor()", type.Constructors.Single().ToTestDisplayString());
            Assert.Null(type.ContainingType);
            Assert.Empty(type.DeclaringSyntaxReferences);
            Assert.True(type.HasCodeAnalysisEmbeddedAttribute);
            Assert.False(type.HasDeclarativeSecurity);
            Assert.False(type.HasSpecialName);
            Assert.False(type.HasUnsupportedMetadata);
            Assert.Empty(type.Indexers);
            Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute..ctor()", type.InstanceConstructors.Single().ToTestDisplayString());
            Assert.False(type.IsAbstract);
            Assert.False(type.IsAnonymousType);
            Assert.False(type.IsByRefLikeType);
            Assert.False(type.IsComImport);
            Assert.False(type.IsConditional);
            Assert.True(type.IsDefinition);
            Assert.False(type.IsExtern);
            Assert.False(type.IsGenericType);
            Assert.True(type.IsImplicitlyDeclared);
            Assert.False(type.IsInterface);
            Assert.False(type.IsManagedType);
            Assert.False(type.IsNamespace);
            Assert.True(type.IsReferenceType);
            Assert.True(type.IsSealed);
            Assert.False(type.IsSerializable);
            Assert.False(type.IsStatic);
            Assert.False(type.IsTupleType);
            Assert.True(type.IsType);
            Assert.Equal(SymbolKind.NamedType, type.Kind);
            Assert.Equal("C#", type.Language);
            Assert.Empty(type.Locations);
            Assert.Equal(new[] { ".ctor" }, type.MemberNames);
            Assert.False(type.MightContainExtensionMethods);
            Assert.Equal("EmbeddedAttribute", type.Name);
            Assert.Null(type.NonNullTypes);
            Assert.Equal(SpecialType.None, type.SpecialType);
            Assert.Empty(type.StaticConstructors);
            Assert.Equal(TypeKind.Class, type.TypeKind);

            var codeAnalysis = type.ContainingNamespace;
            verifyEmptyNamespace(codeAnalysis, "CodeAnalysis");

            var microsoft = codeAnalysis.ContainingNamespace;
            verifyEmptyNamespace(microsoft, "Microsoft");

            Assert.True(microsoft.ContainingNamespace.IsGlobalNamespace);

            var type2 = comp.GetWellKnownType(WellKnownType.Microsoft_CodeAnalysis_EmbeddedAttribute);
            Assert.True(type.Equals(type2));
            Assert.Equal(Accessibility.Internal, type.DeclaredAccessibility);

            void verifyEmptyNamespace(INamespaceSymbol symbol, string expectedName)
            {
                Assert.Equal(expectedName, symbol.Name);
                Assert.Empty(symbol.DeclaringSyntaxReferences);
                Assert.Empty(symbol.Locations);
                Assert.True(symbol.IsImplicitlyDeclared);
                Assert.Equal(NamespaceKind.Module, symbol.NamespaceKind);
            }
        }

        [Fact]
        public void NonNullTypesAttribute_Injected_InCSharp7()
        {
            var comp = CreateCompilation("", options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.0", "8.0").WithLocation(1, 1)
                );

            Assert.True(comp.SourceModule.NonNullTypes);
            Assert.Empty(comp.SourceModule.GetAttributes());

            var type = (NamedTypeSymbol)comp.GlobalNamespace.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute");
            Assert.NotNull(type);
            Assert.Equal(0, type.Arity);
            Assert.Equal("System.Attribute", type.BaseTypeNoUseSiteDiagnostics.ToTestDisplayString());
            Assert.True(type.CanBeReferencedByName);
            Assert.Equal("System.Runtime.CompilerServices.NonNullTypesAttribute..ctor([System.Boolean flag = true])", type.Constructors.Single().ToTestDisplayString());
            Assert.Null(type.ContainingType);
            Assert.Empty(type.DeclaringSyntaxReferences);
            Assert.True(type.HasCodeAnalysisEmbeddedAttribute);
            Assert.False(type.HasDeclarativeSecurity);
            Assert.False(type.HasSpecialName);
            Assert.False(type.HasUnsupportedMetadata);
            Assert.Empty(type.Indexers);
            Assert.Equal("System.Runtime.CompilerServices.NonNullTypesAttribute..ctor([System.Boolean flag = true])", type.InstanceConstructors.Single().ToTestDisplayString());
            Assert.False(type.IsAbstract);
            Assert.False(type.IsAnonymousType);
            Assert.False(type.IsByRefLikeType);
            Assert.False(type.IsComImport);
            Assert.False(type.IsConditional);
            Assert.True(type.IsDefinition);
            Assert.False(type.IsExtern);
            Assert.False(type.IsGenericType);
            Assert.True(type.IsImplicitlyDeclared);
            Assert.False(type.IsInterface);
            Assert.False(type.IsManagedType);
            Assert.False(type.IsNamespace);
            Assert.True(type.IsReferenceType);
            Assert.True(type.IsSealed);
            Assert.False(type.IsSerializable);
            Assert.False(type.IsStatic);
            Assert.False(type.IsTupleType);
            Assert.True(type.IsType);
            Assert.Equal(SymbolKind.NamedType, type.Kind);
            Assert.Equal("C#", type.Language);
            Assert.Empty(type.Locations);
            Assert.Equal(new[] { ".ctor" }, type.MemberNames);
            Assert.False(type.MightContainExtensionMethods);
            Assert.Equal("NonNullTypesAttribute", type.Name);
            Assert.True(type.NonNullTypes);
            Assert.Equal(SpecialType.None, type.SpecialType);
            Assert.Empty(type.StaticConstructors);
            Assert.Equal(TypeKind.Class, type.TypeKind);

            var compilerServices = type.ContainingNamespace;
            verifyEmptyNamespace(compilerServices, "CompilerServices");

            var runtime = compilerServices.ContainingNamespace;
            verifyEmptyNamespace(runtime, "Runtime");

            var system = runtime.ContainingNamespace;
            verifyEmptyNamespace(system, "System");

            Assert.True(system.ContainingNamespace.IsGlobalNamespace);

            var type2 = comp.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_NonNullTypesAttribute);
            Assert.True(type.Equals(type2));
            Assert.Equal(Accessibility.Internal, type.DeclaredAccessibility);

            // https://github.com/dotnet/roslyn/issues/29683 CSharpCompilation.AbstractSymbolSearcher needs to inject namespaces and types too
            //Assert.True(comp.ContainsSymbolsWithName("NonNullTypesAttribute", SymbolFilter.Type));
            //Assert.Equal("System.Runtime.CompilerServices.NonNullTypesAttribute", comp.GetSymbolsWithName("NonNullTypesAttribute", SymbolFilter.Type).Single().ToTestDisplayString());
            //Assert.Equal("System.Runtime.CompilerServices.NonNullTypesAttribute", comp.GetSymbolsWithName(n => n == "NonNullTypesAttribute", SymbolFilter.Type).Single().ToTestDisplayString());

            //Assert.True(comp.ContainsSymbolsWithName("EmbeddedAttribute", SymbolFilter.Type));
            //Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute", comp.GetSymbolsWithName("EmbeddedAttribute", SymbolFilter.Type).Single().ToTestDisplayString());
            //Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute", comp.GetSymbolsWithName(n => n == "EmbeddedAttribute", SymbolFilter.Type).Single().ToTestDisplayString());

            void verifyEmptyNamespace(INamespaceSymbol symbol, string expectedName)
            {
                Assert.Equal(expectedName, symbol.Name);
                Assert.Empty(symbol.DeclaringSyntaxReferences);
                Assert.Empty(symbol.Locations);
                Assert.True(symbol.IsImplicitlyDeclared);
                Assert.Equal(NamespaceKind.Module, symbol.NamespaceKind);
            }
        }

        [Fact]
        public void NonNullTypesAttribute_False_Injected_InCSharp7()
        {
            var comp = CreateCompilation("", options: WithNonNullTypesFalse(), parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'False' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "False", "7.0", "8.0").WithLocation(1, 1)
                );

            Assert.False(comp.SourceModule.NonNullTypes);

            var type = (NamedTypeSymbol)comp.GlobalNamespace.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute");
            Assert.False(type.NonNullTypes);
        }

        [Fact]
        public void NullableOption()
        {
            var comp = CreateCompilation("", options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.0", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation("", options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesAttributeInMergedNamespaceSymbol()
        {
            var reference_cs = @"
namespace System.Runtime.CompilerServices
{
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool enabled = true) { }
    }
}";
            var reference = CreateCompilation(new[] { reference_cs });
            reference.VerifyDiagnostics();

            var comp_cs = @"
namespace System.Runtime.CompilerServices.NonNullTypesAttribute
{
    class C { }
}";
            var comp = CreateCompilation(new[] { comp_cs }, options: WithNonNullTypesTrue(), references: new[] { reference.ToMetadataReference() });
            // https://github.com/dotnet/roslyn/issues/30583: Report an error if we are unable to synthesize NonNullTypesAttribute application
            comp.VerifyEmitDiagnostics(
                //// (1,42): error CS0616: 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not an attribute class
                //// [module: System.Runtime.CompilerServices.NonNullTypes(true)]
                //Diagnostic(ErrorCode.ERR_NotAnAttributeClass, "NonNullTypes").WithArguments("System.Runtime.CompilerServices.NonNullTypesAttribute").WithLocation(1, 42)
                );

            var type = comp.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_NonNullTypesAttribute);
            Assert.True(type.IsErrorType());

            // https://github.com/dotnet/roslyn/issues/29683 CSharpCompilation.AbstractSymbolSearcher needs to inject namespaces and types too
            //Assert.False(comp.ContainsSymbolsWithName("NonNullTypesAttribute", SymbolFilter.Type));
            //Assert.Empty(comp.GetSymbolsWithName("NonNullTypesAttribute", SymbolFilter.Type));
            //Assert.Empty(comp.GetSymbolsWithName(n => n == "NonNullTypesAttribute", SymbolFilter.Type));

            //Assert.True(comp.ContainsSymbolsWithName("EmbeddedAttribute", SymbolFilter.Type));
            //Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute", comp.GetSymbolsWithName("EmbeddedAttribute", SymbolFilter.Type).Single().ToTestDisplayString());
            //Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute", comp.GetSymbolsWithName(n => n == "EmbeddedAttribute", SymbolFilter.Type).Single().ToTestDisplayString());
        }

        [Fact]
        public void NonNullTypesAttribute_NotInjectedIntoWrongNamespace()
        {
            var source = @"
namespace NotRoot.System { }
namespace NotSystem.Runtime { }
namespace NotRuntime.CompilerServices { }
";
            var comp = CreateCompilation(source);
            Assert.Empty(((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("NotRoot.System")).GetMembers());
            Assert.Empty(((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("NotSystem.Runtime")).GetMembers());
            Assert.Empty(((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("NotRuntime.CompilerServices")).GetMembers());
            Assert.Equal("System.Runtime.CompilerServices.NonNullTypesAttribute",
                ((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("System.Runtime.CompilerServices")).GetMembers().Single().ToTestDisplayString());
        }

        [Fact]
        public void EmbeddedAttribute_NotInjectedIntoWrongNamespace()
        {
            var source = @"
namespace NotRoot.Microsoft { }
namespace NotMicrosoft.CodeAnalysis { }
";
            var comp = CreateCompilation(source);
            Assert.Empty(((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("NotRoot.Microsoft")).GetMembers());
            Assert.Empty(((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("NotMicrosoft.CodeAnalysis")).GetMembers());
            Assert.Equal("Microsoft.CodeAnalysis.EmbeddedAttribute",
                ((NamespaceSymbol)comp.SourceModule.GlobalNamespace.GetMember("Microsoft.CodeAnalysis")).GetMembers().Single().ToTestDisplayString());
        }

        // https://github.com/dotnet/roslyn/issues/30144:
        // Test emitting netmodule (we won't inject NNT)
        // Test script

        [Fact]
        public void NonNullTypesAttribute_Injected()
        {
            NonNullTypesAttribute_Injected("", WithNonNullTypesTrue());
            NonNullTypesAttribute_Injected("", WithNonNullTypesFalse());
            NonNullTypesAttribute_Injected(
NonNullTypesOn() + @"
class C { }");
            NonNullTypesAttribute_Injected(
@"class C { 
" + NonNullTypesOn() + @"
public string s = null!; }");
            NonNullTypesAttribute_Injected(
@"class C {
" + NonNullTypesOn() + @"
public event System.Action e; void M() { e(); } }");
            NonNullTypesAttribute_Injected(
@"class C {
" + NonNullTypesOn() + @"
void M() { } }");
            NonNullTypesAttribute_Injected(
@"class C {
" + NonNullTypesOn() + @"
string P { get; set; } }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; class C { NonNullTypesAttribute M() => throw null; }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; class C { void M(NonNullTypesAttribute x) => throw null; }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; namespace System { class C { void M(NonNullTypesAttribute x) => throw null; } }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; namespace System.Runtime { class C { void M(NonNullTypesAttribute x) => throw null; } }");
            NonNullTypesAttribute_Injected("namespace System.Runtime.CompilerServices { class C { void M(NonNullTypesAttribute x) => throw null; } }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; class C { NonNullTypesAttribute field = null; void M() { if (field != null) field = null; } }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; class C { void M() { _ = new NonNullTypesAttribute(); } }");
            NonNullTypesAttribute_Injected("using System.Runtime.CompilerServices; class C { void M() { local(); void local() { _ = new NonNullTypesAttribute(); } } }");
        }

        private void NonNullTypesAttribute_Injected(string source, CSharpCompilationOptions options = null)
        {
            var comp = CreateCompilation(source, parseOptions: TestOptions.Regular8, options: options);
            comp.VerifyDiagnostics();

            Action<ModuleSymbol> validator = module =>
            {
                var nonNullTypesAttribute = (NamedTypeSymbol)module.GlobalNamespace.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute");
                Assert.NotNull(nonNullTypesAttribute);
                Assert.Equal(Accessibility.Internal, nonNullTypesAttribute.DeclaredAccessibility);
                Assert.True(nonNullTypesAttribute.IsSealed);
                Assert.Equal(SymbolKind.NamedType, nonNullTypesAttribute.Kind);

                var embeddedAttribute = module.GlobalNamespace.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute");
                Assert.NotNull(embeddedAttribute);

                var actualNonNullTypes = nonNullTypesAttribute.GetAttributes().Select(a => a.ToString()).ToArray();
                var actualEmbedded = embeddedAttribute.GetAttributes().Select(a => a.ToString()).ToArray();

                // https://github.com/dotnet/roslyn/issues/29672 AttributeData.ToString() prints out a different order on CoreCLR
                if (ExecutionConditionUtil.IsDesktop)
                {
                    if (module is PEModuleSymbol)
                    {
                        Assert.Equal(new[] {
                        "System.Runtime.CompilerServices.CompilerGeneratedAttribute",
                        "Microsoft.CodeAnalysis.EmbeddedAttribute",
                        "System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Event | System.AttributeTargets.Interface | System.AttributeTargets.Delegate)" },
                            actualNonNullTypes);
                        Assert.Equal(new[] {
                        "System.Runtime.CompilerServices.CompilerGeneratedAttribute",
                        "Microsoft.CodeAnalysis.EmbeddedAttribute" },
                            actualEmbedded);
                    }
                    else
                    {
                        Assert.Equal(new[] {
                        "System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Event | System.AttributeTargets.Interface | System.AttributeTargets.Delegate)" },
                            actualNonNullTypes);
                        Assert.Empty(actualEmbedded);
                    }
                }
            };

            CompileAndVerify(comp, sourceSymbolValidator: validator, symbolValidator: validator);
        }

        [Fact]
        public void NonNullTypesAttribute_Injected_WithAmbiguousUserDefinedType()
        {
            var source = @"
using System.Runtime.CompilerServices;
using N1;

[module: NonNullTypesAttribute(true)]
namespace N1
{
    public class NonNullTypesAttribute : System.Attribute
    {
        public NonNullTypesAttribute(bool flag) => throw null;
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (5,10): error CS0104: 'NonNullTypesAttribute' is an ambiguous reference between 'N1.NonNullTypesAttribute' and 'System.Runtime.CompilerServices.NonNullTypesAttribute'
                // [module: NonNullTypesAttribute(true)]
                Diagnostic(ErrorCode.ERR_AmbigContext, "NonNullTypesAttribute").WithArguments("NonNullTypesAttribute", "N1.NonNullTypesAttribute", "System.Runtime.CompilerServices.NonNullTypesAttribute").WithLocation(5, 10)
                );
        }

        [Fact]
        public void NonNullTypesAttribute_Injected_WithNonAmbiguousUserDefinedType()
        {
            var source = @"
using N1;
[module: NonNullTypesAttribute(true)]
namespace N1
{
    public class NonNullTypesAttribute : System.Attribute
    {
        public NonNullTypesAttribute(bool flag) => throw null;
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesAttribute_WithoutUsage()
        {
            var comp = CreateCompilation("class C { }", parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            Action<ModuleSymbol> sourceValidator = module =>
            {
                var nonNullTypes = (NamedTypeSymbol)module.GlobalNamespace.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute");
                Assert.NotNull(nonNullTypes);
                var embedded = (NamedTypeSymbol)module.GlobalNamespace.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute");
                Assert.NotNull(embedded);

                var system = (INamespaceSymbol)module.GlobalNamespace.GetMember("System");
                Assert.Equal(NamespaceKind.Module, system.NamespaceKind);
            };

            Action<ModuleSymbol> peValidator = module =>
            {
                var nonNullTypes = (NamedTypeSymbol)module.GlobalNamespace.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute");
                Assert.Null(nonNullTypes);
                var embedded = (NamedTypeSymbol)module.GlobalNamespace.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute");
                Assert.Null(embedded);

                var system = (INamespaceSymbol)module.GlobalNamespace.GetMember("System");
                Assert.Null(system);
            };
            CompileAndVerify(comp, sourceSymbolValidator: sourceValidator, symbolValidator: peValidator, verify: Verification.Skipped);
        }

        [Fact]
        public void NonNullTypesAttribute_WithoutAttribute()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    // missing Attribute
    public class ValueType { }
    public struct Boolean { }
    public class String { }
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1),
                // error CS0656: Missing compiler required member 'System.AttributeUsageAttribute..ctor'
                Diagnostic(ErrorCode.ERR_MissingPredefinedMember).WithArguments("System.AttributeUsageAttribute", ".ctor").WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1)
                );
        }

        [Fact]
        public void NonNullTypesAttribute_WithoutAttributeUsage()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    // missing AttributeUsageAttribute
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS0656: Missing compiler required member 'System.AttributeUsageAttribute..ctor'
                Diagnostic(ErrorCode.ERR_MissingPredefinedMember).WithArguments("System.AttributeUsageAttribute", ".ctor").WithLocation(1, 1)
                );
        }

        [Fact]
        public void EmbeddedAttribute_WithoutAttribute()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    // missing Attribute
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public struct Int32 { }
    public class Enum { }
}
namespace System.Runtime.InteropServices
{
    public enum UnmanagedType { }
}
class C<T> where T : unmanaged
{
}
";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1)
                );
        }

        [Fact]
        public void EmbeddedAttribute_WithoutAttributeUsage()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public struct Int32 { }
    public class Enum { }
    // missing AttributeUsage
}
namespace System.Runtime.InteropServices
{
    public enum UnmanagedType { }
}
class C<T> where T : unmanaged
{
}
";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"));
        }

        [Fact]
        public void NonNullTypesAttribute_WithoutAttributeUsageConstructor()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public class AttributeUsageAttribute : Attribute { /* missing ctor */ }
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS0656: Missing compiler required member 'System.AttributeUsageAttribute..ctor'
                Diagnostic(ErrorCode.ERR_MissingPredefinedMember).WithArguments("System.AttributeUsageAttribute", ".ctor").WithLocation(1, 1)
                );
        }

        [Fact]
        public void NonNullTypesAttribute_WithObsoleteAttributeUsageConstructor()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public class Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        [System.Obsolete(""obsolete"")]
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"));
        }

        [Fact]
        public void NonNullTypesAttribute_WithBadAttributeConstructor()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { public Attribute(bool ignored) { } }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public class Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) : base(true) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1));

            // https://github.com/dotnet/roslyn/issues/29732 We should not accumulate diagnostics with every attempt to emit
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1),
                // error CS1729: 'Attribute' does not contain a constructor that takes 0 arguments
                Diagnostic(ErrorCode.ERR_BadCtorArgCount).WithArguments("System.Attribute", "0").WithLocation(1, 1));
        }

        [Fact]
        public void NonNullTypesAttribute_WithAttributeUsage()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String { }
    public class Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
}
";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesAttribute_WithoutBool()
        {
            var source = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public class String { }
}
";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyEmitDiagnostics(CodeAnalysis.Emit.EmitOptions.Default.WithRuntimeMetadataVersion("v4.0.30319"),
                // error CS0518: Predefined type 'System.Boolean' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Boolean").WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Boolean' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Boolean").WithLocation(1, 1),
                // error CS0656: Missing compiler required member 'System.AttributeUsageAttribute..ctor'
                Diagnostic(ErrorCode.ERR_MissingPredefinedMember).WithArguments("System.AttributeUsageAttribute", ".ctor").WithLocation(1, 1)
                );
        }

        [Fact]
        public void NonNullTypesAttribute_AlreadyDefined()
        {
            var corlib_cs = @"
namespace System
{
    public struct Boolean { }
    public struct Void { }
    public abstract class ValueType { }
    public class Object { }
    public class Attribute { }
}
namespace System.Runtime.CompilerServices
{
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}
";
            var corlib = CreateEmptyCompilation(corlib_cs, parseOptions: TestOptions.Regular8);
            corlib.VerifyDiagnostics();
        }

        [Fact]
        public void NullableAttribute_NotRequiredCSharp7_01()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static async Task<string> F()
    {
        return await Task.FromResult(default(string));
    }
}";
            var comp = CreateCompilationWithMscorlib45(source, parseOptions: TestOptions.Regular7);
            comp.VerifyEmitDiagnostics();
        }

        [Fact]
        public void NullableAttribute_NotRequiredCSharp7_02()
        {
            var source =
@"using System;
using System.Threading.Tasks;
class C
{
    static async Task F<T>(Func<Task> f)
    {
        await G(async () =>
        {
            await f();
            return default(object);
        });
    }
    static async Task<TResult> G<TResult>(Func<Task<TResult>> f)
    {
        throw new NotImplementedException();
    }
}";
            var comp = CreateCompilationWithMscorlib45(source, parseOptions: TestOptions.Regular7);
            comp.VerifyEmitDiagnostics(
                // (13,32): warning CS1998: This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.
                //     static async Task<TResult> G<TResult>(Func<Task<TResult>> f)
                Diagnostic(ErrorCode.WRN_AsyncLacksAwaits, "G").WithLocation(13, 32));
        }

        [Fact, WorkItem(26739, "https://github.com/dotnet/roslyn/issues/26618")]
        public void SuppressionOnNullConvertedToConstrainedTypeParameterType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public T M<T>() where T : C
    {
        return null!;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MissingInt()
        {
            var source0 =
@"namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
}";
            var comp0 = CreateEmptyCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"enum E { A }
class C
{
    int F() => (int)E.A;
}";
            var comp = CreateEmptyCompilation(
                source,
                references: new[] { ref0 },
                parseOptions: TestOptions.Regular8);
            comp.VerifyEmitDiagnostics(
                // (1,6): error CS0518: Predefined type 'System.Int32' is not defined or imported
                // enum E { A }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "E").WithArguments("System.Int32").WithLocation(1, 6),
                // (4,5): error CS0518: Predefined type 'System.Int32' is not defined or imported
                //     int F() => (int)E.A;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "int").WithArguments("System.Int32").WithLocation(4, 5),
                // (4,17): error CS0518: Predefined type 'System.Int32' is not defined or imported
                //     int F() => (int)E.A;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "int").WithArguments("System.Int32").WithLocation(4, 17));
        }

        [Fact]
        public void MissingNullable()
        {
            var source = @"
namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
}";
            var source2 = @"
class C<T> where T : struct
{
    void M()
    {
        T? local = null;
        _ = local;
    }
}
";
            var comp = CreateEmptyCompilation(new[] { source, source2 });
            comp.VerifyDiagnostics(
                // (6,9): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //         T? local = null;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(6, 9)
                );

            var source3 = @"
class C<T> where T : struct
{
    void M(T? nullable) { }
}
";
            var comp2 = CreateEmptyCompilation(new[] { source, source3 });
            comp2.VerifyDiagnostics(
                // (4,12): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M(T? nullable) { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(4, 12)
                );

            var source4 = @"
class C<T> where T : struct
{
    void M<U>() where U : T? { }
}
";
            var comp3 = CreateEmptyCompilation(new[] { source, source4 });
            comp3.VerifyDiagnostics(
                // (4,27): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M<U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(4, 27),
                // (4,12): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M<U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "U").WithArguments("System.Nullable`1").WithLocation(4, 12)
                );
        }

        [ConditionalFact(typeof(DesktopOnly))]
        public void UnannotatedAssemblies_WithSomeExtraAnnotations()
        {
            // https://github.com/dotnet/roslyn/issues/29821 external annotations should be removed or fully designed/productized
            var comp = CreateCompilation("");
            comp.VerifyDiagnostics();
            var systemNamespace = comp.GetMember<NamedTypeSymbol>("System.Object").ContainingNamespace;

            var expected = ImmutableArray.Create(
"System.String! System.String.Concat(System.String?, System.String?)",
"System.Boolean System.Boolean.Parse(System.String!)",
"void System.Buffer.BlockCopy(System.Array!, System.Int32, System.Array!, System.Int32, System.Int32)",
"System.Byte System.Buffer.GetByte(System.Array!, System.Int32)",
"void System.Buffer.SetByte(System.Array!, System.Int32, System.Byte)",
"System.Int32 System.Buffer.ByteLength(System.Array!)",
"System.Byte System.Byte.Parse(System.String!)",
"System.Byte System.Byte.Parse(System.String!, System.Globalization.NumberStyles)",
"System.Byte System.Byte.Parse(System.String!, System.IFormatProvider)",
"System.Byte System.Byte.Parse(System.String!, System.Globalization.NumberStyles, System.IFormatProvider)"
            );

            VerifyUsesOfNullability(systemNamespace, expected);
        }

        [Fact]
        public void AnnotatedAssemblies_WithSomeExtraAnnotations()
        {
            // https://github.com/dotnet/roslyn/issues/29821 external annotations should be removed or fully designed/productized
            var lib = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String
    {
        public String? Concat(String a, String b) => throw null;
    }
    public class Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
}
";
            var comp = CreateEmptyCompilation(lib);
            comp.VerifyDiagnostics(
                // (11,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public String? Concat(String a, String b) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 22)
                );

            var comp2 = CreateEmptyCompilation("", references: new[] { comp.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var expected = ImmutableArray.Create("System.String! System.String.Concat(System.String?, System.String?)");
            var systemNamespace = comp2.GetMember<NamedTypeSymbol>("System.String").ContainingNamespace;
            VerifyUsesOfNullability(systemNamespace, expected);
        }

        [Fact]
        public void UnannotatedAssemblies_01()
        {
            var source0 =
@"public class A
{
    public static void F(string s) { }
}";
            var source1 =
@"class B
{
    static void Main()
    {
        A.F(string.Empty);
        A.F(null);
    }
}";
            TypeSymbolWithAnnotations getParameterType(Compilation c) => c.GetMember<MethodSymbol>("A.F").Parameters[0].Type;

            // 7.0 library
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            var metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Equal(null, getParameterType(comp0).IsNullable);

            // ... used in 7.0.
            var comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(null, getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(null, getParameterType(comp1).IsNullable);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(null, getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(null, getParameterType(comp1).IsNullable);

            // 8.0 library
            comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics();
            compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Null(getParameterType(comp0).IsNullable);

            // ... used in 7.0.
            comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Null(getParameterType(comp1).IsNullable);

            // 8.0 library
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Equal(false, getParameterType(comp0).IsNullable);

            // ... used in 7.0.
            comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(false, getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(false, getParameterType(comp1).IsNullable);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(false, getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(false, getParameterType(comp1).IsNullable);

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: compRefs0);
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         A.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
            Assert.Equal(false, getParameterType(comp1).IsNullable);
            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: metadataRefs0);
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         A.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
            Assert.Equal(false, getParameterType(comp1).IsNullable);
        }

        [Fact]
        public void UnannotatedAssemblies_02()
        {
            var source0 =
@"#pragma warning disable 67
public delegate void D();
public class C
{
    public object F;
    public event D E;
    public object P => null;
    public object this[object o] => null;
    public object M(object o) => null;
}";
            var source1 =
@"class P
{
    static void F(C c)
    {
        object o;
        o = c.F;
        c.E += null;
        o = c.P;
        o = c[null];
        o = c.M(null);
    }
}";

            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            void verify(Compilation c)
            {
                c.VerifyDiagnostics();
                Assert.Equal(null, c.GetMember<FieldSymbol>("C.F").Type.IsNullable);
                Assert.Equal(null, c.GetMember<EventSymbol>("C.E").Type.IsNullable);
                Assert.Equal(null, c.GetMember<PropertySymbol>("C.P").Type.IsNullable);
                var indexer = c.GetMember<PropertySymbol>("C.this[]");
                Assert.Equal(null, indexer.Type.IsNullable);
                Assert.Equal(null, indexer.Parameters[0].Type.IsNullable);
                var method = c.GetMember<MethodSymbol>("C.M");
                Assert.Equal(null, method.ReturnType.IsNullable);
                Assert.Equal(null, method.Parameters[0].Type.IsNullable);
            }

            var comp1A = CreateCompilation(source1, references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            verify(comp1A);

            var comp1B = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            verify(comp1B);
        }

        [Fact]
        public void UnannotatedAssemblies_03()
        {
            var source0 =
@"#pragma warning disable 67
public class C
{
    public (object, object) F;
    public (object, object) P => (null, null);
    public (object, object) M((object, object) o) => o;
}";
            var source1 =
@"class P
{
    static void F(C c)
    {
        (object, object) t;
        t = c.F;
        t = c.P;
        t = c.M((null, null));
    }
}";

            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            void verifyTuple(TypeSymbolWithAnnotations type)
            {
                var tuple = (TupleTypeSymbol)type.TypeSymbol;
                Assert.Equal(null, tuple.TupleElements[0].Type.IsNullable);
                Assert.Equal(null, tuple.TupleElements[1].Type.IsNullable);
            }

            void verify(Compilation c)
            {
                c.VerifyDiagnostics();
                verifyTuple(c.GetMember<FieldSymbol>("C.F").Type);
                verifyTuple(c.GetMember<PropertySymbol>("C.P").Type);
                var method = c.GetMember<MethodSymbol>("C.M");
                verifyTuple(method.ReturnType);
                verifyTuple(method.Parameters[0].Type);
            }

            var comp1A = CreateCompilation(source1, references: new[] { new CSharpCompilationReference(comp0) });
            verify(comp1A);

            var comp1B = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            verify(comp1B);
        }

        [Fact]
        public void UnannotatedAssemblies_04()
        {
            var source =
@"class A { }
class B : A { }
interface I<T> where T : A { }
abstract class C<T> where T : A
{
    internal abstract void M<U>() where U : T;
}
class D : C<B>, I<B>
{
    internal override void M<T>() { }
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            var derivedType = comp.GetMember<NamedTypeSymbol>("D");
            var baseType = derivedType.BaseTypeNoUseSiteDiagnostics;
            var constraintType = baseType.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(null, constraintType.IsNullable);
            var interfaceType = derivedType.Interfaces().Single();
            constraintType = interfaceType.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(null, constraintType.IsNullable);
            var method = baseType.GetMember<MethodSymbol>("M");
            constraintType = method.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(null, constraintType.IsNullable);
        }

        [Fact]
        public void UnannotatedAssemblies_05()
        {
            var source =
@"interface I<T>
{
    I<object[]> F(I<T> t);
}
class C : I<string>
{
    I<object[]> I<string>.F(I<string> s) => null;
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            var type = comp.GetMember<NamedTypeSymbol>("C");
            var interfaceType = type.Interfaces().Single();
            var typeArg = interfaceType.TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(null, typeArg.IsNullable);
            var method = type.GetMember<MethodSymbol>("I<System.String>.F");
            Assert.Equal(null, method.ReturnType.IsNullable);
            typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(null, typeArg.IsNullable);
            var parameter = method.Parameters.Single();
            Assert.Equal(null, parameter.Type.IsNullable);
            typeArg = ((NamedTypeSymbol)parameter.Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(null, typeArg.IsNullable);
        }

        [Fact]
        public void UnannotatedAssemblies_06()
        {
            var source0 =
@"public class C<T>
{
    public T F;
}
public class C
{
    public static C<T> Create<T>(T t) => new C<T>();
}";
            var source1 =
@"class P
{
    static void F(object x, object? y)
    {
        object z;
        z = C.Create(x).F;
        z = C.Create(y).F;
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = C.Create(y).F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "C.Create(y).F").WithLocation(7, 13));
        }

        [Fact]
        public void UnannotatedAssemblies_07()
        {
            var source0 =
@"public interface I
{
    object F(object o);
}";
            var source1 =
@"class A1 : I
{
    object I.F(object? o) => new object();
}
class A2 : I
{
    object? I.F(object o) => o;
}
class B1 : I
{
    public object F(object? o) => new object();
}
class B2 : I
{
    public object? F(object o) => o;
}
class C1
{
    public object F(object? o) => new object();
}
class C2
{
    public object? F(object o) => o;
}
class D1 : C1, I
{
}
class D2 : C2, I
{
}
class P
{
    static void F(object? x, A1 a1, A2 a2)
    {
        object y;
        y = ((I)a1).F(x);
        y = ((I)a2).F(x);
    }
    static void F(object? x, B1 b1, B2 b2)
    {
        object y;
        y = b1.F(x);
        y = b2.F(x);
        y = ((I)b1).F(x);
        y = ((I)b2).F(x);
    }
    static void F(object? x, D1 d1, D2 d2)
    {
        object y;
        y = d1.F(x);
        y = d2.F(x);
        y = ((I)d1).F(x);
        y = ((I)d2).F(x);
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            comp1.VerifyDiagnostics(
                // (43,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? B2.F(object o)'.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? B2.F(object o)").WithLocation(43, 18),
                // (43,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b2.F(x)").WithLocation(43, 13),
                // (51,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? C2.F(object o)'.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? C2.F(object o)").WithLocation(51, 18),
                // (51,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "d2.F(x)").WithLocation(51, 13));

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (43,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? B2.F(object o)'.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? B2.F(object o)").WithLocation(43, 18),
                // (43,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b2.F(x)").WithLocation(43, 13),
                // (51,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? C2.F(object o)'.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? C2.F(object o)").WithLocation(51, 18),
                // (51,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "d2.F(x)").WithLocation(51, 13));
        }

        [Fact]
        public void UnannotatedAssemblies_08()
        {
            var source0 =
@"public interface I
{
    object? F(object? o);
    object G(object o);
}";
            var source1 =
@"public class A : I
{
    object I.F(object o) => null;
    object I.G(object o) => null;
}
public class B : I
{
    public object F(object o) => null;
    public object G(object o) => null;
}
public class C
{
    public object F(object o) => null;
    public object G(object o) => null;
}
public class D : C
{
}";
            var source2 =
@"class P
{
    static void F(object o, A a)
    {
        ((I)a).F(o).ToString();
        ((I)a).G(null).ToString();
    }
    static void F(object o, B b)
    {
        b.F(o).ToString();
        b.G(null).ToString();
        ((I)b).F(o).ToString();
        ((I)b).G(null).ToString();
    }
    static void F(object o, D d)
    {
        d.F(o).ToString();
        d.G(null).ToString();
        ((I)d).F(o).ToString();
        ((I)d).G(null).ToString();
    }
}";
            var comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var comp2A = CreateCompilation(source2, references: new[] { ref0, ref1 }, parseOptions: TestOptions.Regular7);
            comp2A.VerifyDiagnostics();

            var comp2B = CreateCompilation(source2, references: new[] { ref0, ref1 });
            comp2B.VerifyDiagnostics();

            var comp2C = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp2C.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)a).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)a).F(o)").WithLocation(5, 9),
                // (6,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)a).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 18),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)b).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)b).F(o)").WithLocation(12, 9),
                // (13,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)b).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(13, 18),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)d).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)d).F(o)").WithLocation(19, 9),
                // (20,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)d).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 18));

            var comp2D = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { ref0, ref1 });
            comp2D.VerifyDiagnostics();
        }

        [Fact]
        public void UnannotatedAssemblies_09()
        {
            var source0 =
@"public abstract class A
{
    public abstract object? F(object x, object? y);
}";
            var source1 =
@"public abstract class B : A
{
    public abstract override object F(object x, object y);
    public abstract object G(object x, object y);
}";
            var source2 =
@"class C1 : B
{
    public override object F(object x, object y) => x;
    public override object G(object x, object y) => x;
}
class C2 : B
{
    public override object? F(object? x, object? y) => x;
    public override object? G(object? x, object? y) => x;
}
class P
{
    static void F(object? x, object y, C1 c)
    {
        c.F(x, y).ToString();
        c.G(x, y).ToString();
        ((B)c).F(x, y).ToString();
        ((B)c).G(x, y).ToString();
        ((A)c).F(x, y).ToString();
    }
    static void F(object? x, object y, C2 c)
    {
        c.F(x, y).ToString();
        c.G(x, y).ToString();
        ((B)c).F(x, y).ToString();
        ((B)c).G(x, y).ToString();
        ((A)c).F(x, y).ToString();
    }
}";
            var comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics(
                // (3,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract object? F(object x, object? y);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 47),
                // (3,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract object? F(object x, object? y);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 27)
                );
            var ref0 = comp0.EmitToImageReference();

            var comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var comp2 = CreateCompilation(source2, references: new[] { ref0, ref1 });
            comp2.VerifyDiagnostics(
                // (9,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 37),
                // (9,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 48),
                // (9,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 27),
                // (21,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F(object? x, object y, C2 c)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 25),
                // (13,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F(object? x, object y, C1 c)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 25),
                // (8,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 37),
                // (8,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 48),
                // (8,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 27)
                );

            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            ref0 = comp0.EmitToImageReference();

            comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            ref1 = comp1.EmitToImageReference();

            comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp2.VerifyDiagnostics(
                // (15,13): warning CS8604: Possible null reference argument for parameter 'x' in 'object C1.F(object x, object y)'.
                //         c.F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object C1.F(object x, object y)").WithLocation(15, 13),
                // (16,13): warning CS8604: Possible null reference argument for parameter 'x' in 'object C1.G(object x, object y)'.
                //         c.G(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object C1.G(object x, object y)").WithLocation(16, 13),
                // (19,18): warning CS8604: Possible null reference argument for parameter 'x' in 'object? A.F(object x, object? y)'.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object? A.F(object x, object? y)").WithLocation(19, 18),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A)c).F(x, y)").WithLocation(19, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         c.F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F(x, y)").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         c.G(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.G(x, y)").WithLocation(24, 9),
                // (27,18): warning CS8604: Possible null reference argument for parameter 'x' in 'object? A.F(object x, object? y)'.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object? A.F(object x, object? y)").WithLocation(27, 18),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A)c).F(x, y)").WithLocation(27, 9));
        }

        [Fact]
        public void UnannotatedAssemblies_10()
        {
            var source0 =
@"public abstract class A<T>
{
    public T F;
}
public sealed class B : A<object>
{
}";
            var source1 =
@"class C
{
    static void Main()
    {
        B b = new B();
        b.F = null;
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var comp1 = CreateCompilation(source1, references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            comp1.VerifyDiagnostics();

            comp1 = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_False_Circular()
        {
            string source = @"
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
" + NonNullTypesOff() + @"
    class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            VerifyNonNullTypes(comp.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute"), false);
        }

        [Fact]
        public void NonNullTypes_True_Circular()
        {
            string source = @"
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
" + NonNullTypesOn() + @"
    class NonNullTypesAttribute : System.Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyEmitDiagnostics();

            VerifyNonNullTypes(comp.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute"), true);
        }

        [Fact]
        public void NonNullTypes_WithObsolete()
        {
            string source = @"
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
" + NonNullTypesOn() + @"
    [System.Obsolete(""obsolete"")]
    class NonNullTypesAttribute : System.Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}
";
            // We don't check whether well-known types are obsolete
            var comp = CreateCompilation(new[] { source });
            comp.VerifyEmitDiagnostics();
            Assert.False(comp.GetMember("System.Runtime.CompilerServices.NonNullTypesAttribute").IsImplicitlyDeclared);
        }

        [Fact]
        public void Embedded_WithObsolete()
        {
            string source = @"
namespace Microsoft.CodeAnalysis
{
    [Embedded]
    [System.Obsolete(""obsolete"")]
    class EmbeddedAttribute : System.Attribute
    {
        public EmbeddedAttribute() { }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
            Assert.False(comp.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute").IsImplicitlyDeclared);
        }

        [Fact]
        public void NonNullTypes_Cycle5()
        {
            string source = @"
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    class SomeAttribute : Attribute
    {
        public SomeAttribute() { }
        public int Property { get; set; }
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle12()
        {
            string source = @"
[System.Flags]
enum E { }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle13()
        {
            string source = @"
interface I { }

[System.Obsolete(nameof(I2))]
interface I2 : I { }

";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle15()
        {
            string lib_cs = "public class Base { }";
            var lib = CreateCompilation(lib_cs, assemblyName: "lib");

            string lib2_cs = "public class C : Base { }";
            var lib2 = CreateCompilation(lib2_cs, references: new[] { lib.EmitToImageReference() }, assemblyName: "lib2");

            string source_cs = @"
[D]
class DAttribute : C { }
";
            var comp = CreateCompilation(source_cs, references: new[] { lib2.EmitToImageReference() });
            comp.VerifyDiagnostics(
                // (3,20): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // class DAttribute : C { }
                Diagnostic(ErrorCode.ERR_NoTypeDef, "C").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(3, 20),
                // (2,2): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // [D]
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 2),
                // (2,2): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // [D]
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 2)
                );
        }

        [Fact]
        public void NonNullTypes_Cycle16()
        {
            string source = @"
using System;
[AttributeUsage(AttributeTargets.Property)]
class AttributeWithProperty : System.ComponentModel.DisplayNameAttribute
{
    public override string DisplayName { get => throw null; }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_OnSystemBoolean()
        {
            string source = @"
namespace System
{
" + NonNullTypesOn() + @"
    public struct Boolean { }
" + NonNullTypesOff() + @"
    public class Attribute { }
    public class Object { }
    public struct Void { }
    public class ValueType { }
    public class Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
}
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false)]
    class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}
";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyDiagnostics();
        }

        [WorkItem(29594, "https://github.com/dotnet/roslyn/issues/29594")]
        [Fact(Skip = "Stack overflow")]
        public void NonNullTypes_DoNotWarnInsideAttributes()
        {
            string source = @"
using System.Runtime.CompilerServices;
[NonNullTypes(true)]
class C
{
    [System.Obsolete(D.M1(D.M2()))]
    class D
    {
        static void M1(string x) => throw null;
        static string? M2() => throw null;
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_OnFields()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"

" + NonNullTypesOn() + @"
public class External
{
    public static string s;
    public static string? ns;

" + NonNullTypesOff() + @"
    public static string fs;

" + NonNullTypesOff() + @"
    public static string? fns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());
            libComp.VerifyDiagnostics(
                // (13,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? fns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 25)
                );
            verifyExternal(libComp);

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string s;
        public static string? ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string s;
    public static string? ns;
}

" + NonNullTypesOff() + @"
public class C
{
" + NonNullTypesOn() + @"
    public static string s;

" + NonNullTypesOn() + @"
    public static string? ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string s;
" + NonNullTypesOn() + @"
        public static string? ns;
    }
}

public class Oblivious2
{
" + NonNullTypesOff() + @"
    public static string s;
" + NonNullTypesOff() + @"
    public static string? ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s /*T:string*/ = null;

        External.s /*T:string!*/ = null; // warn 1
        External.ns /*T:string?*/ = null;

        External.fs /*T:string*/ = null;
        External.fns /*T:string?*/ = null;

        OuterA.A.s /*T:string!*/ = null; // warn 2
        OuterA.A.ns /*T:string?*/ = null;

        B.s /*T:string!*/ = null; // warn 3
        B.ns /*T:string?*/ = null;

        C.s /*T:string!*/ = null; // warn 4
        C.ns /*T:string?*/ = null;

        OuterD.D.s /*T:string!*/ = null; // warn 5
        OuterD.D.ns /*T:string?*/ = null;

        Oblivious2.s /*T:string*/ = null;
        Oblivious2.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (49,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(49, 25),
                // (58,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(58, 36),
                // (64,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(64, 36),
                // (67,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(67, 29),
                // (70,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(70, 29),
                // (73,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s /*T:string!*/ = null; // warn 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(73, 36)
                );

            verifyExternal(compilation);

            var outerA = (NamedTypeSymbol)compilation.GetMember("OuterA");
            Assert.False(outerA.NonNullTypes);

            var a = (NamedTypeSymbol)outerA.GetMember("A");
            VerifyNonNullTypes(a, true);

            var b = (NamedTypeSymbol)compilation.GetMember("B");
            VerifyNonNullTypes(b, true);

            var c = (NamedTypeSymbol)compilation.GetMember("C");
            Assert.False(c.NonNullTypes);
            VerifyNonNullTypes(c.GetMember("s"), true);
            VerifyNonNullTypes(c.GetMember("ns"), true);

            var outerD = (NamedTypeSymbol)compilation.GetMember("OuterD");
            Assert.False(outerD.NonNullTypes);

            var d = (NamedTypeSymbol)outerD.GetMember("D");
            Assert.False(d.NonNullTypes);
            VerifyNonNullTypes(d.GetMember("s"), true);
            VerifyNonNullTypes(d.GetMember("ns"), true);

            var oblivious2 = (NamedTypeSymbol)compilation.GetMember("Oblivious2");
            Assert.True(oblivious2.NonNullTypes);
            VerifyNonNullTypes(oblivious2.GetMember("s"), false);
            VerifyNonNullTypes(oblivious2.GetMember("ns"), false);

            void verifyExternal(Compilation comp)
            {
                var external = (NamedTypeSymbol)comp.GetMember("External");
                Assert.True(external.NonNullTypes);
                Assert.True(external.GetMember("s").NonNullTypes);
                Assert.True(external.GetMember("ns").NonNullTypes);
                Assert.False(external.GetMember("fs").NonNullTypes);
                Assert.False(external.GetMember("fns").NonNullTypes);
            }
        }

        [Fact]
        public void SuppressedNullConvertedToUnconstrainedT()
        {
            var source = @"
public class List2<T> { public T Item { get; set; } = null!; }
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,55): error CS0403: Cannot convert null to type parameter 'T' because it could be a non-nullable value type. Consider using 'default(T)' instead.
                // public class List2<T> { public T Item { get; set; } = null!; }
                Diagnostic(ErrorCode.ERR_TypeVarCantBeNull, "null!").WithArguments("T").WithLocation(2, 55)
                );
        }

        [Fact]
        public void TwiceSuppressedNullConvertedToUnconstrainedT()
        {
            var source = @"
public class List2<T> { public T Item { get; set; } = null!!; }
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,55): error CS0403: Cannot convert null to type parameter 'T' because it could be a non-nullable value type. Consider using 'default(T)' instead.
                // public class List2<T> { public T Item { get; set; } = null!!; }
                Diagnostic(ErrorCode.ERR_TypeVarCantBeNull, "null!!").WithArguments("T").WithLocation(2, 55)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Nested()
        {
            var obliviousLib = @"
public class List1<T> { public T Item { get; set; } = default(T); }
public class Oblivious
{
    public static List1<string> s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
using System.Runtime.CompilerServices;
public class List2<T> { public T Item { get; set; } = default!; }
public class External
{
    public static List2<string> s;
    public static List2<string?> ns;

" + NonNullTypesOff() + @"
    public static List2<string> fs;
" + NonNullTypesOff() + @"
    public static List2<string?> fns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"

public class List3<T> { public T Item { get; set; } = default!; }

" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static List3<string> s;
        public static List3<string?> ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static List3<string> s;
    public static List3<string?> ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static List3<string> s;
" + NonNullTypesOn() + @"
        public static List3<string?> ns;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static List3<string> s;
    public static List3<string?> ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s.Item /*T:string*/ = null;

        External.s.Item /*T:string!*/ = null; // warn 1
        External.ns.Item /*T:string?*/ = null;

        External.fs.Item /*T:string*/ = null;
        External.fns.Item /*T:string?*/ = null;

        OuterA.A.s.Item /*T:string!*/ = null; // warn 2
        OuterA.A.ns.Item /*T:string?*/ = null;

        B.s.Item /*T:string!*/ = null; // warn 3
        B.ns.Item /*T:string?*/ = null;

        OuterD.D.s.Item /*T:string!*/ = null; // warn 4
        OuterD.D.ns.Item /*T:string?*/ = null;

        Oblivious2.s.Item /*T:string*/ = null;
        Oblivious2.ns.Item /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (39,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static List3<string?> ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 31),
                // (48,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s.Item /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 41),
                // (54,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s.Item /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 41),
                // (57,34): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s.Item /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(57, 34),
                // (60,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s.Item /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(60, 41)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Tuples()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static (string s, string s2) t;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
public class External
{
    public static (string s, string? ns) t;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static (string s, string? ns) t;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static (string s, string? ns) t;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static (string s, string? ns) t;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static (string s, string? ns) t;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.t.s /*T:string*/ = null;

        External.t.s /*T:string!*/ = null; // warn 1
        External.t.ns /*T:string?*/ = null;

        OuterA.A.t.s /*T:string!*/ = null; // warn 2
        OuterA.A.t.ns /*T:string?*/ = null;

        B.t.s /*T:string!*/ = null; // warn 3
        B.t.ns /*T:string?*/ = null;

        OuterD.D.t.s /*T:string!*/ = null; // warn 4
        OuterD.D.t.ns /*T:string?*/ = null;

        Oblivious2.t.s /*T:string*/ = null;
        Oblivious2.t.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (33,36): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static (string s, string? ns) t;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 36),
                // (42,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.t.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(42, 38),
                // (45,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.t.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(45, 38),
                // (48,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.t.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 31),
                // (51,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.t.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(51, 38)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Arrays()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string[] s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
public class External
{
    public static string[] s;
    public static string?[] ns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string[] s;
        public static string?[] ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string[] s;
    public static string?[] ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string[] s;
" + NonNullTypesOn() + @"
        public static string?[] ns;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static string[] s;
    public static string?[] ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s[0] /*T:string*/ = null;

        External.s[0] /*T:string!*/ = null; // warn 1
        External.ns[0] /*T:string?*/ = null;

        OuterA.A.s[0] /*T:string!*/ = null; // warn 2
        OuterA.A.ns[0] /*T:string?*/ = null;

        B.s[0] /*T:string!*/ = null; // warn 3
        B.ns[0] /*T:string?*/ = null;

        OuterD.D.s[0] /*T:string!*/ = null; // warn 4
        OuterD.D.ns[0] /*T:string?*/ = null;

        Oblivious2.s[0] /*T:string*/ = null;
        Oblivious2.ns[0] /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (38,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string?[] ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 25),
                // (47,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s[0] /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 39),
                // (50,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s[0] /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 39),
                // (53,32): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s[0] /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(53, 32),
                // (56,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s[0] /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(56, 39)
                );
        }

        [Fact]
        public void NonNullTypes_OnProperties()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string s { get; set; }
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);
            obliviousComp.VerifyDiagnostics();
            VerifyNonNullTypes(obliviousComp.GetMember("Oblivious"), expectNonNullTypes: null);

            var lib = @"
public class External
{
    public static string s { get; set; }
    public static string? ns { get; set; }
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
    public class A
    {
" + NonNullTypesOn() + @"
        public static string s { get; set; }
" + NonNullTypesOn() + @"
        public static string? ns { get; set; }
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string s { get; set; }
    public static string? ns { get; set; }
}

" + NonNullTypesOff() + @"
public class OuterD
{
" + NonNullTypesOn() + @"
    public class D
    {
        public static string s { get; set; }
        public static string? ns { get; set; }
    }
}

public class Oblivious2
{
" + NonNullTypesOff() + @"
    public static string s { get; set; }
" + NonNullTypesOff() + @"
    public static string? ns { get; set; }
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s /*T:string*/ = null;

        External.s /*T:string!*/ = null; // warn 1
        External.ns /*T:string?*/ = null;

        OuterA.A.s /*T:string!*/ = null; // warn 2
        OuterA.A.ns /*T:string?*/ = null;

        B.s /*T:string!*/ = null; // warn 3
        B.ns /*T:string?*/ = null;

        OuterD.D.s /*T:string!*/ = null; // warn 4
        OuterD.D.ns /*T:string?*/ = null;

        Oblivious2.s /*T:string*/ = null;
        Oblivious2.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (39,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? ns { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 25),
                // (48,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 36),
                // (51,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(51, 36),
                // (54,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 29),
                // (57,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(57, 36)
                );

            verifyOblivious(compilation);

            var outerA = (NamedTypeSymbol)compilation.GetMember("OuterA");
            Assert.False(outerA.NonNullTypes);

            var a = (NamedTypeSymbol)outerA.GetMember("A");
            Assert.False(a.NonNullTypes);
            VerifyNonNullTypes(a.GetMember("s"), true);
            VerifyNonNullTypes(a.GetMember("ns"), true);

            var b = (NamedTypeSymbol)compilation.GetMember("B");
            VerifyNonNullTypes(b, true);

            var outerD = (NamedTypeSymbol)compilation.GetMember("OuterD");
            Assert.False(outerD.NonNullTypes);

            var d = (NamedTypeSymbol)outerD.GetMember("D");
            VerifyNonNullTypes(d, true);

            var oblivious2 = (NamedTypeSymbol)compilation.GetMember("Oblivious2");
            Assert.True(oblivious2.NonNullTypes);
            VerifyNonNullTypes(oblivious2.GetMember("s"), false);
            VerifyNonNullTypes(oblivious2.GetMember("ns"), false);

            void verifyOblivious(Compilation comp)
            {
                VerifyNonNullTypes(comp.GetMember("Oblivious"), null);
            }
        }

        /// <summary>
        /// The type and all of its members should have the expected NonNullTypes value.
        /// </summary>
        private static void VerifyNonNullTypes(NamedTypeSymbol type, bool? expectNonNullTypes)
        {
            Assert.Equal(expectNonNullTypes, type.NonNullTypes);

            foreach (var member in type.GetMembers())
            {
                VerifyNonNullTypes(member, expectNonNullTypes);
            }
        }

        private static void VerifyNonNullTypes(Symbol symbol, bool? expectNonNullTypes)
        {
            switch (symbol)
            {
                case NamedTypeSymbol type:
                    VerifyNonNullTypes(type, expectNonNullTypes);
                    break;
                case PropertySymbol property:
                    VerifyNonNullTypes(property, expectNonNullTypes);
                    break;
                case MethodSymbol method:
                    VerifyNonNullTypes(method, expectNonNullTypes);
                    break;
                case FieldSymbol field:
                    Assert.Equal(expectNonNullTypes, field.NonNullTypes);
                    break;
            }
        }

        private static void VerifyNonNullTypes(PropertySymbol property, bool? expectNonNullTypes)
        {
            Assert.Equal(expectNonNullTypes, property.NonNullTypes);
            VerifyNonNullTypes(property.GetMethod, expectNonNullTypes);
            VerifyNonNullTypes(property.SetMethod, expectNonNullTypes);
        }

        private static void VerifyNonNullTypes(MethodSymbol method, bool? expectNonNullTypes)
        {
            Assert.Equal(expectNonNullTypes, method.NonNullTypes);

            Assert.Equal(expectNonNullTypes, method.ReturnType.NonNullTypesContext.NonNullTypes);

            foreach (var parameter in method.Parameters)
            {
                Assert.Equal(expectNonNullTypes, parameter.NonNullTypes);
            }
        }

        [Fact]
        public void NonNullTypes_OnMethods()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string Method(string s) => throw null;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);
            VerifyNonNullTypes((NamedTypeSymbol)obliviousComp.GetMember("Oblivious"), expectNonNullTypes: null);

            var lib = @"
public class External
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());
            verifyExternal(libComp);

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string Method(string s) => throw null;
        public static string? NMethod(string? ns) => throw null;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string Method(string s) => throw null;
" + NonNullTypesOn() + @"
        public static string? NMethod(string? ns) => throw null;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.Method(null) /*T:string*/;

        External.Method(null) /*T:string!*/; // warn 1
        External.NMethod(null) /*T:string?*/;

        OuterA.A.Method(null) /*T:string!*/; // warn 2
        OuterA.A.NMethod(null) /*T:string?*/;

        B.Method(null) /*T:string!*/; // warn 3
        B.NMethod(null) /*T:string?*/;

        OuterD.D.Method(null) /*T:string!*/; // warn 4
        OuterD.D.NMethod(null) /*T:string?*/;

        Oblivious2.Method(null) /*T:string*/;
        Oblivious2.NMethod(null) /*T:string?*/;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (38,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? NMethod(string? ns) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 41),
                // (38,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? NMethod(string? ns) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 25),
                // (47,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.Method(null) /*T:string!*/; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 25),
                // (50,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.Method(null) /*T:string!*/; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 25),
                // (53,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.Method(null) /*T:string!*/; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(53, 18),
                // (56,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.Method(null) /*T:string!*/; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(56, 25)
                );

            verifyOblivious(compilation);
            verifyExternal(compilation);

            var outerA = (NamedTypeSymbol)compilation.GetMember("OuterA");
            Assert.False(outerA.NonNullTypes);

            var a = (NamedTypeSymbol)outerA.GetMember("A");
            VerifyNonNullTypes(a, true);

            var b = (NamedTypeSymbol)compilation.GetMember("B");
            VerifyNonNullTypes(b, true);

            var outerD = (NamedTypeSymbol)compilation.GetMember("OuterD");
            Assert.False(outerD.NonNullTypes);

            var d = (NamedTypeSymbol)outerD.GetMember("D");
            Assert.False(d.NonNullTypes);
            VerifyNonNullTypes(d.GetMember("Method"), true);
            VerifyNonNullTypes(d.GetMember("NMethod"), true);

            var oblivious2 = (NamedTypeSymbol)compilation.GetMember("Oblivious2");
            VerifyNonNullTypes(oblivious2, false);

            void verifyOblivious(Compilation comp)
            {
                VerifyNonNullTypes((NamedTypeSymbol)comp.GetMember("Oblivious"), null);
            }

            void verifyExternal(Compilation comp)
            {
                VerifyNonNullTypes((NamedTypeSymbol)comp.GetMember("External"), true);
            }
        }

        [Fact]
        public void NonNullTypes_OnModule()
        {
            var obliviousLib =
NonNullTypesOff() + @"
public class Oblivious { }
";

            var obliviousComp = CreateCompilation(new[] { obliviousLib });
            obliviousComp.VerifyDiagnostics();
            VerifyNonNullTypes(obliviousComp.GetMember("Oblivious"), expectNonNullTypes: false);

            var compilation = CreateCompilation("", options: TestOptions.ReleaseDll,
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });
            compilation.VerifyDiagnostics();
            VerifyNonNullTypes(compilation.GetMember("Oblivious"), false);
        }

        [Fact]
        public void NonNullTypes_OnModule_WithExtraConstructor()
        {
            var obliviousLib = @"
public class Oblivious { }

namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.All)]
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
        public NonNullTypesAttribute(string x) { }
    }
}
";

            var obliviousComp = CreateCompilation(obliviousLib, options: WithNonNullTypesFalse());
            obliviousComp.VerifyDiagnostics();
            VerifyNonNullTypes(obliviousComp.GetMember("Oblivious"), expectNonNullTypes: false);

            var compilation = CreateCompilation("", options: TestOptions.ReleaseDll,
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });
            compilation.VerifyDiagnostics();
            VerifyNonNullTypes(compilation.GetMember("Oblivious"), expectNonNullTypes: false);
        }

        [Fact]
        public void NonNullTypes_OnModule_WithAlias()
        {
            var obliviousLib = @"
using NonNullTypesAlias = System.Runtime.CompilerServices.NonNullTypesAttribute;

" + NonNullTypesOff() + @"
public class Oblivious { }
";

            var obliviousComp = CreateCompilation(new[] { obliviousLib });
            obliviousComp.VerifyDiagnostics(
                // (2,1): hidden CS8019: Unnecessary using directive.
                // using NonNullTypesAlias = System.Runtime.CompilerServices.NonNullTypesAttribute;
                Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using NonNullTypesAlias = System.Runtime.CompilerServices.NonNullTypesAttribute;").WithLocation(2, 1)
                );
            VerifyNonNullTypes(obliviousComp.GetMember("Oblivious"), expectNonNullTypes: false);

            var compilation = CreateCompilation("", options: TestOptions.ReleaseDll,
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });
            compilation.VerifyDiagnostics();
            VerifyNonNullTypes(compilation.GetMember("Oblivious"), expectNonNullTypes: false);
        }

        [Fact]
        public void NonNullTypes_OnAssembly()
        {
            var obliviousLib = @"
using System.Runtime.CompilerServices;

[assembly: NonNullTypes(false)]
public class Oblivious { }
";

            var obliviousComp = CreateCompilation(new[] { obliviousLib }, options: WithNonNullTypesTrue());
            obliviousComp.VerifyDiagnostics(
                // (4,12): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                // [assembly: NonNullTypes(false)]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(4, 12)
                );
            VerifyNonNullTypes(obliviousComp.GetMember("Oblivious"), true); // The attribute is on assembly 
        }

        [Fact]
        public void NonNullTypes_ValueTypeArgument()
        {
            var source =
NonNullTypesOff() + @"
class A<T> { }
class B
{
    A<byte> P { get; }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
        }

        [WorkItem(28324, "https://github.com/dotnet/roslyn/issues/28324")]
        [Fact]
        public void NonNullTypes_GenericOverriddenMethod_ValueType()
        {
            var source =
NonNullTypesOff() + @"
class C<T> { }
abstract class A
{
    internal abstract C<T> F<T>() where T : struct;
}
class B : A
{
    internal override C<T> F<T>() => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var method = comp.GetMember<MethodSymbol>("A.F");
            var typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0];
            Assert.True(typeArg.IsValueType);
            Assert.Equal(false, typeArg.IsNullable);

            method = comp.GetMember<MethodSymbol>("B.F");
            typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0];
            Assert.True(typeArg.IsValueType);
            Assert.Equal(false, typeArg.IsNullable);

            // https://github.com/dotnet/roslyn/issues/29843: Test all combinations of base and derived
            // including explicit Nullable<T>.
        }

        // BoundExpression.Type for Task.FromResult(_f[0]) is Task<T!>
        // but the inferred type is Task<T~>.
        [Fact]
        public void CompareUnannotatedAndNonNullableTypeParameter()
        {
            var source =
@"#pragma warning disable 0649
using System.Threading.Tasks;
class C<T>
{
    T[] _f;
    Task<T> F() => Task.FromResult(_f[0]);
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,7): warning CS8618: Non-nullable field '_f' is uninitialized.
                // class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "_f").WithLocation(3, 7));
        }

        [Fact]
        public void CircularConstraints()
        {
            var source =
@"class A<T> where T : B<T>.I
{
    internal interface I { }
}
class B<T> : A<T> where T : A<T>.I
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.0", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void AssignObliviousIntoLocals()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string f;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var source = @"
class C
{
    void M()
    {
        string s = Oblivious.f;
        s /*T:string*/ .ToString();
        string ns = Oblivious.f;
        ns /*T:string*/ .ToString();
    }
}
";
            // Should a declared type affect an oblivious state? https://github.com/dotnet/roslyn/issues/27686
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesTrue_Foreach()
        {
            var source = @"


class C
{
" + NonNullTypesOn() + @"
    public void M2()
    {
        foreach (string s in Collection())
        {
            s /*T:string!*/ .ToString();
        }

        foreach (string? ns in NCollection())
        {
            ns /*T:string?*/ .ToString(); // 1
        }

        foreach (var s1 in Collection())
        {
            s1 /*T:string!*/ .ToString();
        }

        foreach (var ns1 in NCollection())
        {
            ns1 /*T:string?*/ .ToString(); // 2 
        }

        foreach (string s in FalseCollection())
        {
            s /*T:string*/ .ToString();
        }

        foreach (string? ns in FalseNCollection())
        {
            ns /*T:string?*/ .ToString(); // 3
        }

        foreach (var s1 in FalseCollection())
        {
            s1 /*T:string*/ .ToString();
        }

        foreach (var ns1 in FalseNCollection())
        {
            ns1 /*T:string?*/ .ToString(); // 4
        }
    }

" + NonNullTypesOn() + @"
    string[] Collection() => throw null;

" + NonNullTypesOn() + @"
    string?[] NCollection() => throw null;

" + NonNullTypesOff() + @"
    string[] FalseCollection() => throw null;

" + NonNullTypesOff() + @"
    string?[] FalseNCollection() => throw null; // 5
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (60,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] FalseNCollection() => throw null; // 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(60, 11),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             ns /*T:string?*/ .ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns").WithLocation(16, 13),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             ns1 /*T:string?*/ .ToString(); // 2 
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns1").WithLocation(26, 13),
                // (36,13): warning CS8602: Possible dereference of a null reference.
                //             ns /*T:string?*/ .ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns").WithLocation(36, 13),
                // (46,13): warning CS8602: Possible dereference of a null reference.
                //             ns1 /*T:string?*/ .ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns1").WithLocation(46, 13)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_Foreach()
        {
            var source = @"


class C
{
" + NonNullTypesOff() + @"
    public void M2()
    {
        foreach (string s in Collection())
        {
            s /*T:string!*/ .ToString();
        }

        foreach (string? ns in NCollection()) // 1
        {
            ns /*T:string?*/ .ToString();
        }

        foreach (var s1 in Collection())
        {
            s1 /*T:string!*/ .ToString();
        }

        foreach (var ns1 in NCollection())
        {
            ns1 /*T:string?*/ .ToString();
        }

        foreach (string s in FalseCollection())
        {
            s /*T:string*/ .ToString();
        }

        foreach (string? ns in FalseNCollection()) // 2
        {
            ns /*T:string?*/ .ToString();
        }

        foreach (var s1 in FalseCollection())
        {
            s1 /*T:string*/ .ToString();
        }

        foreach (var ns1 in FalseNCollection())
        {
            ns1 /*T:string?*/ .ToString();
        }
    }

" + NonNullTypesOn() + @"
    string[] Collection() => throw null;

" + NonNullTypesOn() + @"
    string?[] NCollection() => throw null;

" + NonNullTypesOff() + @"
    string[] FalseCollection() => throw null;

" + NonNullTypesOff() + @"
    string?[] FalseNCollection() => throw null; // 3
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (60,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] FalseNCollection() => throw null; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(60, 11),
                // (14,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         foreach (string? ns in NCollection()) // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 24),
                // (34,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         foreach (string? ns in FalseNCollection()) // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(34, 24)
                );
        }

        [Fact]
        public void NonNullTypesTrue_OutVars()
        {
            var source = @"


class C
{
" + NonNullTypesOn() + @"
    public void M()
    {
        Out(out string s2);
        s2 /*T:string!*/ .ToString();
        s2 = null; // warn 1

        NOut(out string? ns2);
        ns2 /*T:string?*/ .ToString(); // warn 2
        ns2 = null;

        FalseOut(out string s3);
        s3 /*T:string*/ .ToString();
        s3 = null; // warn 3

        FalseNOut(out string? ns3);
        ns3 /*T:string?*/ .ToString(); // warn 4
        ns3 = null;

        Out(out var s4);
        s4 /*T:string!*/ .ToString();
        s4 = null; // warn 5

        NOut(out var ns4);
        ns4 /*T:string?*/ .ToString(); // warn 6
        ns4 = null;

        FalseOut(out var s5);
        s5 /*T:string*/ .ToString();
        s5 = null;

        FalseNOut(out var ns5);
        ns5 /*T:string?*/ .ToString(); // warn 6
        ns5 = null;
    }

" + NonNullTypesOn() + @"
    void Out(out string s) => throw null;

" + NonNullTypesOn() + @"
    void NOut(out string? ns) => throw null;

" + NonNullTypesOff() + @"
    void FalseOut(out string s) => throw null;

" + NonNullTypesOff() + @"
    void FalseNOut(out string? ns) => throw null; // warn 7
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (52,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void FalseNOut(out string? ns) => throw null; // warn 7
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(52, 30),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s2 = null; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ns2 /*T:string?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns2").WithLocation(14, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s3 = null; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(19, 14),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         ns3 /*T:string?*/ .ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns3").WithLocation(22, 9),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s4 = null; // warn 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(27, 14),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ns4 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns4").WithLocation(30, 9),
                // (38,9): warning CS8602: Possible dereference of a null reference.
                //         ns5 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns5").WithLocation(38, 9)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_OutVars()
        {
            var source = @"


class C
{
" + NonNullTypesOff() + @"
    public void M()
    {
        Out(out string s2);
        s2 /*T:string!*/ .ToString();
        s2 = null;

        NOut(out string? ns2); // 1
        ns2 /*T:string?*/ .ToString(); // 2
        ns2 = null;

        FalseOut(out string s3);
        s3 /*T:string*/ .ToString();
        s3 = null;

        FalseNOut(out string? ns3); // 3
        ns3 /*T:string?*/ .ToString(); // 4
        ns3 = null;

        Out(out var s4);
        s4 /*T:string!*/ .ToString();
        s4 = null; // 5

        NOut(out var ns4);
        ns4 /*T:string?*/ .ToString(); // 6
        ns4 = null;

        FalseOut(out var s5);
        s5 /*T:string*/ .ToString();
        s5 = null;

        FalseNOut(out var ns5);
        ns5 /*T:string?*/ .ToString(); // 7
        ns5 = null;
    }

" + NonNullTypesOn() + @"
    void Out(out string s) => throw null;

" + NonNullTypesOn() + @"
    void NOut(out string? ns) => throw null;

" + NonNullTypesOff() + @"
    void FalseOut(out string s) => throw null;

" + NonNullTypesOff() + @"
    void FalseNOut(out string? ns) => throw null; // 8
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (52,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void FalseNOut(out string? ns) => throw null; // 8
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(52, 30),
                // (13,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         NOut(out string? ns2); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 24),
                // (21,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         FalseNOut(out string? ns3); // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 29)
                );
        }

        [Fact]
        public void NonNullTypesTrue_LocalDeclarations()
        {
            var source = @"


" + NonNullTypesOn() + @"
public class C : Base
{
    public void M()
    {
        string s2 = Method();
        s2 /*T:string!*/ .ToString();
        s2 = null; // warn 1

        string? ns2 = NMethod();
        ns2 /*T:string?*/ .ToString(); // warn 2
        ns2 = null;

        string s3 = FalseMethod();
        s3 /*T:string*/ .ToString();
        s3 = null; // warn 3

        string? ns3 = FalseNMethod();
        ns3 /*T:string?*/ .ToString(); // warn 4
        ns3 = null;

        var s4 = Method();
        s4 /*T:string!*/ .ToString();
        s4 = null; // warn 5

        var ns4 = NMethod();
        ns4 /*T:string?*/ .ToString(); // warn 6
        ns4 = null;

        var s5 = FalseMethod();
        s5 /*T:string*/ .ToString();
        s5 = null;

        var ns5 = FalseNMethod();
        ns5 /*T:string?*/ .ToString(); // warn 7
        ns5 = null;
    }
}
public class Base
{
" + NonNullTypesOn() + @"
    public string Method() => throw null;

" + NonNullTypesOn() + @"
    public string? NMethod() => throw null;

" + NonNullTypesOff() + @"
    public string FalseMethod() => throw null;

" + NonNullTypesOff() + @"
    public string? FalseNMethod() => throw null; // warn 8
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (54,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? FalseNMethod() => throw null; // warn 8
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(54, 18),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s2 = null; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ns2 /*T:string?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns2").WithLocation(14, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s3 = null; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(19, 14),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         ns3 /*T:string?*/ .ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns3").WithLocation(22, 9),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s4 = null; // warn 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(27, 14),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ns4 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns4").WithLocation(30, 9),
                // (38,9): warning CS8602: Possible dereference of a null reference.
                //         ns5 /*T:string?*/ .ToString(); // warn 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns5").WithLocation(38, 9)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_LocalDeclarations()
        {
            var source = @"


" + NonNullTypesOff() + @"
public class C : Base
{
    public void M()
    {
        string s2 = Method();
        s2 /*T:string!*/ .ToString();
        s2 = null;

        string? ns2 = NMethod(); // 1
        ns2 /*T:string?*/ .ToString();
        ns2 = null;

        string s3 = FalseMethod();
        s3 /*T:string*/ .ToString();
        s3 = null;

        string? ns3 = FalseNMethod(); // 2
        ns3 /*T:string?*/ .ToString();
        ns3 = null;

        var s4 = Method();
        s4 /*T:string!*/ .ToString();
        s4 = null;

        var ns4 = NMethod();
        ns4 /*T:string?*/ .ToString();
        ns4 = null;

        var s5 = FalseMethod();
        s5 /*T:string*/ .ToString();
        s5 = null;

        var ns5 = FalseNMethod();
        ns5 /*T:string?*/ .ToString();
        ns5 = null;
    }
}
public class Base
{
" + NonNullTypesOn() + @"
    public string Method() => throw null;

" + NonNullTypesOn() + @"
    public string? NMethod() => throw null;

" + NonNullTypesOff() + @"
    public string FalseMethod() => throw null;

" + NonNullTypesOff() + @"
    public string? FalseNMethod() => throw null; // 3
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (54,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? FalseNMethod() => throw null; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(54, 18),
                // (13,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? ns2 = NMethod(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 15),
                // (21,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? ns3 = FalseNMethod(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 15)
                );
        }

        [Fact]
        public void NonNullTypes_Constraint()
        {
            var source = @"

public class S { }

" + NonNullTypesOn() + @"
public struct C<T> where T : S
{
    public void M(T t)
    {
        t.ToString();
        t = null; // warn
    }
}

" + NonNullTypesOff() + @"
public struct D<T> where T : S
{
    public void M(T t)
    {
        t.ToString();
        t = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (11,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 13)
                );
        }

        [Fact]
        public void NonNullTypes_Delegate()
        {
            var source = @"


" + NonNullTypesOn() + @"
public delegate string[] MyDelegate(string[] x);

" + NonNullTypesOff() + @"
public delegate string[] MyFalseDelegate(string[] x);
" + NonNullTypesOn() + @"
public delegate string[]? MyNullableDelegate(string[]? x);

class C
{
    void M()
    {
        MyDelegate x1 = Method;
        MyDelegate x2 = FalseMethod;
        MyDelegate x4 = NullableReturnMethod; // warn 1
        MyDelegate x5 = NullableParameterMethod; // warn 2
        MyFalseDelegate y1 = Method;
        MyFalseDelegate y2 = FalseMethod;
        MyFalseDelegate y4 = NullableReturnMethod;
        MyFalseDelegate y5 = NullableParameterMethod;
        MyNullableDelegate z1 = Method; // warn 3
        MyNullableDelegate z2 = FalseMethod;
        MyNullableDelegate z4 = NullableReturnMethod; // warn 4
        MyNullableDelegate z5 = NullableParameterMethod; // warn 5
     }

" + NonNullTypesOn() + @"
    public string[] Method(string[] x) => throw null;

" + NonNullTypesOff() + @"
    public string[] FalseMethod(string[] x) => throw null;
" + NonNullTypesOn() + @"
    public string[]? NullableReturnMethod(string[] x) => throw null;
    public string[] NullableParameterMethod(string[]? x) => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (18,25): warning CS8621: Nullability of reference types in return type of 'string[]? C.NullableReturnMethod(string[] x)' doesn't match the target delegate 'MyDelegate'.
                //         MyDelegate x4 = NullableReturnMethod; // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "NullableReturnMethod").WithArguments("string[]? C.NullableReturnMethod(string[] x)", "MyDelegate").WithLocation(18, 25),
                // (24,33): warning CS8622: Nullability of reference types in type of parameter 'x' of 'string[] C.Method(string[] x)' doesn't match the target delegate 'MyNullableDelegate'.
                //         MyNullableDelegate z1 = Method; // warn 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "Method").WithArguments("x", "string[] C.Method(string[] x)", "MyNullableDelegate").WithLocation(24, 33),
                // (26,33): warning CS8622: Nullability of reference types in type of parameter 'x' of 'string[]? C.NullableReturnMethod(string[] x)' doesn't match the target delegate 'MyNullableDelegate'.
                //         MyNullableDelegate z4 = NullableReturnMethod; // warn 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "NullableReturnMethod").WithArguments("x", "string[]? C.NullableReturnMethod(string[] x)", "MyNullableDelegate").WithLocation(26, 33)
                );

            // https://github.com/dotnet/roslyn/issues/29844: Missing warnings 2 and 5
        }

        [Fact]
        public void NonNullTypes_Constructor()
        {
            var source = @"


public class C
{
" + NonNullTypesOn() + @"
    public C(string[] x) => throw null;
}
public class D
{
" + NonNullTypesOff() + @"
    public D(string[] x) => throw null;
}
" + NonNullTypesOn() + @"
public class E
{
    public string[] field = null!;
" + NonNullTypesOff() + @"
    public string[] obliviousField;
" + NonNullTypesOn() + @"
    public string[]? nullableField;

    void M()
    {
        new C(field);
        new C(obliviousField);
        new C(nullableField); // warn
        new D(field);
        new D(obliviousField);
        new D(nullableField);
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (27,15): warning CS8604: Possible null reference argument for parameter 'x' in 'C.C(string[] x)'.
                //         new C(nullableField); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nullableField").WithArguments("x", "C.C(string[] x)").WithLocation(27, 15)
                );
        }

        [Fact]
        public void NonNullTypes_Constraint_Nested()
        {
            var source = @"

public class S { }
public class List<T> { public T Item { get; set; } = default!; }

" + NonNullTypesOn() + @"
public struct C<T, NT>
    where T : List<S>
    where NT : List<S?>
{
    public void M(T t, NT nt)
    {
        t.Item /*T:S!*/ .ToString();
        t.Item = null; // warn 1
        nt.Item /*T:S?*/ .ToString(); // warn 2
        nt.Item = null;
    }
}

" + NonNullTypesOff() + @"
public struct D<T, NT>
    where T : List<S>
    where NT : List<S?> // warn 3
{
    public void M(T t, NT nt)
    {
        t.Item /*T:S*/ .ToString();
        t.Item = null;
        nt.Item /*T:S?*/ .ToString();
        nt.Item = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     where NT : List<S?> // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22),
                // (14,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t.Item = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 18),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         nt.Item /*T:S?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "nt.Item").WithLocation(15, 9)
                );
        }

        [Fact]
        public void IsAnnotated_01()
        {
            var source =
@"using System;

class C1
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}
" + NonNullTypesOff() + @"
class C2
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}
" + NonNullTypesOn() + @"
class C3
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (6,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string? F2() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 11),
                // (15,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string? F2() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 11)
                );

            verify("C1.F1", "System.String", isAnnotated: false, isNullable: null);
            verify("C1.F2", "System.String?", isAnnotated: true, isNullable: true);
            verify("C1.F3", "System.Int32", isAnnotated: false, isNullable: false);
            verify("C1.F4", "System.Int32?", isAnnotated: true, isNullable: true);
            verify("C1.F5", "System.Int32?", isAnnotated: true, isNullable: true);
            verify("C2.F1", "System.String", isAnnotated: false, isNullable: null);
            verify("C2.F2", "System.String?", isAnnotated: true, isNullable: true);
            verify("C2.F3", "System.Int32", isAnnotated: false, isNullable: false);
            verify("C2.F4", "System.Int32?", isAnnotated: true, isNullable: true);
            verify("C2.F5", "System.Int32?", isAnnotated: true, isNullable: true);
            verify("C3.F1", "System.String!", isAnnotated: false, isNullable: false);
            verify("C3.F2", "System.String?", isAnnotated: true, isNullable: true);
            verify("C3.F3", "System.Int32", isAnnotated: false, isNullable: false);
            verify("C3.F4", "System.Int32?", isAnnotated: true, isNullable: true);
            verify("C3.F5", "System.Int32?", isAnnotated: true, isNullable: true);

            // https://github.com/dotnet/roslyn/issues/29845: Test nested nullability.

            void verify(string methodName, string displayName, bool isAnnotated, bool? isNullable)
            {
                var method = comp.GetMember<MethodSymbol>(methodName);
                var type = method.ReturnType;
                Assert.Equal(displayName, type.ToTestDisplayString(true));
                Assert.Equal(isAnnotated, type.IsAnnotated);
                Assert.Equal(isNullable, type.IsNullable);
            }
        }

        [Fact]
        public void IsAnnotated_02()
        {
            var source =
@"using System;

class C1
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}
" + NonNullTypesOff() + @"
class C2
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}
" + NonNullTypesOn() + @"
class C3
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (6,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 5),
                // (6,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 6),
                // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6),
                // (8,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 5),
                // (17,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 5),
                // (28,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(28, 5),
                // (17,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 6),
                // (19,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 6),
                // (19,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(19, 5)
            );

            verify("C1.F1", "T", isAnnotated: false, isNullable: null);
            verify("C1.F2", "T?", isAnnotated: true, isNullable: true);
            verify("C1.F3", "T", isAnnotated: false, isNullable: null);
            verify("C1.F4", "T?", isAnnotated: true, isNullable: true);
            verify("C1.F5", "T", isAnnotated: false, isNullable: false);
            verify("C1.F6", "T?", isAnnotated: true, isNullable: true);
            verify("C1.F7", "T?", isAnnotated: true, isNullable: true);
            verify("C2.F1", "T", isAnnotated: false, isNullable: null);
            verify("C2.F2", "T?", isAnnotated: true, isNullable: true);
            verify("C2.F3", "T", isAnnotated: false, isNullable: null);
            verify("C2.F4", "T?", isAnnotated: true, isNullable: true);
            verify("C2.F5", "T", isAnnotated: false, isNullable: false);
            verify("C2.F6", "T?", isAnnotated: true, isNullable: true);
            verify("C2.F7", "T?", isAnnotated: true, isNullable: true);
            verify("C3.F1", "T", isAnnotated: false, isNullable: true);
            verify("C3.F2", "T?", isAnnotated: true, isNullable: true);
            verify("C3.F3", "T!", isAnnotated: false, isNullable: false);
            verify("C3.F4", "T?", isAnnotated: true, isNullable: true);
            verify("C3.F5", "T", isAnnotated: false, isNullable: false);
            verify("C3.F6", "T?", isAnnotated: true, isNullable: true);
            verify("C3.F7", "T?", isAnnotated: true, isNullable: true);

            // https://github.com/dotnet/roslyn/issues/29845: Test nested nullability.
            // https://github.com/dotnet/roslyn/issues/29845: Test all combinations of overrides.

            void verify(string methodName, string displayName, bool isAnnotated, bool? isNullable)
            {
                var method = comp.GetMember<MethodSymbol>(methodName);
                var type = method.ReturnType;
                Assert.Equal(displayName, type.ToTestDisplayString(true));
                Assert.Equal(isAnnotated, type.IsAnnotated);
                Assert.Equal(isNullable, type.IsNullable);
            }
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_01()
        {
            var source = @"
class A
{
    public virtual T? Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override T? Foo<T>()
    {
        return null;
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            //var a = compilation.GetTypeByMetadataName("A");
            //var aFoo = a.GetMember<MethodSymbol>("Foo");
            //Assert.Equal("T? A.Foo<T>()", aFoo.ToTestDisplayString());

            //var b = compilation.GetTypeByMetadataName("B");
            //var bFoo = b.GetMember<MethodSymbol>("Foo");
            //Assert.Equal("T? A.Foo<T>()", bFoo.OverriddenMethod.ToTestDisplayString());

            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_02()
        {
            var source = @"
class A
{
    public virtual void Foo<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void Foo<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_03()
        {
            var source = @"
class A
{
    public virtual System.Nullable<T> Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override T? Foo<T>()
    {
        return null;
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_04()
        {
            var source = @"
class A
{
    public virtual void Foo<T>(System.Nullable<T> x) where T : struct 
    { 
    }
}

class B : A
{
    public override void Foo<T>(T? x)
    {
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_05()
        {
            var source = @"
class A
{
    public virtual T? Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override System.Nullable<T> Foo<T>()
    {
        return null;
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_06()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void M1<T>(System.Nullable<T> x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.IsValueType);
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_03()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : class 
    { 
    }

    public virtual T? M2<T>() where T : class 
    { 
        return null;
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override T? M2<T>()
    { 
        return null;
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.IsNullable);
            Assert.True(m1.Parameters[0].Type.IsReferenceType);
            Assert.False(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m2 = b.GetMember<MethodSymbol>("M2");
            Assert.False(m2.ReturnType.IsNullableType());
            Assert.True(m2.ReturnType.IsNullable);
            Assert.True(m2.ReturnType.IsReferenceType);
            Assert.False(m2.OverriddenMethod.ReturnType.IsNullableType());
        }

        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29846 : Override matches other M3<T>.")]
        [WorkItem(29846, "https://github.com/dotnet/roslyn/issues/29846")]
        public void Overriding_04()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }

    public virtual void M1<T>(T x) 
    { 
    }

    public virtual void M2<T>(T? x) where T : struct 
    { 
    }

    public virtual void M2<T>(T x) 
    { 
    }

    public virtual void M3<T>(T x) 
    { 
    }

    public virtual void M3<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T x)
    {
    }

    public override void M3<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m2 = b.GetMember<MethodSymbol>("M2");
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m2.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.Parameters[0].Type.IsNullableType());
            Assert.True(m3.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        [WorkItem(29847, "https://github.com/dotnet/roslyn/issues/29847")]
        public void Overriding_05()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }

    public virtual void M1<T>(T? x) where T : class 
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }
} 

class C
{
    public virtual void M2<T>(T? x) where T : class 
    { 
    }

    public virtual void M2<T>(T? x) where T : struct 
    { 
    }
}

class D : C
{
    public override void M2<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29847: The overriding is ambiguous.
            // We simply matched the first candidate. Should this be an error?
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var d = compilation.GetTypeByMetadataName("D");
            var m2 = d.GetMember<MethodSymbol>("M2");
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m2.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_06()
        {
            var source = @"
class A
{
    public virtual void M1<T>(System.Nullable<T> x) where T : struct
    {
    }

    public virtual void M2<T>(T? x) where T : struct
    {
    }

    public virtual void M3<T>(C<T?> x) where T : struct
    {
    }

    public virtual void M4<T>(C<System.Nullable<T>> x) where T : struct
    {
    }

    public virtual void M5<T>(C<T?> x) where T : class
    {
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T? x)
    {
    }

    public override void M3<T>(C<T?> x)
    {
    }

    public override void M4<T>(C<T?> x)
    {
    }

    public override void M5<T>(C<T?> x)
    {
    }
}

class C<T> {}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m3 = b.GetMember<MethodSymbol>("M3");
            var m4 = b.GetMember<MethodSymbol>("M4");
            var m5 = b.GetMember<MethodSymbol>("M5");
            Assert.True(((NamedTypeSymbol)m3.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m3.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m4.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m4.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.False(((NamedTypeSymbol)m5.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.False(((NamedTypeSymbol)m5.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
        }

        [Fact]
        public void Overriding_07()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }
}

class B : A
{
    public void M1<T>(T? x) where T : struct
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsValueType);
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_08()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }
}

class B : A
{
    public override void M1<T>(T? x) where T : struct
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (11,38): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(11, 38),
                // (11,26): error CS0506: 'B.M1<T>(T?)': cannot override inherited member 'A.M1<T>(T)' because it is not marked virtual, abstract, or override
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M1").WithArguments("B.M1<T>(T?)", "A.M1<T>(T)").WithLocation(11, 26),
                // (11,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.False(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsValueType);
            Assert.False(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsReferenceType);
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_09()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }

    public void M2<T>(T? x) 
    {
    }

    public void M3<T>(T? x) where T : class
    {
    }

    public void M4<T>(T? x) where T : struct
    {
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T? x)
    {
    }

    public override void M3<T>(T? x)
    {
    }

    public override void M4<T>(T? x)
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (8,23): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void M2<T>(T? x) 
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 23),
                // (27,26): error CS0506: 'B.M2<T>(T?)': cannot override inherited member 'A.M2<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M2<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M2").WithArguments("B.M2<T>(T?)", "A.M2<T>(T?)").WithLocation(27, 26),
                // (31,26): error CS0506: 'B.M3<T>(T?)': cannot override inherited member 'A.M3<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M3<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M3").WithArguments("B.M3<T>(T?)", "A.M3<T>(T?)").WithLocation(31, 26),
                // (35,26): error CS0506: 'B.M4<T>(T?)': cannot override inherited member 'A.M4<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M4<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M4").WithArguments("B.M4<T>(T?)", "A.M4<T>(T?)").WithLocation(35, 26),
                // (23,26): error CS0506: 'B.M1<T>(T?)': cannot override inherited member 'A.M1<T>(T)' because it is not marked virtual, abstract, or override
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M1").WithArguments("B.M1<T>(T?)", "A.M1<T>(T)").WithLocation(23, 26),
                // (23,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(23, 32),
                // (27,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M2<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(27, 32),
                // (31,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M3<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(31, 32),
                // (35,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M4<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(35, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            var m2 = b.GetMember<MethodSymbol>("M2");
            var m3 = b.GetMember<MethodSymbol>("M3");
            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m3.Parameters[0].Type.IsNullableType());
            Assert.False(m4.Parameters[0].Type.IsNullableType());

            Assert.Null(m1.OverriddenMethod);
            Assert.Null(m2.OverriddenMethod);
            Assert.Null(m3.OverriddenMethod);
            Assert.Null(m4.OverriddenMethod);
        }

        [Fact]
        public void Overriding_10()
        {
            var source = @"
class A
{
    public virtual void M1<T>(System.Nullable<T> x) where T : class
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (4,50): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                //     public virtual void M1<T>(System.Nullable<T> x) where T : class
                Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "T").WithLocation(4, 50),
                // (11,26): error CS0115: 'B.M1<T>(T?)': no suitable method found to override
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M1").WithArguments("B.M1<T>(T?)").WithLocation(11, 26),
                // (11,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_11()
        {
            var source = @"
class A
{
    public virtual C<System.Nullable<T>> M1<T>() where T : class
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override C<T?> M1<T>()
    {
        throw new System.NotImplementedException();
    }
} 

class C<T> {}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (4,42): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual C<System.Nullable<T>> M1<T>() where T : class
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M1").WithArguments("System.Nullable<T>", "T", "T").WithLocation(4, 42),
                 // (12,27): error CS0508: 'B.M1<T>()': return type must be 'C<T?>' to match overridden member 'A.M1<T>()'
                 //     public override C<T?> M1<T>()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M1").WithArguments("B.M1<T>()", "A.M1<T>()", "C<T?>").WithLocation(12, 27)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(((NamedTypeSymbol)m1.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m1.OverriddenMethod.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
        }

        [Fact]
        public void Overriding_12()
        {
            var source = @"
class A
{
    public virtual string M1()
    { 
        throw new System.NotImplementedException();
    }

    public virtual string? M2()
    { 
        throw new System.NotImplementedException();
    }

    public virtual string? M3()
    { 
        throw new System.NotImplementedException();
    }

    public virtual System.Nullable<string> M4()
    { 
        throw new System.NotImplementedException();
    }

    public System.Nullable<string> M5()
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override string? M1()
    {
        throw new System.NotImplementedException();
    }

    public override string? M2()
    {
        throw new System.NotImplementedException();
    }

    public override string M3()
    {
        throw new System.NotImplementedException();
    }

    public override string? M4()
    {
        throw new System.NotImplementedException();
    }

    public override string? M5()
    {
        throw new System.NotImplementedException();
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (32,29): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string? M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(32, 29),
                 // (42,28): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string M3()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M3").WithLocation(42, 28),
                 // (47,29): error CS0508: 'B.M4()': return type must be 'string?' to match overridden member 'A.M4()'
                 //     public override string? M4()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M4").WithArguments("B.M4()", "A.M4()", "string?").WithLocation(47, 29),
                 // (52,29): error CS0506: 'B.M5()': cannot override inherited member 'A.M5()' because it is not marked virtual, abstract, or override
                 //     public override string? M5()
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5()", "A.M5()").WithLocation(52, 29),
                 // (19,44): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual System.Nullable<string> M4()
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M4").WithArguments("System.Nullable<T>", "T", "string").WithLocation(19, 44),
                 // (24,36): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public System.Nullable<string> M5()
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M5").WithArguments("System.Nullable<T>", "T", "string").WithLocation(24, 36)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.ReturnType.IsNullableType());
            Assert.False(m1.OverriddenMethod.ReturnType.IsNullableType());

            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m4.ReturnType.IsNullableType());
            Assert.True(m4.OverriddenMethod.ReturnType.IsNullableType());

            var m5 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m5.ReturnType.IsNullableType());
        }

        [Fact]
        public void Overriding_13()
        {
            var source = @"
class A
{
    public virtual void M1(string x)
    { 
    }

    public virtual void M2(string? x)
    { 
    }

    public virtual void M3(string? x)
    { 
    }

    public virtual void M4(System.Nullable<string> x)
    { 
    }

    public void M5(System.Nullable<string> x)
    { 
    }
}

class B : A
{
    public override void M1(string? x)
    {
    }

    public override void M2(string? x)
    {
    }

    public override void M3(string x)
    {
    }

    public override void M4(string? x)
    {
    }

    public override void M5(string? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (27,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M1(string? x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(27, 26),
                 // (35,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M3(string x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M3").WithArguments("x").WithLocation(35, 26),
                 // (39,26): error CS0115: 'B.M4(string)': no suitable method found to override
                 //     public override void M4(string? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M4").WithArguments("B.M4(string?)").WithLocation(39, 26),
                 // (43,26): error CS0115: 'B.M5(string)': no suitable method found to override
                 //     public override void M5(string? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M5").WithArguments("B.M5(string?)").WithLocation(43, 26),
                 // (16,52): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual void M4(System.Nullable<string> x)
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "string").WithLocation(16, 52),
                 // (20,44): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public void M5(System.Nullable<string> x)
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "string").WithLocation(20, 44)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.IsNullable);
            Assert.True(m1.Parameters[0].Type.IsReferenceType);
            Assert.False(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m4.Parameters[0].Type.IsNullableType());
            Assert.Null(m4.OverriddenMethod);

            var m5 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m5.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_14()
        {
            var source = @"
class A
{
    public virtual int M1()
    { 
        throw new System.NotImplementedException();
    }

    public virtual int? M2()
    { 
        throw new System.NotImplementedException();
    }

    public virtual int? M3()
    { 
        throw new System.NotImplementedException();
    }

    public virtual System.Nullable<int> M4()
    { 
        throw new System.NotImplementedException();
    }

    public System.Nullable<int> M5()
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override int? M1()
    {
        throw new System.NotImplementedException();
    }

    public override int? M2()
    {
        throw new System.NotImplementedException();
    }

    public override int M3()
    {
        throw new System.NotImplementedException();
    }

    public override int? M4()
    {
        throw new System.NotImplementedException();
    }

    public override int? M5()
    {
        throw new System.NotImplementedException();
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (42,25): error CS0508: 'B.M3()': return type must be 'int?' to match overridden member 'A.M3()'
                 //     public override int M3()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M3").WithArguments("B.M3()", "A.M3()", "int?").WithLocation(42, 25),
                 // (52,26): error CS0506: 'B.M5()': cannot override inherited member 'A.M5()' because it is not marked virtual, abstract, or override
                 //     public override int? M5()
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5()", "A.M5()").WithLocation(52, 26),
                 // (32,26): error CS0508: 'B.M1()': return type must be 'int' to match overridden member 'A.M1()'
                 //     public override int? M1()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M1").WithArguments("B.M1()", "A.M1()", "int").WithLocation(32, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            Assert.True(b.GetMember<MethodSymbol>("M1").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M2").ReturnType.IsNullableType());
            Assert.False(b.GetMember<MethodSymbol>("M3").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M4").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M5").ReturnType.IsNullableType());
        }

        [Fact]
        public void Overriding_15()
        {
            var source = @"
class A
{
    public virtual void M1(int x)
    { 
    }

    public virtual void M2(int? x)
    { 
    }

    public virtual void M3(int? x)
    { 
    }

    public virtual void M4(System.Nullable<int> x)
    { 
    }

    public void M5(System.Nullable<int> x)
    { 
    }
}

class B : A
{
    public override void M1(int? x)
    {
    }

    public override void M2(int? x)
    {
    }

    public override void M3(int x)
    {
    }

    public override void M4(int? x)
    {
    }

    public override void M5(int? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (35,26): error CS0115: 'B.M3(int)': no suitable method found to override
                 //     public override void M3(int x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M3").WithArguments("B.M3(int)").WithLocation(35, 26),
                 // (43,26): error CS0506: 'B.M5(int?)': cannot override inherited member 'A.M5(int?)' because it is not marked virtual, abstract, or override
                 //     public override void M5(int? x)
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5(int?)", "A.M5(int?)").WithLocation(43, 26),
                 // (27,26): error CS0115: 'B.M1(int?)': no suitable method found to override
                 //     public override void M1(int? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M1").WithArguments("B.M1(int?)").WithLocation(27, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            Assert.True(b.GetMember<MethodSymbol>("M1").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M2").Parameters[0].Type.IsNullableType());
            Assert.False(b.GetMember<MethodSymbol>("M3").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M4").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M5").Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_16()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract event System.Action<string> E1; 
    public abstract event System.Action<string>? E2; 
    public abstract event System.Action<string?>? E3; 
}

class B1 : A
{
    public override event System.Action<string?> E1 {add {} remove{}}
    public override event System.Action<string> E2 {add {} remove{}}
    public override event System.Action<string?>? E3 {add {} remove{}}
}

class B2 : A
{
    public override event System.Action<string?> E1; // 2
    public override event System.Action<string> E2; // 2
    public override event System.Action<string?>? E3; // 2

    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
        var e3 = E3;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (19,49): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string> E2;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E2").WithLocation(19, 49),
                 // (18,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string?> E1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(18, 50),
                 // (26,49): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string> E2; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E2").WithLocation(26, 49),
                 // (25,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string?> E1; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(25, 50)
                );

            foreach (string typeName in new[] { "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (string memberName in new[] { "E1", "E2" })
                {
                    var member = type.GetMember<EventSymbol>(memberName);
                    Assert.False(member.Type.Equals(member.OverriddenEvent.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }

                var e3 = type.GetMember<EventSymbol>("E3");
                Assert.True(e3.Type.Equals(e3.OverriddenEvent.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A", "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        [WorkItem(29851, "https://github.com/dotnet/roslyn/issues/29851")]
        public void Overriding_Methods()
        {
            var source = @"
using System.Runtime.CompilerServices;
public abstract class A
{
" + NonNullTypesOff() + @"
    public abstract System.Action<string> Oblivious1(System.Action<string> x);
" + NonNullTypesOn() + @"
    [return: NonNullTypes(false)]
    public abstract System.Action<string> Oblivious2([NonNullTypes(false)] System.Action<string> x);
    public abstract System.Action<string> M3(System.Action<string> x);
    public abstract System.Action<string> M4(System.Action<string> x);
    public abstract System.Action<string>? M5(System.Action<string>? x);
}

public class B1 : A
{
    public override System.Action<string?> Oblivious1(System.Action<string?> x) => throw null;
    public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
    public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
    public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
    public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
}

public class B2 : A
{
    [return: NonNullTypes(false)]
    public override System.Action<string> Oblivious1([NonNullTypes(false)] System.Action<string> x) => throw null;
    public override System.Action<string> Oblivious2(System.Action<string> x) => throw null;
" + NonNullTypesOff() + @"
    public override System.Action<string> M3(System.Action<string> x) => throw null;
" + NonNullTypesOn() + @"
    [return: NonNullTypes(false)]
    public override System.Action<string> M4([NonNullTypes(false)] System.Action<string> x) => throw null;
" + NonNullTypesOff() + @"
    public override System.Action<string> M5(System.Action<string> x) => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (8,14): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     [return: NonNullTypes(false)]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(8, 14),
                // (9,55): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     public abstract System.Action<string> Oblivious2([NonNullTypes(false)] System.Action<string> x);
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(9, 55),
                // (18,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "Oblivious2").WithLocation(18, 44),
                // (18,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "Oblivious2").WithArguments("x").WithLocation(18, 44),
                // (19,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M3").WithLocation(19, 44),
                // (19,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M3").WithArguments("x").WithLocation(19, 44),
                // (20,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M4").WithLocation(20, 44),
                // (20,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M4").WithArguments("x").WithLocation(20, 44),
                // (21,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M5").WithLocation(21, 44),
                // (21,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M5").WithArguments("x").WithLocation(21, 44),
                // (32,14): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     [return: NonNullTypes(false)]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(32, 14),
                // (33,47): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     public override System.Action<string> M4([NonNullTypes(false)] System.Action<string> x) => throw null;
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(33, 47),
                // (26,14): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     [return: NonNullTypes(false)]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(26, 14),
                // (27,55): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     public override System.Action<string> Oblivious1([NonNullTypes(false)] System.Action<string> x) => throw null;
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(27, 55)
                );

            var b1 = compilation.GetTypeByMetadataName("B1");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "Oblivious1");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "Oblivious2");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M3");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M4");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M5");

            var b2 = compilation.GetTypeByMetadataName("B2");
            verifyMethodMatchesOverridden(expectMatch: false, b2, "Oblivious1"); // https://github.com/dotnet/roslyn/issues/29851: They should match
            verifyMethodMatchesOverridden(expectMatch: true, b2, "Oblivious2"); // https://github.com/dotnet/roslyn/issues/29851: They should not match
            verifyMethodMatchesOverridden(expectMatch: false, b2, "M3");
            verifyMethodMatchesOverridden(expectMatch: true, b2, "M4"); // https://github.com/dotnet/roslyn/issues/29851: They should not match
            verifyMethodMatchesOverridden(expectMatch: false, b2, "M5");

            void verifyMethodMatchesOverridden(bool expectMatch, NamedTypeSymbol type, string methodName)
            {
                var member = type.GetMember<MethodSymbol>(methodName);
                Assert.Equal(expectMatch, member.ReturnType.Equals(member.OverriddenMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                Assert.Equal(expectMatch, member.Parameters.Single().Type.Equals(member.OverriddenMethod.Parameters.Single().Type, TypeCompareKind.ConsiderEverything));
            }
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Base<T>
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T>
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (7,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public virtual List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 25),
                // (12,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 26),
                // (12,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(12, 27)
                );
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument_WithClassConstraint()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Base<T> where T : class
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T> where T : class
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (12,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(12, 27)
                );
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument_WithStructConstraint()
        {
            var source = @"

public class List<T> { }
public class Base<T> where T : struct
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T> where T : struct
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_Indexer()
        {
            var source = @"
using System.Runtime.CompilerServices;
public class List<T> { }
public class Base
{
    public virtual List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
public class Class : Base
{
" + NonNullTypesOff() + @"
    public override List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
public class Class2 : Base {
" + NonNullTypesOn() + @"
    public override List<string[]> this[[NonNullTypes(false)] List<string[]> x] { [return: NonNullTypes(false)] get => throw null; set => throw null; }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,92): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     public override List<string[]> this[[NonNullTypes(false)] List<string[]> x] { [return: NonNullTypes(false)] get => throw null; set => throw null; }
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(15, 92),
                // (15,42): error CS0592: Attribute 'NonNullTypes' is not valid on this declaration type. It is only valid on 'module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
                //     public override List<string[]> this[[NonNullTypes(false)] List<string[]> x] { [return: NonNullTypes(false)] get => throw null; set => throw null; }
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "NonNullTypes").WithArguments("NonNullTypes", "module, class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(15, 42));
        }

        [Fact]
        public void Overriding_Indexer2()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Oblivious
{
" + NonNullTypesOff() + @"
    public virtual List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
" + NonNullTypesOn() + @"
public class Class : Oblivious
{
    public override List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_21()
        {
            var source = @"

class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract event System.Action<string> E1; 
    public abstract event System.Action<string>? E2; 
}

class B1 : A
{
" + NonNullTypesOff() + @"
    public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
" + NonNullTypesOff() + @"
    public override event System.Action<string> E2 {add {} remove{}}
}
" + NonNullTypesOn() + @"
class B2 : A
{
" + NonNullTypesOff() + @"
    public override event System.Action<string?> E1; // 3, 4
" + NonNullTypesOff() + @"
    public override event System.Action<string> E2;
" + NonNullTypesOn() + @"
    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (19,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                //     public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(19, 50),
                // (27,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                //     public override event System.Action<string?> E1; // 3, 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(27, 50),
                // (27,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override event System.Action<string?> E1; // 3, 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(27, 47),
                // (19,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 47)
                );
        }

        [Fact]
        public void Implementing_01()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    event System.Action<string> E1; 
    event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B1 : IA
{
    public event System.Action<string?> E1 {add {} remove{}}
    public event System.Action<string> E2 {add {} remove{}}
    public event System.Action<string?>? E3 {add {} remove{}}
}

class B2 : IA
{
    public event System.Action<string?> E1; // 2
    public event System.Action<string> E2; // 2
    public event System.Action<string?>? E3; // 2

    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
        var e3 = E3;
    }
}

";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (26,40): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string>? IA.E2'.
                 //     public event System.Action<string> E2; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(26, 40),
                 // (25,41): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string> IA.E1'.
                 //     public event System.Action<string?> E1; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(25, 41),
                 // (19,40): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string>? IA.E2'.
                 //     public event System.Action<string> E2 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(19, 40),
                 // (18,41): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string> IA.E1'.
                 //     public event System.Action<string?> E1 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(18, 41)
                );

            var ia = compilation.GetTypeByMetadataName("IA");

            foreach (string memberName in new[] { "E1", "E2" })
            {
                var member = ia.GetMember<EventSymbol>(memberName);

                foreach (string typeName in new[] { "B1", "B2" })
                {
                    var type = compilation.GetTypeByMetadataName(typeName);

                    var impl = (EventSymbol)type.FindImplementationForInterfaceMember(member);
                    Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }
            }

            var e3 = ia.GetMember<EventSymbol>("E3");

            foreach (string typeName in new[] { "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                var impl = (EventSymbol)type.FindImplementationForInterfaceMember(e3);
                Assert.True(impl.Type.Equals(e3.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_02()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    event System.Action<string> E1; 
    event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B1 : IA
{
    event System.Action<string?> IA.E1 {add {} remove{}}
    event System.Action<string> IA.E2 {add {} remove{}}
    event System.Action<string?>? IA.E3 {add {} remove{}}
}

interface IB
{
    //event System.Action<string> E1; 
    //event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B2 : IB
{
    //event System.Action<string?> IB.E1; // 2
    //event System.Action<string> IB.E2; // 2
    event System.Action<string?>? IB.E3; // 2
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (34,37): error CS0071: An explicit interface implementation of an event must use event accessor syntax
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_ExplicitEventFieldImpl, ".").WithLocation(34, 37),
                 // (34,40): error CS1519: Invalid token ';' in class, struct, or interface member declaration
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_InvalidMemberDecl, ";").WithArguments(";").WithLocation(34, 40),
                 // (34,40): error CS1519: Invalid token ';' in class, struct, or interface member declaration
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_InvalidMemberDecl, ";").WithArguments(";").WithLocation(34, 40),
                 // (34,38): error CS0539: 'B2.' in explicit interface declaration is not a member of interface
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_InterfaceMemberNotFound, "").WithArguments("B2.").WithLocation(34, 38),
                 // (34,38): error CS0065: 'B2.': event property must have both add and remove accessors
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_EventNeedsBothAccessors, "").WithArguments("B2.").WithLocation(34, 38),
                 // (30,12): error CS0535: 'B2' does not implement interface member 'IB.E3'
                 // class B2 : IB
                 Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "IB").WithArguments("B2", "IB.E3").WithLocation(30, 12),
                 // (18,37): warning CS8615: Nullability of reference types in type doesn't match implemented member 'event Action<string> IA.E1'.
                 //     event System.Action<string?> IA.E1 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(18, 37),
                 // (19,36): warning CS8615: Nullability of reference types in type doesn't match implemented member 'event Action<string>? IA.E2'.
                 //     event System.Action<string> IA.E2 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(19, 36)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b1 = compilation.GetTypeByMetadataName("B1");

            foreach (string memberName in new[] { "E1", "E2" })
            {
                var member = ia.GetMember<EventSymbol>(memberName);

                var impl = (EventSymbol)b1.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var e3 = ia.GetMember<EventSymbol>("E3");
            {
                var impl = (EventSymbol)b1.FindImplementationForInterfaceMember(e3);
                Assert.True(impl.Type.Equals(e3.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "B1" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_17()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract string?[] P1 {get; set;} 
    public abstract string[] P2 {get; set;} 

    public abstract string?[] this[int x] {get; set;} 
    public abstract string[] this[short x] {get; set;} 
}

abstract class A2
{
    public abstract string?[]? P3 {get; set;} 

    public abstract string?[]? this[long x] {get; set;} 
}

class B1 : A1
{
    public override string[] P1 {get; set;} 
    public override string[]? P2 {get; set;} 
    
    public override string[] this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
    
    public override string[]? this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}

class B2 : A2
{
    public override string?[]? P3 {get; set;} 
    
    public override string?[]? this[long x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (28,31): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[]? P2 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "P2").WithLocation(28, 31),
                 // (30,30): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[] this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "this").WithLocation(30, 30),
                 // (36,31): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[]? this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "this").WithLocation(36, 31),
                 // (27,30): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[] P1 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "P1").WithLocation(27, 30)
                );

            foreach (var member in compilation.GetTypeByMetadataName("B1").GetMembers().OfType<PropertySymbol>())
            {
                Assert.False(member.Type.Equals(member.OverriddenProperty.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("B2").GetMembers().OfType<PropertySymbol>())
            {
                Assert.True(member.Type.Equals(member.OverriddenProperty.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A1", "B1", "A2", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_22()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract string?[] P1 {get; set;} // 1
    public abstract string[] P2 {get; set;} 

    public abstract string?[] this[int x] {get; set;} // 2
    public abstract string[] this[short x] {get; set;} 
}

class B1 : A1
{
" + NonNullTypesOff() + @"
    public override string[] P1 {get; set;}
" + NonNullTypesOff() + @"
    public override string[]? P2 {get; set;} // 3
    
" + NonNullTypesOff() + @"
    public override string[] this[int x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
    
" + NonNullTypesOff() + @"
    public override string[]? this[short x] // 4
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyDiagnostics(
                // (14,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract string?[] this[int x] {get; set;} // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 27),
                // (11,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract string?[] P1 {get; set;} // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 27),
                // (23,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string[]? P2 {get; set;} // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 29),
                // (33,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string[]? this[short x] // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 29)
                );
        }

        [Fact]
        public void Implementing_03()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    string?[] P1 {get; set;} 
    string[] P2 {get; set;} 
    string?[] this[int x] {get; set;} 
    string[] this[short x] {get; set;} 
}
interface IA2
{
    string?[]? P3 {get; set;} 
    string?[]? this[long x] {get; set;} 
}
class B : IA, IA2
{
    public string[] P1 {get; set;} 
    public string[]? P2 {get; set;} 
    public string?[]? P3 {get; set;} 

    public string[] this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    public string[]? this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    public string?[]? this[long x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,22): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string[] IA.P2'.
                 //     public string[]? P2 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "P2").WithArguments("string[] IA.P2").WithLocation(23, 22),
                 // (26,21): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string?[] IA.this[int x]'.
                 //     public string[] this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "this").WithArguments("string?[] IA.this[int x]").WithLocation(26, 21),
                 // (32,22): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string[] IA.this[short x]'.
                 //     public string[]? this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "this").WithArguments("string[] IA.this[short x]").WithLocation(32, 22),
                 // (22,21): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string?[] IA.P1'.
                 //     public string[] P1 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "P1").WithArguments("string?[] IA.P1").WithLocation(22, 21)
                );

            var b = compilation.GetTypeByMetadataName("B");

            foreach (var member in compilation.GetTypeByMetadataName("IA").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("IA2").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.True(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "IA2", "B" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_04()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    string?[] P1 {get; set;} 
    string[] P2 {get; set;} 
    string?[] this[int x] {get; set;} 
    string[] this[short x] {get; set;} 
}
interface IA2
{
    string?[]? P3 {get; set;} 
    string?[]? this[long x] {get; set;} 
}
class B : IA, IA2
{
    string[] IA.P1 {get; set;} 
    string[]? IA.P2 {get; set;} 
    string?[]? IA2.P3 {get; set;} 

    string[] IA.this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    string[]? IA.this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    string?[]? IA2.this[long x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (22,17): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string?[] IA.P1'.
                 //     string[] IA.P1 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "P1").WithArguments("string?[] IA.P1").WithLocation(22, 17),
                 // (23,18): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string[] IA.P2'.
                 //     string[]? IA.P2 {get; set;} 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "P2").WithArguments("string[] IA.P2").WithLocation(23, 18),
                 // (26,17): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string?[] IA.this[int x]'.
                 //     string[] IA.this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "this").WithArguments("string?[] IA.this[int x]").WithLocation(26, 17),
                 // (32,18): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string[] IA.this[short x]'.
                 //     string[]? IA.this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "this").WithArguments("string[] IA.this[short x]").WithLocation(32, 18)
                );

            var b = compilation.GetTypeByMetadataName("B");

            foreach (var member in compilation.GetTypeByMetadataName("IA").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("IA2").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.True(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "IA2", "B" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_18()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract string[] M1(); 
    public abstract T[] M2<T>() where T : class; 
    public abstract T?[]? M3<T>() where T : class; 
}

class B : A
{
    public override string?[] M1()
    {
        return new string?[] {};
    } 

    public override S?[] M2<S>()
    {
        return new S?[] {};
    } 

    public override S?[]? M3<S>()
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,26): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override S?[] M2<S>()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M2").WithLocation(23, 26),
                 // (18,31): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string?[] M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(18, 31)
                );

            var b = compilation.GetTypeByMetadataName("B");
            foreach (string memberName in new[] { "M1", "M2" })
            {
                var member = b.GetMember<MethodSymbol>(memberName);
                Assert.False(member.ReturnType.Equals(member.OverriddenMethod.ConstructIfGeneric(member.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.ReturnType.Equals(m3.OverriddenMethod.ConstructIfGeneric(m3.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).ReturnType,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void Overriding_23()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract string[] M1(); 
    public abstract T[] M2<T>() where T : class; 
}

class B : A
{
" + NonNullTypesOff() + @"
    public override string?[] M1()
    {
        return new string?[] {};
    } 

" + NonNullTypesOff() + @"
    public override S?[] M2<S>()
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (18,31): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override string?[] M1()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(18, 31),
                // (24,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override S?[] M2<S>()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(24, 22),
                // (24,26): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override S?[] M2<S>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M2").WithLocation(24, 26),
                // (18,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string?[] M1()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 27),
                // (20,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new string?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 26),
                // (26,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new S?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 21)
                );
        }

        [Fact]
        public void Implementing_05()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    string[] M1(); 
    T[] M2<T>() where T : class; 
    T?[]? M3<T>() where T : class; 
}

class B : IA
{
    public string?[] M1()
    {
        return new string?[] {};
    } 

    public S?[] M2<S>() where S : class
    {
        return new S?[] {};
    } 

    public S?[]? M3<S>() where S : class
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,17): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'T[] IA.M2<T>()'.
                 //     public S?[] M2<S>() where S : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(23, 17),
                 // (18,22): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'string[] IA.M1()'.
                 //     public string?[] M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(18, 22)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Implementing_06()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    string[] M1(); 
    T[] M2<T>() where T : class; 
    T?[]? M3<T>() where T : class; 
}

class B : IA
{
    string?[] IA.M1()
    {
        return new string?[] {};
    } 

    S?[] IA.M2<S>() 
    {
        return new S?[] {};
    } 

    S?[]? IA.M3<S>() 
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,13): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T[] IA.M2<T>()'.
                 //     S?[] IA.M2<S>() 
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(23, 13),
                 // (18,18): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string[] IA.M1()'.
                 //     string?[] IA.M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(18, 18)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void ImplementingNonNullWithNullable()
        {
            var source = @"
interface IA
{
    string[] M1();
    T[] M2<T>() where T : class;
}

class B : IA
{
" + NonNullTypesOff() + @"
    string?[] IA.M1()
    {
        return new string?[] {};
    }

" + NonNullTypesOff() + @"
    S?[] IA.M2<S>()
    {
        return new S?[] {};
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (11,18): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string[] IA.M1()'.
                //     string?[] IA.M1()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(11, 18),
                // (17,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     S?[] IA.M2<S>()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 6),
                // (17,13): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T[] IA.M2<T>()'.
                //     S?[] IA.M2<S>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(17, 13),
                // (11,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] IA.M1()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 11),
                // (13,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new string?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 26),
                // (19,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new S?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 21)
                );
        }

        [Fact]
        public void ImplementingNullableWithNonNull()
        {
            var source = @"
interface IA
{
" + NonNullTypesOff() + @"
    string?[] M1();
" + NonNullTypesOff() + @"
    T?[] M2<T>() where T : class;
}
" + NonNullTypesOn() + @"
class B : IA
{
    string[] IA.M1() => throw null;
    S[] IA.M2<S>() => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (13,12): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T?[] IA.M2<T>()'.
                //     S[] IA.M2<S>() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T?[] IA.M2<T>()").WithLocation(13, 12),
                // (12,17): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string?[] IA.M1()'.
                //     string[] IA.M1() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string?[] IA.M1()").WithLocation(12, 17),
                // (7,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T?[] M2<T>() where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 6),
                // (7,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T?[] M2<T>() where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 5),
                // (5,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] M1();
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 11)
                );
        }

        [Fact]
        public void ImplementingObliviousWithNonNull()
        {
            var source = @"
interface IA
{
" + NonNullTypesOff() + @"
    string[] M1();
" + NonNullTypesOff() + @"
    T[] M2<T>() where T : class;
}
" + NonNullTypesOn() + @"
class B : IA
{
    string[] IA.M1() => throw null;
    S[] IA.M2<S>() => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_19()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract void M1(string[] x); 
    public abstract void M2<T>(T[] x) where T : class; 
    public abstract void M3<T>(T?[]? x) where T : class; 
}

class B : A
{
    public override void M1(string?[] x)
    {
    } 

    public override void M2<T>(T?[] x)
    {
    } 

    public override void M3<T>(T?[]? x)
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (22,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M2<T>(T?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M2").WithArguments("x").WithLocation(22, 26),
                 // (18,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(18, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            foreach (string memberName in new[] { "M1", "M2" })
            {
                var member = b.GetMember<MethodSymbol>(memberName);
                Assert.False(member.Parameters[0].Type.Equals(member.OverriddenMethod.ConstructIfGeneric(member.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.Parameters[0].Type.Equals(m3.OverriddenMethod.ConstructIfGeneric(m3.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).Parameters[0].Type,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void Overriding_24()
        {
            var source = @"
" + NonNullTypesOn() + @"

abstract class A
{
    public abstract void M1(string[] x); 
    public abstract void M2<T>(T[] x) where T : class; 
}

class B : A
{
" + NonNullTypesOff() + @"
    public override void M1(string?[] x)
    {
    } 

" + NonNullTypesOff() + @"
    public override void M2<T>(T?[] x)
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyDiagnostics(
                // (13,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override void M1(string?[] x)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(13, 26),
                // (18,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override void M2<T>(T?[] x)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M2").WithArguments("x").WithLocation(18, 26),
                // (18,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override void M2<T>(T?[] x)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 33),
                // (13,35): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override void M1(string?[] x)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 35)
                );
        }

        [Fact]
        public void Overriding_25()
        {
            var ilSource = @"
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}

.assembly '<<GeneratedFileName>>'
{
}

.module '<<GeneratedFileName>>.dll'
.custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 ) 

.class public auto ansi beforefieldinit C`2<T,S>
       extends [mscorlib]System.Object
{
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method C`2::.ctor

} // end of class C`2

.class public abstract auto ansi beforefieldinit A
       extends [mscorlib]System.Object
{
  .method public hidebysig newslot abstract virtual 
          instance class C`2<string modopt([mscorlib]System.Runtime.CompilerServices.IsConst),string> 
          M1() cil managed
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = ( 01 00 03 00 00 00 00 01 00 00 00 ) 
  } // end of method A::M1

  .method family hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method A::.ctor

} // end of class A

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.NullableAttribute
       extends [mscorlib]System.Attribute
{
  .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = ( 01 00 86 6B 00 00 01 00 54 02 0D 41 6C 6C 6F 77   // ...k....T..Allow
                                                                                                                         4D 75 6C 74 69 70 6C 65 00 )              // Multiple.
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(bool[] transformFlags) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

} // end of class System.Runtime.CompilerServices.NullableAttribute
";

            var source = @"
class C
{
    public static void Main()
    { 
    }
}

class B : A
{
    public override C<string, string?> M1()
    {
        return new C<string, string?>();
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, new[] { CompileIL(ilSource, prependDefaultHeader: false) },
                                                            options: WithNonNullTypesTrue(),
                                                            parseOptions: TestOptions.Regular8);

            var m1 = compilation.GetTypeByMetadataName("B").GetMember<MethodSymbol>("M1");
            Assert.Equal("C<System.String? modopt(System.Runtime.CompilerServices.IsConst), System.String>", m1.OverriddenMethod.ReturnType.ToTestDisplayString());
            Assert.Equal("C<System.String modopt(System.Runtime.CompilerServices.IsConst), System.String?>", m1.ReturnType.ToTestDisplayString());

            compilation.VerifyDiagnostics(
                 // (11,40): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override C<string, string?> M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(11, 40)
                );
        }

        [Fact]
        public void Implementing_07()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    void M1(string[] x); 
    void M2<T>(T[] x) where T : class; 
    void M3<T>(T?[]? x) where T : class; 
}
class B : IA
{
    public void M1(string?[] x)
    {
    } 

    public void M2<T>(T?[] x)  where T : class
    {
    } 

    public void M3<T>(T?[]? x)  where T : class
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (20,17): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'void IA.M2<T>(T[] x)'.
                 //     public void M2<T>(T?[] x)  where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "M2").WithArguments("x", "void IA.M2<T>(T[] x)").WithLocation(20, 17),
                 // (16,17): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'void IA.M1(string[] x)'.
                 //     public void M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "M1").WithArguments("x", "void IA.M1(string[] x)").WithLocation(16, 17)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Implementing_08()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    void M1(string[] x); 
    void M2<T>(T[] x) where T : class; 
    void M3<T>(T?[]? x) where T : class; 
}
class B : IA
{
    void IA.M1(string?[] x)
    {
    } 

    void IA.M2<T>(T?[] x)  
    {
    } 

    void IA.M3<T>(T?[]? x)  
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (20,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M2<T>(T[] x)'.
                 //     void IA.M2<T>(T?[] x)  
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M2").WithArguments("x", "void IA.M2<T>(T[] x)").WithLocation(20, 13),
                 // (16,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M1(string[] x)'.
                 //     void IA.M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M1").WithArguments("x", "void IA.M1(string[] x)").WithLocation(16, 13)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Overriding_20()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract int this[string?[] x] {get; set;} 
}
abstract class A2
{
    public abstract int this[string[] x] {get; set;} 
}
abstract class A3
{
    public abstract int this[string?[]? x] {get; set;} 
}

class B1 : A1
{
    public override int this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : A2
{
    public override int this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : A3
{
    public override int this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (24,25): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override int this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "this").WithArguments("x").WithLocation(24, 25),
                 // (32,25): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override int this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "this").WithArguments("x").WithLocation(32, 25)
                );

            foreach (string typeName in new[] { "B1", "B2" })
            {
                foreach (var member in compilation.GetTypeByMetadataName(typeName).GetMembers().OfType<PropertySymbol>())
                {
                    Assert.False(member.Parameters[0].Type.Equals(member.OverriddenProperty.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }
            }

            foreach (var member in compilation.GetTypeByMetadataName("B3").GetMembers().OfType<PropertySymbol>())
            {
                Assert.True(member.Parameters[0].Type.Equals(member.OverriddenProperty.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A1", "A2", "A3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_09()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA1
{
    int this[string?[] x] {get; set;} 
}
interface IA2
{
    int this[string[] x] {get; set;} 
}
interface IA3
{
    int this[string?[]? x] {get; set;} 
}

class B1 : IA1
{
    public int this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : IA2
{
    public int this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : IA3
{
    public int this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (32,16): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'int IA2.this[string[] x]'.
                 //     public int this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "this").WithArguments("x", "int IA2.this[string[] x]").WithLocation(32, 16),
                 // (24,16): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'int IA1.this[string?[] x]'.
                 //     public int this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "this").WithArguments("x", "int IA1.this[string?[] x]").WithLocation(24, 16)
                );

            foreach (string[] typeName in new[] { new[] { "IA1", "B1" }, new[] { "IA2", "B2" } })
            {
                var implemented = compilation.GetTypeByMetadataName(typeName[0]).GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName(typeName[1]).FindImplementationForInterfaceMember(implemented);
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var implemented = compilation.GetTypeByMetadataName("IA3").GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName("B3").FindImplementationForInterfaceMember(implemented);
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA1", "IA2", "IA3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_10()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA1
{
    int this[string?[] x] {get; set;} 
}
interface IA2
{
    int this[string[] x] {get; set;} 
}
interface IA3
{
    int this[string?[]? x] {get; set;} 
}

class B1 : IA1
{
    int IA1.this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : IA2
{
    int IA2.this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : IA3
{
    int IA3.this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (24,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'int IA1.this[string?[] x]'.
                 //     int IA1.this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "this").WithArguments("x", "int IA1.this[string?[] x]").WithLocation(24, 13),
                 // (32,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'int IA2.this[string[] x]'.
                 //     int IA2.this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "this").WithArguments("x", "int IA2.this[string[] x]").WithLocation(32, 13)
                );

            foreach (string[] typeName in new[] { new[] { "IA1", "B1" }, new[] { "IA2", "B2" } })
            {
                var implemented = compilation.GetTypeByMetadataName(typeName[0]).GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName(typeName[1]).FindImplementationForInterfaceMember(implemented);
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var implemented = compilation.GetTypeByMetadataName("IA3").GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName("B3").FindImplementationForInterfaceMember(implemented);
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA1", "IA2", "IA3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void PartialMethods_01()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

partial class C1
{
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30145: What nullability is getting emitted?
            compilation.VerifyDiagnostics(
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(16, 18),
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(16, 18),
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(16, 18)
                );

            var c1 = compilation.GetTypeByMetadataName("C1");

            var m1 = c1.GetMember<MethodSymbol>("M1");
            var m1Impl = m1.PartialImplementationPart;
            var m1Def = m1.ConstructIfGeneric(m1Impl.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));

            for (int i = 0; i < 3; i++)
            {
                Assert.False(m1Impl.Parameters[i].Type.Equals(m1Def.Parameters[i].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            Assert.True(m1Impl.Parameters[3].Type.Equals(m1Def.Parameters[3].Type,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        public void PartialMethods_02_01()
        {
            var source = @"
partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 25),
                // (10,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 24),
                // (10,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 33),
                // (10,53): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 53),
                // (10,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 52),
                // (10,74): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 74),
                // (10,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 73),
                // (10,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 77),
                // (10,79): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 79),
                // (10,82): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 82),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(10, 18),
                // (5,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 30),
                // (5,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 29),
                // (5,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 72),
                // (5,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 71),
                // (5,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 75),
                // (5,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 77),
                // (5,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 80)
                );
        }

        [Fact]
        public void PartialMethods_02_02()
        {
            var source = @"
partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}
" + NonNullTypesOn() + @"
partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(10, 18),
                // (5,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 30),
                // (5,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 29),
                // (5,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 72),
                // (5,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 71),
                // (5,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 75),
                // (5,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 77),
                // (5,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 80)
                );
        }

        [Fact]
        public void PartialMethods_03()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

partial class C1
{
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source });
            compilation.VerifyDiagnostics(
                // (17,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 25),
                // (17,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 24),
                // (17,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 33),
                // (17,53): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 53),
                // (17,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 52),
                // (17,74): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 74),
                // (17,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 73),
                // (17,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 77),
                // (17,79): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 79),
                // (17,82): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 82),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(17, 18),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(17, 18),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(17, 18),
                // (11,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 30),
                // (11,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 29),
                // (11,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 72),
                // (11,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 71),
                // (11,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 75),
                // (11,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 77),
                // (11,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 80)
                );
        }

        [Fact]
        public void Overloading_01()
        {
            var source = @"
class A
{
    void Test1(string? x1) {}
    void Test1(string x2) {}

    string Test2(string y1) { return y1; }
    string? Test2(string y2) { return y2; }
}
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).
                VerifyDiagnostics(
                // (5,10): error CS0111: Type 'A' already defines a member called 'Test1' with the same parameter types
                //     void Test1(string x2) {}
                Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "Test1").WithArguments("Test1", "A").WithLocation(5, 10),
                // (8,13): error CS0111: Type 'A' already defines a member called 'Test2' with the same parameter types
                //     string? Test2(string y2) { return y2; }
                Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "Test2").WithArguments("Test2", "A").WithLocation(8, 13)
                );
        }

        [Fact]
        public void Overloading_02()
        {
            var source = @"
class A
{
    public void M1<T>(T? x) where T : struct 
    { 
    }

    public void M1<T>(T? x) where T : class 
    { 
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact()]
        public void Test1()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        string? x1 = null;
        string? y1 = x1; 
        string z1 = x1; 
    }

    void Test2()
    {
        string? x2 = """";
        string z2 = x2; 
    }

    void Test3()
    {
        string? x3;
        string z3 = x3; 
    }

    void Test4()
    {
        string x4;
        string z4 = x4; 
    }

    void Test5()
    {
        string? x5 = """";
        x5 = null;
        string? y5;
        y5 = x5; 
        string z5;
        z5 = x5; 
    }

    void Test6()
    {
        string? x6 = """";
        string z6;
        z6 = x6; 
    }

    void Test7()
    {
        CL1? x7 = null;
        CL1 y7 = x7.P1; 
        CL1 z7 = x7?.P1;
        x7 = new CL1();
        CL1 u7 = x7.P1; 
    }

    void Test8()
    {
        CL1? x8 = new CL1();
        CL1 y8 = x8.M1(); 
        x8 = null;
        CL1 u8 = x8.M1(); 
        CL1 z8 = x8?.M1();
    }

    void Test9(CL1? x9, CL1 y9)
    {
        CL1 u9; 
        u9 = x9;
        u9 = y9;
        x9 = y9;
        CL1 v9; 
        v9 = x9;
        y9 = null;
    }

    void Test10(CL1 x10)
    {
        CL1 u10; 
        u10 = x10.P1;
        u10 = x10.P2;
        u10 = x10.M1();
        u10 = x10.M2();
        CL1? v10;
        v10 = x10.P2;
        v10 = x10.M2();
    }

    void Test11(CL1 x11, CL1? y11)
    {
        CL1 u11; 
        u11 = x11.F1;
        u11 = x11.F2;
        CL1? v11;
        v11 = x11.F2;
        x11.F2 = x11.F1;
        u11 = x11.F2;

        v11 = y11.F1;
    }

    void Test12(CL1 x12)
    {
        S1 y12;
        CL1 u12; 
        u12 = y12.F3;
        u12 = y12.F4;
    }

    void Test13(CL1 x13)
    {
        S1 y13;
        CL1? u13; 
        u13 = y13.F3;
        u13 = y13.F4;
    }

    void Test14(CL1 x14)
    {
        S1 y14;
        y14.F3 = null;
        y14.F4 = null;
        y14.F3 = x14;
        y14.F4 = x14;
    }

    void Test15(CL1 x15)
    {
        S1 y15;
        CL1 u15; 
        y15.F3 = null;
        y15.F4 = null;
        u15 = y15.F3;
        u15 = y15.F4;

        CL1? v15;
        v15 = y15.F4;
        y15.F4 = x15;
        u15 = y15.F4;
    }

    void Test16()
    {
        S1 y16;
        CL1 u16; 
        y16 = new S1();
        u16 = y16.F3;
        u16 = y16.F4;
    }

    void Test17(CL1 z17)
    {
        S1 x17;
        x17.F4 = z17;
        S1 y17 = new S1();
        CL1 u17; 
        u17 = y17.F4;

        y17 = x17;
        CL1 v17; 
        v17 = y17.F4;
    }

    void Test18(CL1 z18)
    {
        S1 x18;
        x18.F4 = z18;
        S1 y18 = x18;
        CL1 u18; 
        u18 = y18.F4;
    }

    void Test19(S1 x19, CL1 z19)
    {
        S1 y19;
        y19.F4 = null; 
        CL1 u19; 
        u19 = y19.F4;

        x19.F4 = z19;
        y19 = x19;
        CL1 v19;
        v19 = y19.F4;
    }

    void Test20(S1 x20, CL1 z20)
    {
        S1 y20;
        y20.F4 = z20;
        CL1 u20; 
        u20 = y20.F4;

        y20 = x20;
        CL1 v20;
        v20 = y20.F4;
    }

    S1 GetS1()
    {
        return new S1();
    }
    void Test21(CL1 z21)
    {
        S1 y21;
        y21.F4 = z21;
        CL1 u21; 
        u21 = y21.F4;

        y21 = GetS1();
        CL1 v21;
        v21 = y21.F4;
    }

    void Test22()
    {
        S1 y22;
        CL1 u22; 
        u22 = y22.F4;

        y22 = GetS1();
        CL1 v22;
        v22 = y22.F4;
    }

    void Test23(CL1 z23)
    {
        S2 y23;
        y23.F5.F4 = z23;
        CL1 u23; 
        u23 = y23.F5.F4;

        y23 = GetS2();
        CL1 v23;
        v23 = y23.F5.F4;
    }

    S2 GetS2()
    {
        return new S2();
    }

    void Test24()
    {
        S2 y24;
        CL1 u24; 
        u24 = y24.F5.F4; // 1
        u24 = y24.F5.F4; // 2

        y24 = GetS2();
        CL1 v24;
        v24 = y24.F5.F4;
    }

    void Test25(CL1 z25)
    {
        S2 y25;
        S2 x25 = GetS2();
        x25.F5.F4 = z25;
        y25 = x25;
        CL1 v25;
        v25 = y25.F5.F4;
    }

    void Test26(CL1 x26, CL1? y26, CL1 z26)
    {
        x26.P1 = y26;
        x26.P1 = z26;
    }

    void Test27(CL1 x27, CL1? y27, CL1 z27)
    {
        x27[x27] = y27;
        x27[x27] = z27;
    }

    void Test28(CL1 x28, CL1? y28, CL1 z28)
    {
        x28[y28] = z28;
    }

    void Test29(CL1 x29, CL1 y29, CL1 z29)
    {
        z29 = x29[y29];
        z29 = x29[1];
    }

    void Test30(CL1? x30, CL1 y30, CL1 z30)
    {
        z30 = x30[y30];
    }

    void Test31(CL1 x31)
    {
        x31 = default(CL1);
    }

    void Test32(CL1 x32)
    {
        var y32 = new CL1() ?? x32;
    }

    void Test33(object x33)
    {
        var y33 = new { p = (object)null } ?? x33;
    }
}

class CL1
{
    public CL1()
    {
        F1 = this;
    }

    public CL1 F1;
    public CL1? F2;

    public CL1 P1 { get; set; }
    public CL1? P2 { get; set; }

    public CL1 M1() { return new CL1(); }
    public CL1? M2() { return null; }

    public CL1 this[CL1 x]
    {
        get { return x; }
        set { }
    }

    public CL1? this[int x]
    {
        get { return null; }
        set { }
    }
}

struct S1
{
    public CL1 F3;
    public CL1? F4;
}

struct S2
{
    public S1 F5;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z1 = x1; 
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(12, 21),
                // (24,21): error CS0165: Use of unassigned local variable 'x3'
                //         string z3 = x3; 
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(24, 21),
                // (30,21): error CS0165: Use of unassigned local variable 'x4'
                //         string z4 = x4; 
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x4").WithArguments("x4").WithLocation(30, 21),
                // (40,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z5 = x5; 
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(40, 14),
                // (53,18): warning CS8602: Possible dereference of a null reference.
                //         CL1 y7 = x7.P1; 
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x7").WithLocation(53, 18),
                // (54,18): hidden CS8607: Expression is probably never null.
                //         CL1 z7 = x7?.P1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x7").WithLocation(54, 18),
                // (64,18): warning CS8602: Possible dereference of a null reference.
                //         CL1 u8 = x8.M1(); 
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x8").WithLocation(64, 18),
                // (65,18): hidden CS8607: Expression is probably never null.
                //         CL1 z8 = x8?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8").WithLocation(65, 18),
                // (71,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u9 = x9;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x9").WithLocation(71, 14),
                // (76,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y9 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(76, 14),
                // (83,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u10 = x10.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10.P2").WithLocation(83, 15),
                // (85,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u10 = x10.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10.M2()").WithLocation(85, 15),
                // (95,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u11 = x11.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11.F2").WithLocation(95, 15),
                // (101,15): warning CS8602: Possible dereference of a null reference.
                //         v11 = y11.F1;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y11").WithLocation(101, 15),
                // (108,15): error CS0170: Use of possibly unassigned field 'F3'
                //         u12 = y12.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y12.F3").WithArguments("F3").WithLocation(108, 15),
                // (109,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u12 = y12.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y12.F4").WithArguments("F4").WithLocation(109, 15),
                // (116,15): error CS0170: Use of possibly unassigned field 'F3'
                //         u13 = y13.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y13.F3").WithArguments("F3").WithLocation(116, 15),
                // (117,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u13 = y13.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y13.F4").WithArguments("F4").WithLocation(117, 15),
                // (123,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y14.F3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(123, 18),
                // (133,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y15.F3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(133, 18),
                // (135,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u15 = y15.F3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y15.F3").WithLocation(135, 15),
                // (136,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u15 = y15.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y15.F4").WithLocation(136, 15),
                // (150,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u16 = y16.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y16.F4").WithLocation(150, 15),
                // (161,15): error CS0165: Use of unassigned local variable 'x17'
                //         y17 = x17;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x17").WithArguments("x17").WithLocation(161, 15),
                // (159,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u17 = y17.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y17.F4").WithLocation(159, 15),
                // (170,18): error CS0165: Use of unassigned local variable 'x18'
                //         S1 y18 = x18;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x18").WithArguments("x18").WithLocation(170, 18),
                // (180,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u19 = y19.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y19.F4").WithLocation(180, 15),
                // (197,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v20 = y20.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y20.F4").WithLocation(197, 15),
                // (213,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v21 = y21.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y21.F4").WithLocation(213, 15),
                // (220,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u22 = y22.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y22.F4").WithArguments("F4").WithLocation(220, 15),
                // (224,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v22 = y22.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y22.F4").WithLocation(224, 15),
                // (236,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v23 = y23.F5.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y23.F5.F4").WithLocation(236, 15),
                // (248,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u24 = y24.F5.F4; // 1
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y24.F5.F4").WithArguments("F4").WithLocation(248, 15),
                // (253,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v24 = y24.F5.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y24.F5.F4").WithLocation(253, 15),
                // (268,18): warning CS8601: Possible null reference assignment.
                //         x26.P1 = y26;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y26").WithLocation(268, 18),
                // (274,20): warning CS8601: Possible null reference assignment.
                //         x27[x27] = y27;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y27").WithLocation(274, 20),
                // (280,13): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL1.this[CL1 x]'.
                //         x28[y28] = z28;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y28").WithArguments("x", "CL1 CL1.this[CL1 x]").WithLocation(280, 13),
                // (286,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z29 = x29[1];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x29[1]").WithLocation(286, 15),
                // (291,15): warning CS8602: Possible dereference of a null reference.
                //         z30 = x30[y30];
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x30").WithLocation(291, 15),
                // (296,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x31 = default(CL1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(CL1)").WithLocation(296, 15),
                // (301,19): hidden CS8607: Expression is probably never null.
                //         var y32 = new CL1() ?? x32;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL1()").WithLocation(301, 19),
                // (306,29): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var y33 = new { p = (object)null } ?? x33;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(306, 29),
                // (306,19): hidden CS8607: Expression is probably never null.
                //         var y33 = new { p = (object)null } ?? x33;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new { p = (object)null }").WithLocation(306, 19));
        }

        [Fact]
        public void PassingParameters_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1(CL1 p) {}

    void Test1(CL1? x1, CL1 y1)
    {
        M1(x1);
        M1(y1);
    }

    void Test2()
    {
        CL1? x2;
        M1(x2);
    }

    void M2(ref CL1? p) {}

    void Test3()
    {
        CL1 x3;
        M2(ref x3);
    }

    void Test4(CL1 x4)
    {
        M2(ref x4);
    }

    void M3(out CL1? p) { p = null; }

    void Test5()
    {
        CL1 x5;
        M3(out x5);
    }

    void M4(ref CL1 p) {}

    void Test6()
    {
        CL1? x6 = null;
        M4(ref x6);
    }

    void M5(out CL1 p) { p = new CL1(); }

    void Test7()
    {
        CL1? x7 = null;
        CL1 u7 = x7;
        M5(out x7);
        CL1 v7 = x7;
    }

    void M6(CL1 p1, CL1? p2) {}

    void Test8(CL1? x8, CL1? y8)
    {
        M6(p2: x8, p1: y8);
    }

    void M7(params CL1[] p1) {}

    void Test9(CL1 x9, CL1? y9)
    {
        M7(x9, y9);
    }

    void Test10(CL1? x10, CL1 y10)
    {
        M7(x10, y10);
    }

    void M8(CL1 p1, params CL1[] p2) {}

    void Test11(CL1? x11, CL1 y11, CL1? z11)
    {
        M8(x11, y11, z11);
    }

    void Test12(CL1? x12, CL1 y12)
    {
        M8(p2: x12, p1: y12);
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (12,12): warning CS8604: Possible null reference argument for parameter 'p' in 'void C.M1(CL1 p)'.
                //         M1(x1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("p", "void C.M1(CL1 p)").WithLocation(12, 12),
                // (19,12): error CS0165: Use of unassigned local variable 'x2'
                //         M1(x2);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x2").WithArguments("x2").WithLocation(19, 12),
                // (27,16): error CS0165: Use of unassigned local variable 'x3'
                //         M2(ref x3);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(27, 16),
                // (32,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M2(ref x4);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4").WithLocation(32, 16),
                // (40,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M3(out x5);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(40, 16),
                // (48,16): warning CS8604: Possible null reference argument for parameter 'p' in 'void C.M4(ref CL1 p)'.
                //         M4(ref x6);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x6").WithArguments("p", "void C.M4(ref CL1 p)").WithLocation(48, 16),
                // (56,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u7 = x7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7").WithLocation(56, 18),
                // (65,24): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M6(CL1 p1, CL1? p2)'.
                //         M6(p2: x8, p1: y8);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y8").WithArguments("p1", "void C.M6(CL1 p1, CL1? p2)").WithLocation(65, 24),
                // (72,16): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M7(params CL1[] p1)'.
                //         M7(x9, y9);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y9").WithArguments("p1", "void C.M7(params CL1[] p1)").WithLocation(72, 16),
                // (77,12): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M7(params CL1[] p1)'.
                //         M7(x10, y10);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x10").WithArguments("p1", "void C.M7(params CL1[] p1)").WithLocation(77, 12),
                // (84,12): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(x11, y11, z11);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x11").WithArguments("p1", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(84, 12),
                // (84,22): warning CS8604: Possible null reference argument for parameter 'p2' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(x11, y11, z11);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z11").WithArguments("p2", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(84, 22),
                // (89,16): warning CS8604: Possible null reference argument for parameter 'p2' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(p2: x12, p1: y12);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x12").WithArguments("p2", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(89, 16));
        }

        [Fact]
        public void PassingParameters_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1)
    {
        var y1 = new CL0() { [null] = x1 };
    }
}

class CL0
{
    public CL0 this[CL0 x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var y1 = new CL0() { [null] = x1 };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 31));
        }

        [Fact]
        public void PassingParameters_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1)
    {
        var y1 = new CL0() { null };
    }
}

class CL0 : System.Collections.IEnumerable 
{
    public void Add(CL0 x)
    {
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        throw new System.NotImplementedException();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,30): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var y1 = new CL0() { null };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 30));
        }

        [Fact]
        public void PassingParameters_04()
        {
            var source =
@"interface I<T> { }
class C
{
    static void F(I<object> x, I<object?> y, I<object>? z, I<object?>? w, I<object?>[]? a)
    {
        G(x);
        G(y);
        G(x, x, x);
        G(x, y, y);
        G(x, x, y, z, w);
        G(y: x, x: y);
        G(y: y, x: x);
        G(x, a);
        G(x, new I<object?>[0]);
        G(x, new[] { x, x });
        G(x, new[] { y, y });
        G(x, new[] { x, y, z });
        G(y: new[] { x, x }, x: y);
        G(y: new[] { y, y }, x: x);
    }
    static void G(I<object> x, params I<object?>[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,11): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(7, 11),
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(8, 14),
                // (8,17): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(8, 17),
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 14),
                // (10,20): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 20),
                // (10,20): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 20),
                // (10,23): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "w").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 23),
                // (11,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: x, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(11, 14),
                // (11,20): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: x, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(11, 20),
                // (13,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(13, 14),
                // (15,14): warning CS8620: Nullability of reference types in argument of type 'I<object>[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, new[] { x, x });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, x }").WithArguments("I<object>[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(15, 14),
                // (17,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         G(x, new[] { x, y, z });
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y, z }").WithLocation(17, 14),
                // (17,14): warning CS8620: Nullability of reference types in argument of type 'I<object>?[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, new[] { x, y, z });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, y, z }").WithArguments("I<object>?[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(17, 14),
                // (18,14): warning CS8620: Nullability of reference types in argument of type 'I<object>[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: new[] { x, x }, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, x }").WithArguments("I<object>[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(18, 14),
                // (18,33): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: new[] { x, x }, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(18, 33));
        }

        [Fact]
        public void PassingParameters_DifferentRefKinds()
        {
            var source = @"
class C
{
    void M(string xNone, ref string xRef, out string xOut)
    {
        xNone = null;
        xRef = null;
        xOut = null;
    }
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (6,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         xNone = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 17),
                // (7,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         xRef = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(7, 16),
                // (8,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         xOut = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 16)
                );

            var source2 = @"
class C
{
    void M(in string xIn)
    {
        xIn = null;
    }
}
";
            var c2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue());
            c2.VerifyDiagnostics(
                // (6,9): error CS8331: Cannot assign to variable 'in string' because it is a readonly variable
                //         xIn = null;
                Diagnostic(ErrorCode.ERR_AssignReadonlyNotField, "xIn").WithArguments("variable", "in string").WithLocation(6, 9)
                );
        }

        [Fact]
        public void DuplicateArguments()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        // Duplicate x
        G(x: x, x: y);
        G(x: y, x: x);
        G(x: x, x: y, y: y);
        G(x: y, x: x, y: y);
        G(y: y, x: x, x: y);
        G(y: y, x: y, x: x);
        // Duplicate y
        G(y: x, y: y);
        G(y: y, y: x);
        G(x, y: x, y: y);
        G(x, y: y, y: x);
        G(y: x, y: y, x: x);
        G(y: y, y: x, x: x);
    }
    static void G(object x, params object?[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: x, x: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(6, 17),
                // (7,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(7, 17),
                // (8,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: x, x: y, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(8, 17),
                // (9,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: y, x: x, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(9, 17),
                // (10,23): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(y: y, x: x, x: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(10, 23),
                // (11,23): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(y: y, x: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(11, 23),
                // (13,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, params object?[])'
                //         G(y: x, y: y);
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, params object?[])").WithLocation(13, 9),
                // (14,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, params object?[])'
                //         G(y: y, y: x);
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, params object?[])").WithLocation(14, 9),
                // (15,20): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(x, y: x, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(15, 20),
                // (16,20): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(x, y: y, y: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(16, 20),
                // (17,17): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(y: x, y: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(17, 17),
                // (18,17): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(y: y, y: x, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(18, 17));
        }

        [Fact]
        public void MissingArguments()
        {
            var source =
@"class C
{
    static void F(object? x)
    {
        G(y: x);
    }
    static void G(object? x = null, object y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,45): error CS1737: Optional parameters must appear after all required parameters
                //     static void G(object? x = null, object y)
                Diagnostic(ErrorCode.ERR_DefaultValueBeforeRequiredValue, ")").WithLocation(7, 45),
                // (5,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(object? x = null, object y)'.
                //         G(y: x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("y", "void C.G(object? x = null, object y)").WithLocation(5, 14));
        }

        [Fact]
        public void ParamsArgument_NotLast()
        {
            var source =
@"class C
{
    static void F(object[]? a, object? b)
    {
        G(a, b, a);
    }
    static void G(params object[] x, params object[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,19): error CS0231: A params parameter must be the last parameter in a formal parameter list
                //     static void G(params object[] x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsLast, "params object[] x").WithLocation(7, 19),
                // (5,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("x", "void C.G(params object[] x, params object[] y)").WithLocation(5, 11),
                // (5,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("y", "void C.G(params object[] x, params object[] y)").WithLocation(5, 14),
                // (5,17): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("y", "void C.G(params object[] x, params object[] y)").WithLocation(5, 17));
        }

        [Fact]
        public void ParamsArgument_NotArray()
        {
            var source =
@"class C
{
    static void F1(object x, object? y)
    {
        F2(y);
        F2(x, y);
        F3(y, x);
        F3(x, y, x);
    }
    static void F2(params object x)
    {
    }
    static void F3(params object x, params object[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,20): error CS0225: The params parameter must be a single dimensional array
                //     static void F2(params object x)
                Diagnostic(ErrorCode.ERR_ParamsMustBeArray, "params").WithLocation(10, 20),
                // (13,20): error CS0225: The params parameter must be a single dimensional array
                //     static void F3(params object x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsMustBeArray, "params").WithLocation(13, 20),
                // (13,20): error CS0231: A params parameter must be the last parameter in a formal parameter list
                //     static void F3(params object x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsLast, "params object x").WithLocation(13, 20),
                // (6,9): error CS1501: No overload for method 'F2' takes 2 arguments
                //         F2(x, y);
                Diagnostic(ErrorCode.ERR_BadArgCount, "F2").WithArguments("F2", "2").WithLocation(6, 9),
                // (5,12): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.F2(params object x)'.
                //         F2(y);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void C.F2(params object x)").WithLocation(5, 12),
                // (7,12): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.F3(params object x, params object[] y)'.
                //         F3(y, x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void C.F3(params object x, params object[] y)").WithLocation(7, 12),
                // (8,15): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.F3(params object x, params object[] y)'.
                //         F3(x, y, x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void C.F3(params object x, params object[] y)").WithLocation(8, 15));
        }

        [Fact]
        public void ParamsArgument_BinaryOperator()
        {
            var source =
@"class C
{
    public static object operator+(C x, params object?[] y) => x;
    static object F(C x, object[] y) => x + y;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,41): error CS1670: params is not valid in this context
                //     public static object operator+(C x, params object?[] y) => x;
                Diagnostic(ErrorCode.ERR_IllegalParams, "params").WithLocation(3, 41),
                // (4,45): warning CS8620: Nullability of reference types in argument of type 'object[]' doesn't match target type 'object?[]' for parameter 'y' in 'object C.operator +(C x, params object?[] y)'.
                //     static object F(C x, object[] y) => x + y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("object[]", "object?[]", "y", "object C.operator +(C x, params object?[] y)").WithLocation(4, 45));
        }

        [Fact]
        public void RefOutParameters_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(ref CL1 x1, CL1 y1)
    {
        y1 = x1;
    }

    void Test2(ref CL1? x2, CL1 y2)
    {
        y2 = x2;
    }

    void Test3(ref CL1? x3, CL1 y3)
    {
        x3 = y3;
        y3 = x3;
    }

    void Test4(out CL1 x4, CL1 y4)
    {
        y4 = x4;
        x4 = y4;
    }

    void Test5(out CL1? x5, CL1 y5)
    {
        y5 = x5;
        x5 = y5;
    }

    void Test6(out CL1? x6, CL1 y6)
    {
        x6 = y6;
        y6 = x6;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y2 = x2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(15, 14),
                 // (21,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y3 = x3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(21, 14),
                 // (26,14): error CS0269: Use of unassigned out parameter 'x4'
                 //         y4 = x4;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x4").WithArguments("x4").WithLocation(26, 14),
                 // (32,14): error CS0269: Use of unassigned out parameter 'x5'
                 //         y5 = x5;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x5").WithArguments("x5").WithLocation(32, 14),
                 // (39,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y6 = x6;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x6").WithLocation(39, 14)
                );
        }

        [Fact]
        public void RefOutParameters_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(ref S1 x1, CL1 y1)
    {
        y1 = x1.F1;
    }

    void Test2(ref S1 x2, CL1 y2)
    {
        y2 = x2.F2;
    }

    void Test3(ref S1 x3, CL1 y3)
    {
        x3.F2 = y3;
        y3 = x3.F2;
    }

    void Test4(out S1 x4, CL1 y4)
    {
        y4 = x4.F1;
        x4.F1 = y4;
        x4.F2 = y4;
    }

    void Test5(out S1 x5, CL1 y5)
    {
        y5 = x5.F2;
        x5.F1 = y5;
        x5.F2 = y5;
    }

    void Test6(out S1 x6, CL1 y6)
    {
        x6.F1 = y6;
        x6.F2 = y6;
        y6 = x6.F2;
    }
}

class CL1
{
}

struct S1
{
    public CL1 F1;
    public CL1? F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y2 = x2.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2.F2").WithLocation(15, 14),
                 // (21,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y3 = x3.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3.F2").WithLocation(21, 14),
                 // (26,14): error CS0170: Use of possibly unassigned field 'F1'
                 //         y4 = x4.F1;
                 Diagnostic(ErrorCode.ERR_UseDefViolationField, "x4.F1").WithArguments("F1").WithLocation(26, 14),
                 // (33,14): error CS0170: Use of possibly unassigned field 'F2'
                 //         y5 = x5.F2;
                 Diagnostic(ErrorCode.ERR_UseDefViolationField, "x5.F2").WithArguments("F2").WithLocation(33, 14),
                 // (42,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y6 = x6.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x6.F2").WithLocation(42, 14)
                );
        }

        [Fact]
        public void RefOutParameters_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test3(ref S1 x3, CL1 y3)
    {
        S1 z3;
        z3.F1 = y3;
        z3.F2 = y3;
        x3 = z3;
        y3 = x3.F2;
    }

    void Test6(out S1 x6, CL1 y6)
    {
        S1 z6;
        z6.F1 = y6;
        z6.F2 = y6;
        x6 = z6;
        y6 = x6.F2;
    }
}

class CL1
{
}

struct S1
{
    public CL1 F1;
    public CL1? F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y3 = x3.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3.F2").WithLocation(14, 14),
                 // (23,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y6 = x6.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x6.F2").WithLocation(23, 14)
                );
        }

        [Fact]
        public void RefOutParameters_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1(ref CL0<string> x) {}

    void Test1(CL0<string?> x1)
    {
        M1(ref x1);
    }

    void M2(out CL0<string?> x) { throw new System.NotImplementedException(); }

    void Test2(CL0<string> x2)
    {
        M2(out x2);
    }

    void M3(CL0<string> x) {}

    void Test3(CL0<string?> x3)
    {
        M3(x3);
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,16): warning CS8620: Nullability of reference types in argument of type 'CL0<string?>' doesn't match target type 'CL0<string>' for parameter 'x' in 'void C.M1(ref CL0<string> x)'.
                //         M1(ref x1);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("CL0<string?>", "CL0<string>", "x", "void C.M1(ref CL0<string> x)").WithLocation(12, 16),
                // (19,16): warning CS8620: Nullability of reference types in argument of type 'CL0<string>' doesn't match target type 'CL0<string?>' for parameter 'x' in 'void C.M2(out CL0<string?> x)'.
                //         M2(out x2);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("CL0<string>", "CL0<string?>", "x", "void C.M2(out CL0<string?> x)").WithLocation(19, 16),
                // (26,12): warning CS8620: Nullability of reference types in argument of type 'CL0<string?>' doesn't match target type 'CL0<string>' for parameter 'x' in 'void C.M3(CL0<string> x)'.
                //         M3(x3);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x3").WithArguments("CL0<string?>", "CL0<string>", "x", "void C.M3(CL0<string> x)").WithLocation(26, 12)
                );
        }

        [Fact]
        public void RefOutParameters_05()
        {
            var source =
@"class C
{
    static void F(object? x, object? y, object? z)
    {
        G(out x, ref y, in z);
        x.ToString();
        y.ToString();
        z.ToString();
    }
    static void G(out object x, ref object y, in object z)
    {
        x = new object();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,22): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(out object x, ref object y, in object z)'.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void C.G(out object x, ref object y, in object z)").WithLocation(5, 22),
                // (5,28): warning CS8604: Possible null reference argument for parameter 'z' in 'void C.G(out object x, ref object y, in object z)'.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z").WithArguments("z", "void C.G(out object x, ref object y, in object z)").WithLocation(5, 28),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(8, 9));
        }

        [Fact]
        public void RefOutParameters_06()
        {
            var source =
@"class C
{
    static void F(object x, object y, object z)
    {
        G(out x, ref y, in z);
        x.ToString();
        y.ToString();
        z.ToString();
    }
    static void G(out object? x, ref object? y, in object? z)
    {
        x = new object();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(5, 15),
                // (5,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(5, 22),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(7, 9));
        }

        [Fact]
        public void TargetingUnannotatedAPIs_01()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public object F1;

    public object P1 { get; set;}

    public object this[object x]
    {
        get { return null; }
        set { }
    }

    public S1 M1() { return new S1(); }
}

public struct S1
{
    public CL0 F1;
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    bool Test1(string? x1, string y1)
    {
        return string.Equals(x1, y1);
    }

    object Test2(ref object? x2, object? y2)
    {
        System.Threading.Interlocked.Exchange(ref x2, y2);
        return x2 ?? new object(); 
    }    

    object Test3(ref object? x3, object? y3)
    {
        return System.Threading.Interlocked.Exchange(ref x3, y3) ?? new object(); 
    }    

    object Test4(System.Delegate x4)
    {
        return x4.Target ?? new object(); 
    }    

    object Test5(CL0 x5)
    {
        return x5.F1 ?? new object(); 
    }    

    void Test6(CL0 x6, object? y6)
    {
        x6.F1 = y6;
    }    

    void Test7(CL0 x7, object? y7)
    {
        x7.P1 = y7;
    }    

    void Test8(CL0 x8, object? y8, object? z8)
    {
        x8[y8] = z8;
    }    

    object Test9(CL0 x9)
    {
        return x9[1] ?? new object(); 
    }    

    object Test10(CL0 x10)
    {
        return x10.M1().F1 ?? new object(); 
    }    

    object Test11(CL0 x11, CL0? z11)
    {
        S1 y11 = x11.M1();
        y11.F1 = z11;
        return y11.F1; 
    }    

    object Test12(CL0 x12)
    {
        S1 y12 = x12.M1();
        y12.F1 = x12;
        return y12.F1 ?? new object(); 
    }    

    void Test13(CL0 x13, object? y13)
    {
        y13 = x13.F1;
        object z13 = y13;
        z13 = y13 ?? new object();
    }    

    void Test14(CL0 x14)
    {
        object? y14 = x14.F1;
        object z14 = y14;
        z14 = y14 ?? new object();
    }    

    void Test15(CL0 x15)
    {
        S2 y15;
        y15.F2 = x15.F1;
        object z15 = y15.F2;
        z15 = y15.F2 ?? new object();
    }    

    struct Test16
    {
        object? y16 {get;}

        public Test16(CL0 x16)
        {
            y16 = x16.F1;
            object z16 = y16;
            z16 = y16 ?? new object();
        }    
    }

    void Test17(CL0 x17)
    {
        var y17 = new { F2 = x17.F1 };
        object z17 = y17.F2;
        z17 = y17.F2 ?? new object();
    }    
}

public struct S2
{
    public object? F2;
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (63,16): warning CS8603: Possible null reference return.
                //         return y11.F1; 
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y11.F1").WithLocation(63, 16),
                // (70,16): hidden CS8607: Expression is probably never null.
                //         return y12.F1 ?? new object(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y12.F1").WithLocation(70, 16));
        }

        [Fact]
        public void TargetingUnannotatedAPIs_02()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }

    void Test1()
    {
        object? x1 = CL0.M1() ?? M2();
        object y1 = x1;
        object z1 = x1 ?? new object();
    }

    void Test2()
    {
        object? x2 = CL0.M1() ?? M3();
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3 = M3() ?? M2();
        object z3 = x3 ?? new object();
    }

    void Test4()
    {
        object? x4 = CL0.M1() ?? CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object x5 = M2() ?? M2();
    }

    void Test6()
    {
        object? x6 = M3() ?? M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(14, 21),
                // (21,21): hidden CS8607: Expression is probably never null.
                //         object z2 = x2 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(21, 21),
                // (26,22): hidden CS8607: Expression is probably never null.
                //         object? x3 = M3() ?? M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(26, 22),
                // (27,21): hidden CS8607: Expression is probably never null.
                //         object z3 = x3 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(27, 21),
                // (39,21): warning CS8601: Possible null reference assignment.
                //         object x5 = M2() ?? M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M2() ?? M2()").WithLocation(39, 21),
                // (44,22): hidden CS8607: Expression is probably never null.
                //         object? x6 = M3() ?? M3();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(44, 22),
                // (45,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(45, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_03()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }

    void Test1()
    {
        object? x1 = M2() ?? CL0.M1();
        object y1 = x1;
        object z1 = x1 ?? new object();
    }

    void Test2()
    {
        object? x2 = M3() ?? CL0.M1();
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3 = M2() ?? M3();
        object z3 = x3 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                 // (20,22): hidden CS8607: Expression is probably never null.
                 //         object? x2 = M3() ?? CL0.M1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(20, 22),
                 // (21,21): hidden CS8607: Expression is probably never null.
                 //         object z2 = x2 ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(21, 21),
                 // (27,21): hidden CS8607: Expression is probably never null.
                 //         object z3 = x3 ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(27, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_04()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object x1 = M4() ? CL0.M1() : M2();
    }

    void Test2()
    {
        object? x2 = M4() ? CL0.M1() : M3();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object x3 =  M4() ? M3() : M2();
    }

    void Test4()
    {
        object? x4 =  M4() ? CL0.M1() : CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object x5 =  M4() ? M2() : M2();
    }

    void Test6()
    {
        object? x6 =  M4() ? M3() : M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x1 = M4() ? CL0.M1() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? CL0.M1() : M2()").WithLocation(14, 21),
                // (26,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x3 =  M4() ? M3() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M3() : M2()").WithLocation(26, 22),
                // (38,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x5 =  M4() ? M2() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : M2()").WithLocation(38, 22),
                // (44,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(44, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_05()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object x1 = M4() ? M2() : CL0.M1();
    }

    void Test2()
    {
        object? x2 = M4() ? M3() : CL0.M1();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object x3 =  M4() ? M2() : M3();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                 // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x1 = M4() ? M2() : CL0.M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : CL0.M1()").WithLocation(14, 21),
                 // (26,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x3 =  M4() ? M2() : M3();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : M3()").WithLocation(26, 22)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_06()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object? x1;
        if (M4()) x1 = CL0.M1(); else x1 = M2();
        object y1 = x1;
    }

    void Test2()
    {
        object? x2;
        if (M4()) x2 = CL0.M1(); else x2 = M3();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3;
        if (M4()) x3 = M3(); else x3 = M2();
        object y3 = x3;
    }

    void Test4()
    {
        object? x4;
        if (M4()) x4 = CL0.M1(); else x4 = CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object? x5;
        if (M4()) x5 = M2(); else x5 = M2();
        object y5 = x5;
    }

    void Test6()
    {
        object? x6;
        if (M4()) x6 = M3(); else x6 = M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(16, 21),
                // (31,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(31, 21),
                // (46,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y5 = x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(46, 21),
                // (53,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(53, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_07()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object? x1;
        if (M4()) x1 = M2(); else x1 = CL0.M1();
        object y1 = x1;
    }

    void Test2()
    {
        object? x2;
        if (M4()) x2 = M3(); else x2 = CL0.M1();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3;
        if (M4()) x3 = M2(); else x3 = M3();
        object y3 = x3;
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(16, 21),
                // (31,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(31, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_08()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public abstract class A1
{
    public abstract event System.Action E1;
    public abstract string P2 { get; set; }
    public abstract string M3(string x);
    public abstract event System.Action E4;
    public abstract string this[string x] { get; set; }
}

public interface IA2
{
    event System.Action E5;
    string P6 { get; set; }
    string M7(string x);
    event System.Action E8;
    string this[string x] { get; set; }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class B1 : A1
{
    static void Main()
    {
    }

    public override string? P2 { get; set; }
    public override event System.Action? E1;
    public override string? M3(string? x)
    {
        var dummy = E1;
        throw new System.NotImplementedException();
    }
    public override event System.Action? E4
    {
        add { }
        remove { }
    }

    public override string? this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }
}

class B2 : IA2
{
    public string? P6 { get; set; }
    public event System.Action? E5;
    public event System.Action? E8
    {
        add { }
        remove { }
    }

    public string? M7(string? x)
    {
        var dummy = E5;
        throw new System.NotImplementedException();
    }

    public string? this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }
}

class B3 : IA2
{
    string? IA2.P6 { get; set; }

    event System.Action? IA2.E5
    {
        add { }
        remove { }
    }

    event System.Action? IA2.E8
    {
        add { }
        remove { }
    }

    string? IA2.M7(string? x)
    {
        throw new System.NotImplementedException();
    }
    
    string? IA2.this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }

}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ReturningValues_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1 Test1(CL1? x1)
    {
        return x1;
    }

    CL1? Test2(CL1? x2)
    {
        return x2;
    }

    CL1? Test3(CL1 x3)
    {
        return x3;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,16): warning CS8603: Possible null reference return.
                 //         return x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x1").WithLocation(10, 16)
                );
        }

        [Fact]
        public void ReturningValues_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1<string?> Test1(CL1<string> x1)
    {
        return x1;
    }

    CL1<string> Test2(CL1<string?> x2)
    {
        return x2;
    }
}

class CL1<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,16): warning CS8619: Nullability of reference types in value of type 'CL1<string>' doesn't match target type 'CL1<string?>'.
                //         return x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL1<string>", "CL1<string?>").WithLocation(10, 16),
                // (15,16): warning CS8619: Nullability of reference types in value of type 'CL1<string?>' doesn't match target type 'CL1<string>'.
                //         return x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("CL1<string?>", "CL1<string>").WithLocation(15, 16)
                );
        }

        [Fact]
        public void IdentityConversion_Return_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<object?> F(I<object> x) => x;
    static IIn<object?> F(IIn<object> x) => x;
    static IOut<object?> F(IOut<object> x) => x;
    static I<object> G(I<object?> x) => x;
    static IIn<object> G(IIn<object?> x) => x;
    static IOut<object> G(IOut<object?> x) => x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,41): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //     static I<object?> F(I<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(6, 41),
                // (7,45): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //     static IIn<object?> F(IIn<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(7, 45),
                // (9,41): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //     static I<object> G(I<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object?>", "I<object>").WithLocation(9, 41),
                // (11,47): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //     static IOut<object> G(IOut<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(11, 47));
        }

        [Fact]
        public void IdentityConversion_Return_02()
        {
            var source =
@"#pragma warning disable 1998
using System.Threading.Tasks;
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static async Task<I<object?>> F(I<object> x) => x;
    static async Task<IIn<object?>> F(IIn<object> x) => x;
    static async Task<IOut<object?>> F(IOut<object> x) => x;
    static async Task<I<object>> G(I<object?> x) => x;
    static async Task<IIn<object>> G(IIn<object?> x) => x;
    static async Task<IOut<object>> G(IOut<object?> x) => x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,53): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //     static async Task<I<object?>> F(I<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(8, 53),
                // (9,57): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //     static async Task<IIn<object?>> F(IIn<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(9, 57),
                // (11,53): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //     static async Task<I<object>> G(I<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object?>", "I<object>").WithLocation(11, 53),
                // (13,59): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //     static async Task<IOut<object>> G(IOut<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(13, 59));
        }

        [Fact]
        public void MakeMethodKeyForWhereMethod()
        {
            // this test verifies that a bad method symbol doesn't crash when generating a key for external annotations
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    public void SimpleWhere()
    {
        int[] numbers = { 1, 2, 3 };
        var lowNums = from n in numbers
                      where n < 5
                      select n;
    }
}" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,33): error CS1935: Could not find an implementation of the query pattern for source type 'int[]'.  'Where' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?
                //         var lowNums = from n in numbers
                Diagnostic(ErrorCode.ERR_QueryNoProviderStandard, "numbers").WithArguments("int[]", "Where").WithLocation(7, 33)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_EqualsTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (MyIsNullOrEmpty(s) == true)
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_EqualsFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (false == MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_NotEqualsFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (false != MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_RequiresBoolReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public static object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_RequiresBoolReturn_OnGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s)
    {
        if (MyIsNullOrEmpty(s, true))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
    public static T MyIsNullOrEmpty<T>([NotNullWhenFalse] string? s, T t) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );
        }

        [Fact]
        public void MethodWithOutNullableParameter_AfterNotNullWhenTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (M(s, out string? s2))
        {
            s.ToString(); // ok
            s2.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
            s2.ToString(); // warn 3
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool M([NotNullWhenTrue] string? s, out string? s2) => throw null;
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );
        }

        [Fact]
        public void MethodWithOutNullableParameter_AfterEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (M(s, out string? s2))
        {
            s.ToString(); // ok
            s2.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // warn 2
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool M([EnsuresNotNull] string? s, out string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );
        }

        [Fact]
        public void MethodWithOutNonNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        M(out string s);
        s.ToString(); // ok
    }
    public static void M(out string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithOutNonNullableParameter_WithNullableOutArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        M(out string? s);
        s.ToString(); // ok
    }
    public static void M(out string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNonNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string s = ""hello"";
        M(ref s);
        s.ToString(); // ok
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNonNullableParameter_WithNullableRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? s)
    {
        M(ref s); // warn
        s.ToString();
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,15): warning CS8604: Possible null reference argument for parameter 'value' in 'void C.M(ref string value)'.
                //         M(ref s); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "s").WithArguments("value", "void C.M(ref string value)").WithLocation(6, 15)
                );
        }

        [Fact]
        public void MethodWithRefNonNullableParameter_WithNonNullRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string? s = ""hello"";
        M(ref s);
        s.ToString();
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string? s = ""hello"";
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(7, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithRefNullableParameter_WithNonNullableRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(6, 15),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithRefNullableParameter_WithNonNullableLocal()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string s = ""hello"";
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(7, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithOutParameter_WithNullableOut()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        if (TryGetValue(key, out var s))
        {
            s/*T:string?*/.ToString(); // warn
        }
        else
        {
            s/*T:string?*/.ToString(); // warn 2
        }

        s.ToString(); // ok
    }
    public static bool TryGetValue(string key, out string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );
        }

        /// <summary>
        /// Check the inferred type of var from the semantic model, which currently means from initial binding.
        /// </summary>
        private static void VerifyOutVar(CSharpCompilation compilation, string expectedType)
        {
            if (SkipVerify(expectedType))
            {
                return;
            }
            var tree = compilation.SyntaxTrees.First();
            var model = compilation.GetSemanticModel(tree);
            var outVar = tree.GetRoot().DescendantNodes().OfType<DeclarationExpressionSyntax>().Single();
            var symbol = (LocalSymbol)model.GetSymbolInfo(outVar).Symbol;
            Assert.Equal(expectedType, symbol.Type.ToDisplayString(TypeSymbolWithAnnotations.TestDisplayFormat));
            Assert.Null(model.GetDeclaredSymbol(outVar));
        }

        /// <summary>
        /// Check the inferred type of var from the semantic model, which currently means from initial binding.
        /// </summary>
        private static void VerifyVarLocal(CSharpCompilation compilation, string expectedType)
        {
            if (SkipVerify(expectedType))
            {
                return;
            }
            var tree = compilation.SyntaxTrees.First();
            var model = compilation.GetSemanticModel(tree);
            var varDecl = tree.GetRoot().DescendantNodes().OfType<LocalDeclarationStatementSyntax>().Where(d => d.Declaration.Type.IsVar).Single();
            var variable = varDecl.Declaration.Variables.Single();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(variable);
            Assert.Equal(expectedType, symbol.Type.ToDisplayString(TypeSymbolWithAnnotations.TestDisplayFormat));
            Assert.Null(model.GetSymbolInfo(variable).Symbol);
        }

        // https://github.com/dotnet/roslyn/issues/30150: VerifyOutVar and VerifyVarLocal are currently
        // checking the type and nullability from initial binding, but there are many cases where initial binding
        // sets nullability to unknown - in particular, for method type inference which is used in many
        // of the existing callers of these methods. Re-enable these methods when we're checking the
        // nullability from NullableWalker instead of initial binding.
        private static bool SkipVerify(string expectedType)
        {
            return expectedType.Contains('?') || expectedType.Contains('!');
        }

        [Fact]
        public void MethodWithGenericOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithUnnecessarySuppression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key!, out var s);
        s/*T:string!*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocal_FromGenericMethod_WithUnnecessarySuppression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key!);
        s/*T:string!*/.ToString();
    }
    public static T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocal_FromGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public static T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string!*/.ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.CopyOrDefault<T>(T, out T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         CopyOrDefault(key, out var s);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "CopyOrDefault").WithArguments("C.CopyOrDefault<T>(T, out T?)", "T", "string?").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableArrayOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?[]!*/[0].ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T?[] value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?[]!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?[]!*/[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s/*T:string?[]!*/[0]").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableArrayOutParameter_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?[]!*/[0].ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T?[] value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?[]!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.CopyOrDefault<T>(T, out T?[])'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         CopyOrDefault(key, out var s);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "CopyOrDefault").WithArguments("C.CopyOrDefault<T>(T, out T?[])", "T", "string?").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?[]!*/[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s/*T:string?[]!*/[0]").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericArrayOutParameter_WithNonNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string![]!*/[0].ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T[] value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string![]!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericArrayOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string![]!*/[0].ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T[] value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string![]!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?[]!
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s); // ok
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, [EnsuresNotNull] out T value) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: T is inferred to string! instead of string?, so the `var` gets `string!`
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s); // ok
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, [EnsuresNotNull] out T? value) where T : class => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.Copy<T>(T, out T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         Copy(key, out var s); // ok
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "Copy").WithArguments("C.Copy<T>(T, out T?)", "T", "string?").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNullLiteralArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        Copy(null, out string s); // warn
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         Copy(null, out string s); // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 14)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullableArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        Copy(key, out string s);
        s/*T:string!*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29857, "https://github.com/dotnet/roslyn/issues/29857")]
        public void MethodWithGenericOutParameter_WithNullableArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out string s);
        s/*T:string?*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Copy(key, out string s);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "string s").WithLocation(6, 23),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullableArgument_WithNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        Copy(key, out string? s);
        s/*T:string?*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNullableArgument_WithNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out string? s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        var s = Copy(key);
        s/*T:string!*/.ToString(); // ok
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        var s = Copy(key);
        s/*T:string!*/.ToString(); // ok
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T? Copy<T>(T key) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,17): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.Copy<T>(T)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         var s = Copy(key);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "Copy").WithArguments("C.Copy<T>(T)", "T", "string?").WithLocation(6, 17),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableReturn_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T? Copy<T>(T key) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29858, "https://github.com/dotnet/roslyn/issues/29858")]
        public void GenericMethod_WithEnsuresNotNullOnReturnType()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    [EnsuresNotNull]
    public static T Copy<T>(T key) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics(
                // (5,6): error CS0592: Attribute 'EnsuresNotNull' is not valid on this declaration type. It is only valid on 'parameter' declarations.
                //     [EnsuresNotNull]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "EnsuresNotNull").WithArguments("EnsuresNotNull", "parameter").WithLocation(5, 6)
                );
            // https://github.com/dotnet/roslyn/issues/29858: Need to confirm if this would be useful
        }

        [Fact]
        [WorkItem(29862, "https://github.com/dotnet/roslyn/issues/29862")]
        public void SuppressedNullGivesNonNullResult()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = null!; // https://github.com/dotnet/roslyn/issues/29862: null! returns an oblivious result
        var s2 = s;
        s2 /*T:string*/ .ToString(); // ok
        s2 = null; // warn
    }
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29862, "https://github.com/dotnet/roslyn/issues/29862")]
        public void SuppressedDefaultGivesNonNullResult()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = default!; // default! returns an oblivious result
        var s2 = s;
        s2/*T:string*/.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29862: The suppression operator isn't producing a non-null result
            //                                                I'd expect default! to return a non-null result
            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressedObliviousValueGivesNonNullResult()
        {
            var libComp = CreateCompilation(@"
public static class Static
{
    public static string Oblivious = null;
}
", parseOptions: TestOptions.Regular7);

            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s, string? ns)
    {
        s = Static.Oblivious!;
        var s2 = s;
        s2/*T:string!*/.ToString(); // ok
        ns = Static.Oblivious!;
        ns.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { libComp.EmitToImageReference() });

            VerifyVarLocal(comp, "string!");
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressedValueGivesNonNullResult()
        {
            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? ns, bool b)
    {
        var x1 = F(ns!);
        x1 /*T:string!*/ .ToString();

        var listNS = List.Create(ns);
        listNS /*T:List<string?>!*/ .ToString();
        var x2 = F2(listNS);
        x2 /*T:string!*/ .ToString();
    }
    public T F<T>(T? x) where T : class => throw null;
    public T F2<T>(List<T?> x) where T : class => throw null;
}
public class List { public static List<T> Create<T>(T t) => throw null; }
public class List<T> { }
" }, options: WithNonNullTypesTrue());

            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NestedNullabilityMismatchIgnoresSuppression()
        {
            var obliviousComp = CreateCompilation(@"
public static class Static
{
    public static string Oblivious = null;
}
", parseOptions: TestOptions.Regular7);

            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s, string? ns)
    {
        var o = Static.Oblivious;

        {
            var listS = List.Create(s);
            var listNS = List.Create(ns);
            listS /*T:List<string!>!*/ .ToString();
            listNS /*T:List<string?>!*/ .ToString();
            listS = listNS!; // warn 1
        }

        {
            var listS = List.Create(s);
            var listO = List.Create(o);
            listO /*T:List<string>!*/ .ToString();
            listS = listO; // ok
        }

        {
            var listNS = List.Create(ns);
            var listS = List.Create(s);
            listNS = listS!; // warn 2
        }

        {
            var listNS = List.Create(ns);
            var listO = List.Create(o);
            listNS = listO; // ok
        }

        {
            var listO = List.Create(o);
            var listNS = List.Create(ns);
            listO = listNS; // ok
        }

        {
            var listO = List.Create(o);
            var listS = List.Create(s);
            listO = listS; // ok
        }
    }
}
public class List { public static List<T> Create<T>(T t) => throw null; }
public class List<T> { }
" }, options: WithNonNullTypesTrue(), references: new[] { obliviousComp.EmitToImageReference() });

            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (13,21): warning CS8619: Nullability of reference types in value of type 'List<string?>' doesn't match target type 'List<string>'.
                //             listS = listNS!; // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "listNS!").WithArguments("List<string?>", "List<string>").WithLocation(13, 21),
                // (26,22): warning CS8619: Nullability of reference types in value of type 'List<string>' doesn't match target type 'List<string?>'.
                //             listNS = listS!; // warn 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "listS!").WithArguments("List<string>", "List<string?>").WithLocation(26, 22)
                );
        }

        [Fact]
        public void AssignNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = null; // warn
        s.ToString(); // warn 2
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void AssignDefault()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = default; // warn
        s.ToString(); // warn 2
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = default; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NotNullWhenTrue_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string key)
    {
        if (TryGetValue(key, out string? s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }

        s.ToString(); // ok
    }
    public static bool TryGetValue(string key, [NotNullWhenTrue] out string? value) => throw null;
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.Main", None);
            VerifyAnnotationsAndMetadata(c, "C.TryGetValue", None, NotNullWhenTrue);
        }

        [Fact]
        public void NotNullWhenTrue_WithNotNullWhenFalse_WithVoidReturn()
        {
            // When both NotNullWhenTrue and NotNullWhenFalse are applied, it's the same as EnsuresNotNull,
            // even if the method doesn't return bool.
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main()
    {
        M(out string? s);
        s.ToString(); // ok
    }
    public static void M([NotNullWhenTrue, NotNullWhenFalse] out string? value) => throw null;
}
", NotNullWhenTrueAttributeDefinition, NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.M", EnsuresNotNull);
        }

        [Fact]
        public void AssertsTrue_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c != null);
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNull_NullConditionalAccess()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    object? _o = null;
    void Main(C? c)
    {
        MyAssert(c?._o != null);
        c.ToString();
        c._o.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c == null);
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_RefOutInParameters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(bool b)
    {
        MyAssert(ref b, out bool b2, in b);
    }

    void MyAssert([AssertsTrue] ref bool condition, [AssertsFalse] out bool condition2, [AssertsTrue] in bool condition3) => throw null;
}
", AssertsTrueAttributeDefinition, AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_MethodWithReturnType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        if (MyAssert(c != null))
        {
            c.ToString();
        }
        else
        {
            c.ToString();
        }
    }

    bool MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert1_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null);
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNullAndNotEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? c)
    {
        Assert(c != null && c != """");
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert1_NotNullAndNotEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? c)
    {
        System.Diagnostics.Debug.Assert(c != null && c != """");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNullOrUnknown()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? c, bool b)
    {
        Assert(c != null || b);
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_Debug_Assert2_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert3_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"", ""world"");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert4_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"", ""world"", new object[] { });
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_IsNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C c)
    {
        Assert(c == null, ""hello"");
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,16): hidden CS8606: Result of the comparison is possibly always false.
                //         Assert(c == null, "hello");
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c == null").WithLocation(7, 16)
                );
        }

        [Fact]
        public void AssertsTrue_NoDuplicateDiagnostics()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        Assert(Method(null), ""hello"");
        c.ToString();
    }
    bool Method(string x) => throw null;
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         Assert(Method(null), "hello");
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(7, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_InTry()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        try
        {
            Assert(c != null, ""hello"");
        }
        catch { }

        c.ToString();
    }
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(13, 9)
                );
        }

        [Fact]
        public void AssertsTrue_WithNotNullWhenFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s, string? s2)
    {
        Assert(!string.IsNullOrEmpty(s));
        s.ToString(); // ok

        Assert(string.IsNullOrEmpty(s2));
        s2.ToString(); // warn
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(11, 9)
                );
        }

        [Fact]
        public void AssertsFalse_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c == null);
        c.ToString();
    }

    void MyAssert([AssertsFalse] bool condition) => throw null;
}
", AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsFalse_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c != null);
        c.ToString();
    }

    void MyAssert([AssertsFalse] bool condition) => throw null;
}
", AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NotNullWhenFalse_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.Main", None);
            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_BoolReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public static object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_OnTwoParameters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        if (MyIsNullOrEmpty(s, s2))
        {
            s.ToString(); // warn 1
            s2.ToString(); // warn 2
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // ok
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [NotNullWhenFalse] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_WithNotNullWhenTrueOnSecondParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        if (MyIsNullOrEmpty(s, s2))
        {
            s.ToString(); // warn 1
            s2.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // warn 2
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [NotNullWhenTrue] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition, NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, NotNullWhenTrue);
        }

        [Fact]
        public void NotNullWhenFalse_OnIndexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s, int x)
    {
        if (this[s, x])
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public bool this[[NotNullWhenFalse] string? s, int x] => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_SecondArgumentDereferences()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (Method(s, s.ToString())) // warn 1
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }
    }
    static bool Method([NotNullWhenFalse] string? s, string s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,23): warning CS8602: Possible dereference of a null reference.
                //         if (Method(s, s.ToString())) // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 23)
                );
        }

        [Fact]
        public void NotNullWhenFalse_SecondArgumentAssigns()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (Method(s, s = null))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    static bool Method([NotNullWhenFalse] string? s, string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_MissingAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
        }

        s.ToString(); // ok
    }
    static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (17,34): error CS0246: The type or namespace name 'NotNullWhenFalseAttribute' could not be found (are you missing a using directive or an assembly reference?)
                //     static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "NotNullWhenFalse").WithArguments("NotNullWhenFalseAttribute").WithLocation(17, 34),
                // (17,34): error CS0246: The type or namespace name 'NotNullWhenFalse' could not be found (are you missing a using directive or an assembly reference?)
                //     static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "NotNullWhenFalse").WithArguments("NotNullWhenFalse").WithLocation(17, 34),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", None);
        }

        private static void VerifyAnnotations(Compilation compilation, string memberName, params FlowAnalysisAnnotations[] expected)
        {
            var method = compilation.GetMember<MethodSymbol>(memberName);
            Assert.True((object)method != null, $"Could not find method '{memberName}'");
            var actual = method.Parameters.Select(p => p.FlowAnalysisAnnotations);
            Assert.Equal(expected, actual);
        }

        private void VerifyAnnotationsAndMetadata(Compilation compilation, string memberName, params FlowAnalysisAnnotations[] expected)
        {
            VerifyAnnotations(compilation, memberName, expected);

            // Also verify from metadata
            var compilation2 = CreateCompilation("", references: new[] { compilation.EmitToImageReference() });
            VerifyAnnotations(compilation2, memberName, expected);
        }

        [Fact]
        public void NotNullWhenFalse_BadAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse(true)] string? s) => throw null;
}
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Parameter,
                   AllowMultiple = false)]
    public class NotNullWhenFalseAttribute : Attribute
    {
        public NotNullWhenFalseAttribute(bool bad) { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", None);
        }

        [Fact]
        public void NotNullWhenFalse_InvertIf()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (!MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_WithNullLiteral()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        _ = MyIsNullOrEmpty(null);
    }
    static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void NotNullWhenFalse_InstanceMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (this.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
    public bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ExtensionMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (this.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
public static class Extension
{
    public static bool MyIsNullOrEmpty(this C c, [NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "Extension.MyIsNullOrEmpty", None, NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty_WithoutCorlib()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrEmpty(string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Attribute { }
    public struct Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty_WithoutCorlib_RemovingAnnotations()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrEmpty([NotNullWhenTrue] string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Enum { }
    public struct Int32 { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void ExtraAnnotationsWin()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        System.Diagnostics.Debug.Assert(s != null, ""message"");
        s.ToString(); // ok
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String { }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Enum { }
    public struct Int32 { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
namespace System.Diagnostics
{
    public static class Debug
    {
        public static void Assert(bool condition, [EnsuresNotNull] string message) => throw null;
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "System.Diagnostics.Debug.Assert", AssertsTrue, None);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrWhiteSpace_WithoutCorlib()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrWhiteSpace(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrWhiteSpace(string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Attribute { }
    public struct Int32 { }
    public struct Enum { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrWhiteSpace", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (!string.IsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty_NoDuplicateWarnings()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void M()
    {
        if (!string.IsNullOrEmpty(M2(null)))
        {
        }
    }
    string? M2(string s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         if (!string.IsNullOrEmpty(M2(null)))
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 38)
                );
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty_NotAString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void M()
    {
        if (!string.IsNullOrEmpty(M2(null)))
        {
        }
    }
    void M2(string s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,35): error CS1503: Argument 1: cannot convert from 'void' to 'string'
                //         if (!string.IsNullOrEmpty(M2(null)))
                Diagnostic(ErrorCode.ERR_BadArgType, "M2(null)").WithArguments("1", "void", "string").WithLocation(6, 35)
                );
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrWhiteSpace()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrWhiteSpace(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrWhiteSpace", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_PartialMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public partial class C
{
    partial void M1(string? s);
    partial void M1([NotNullWhenFalse] string? s) => throw null;

    partial void M2([NotNullWhenFalse] string? s);
    partial void M2(string? s) => throw null;

    partial void M3([NotNullWhenFalse] string? s);
    partial void M3([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,22): error CS0579: Duplicate 'NotNullWhenFalse' attribute
                //     partial void M3([NotNullWhenFalse] string? s);
                Diagnostic(ErrorCode.ERR_DuplicateAttribute, "NotNullWhenFalse").WithArguments("NotNullWhenFalse").WithLocation(11, 22)
                );

            VerifyAnnotations(c, "C.M1", NotNullWhenFalse);
            VerifyAnnotations(c, "C.M2", NotNullWhenFalse);
            VerifyAnnotations(c, "C.M3", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningDynamic()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    public dynamic MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningObject_FromMetadata()
        {
            string il = @"
.class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.NullableAttribute
    extends [mscorlib]System.Attribute
{
    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig
        instance object MyIsNullOrEmpty (string s) cil managed
    {
        .param [1]
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NotNullWhenFalseAttribute::.ctor() = (
            01 00 00 00
        )

        IL_0000: ldnull
        IL_0001: throw
    }

    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.NotNullWhenFalseAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = (
        01 00 00 08 00 00 01 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00
    )
    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}
";
            string source = @"
public class D
{
    void Main(C c, string? s)
    {
        if ((bool)c.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
}
";
            var compilation = CreateCompilationWithIL(new[] { source }, il, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotations(compilation, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningObject()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        MyIsNullOrEmpty(s);
        s.ToString(); // warn
    }
    object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NotNullWhenFalse_FollowedByEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s, s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [EnsuresNotNull] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition, EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, EnsuresNotNull);
        }

        [Fact]
        public void NotNullWhenFalse_AndEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse, EnsuresNotNull] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition, EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public static void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_ResettingStateMatters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        ThrowIfNull(s = s2, s2 = ""hello"");
        s.ToString(); // warn
        s2.ToString(); // ok
    }
    public static void ThrowIfNull(string? s1, [EnsuresNotNull] string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ResettingStateMatters_InIndexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        _ = this[s = s2, s2 = ""hello""];
        s.ToString(); // warn
        s2.ToString(); // ok
    }
    public int this[string? s1, [EnsuresNotNull] string? s2] { get { throw null; } }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_NoDuplicateDiagnosticsWhenResettingState()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public interface I<T> { }
public class C
{
    void Main(string? s, I<object> i)
    {
        ThrowIfNull(i, s); // single warning on conversion failure
    }
    public static void ThrowIfNull(I<object?> x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,21): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.ThrowIfNull(I<object?> x, string? s)'.
                //         ThrowIfNull(i, s); // single warning on conversion failure
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "i").WithArguments("I<object>", "I<object?>", "x", "void C.ThrowIfNull(I<object?> x, string? s)").WithLocation(8, 21)
                );
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithRefType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(s);
        s.ToString(); // ok
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithValueType()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    void Main(int s)
    {
        ThrowIfNull(s);
        s.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithUnconstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M<U>(U u)
    {
        ThrowIfNull(u);
        u.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_OnInterface()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, Interface i)
    {
        i.ThrowIfNull(42, s);
        s.ToString(); // ok
    }
}
public interface Interface
{
    void ThrowIfNull(int x, [EnsuresNotNull] string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_OnInterface_ImplementedWithoutAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C : Interface
{
    void Main(string? s)
    {
        this.ThrowIfNull(42, s);
        s.ToString(); // warn
        ((Interface)this).ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public void ThrowIfNull(int x, string? s) => throw null;
}
public interface Interface
{
    void ThrowIfNull(int x, [EnsuresNotNull] string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, EnsuresNotNull);
            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, None);
        }

        [Fact]
        public void EnsuresNotNull_OnInterface_ImplementedWithAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C : Interface
{
    void Main(string? s)
    {
        ((Interface)this).ThrowIfNull(42, s);
        s.ToString(); // warn
        this.ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
public interface Interface
{
    void ThrowIfNull(int x, string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, None);
            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_OnDelegate()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
delegate void D([EnsuresNotNull] object? o);
public class C
{
    void Main(string? s, D d)
    {
        d(s);
        s.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_WithParams()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    static void EnsuresNotNull([EnsuresNotNull] params object?[]? args) { }
    static void F(object? x, object? y, object[]? a)
    {
        EnsuresNotNull();
        a.ToString(); // warn 1

        EnsuresNotNull(x, y);
        x.ToString(); // warn 2
        y.ToString(); // warn 3

        EnsuresNotNull(a);
        a.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(9, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_WithParamsOnFirstParameter()
        {
            CSharpCompilation c = CreateCompilationWithIL(new[] { @"
public class D
{
    static void F(object[]? a, object? b, object? c)
    {
        C.EnsuresNotNull(a, b, c);
        a.ToString(); // ok
        b.ToString(); // warn 1
        c.ToString(); // warn 2
    }
}
" }, @"
.class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.NullableAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
        01 00 00 00
    )
    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: ret
    }

    .method public hidebysig specialname rtspecialname instance void .ctor ( bool[] '' ) cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: ret
    }
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig static void EnsuresNotNull ( object[] args, object[] args2 ) cil managed
    {
        .param [1]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = (
            01 00 02 00 00 00 01 01 00 00
        )
        .custom instance void System.Runtime.CompilerServices.EnsuresNotNullAttribute::.ctor() = (
            01 00 00 00
        )
        .param [2]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = (
            01 00 02 00 00 00 01 01 00 00
        )
        .custom instance void System.Runtime.CompilerServices.EnsuresNotNullAttribute::.ctor() = (
            01 00 00 00
        )

        IL_0000: nop
        IL_0001: ret
    }

    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: nop
        IL_0007: ret
    }
}

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.EnsuresNotNullAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = (
        01 00 00 08 00 00 01 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00
    )
    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: nop
        IL_0008: ret
    }
}
", options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_WithNamedArguments()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    static void EnsuresNotNull1([EnsuresNotNull] object? x = null, object? y = null) { }
    static void EnsuresNotNull2(object? x = null, [EnsuresNotNull] object? y = null) { }
    static void F(object? x)
    {
        EnsuresNotNull1();
        EnsuresNotNull1(y: x);
        x.ToString(); // warn
        EnsuresNotNull2(y: x);
        x.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_OnDifferentTypes()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    public static void Bad<T>([EnsuresNotNull] int i) => throw null;
    public static void ThrowIfNull<T>([EnsuresNotNull] T t) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.Bad", EnsuresNotNull);
            VerifyAnnotations(c, "C.ThrowIfNull", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_GenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
   void M<T>(T t)
    {
        t.ToString(); // warn
        ThrowIfNull(t);
        t.ToString(); // ok
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(7, 9)
                );

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_BeginInvoke()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public delegate void Delegate([EnsuresNotNull] string? s);
public class C
{
   void M(Delegate d, string? s)
    {
        if (s != string.Empty) s.ToString(); // warn
        d.BeginInvoke(s, null, null);
        s.ToString(); // warn 2
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,32): warning CS8602: Possible dereference of a null reference.
                //         if (s != string.Empty) s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 32),
                // (9,26): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         d.BeginInvoke(s, null, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(9, 26),
                // (9,32): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         d.BeginInvoke(s, null, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(9, 32),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(10, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_BackEffect()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s2 = s1, s1);
        s2.ToString(); // warn
    }
    public static void ThrowIfNull(string? x1, [EnsuresNotNull] string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29865: Should we be able to trace that s2 was assigned a non-null value?
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s1, s2 = s1);
        s2.ToString(); // ok
    }
    public static void ThrowIfNull([EnsuresNotNull] string? x1, string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect2()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1)
    {
        ThrowIfNull(s1, s1 = null);
        s1.ToString(); // warn
    }
    public static void ThrowIfNull([EnsuresNotNull] string? x1, string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s1.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s1").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect3()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s1 = null, s2 = s1, s1 = """", s1);
        s2.ToString(); // warn
    }
    public static void ThrowIfNull(string? x1, string? x2, string? x3, [EnsuresNotNull] string? x4) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29867, "https://github.com/dotnet/roslyn/issues/29867")]
        public void EnsuresNotNull_TypeInference()
        {
            // https://github.com/dotnet/roslyn/issues/29867: This test raises the question of flowing information from annotations into the inferred type
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1)
    {
        ThrowIfNull(s1, out var s2);
        s2/*T:string?*/.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T x1, out T x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ConditionalMethodInReleaseMode()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    [System.Diagnostics.Conditional(""DEBUG"")]
    static void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_SecondArgumentDereferences()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(s, s.ToString()); // warn
        s.ToString(); // ok
    }
    public static void ThrowIfNull([EnsuresNotNull] string? s, string s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,24): warning CS8602: Possible dereference of a null reference.
                //         ThrowIfNull(s, s.ToString()); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 24)
                );

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", EnsuresNotNull, None);
        }

        [Fact]
        public void EnsuresNotNull_SecondArgumentAssigns()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        ThrowIfNull(s, s = null);
        s.ToString(); // warn
    }
    static void ThrowIfNull([EnsuresNotNull] string? s, string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_String_Contains()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        ""hello"".Contains(s);
        s.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "System.String.Contains", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_Indexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        _ = this[42, s];
        s.ToString(); // ok
    }
    public int this[int x, [EnsuresNotNull] string? s] => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalBranching_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1)
    {
        if (y1 != null)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2)
    {
        if (y2 == null)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    void Test3(CL2 x3, CL2? y3, CL2 z3)
    {
        if (y3 != null)
        {
            x3 = y3;
        }
        else
        {
            z3 = y3;
        }
    }

    void Test4(CL2 x4, CL2? y4, CL2 z4)
    {
        if (y4 == null)
        {
            x4 = y4;
        }
        else
        {
            z4 = y4;
        }
    }

    void Test5(CL1 x5, CL1 y5, CL1 z5)
    {
        if (y5 != null)
        {
            x5 = y5;
        }
        else
        {
            z5 = y5;
        }
    }
}

class CL1
{
}

class CL2
{
    public static bool operator == (CL2? x, CL2? y) { return false; }
    public static bool operator != (CL2? x, CL2? y) { return false; }
    public override bool Equals(object obj) { return false; }
    public override int GetHashCode() { return 0; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(24, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z3 = y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y3").WithLocation(40, 18),
                 // (48,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x4 = y4;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4").WithLocation(48, 18),
                 // (58,13): hidden CS8605: Result of the comparison is possibly always true.
                 //         if (y5 != null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y5 != null").WithLocation(58, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1)
    {
        if (null != y1)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2)
    {
        if (null == y2)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    void Test3(CL2 x3, CL2? y3, CL2 z3)
    {
        if (null != y3)
        {
            x3 = y3;
        }
        else
        {
            z3 = y3;
        }
    }

    void Test4(CL2 x4, CL2? y4, CL2 z4)
    {
        if (null == y4)
        {
            x4 = y4;
        }
        else
        {
            z4 = y4;
        }
    }

    void Test5(CL1 x5, CL1 y5, CL1 z5)
    {
        if (null == y5)
        {
            x5 = y5;
        }
        else
        {
            z5 = y5;
        }
    }
}

class CL1
{
}

class CL2
{
    public static bool operator == (CL2? x, CL2? y) { return false; }
    public static bool operator != (CL2? x, CL2? y) { return false; }
    public override bool Equals(object obj) { return false; }
    public override int GetHashCode() { return 0; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(24, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z3 = y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y3").WithLocation(40, 18),
                 // (48,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x4 = y4;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4").WithLocation(48, 18),
                 // (58,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (null == y5)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "null == y5").WithLocation(58, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1, bool u1)
    {
        if (null != y1 || u1)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2, bool u2)
    {
        if (y2 != null && u2)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    bool Test3(CL1? x3)
    {
        return x3.M1();
    }

    bool Test4(CL1? x4)
    {
        return x4 != null && x4.M1();
    }

    bool Test5(CL1? x5)
    {
        return x5 == null && x5.M1();
    }
}

class CL1
{
    public bool M1() { return true; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(12, 18),
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (28,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(28, 18),
                 // (34,16): warning CS8602: Possible dereference of a null reference.
                 //         return x3.M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(34, 16),
                 // (44,30): warning CS8602: Possible dereference of a null reference.
                 //         return x5 == null && x5.M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x5").WithLocation(44, 30)
                );
        }

        [Fact]
        public void ConditionalBranching_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 ?? x1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 ?? x2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 ?? y3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 ?? x4.M1();
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 ?? x5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 ?? x6.M2();
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 ?? x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 ?? x2").WithLocation(15, 18),
                // (20,18): hidden CS8607: Expression is probably never null.
                //         CL1 z3 = x3 ?? y3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(20, 18),
                // (26,18): hidden CS8607: Expression is probably never null.
                //         CL1 z4 = x4 ?? x4.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4").WithLocation(26, 18),
                // (38,21): hidden CS8607: Expression is probably never null.
                //         string z6 = y6 ?? x6.M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y6").WithLocation(38, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1)
    {
        CL1 z1 = x1?.M1();
    }

    void Test2(CL1? x2, CL1 y2)
    {
        x2 = y2;
        CL1 z2 = x2?.M1();
    }

    void Test3(CL1? x3, CL1 y3)
    {
        x3 = y3;
        CL1 z3 = x3?.M2();
    }

    void Test4(CL1? x4)
    {
        x4?.M3(x4);
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public CL1? M2() { return null; }
    public void M3(CL1 x) { }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z1 = x1?.M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1?.M1()").WithLocation(10, 18),
                 // (16,18): hidden CS8607: Expression is probably never null.
                 //         CL1 z2 = x2?.M1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(16, 18),
                 // (22,18): hidden CS8607: Expression is probably never null.
                 //         CL1 z3 = x3?.M2();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(22, 18),
                 // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z3 = x3?.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3?.M2()").WithLocation(22, 18)
                );
        }

        [Fact]
        public void ConditionalBranching_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 != null ? y1 : x1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 != null ? y2 : x2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 != null ? x3 : y3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 != null ? x4 : x4.M1();
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 != null ? y5 : x5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 != null ? y6 : x6.M2();
    }

    void Test7(CL1 x7)
    {
        const string? y7 = null;
        string z7 = y7 != null ? y7 : x7.M2();
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 != null ? y2 : x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 != null ? y2 : x2").WithLocation(15, 18),
                // (20,18): hidden CS8605: Result of the comparison is possibly always true.
                //         CL1 z3 = x3 != null ? x3 : y3;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x3 != null").WithLocation(20, 18),
                // (20,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z3 = x3 != null ? x3 : y3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 != null ? x3 : y3").WithLocation(20, 18),
                // (26,18): hidden CS8605: Result of the comparison is possibly always true.
                //         CL1 z4 = x4 != null ? x4 : x4.M1();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x4 != null").WithLocation(26, 18),
                // (38,21): hidden CS8605: Result of the comparison is possibly always true.
                //         string z6 = y6 != null ? y6 : x6.M2();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y6 != null").WithLocation(38, 21),
                // (44,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z7 = y7 != null ? y7 : x7.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y7 != null ? y7 : x7.M2()").WithLocation(44, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 == null ? x1 : y1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 == null ? x2 : y2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 == null ? y3 : x3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 == null ? x4.M1() : x4;
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 == null ? x5 : y5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 == null ? x6.M2() : y6;
    }

    void Test7(CL1 x7)
    {
        const string? y7 = null;
        string z7 = y7 == null ? x7.M2() : y7;
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 == null ? x2 : y2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 == null ? x2 : y2").WithLocation(15, 18),
                // (20,18): hidden CS8606: Result of the comparison is possibly always false.
                //         CL1 z3 = x3 == null ? y3 : x3;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x3 == null").WithLocation(20, 18),
                // (20,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z3 = x3 == null ? y3 : x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 == null ? y3 : x3").WithLocation(20, 18),
                // (26,18): hidden CS8606: Result of the comparison is possibly always false.
                //         CL1 z4 = x4 == null ? x4.M1() : x4;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x4 == null").WithLocation(26, 18),
                // (38,21): hidden CS8606: Result of the comparison is possibly always false.
                //         string z6 = y6 == null ? x6.M2() : y6;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "y6 == null").WithLocation(38, 21),
                // (44,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z7 = y7 == null ? x7.M2() : y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y7 == null ? x7.M2() : y7").WithLocation(44, 21)
                );
        }

        [Fact]
        [WorkItem(26624, "https://github.com/dotnet/roslyn/issues/26624")]
        public void ConditionalBranching_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    bool Test1(CL1? x1)
    {
        if (x1?.P1 == true)
        {
            return x1.P2;
        }

        return false;
    }
}

class CL1
{
    public bool P1 { get { return true;} }
    public bool P2 { get { return true;} }
}
" }, options: WithNonNullTypesTrue());
            // Not tracking state of x?.P == expr
            // unless expr is `null`. See https://github.com/dotnet/roslyn/issues/26624.
            c.VerifyDiagnostics(
                // (12,20): warning CS8602: Possible dereference of a null reference.
                //             return x1.P2;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 20)
                );
        }

        [Fact]
        public void ConditionalBranching_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        object z1 = y1 ?? x1;
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,21): hidden CS8607: Expression is probably never null.
                 //         object z1 = y1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(12, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        object z1 = y1 != null ? y1 : x1;
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,21): hidden CS8605: Result of the comparison is possibly always true.
                 //         object z1 = y1 != null ? y1 : x1;
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y1 != null").WithLocation(12, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        y1?.GetHashCode();
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,9): hidden CS8607: Expression is probably never null.
                 //         y1?.GetHashCode();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(12, 9)
                );
        }

        [Fact]
        public void ConditionalBranching_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();

        if (y1 == null)
        {
            System.Console.WriteLine(1);
        }
        else
        {
            System.Console.WriteLine(2);
        }

        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (13,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (y1 == null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "y1 == null").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();

        if (y1 != null)
        {
            System.Console.WriteLine(1);
        }
        else
        {
            System.Console.WriteLine(2);
        }

        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                 //         if (y1 != null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y1 != null").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_14()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    C? _cField = null;
    C _nonNullCField = new C();
    C? GetC() => null;
    C? CProperty { get => null; }

    void Test1(C? c1)
    {
        if (c1?._cField != null)
        {
            c1._cField.ToString();
        }
        else
        {
            c1._cField.ToString(); // warn 1 2
        }
    }

    void Test2()
    {
        C? c2 = GetC();
        if (c2?._cField != null)
        {
            c2._cField.ToString();
        }
        else
        {
            c2._cField.ToString(); // warn 3 4
        }
    }

    void Test3(C? c3)
    {
        if (c3?._cField?._cField != null)
        {
            c3._cField._cField.ToString();
        }
        else if (c3?._cField != null)
        {
            c3._cField.ToString();
            c3._cField._cField.ToString(); // warn 5
        }
        else
        {
            c3.ToString(); // warn 6
        }
    }

    void Test4(C? c4)
    {
        if (c4?._nonNullCField._cField?._nonNullCField._cField != null)
        {
            c4._nonNullCField._cField._nonNullCField._cField.ToString();
        }
        else
        {
            c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
        }
    }

    void Test5(C? c5)
    {
        if (c5?._cField == null)
        {
            c5._cField.ToString(); // warn 10 11
        }
        else
        {
            c5._cField.ToString();
        }
    }

    void Test6(C? c6)
    {
        if (c6?._cField?.GetC() != null)
        {
            c6._cField.GetC().ToString(); // warn 12
        }
    }

    void Test7(C? c7)
    {
        if (c7?._cField?.CProperty != null)
        {
            c7._cField.CProperty.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             c1._cField.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(17, 13),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             c1._cField.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1._cField").WithLocation(17, 13),

                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             c2._cField.ToString(); // warn 3 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(30, 13),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             c2._cField.ToString(); // warn 3 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2._cField").WithLocation(30, 13),

                // (43,13): warning CS8602: Possible dereference of a null reference.
                //             c3._cField._cField.ToString(); // warn 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3._cField._cField").WithLocation(43, 13),

                // (47,13): warning CS8602: Possible dereference of a null reference.
                //             c3.ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3").WithLocation(47, 13),

                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4").WithLocation(59, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4._nonNullCField._cField").WithLocation(59, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4._nonNullCField._cField._nonNullCField._cField").WithLocation(59, 13),

                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             c5._cField.ToString(); // warn 10 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c5").WithLocation(67, 13),
                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             c5._cField.ToString(); // warn 10 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c5._cField").WithLocation(67, 13),

                // (79,13): warning CS8602: Possible dereference of a null reference.
                //             c6._cField.GetC().ToString(); // warn 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c6._cField.GetC()").WithLocation(79, 13)
            );
        }

        [Fact]
        public void ConditionalBranching_15()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test(C? c1)
    {
        if (c1?[0] != null)
        {
            c1.ToString();
            c1[0].ToString(); // warn 1
        }
        else
        {
            c1.ToString(); // warn 2
        }
    }

    object? this[int i] { get => null; }
}
" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c1[0].ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1[0]").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             c1.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(13, 13)
            );
        }

        [Fact]
        public void ConditionalBranching_16()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test<T>(T t)
    {
        if (t?.ToString() != null)
        {
            t.ToString();
        }
        else
        {
            t.ToString(); // warn
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_17()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    object? Prop { get; }
    object? GetObj(bool val) => null;
    void Test(C? c1, C? c2)
    {
        if (c1?.GetObj(c2?.Prop != null) != null)
        {
            c2.Prop.ToString(); // warn 1 2
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             c2.Prop.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(10, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             c2.Prop.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2.Prop").WithLocation(10, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_18()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test(C? x, C? y)
    {
        if ((x = y)?.GetHashCode() != null)
        {
            x.ToString();
            y.ToString(); // warn
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_ReferenceType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is C)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_GenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Base { }
class C : Base
{
    void Test<T>(C? x) where T : Base
    {
        if (x is T)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_UnconstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o)
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_StructConstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o) where T : struct
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_ClassConstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o) where T : class
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_UnconstrainedGenericOperand()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(T t, object? o)
    {
        if (t is string) t.ToString();
        if (t is string s) { t.ToString(); s.ToString(); }
        if (t != null) t.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalBranching_Is_NullOperand()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F(object? o)
    {
        if (null is string) return;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS0184: The given expression is never of the provided ('string') type
                //         if (null is string) return;
                Diagnostic(ErrorCode.WRN_IsAlwaysFalse, "null is string").WithArguments("string").WithLocation(6, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is null)
        {
            x.ToString(); // warn
        }
        else
        {
            x.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NullInverted()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (!(x is null))
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NonNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        const string nonNullConstant = ""hello"";
        if (x is nonNullConstant)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NullConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        const string? nullConstant = null;
        if (x is nullConstant)
        {
            x.ToString(); // warn
        }
        else
        {
            x.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NonConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        string nonConstant = ""hello"";
        if (x is nonConstant)
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,18): error CS0150: A constant value is expected
                //         if (x is nonConstant)
                Diagnostic(ErrorCode.ERR_ConstantExpected, "nonConstant").WithLocation(7, 18),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 13)
                );
        }

        [Fact]
        [WorkItem(29868, "https://github.com/dotnet/roslyn/issues/29868")]
        public void ConditionalBranching_IsConstantPattern_Null_AlreadyTestedAsNonNull()
        {
            // https://github.com/dotnet/roslyn/issues/29868: confirm that we want such hidden warnings
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x != null)
        {
            if (x is null) // hidden
            {
                x.ToString(); // warn
            }
            else
            {
                x.ToString();
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,22): hidden CS8606: Result of the comparison is possibly always false.
                //             if (x is null) // hidden
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "null").WithLocation(8, 22),
                // (10,17): warning CS8602: Possible dereference of a null reference.
                //                 x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 17)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_Null_AlreadyTestedAsNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x == null)
        {
            if (x is null)
            {
                x.ToString(); // warn
            }
            else
            {
                x.ToString();
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,17): warning CS8602: Possible dereference of a null reference.
                //                 x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 17)
                );
        }

        [Fact]
        public void ConditionalBranching_IsDeclarationPattern()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is C c)
        {
            x.ToString();
            c.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is var c)
        {
            x.ToString(); // warn 1
            c /*T:object?*/ .ToString(); // warn 2
        }
        else
        {
            x.ToString(); // warn 3
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c /*T:object?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern_Discard()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is var _)
        {
            x.ToString(); // warn 1
        }
        else
        {
            x.ToString(); // warn 2
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern_AlreadyTestedAsNonNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x != null)
        {
            if (x is var c)
            {
                c /*T:object!*/ .ToString();
                c = null; // warn
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (11,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                 c = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 21)
                );
        }

        [Fact]
        public void ConditionalOperator_01()
        {
            var source =
@"class C
{
    static void F(bool b, object x, object? y)
    {
        var z = b ? x : y;
        z.ToString();
        var w = b ? y : x;
        w.ToString();
        var v = true ? y : x;
        v.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         v.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v").WithLocation(10, 9));
        }

        [Fact]
        public void ConditionalOperator_02()
        {
            var source =
@"class C
{
    static void F(bool b, object x, object? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
        if (y != null) (b ? x : y).ToString();
        if (y != null) (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(6, 10));
        }

        [Fact]
        public void ConditionalOperator_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (false ? x : y).ToString();
        (false ? y : x).ToString();
        (true ? x : y).ToString();
        (true ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (false ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "false ? x : y").WithLocation(5, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (true ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "true ? y : x").WithLocation(8, 10));
        }

        [Fact]
        public void ConditionalOperator_04()
        {
            var source =
@"class C
{
    static void F(bool b, object x, string? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void G(bool b, object? x, string y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(6, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(11, 10));
        }

        [Fact]
        public void ConditionalOperator_05()
        {
            var source =
@"#pragma warning disable 0649
class A<T> { }
class B1 : A<object?> { }
class B2 : A<object> { }
class C
{
    static void F(bool b, A<object> x, A<object?> y, B1 z, B2 w)
    {
        object o;
        o = (b ? x : z)/*T:A<object!>!*/;
        o = (b ? x : w)/*T:A<object!>!*/;
        o = (b ? z : x)/*T:A<object!>!*/;
        o = (b ? w : x)/*T:A<object!>!*/;
        o = (b ? y : z)/*T:A<object?>!*/;
        o = (b ? y : w)/*T:A<object?>!*/;
        o = (b ? z : y)/*T:A<object?>!*/;
        o = (b ? w : y)/*T:A<object?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,22): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<object>'.
                //         o = (b ? x : z)/*T:A<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z").WithArguments("B1", "A<object>").WithLocation(10, 22),
                // (12,18): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<object>'.
                //         o = (b ? z : x)/*T:A<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z").WithArguments("B1", "A<object>").WithLocation(12, 18),
                // (15,22): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<object?>'.
                //         o = (b ? y : w)/*T:A<object?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B2", "A<object?>").WithLocation(15, 22),
                // (17,18): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<object?>'.
                //         o = (b ? w : y)/*T:A<object?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B2", "A<object?>").WithLocation(17, 18));
        }

        [Fact]
        public void ConditionalOperator_06()
        {
            var source =
@"class C
{
    static void F(bool b, object x, string? y)
    {
        (b ? null : x).ToString();
        (b ? null : y).ToString();
        (b ? x: null).ToString();
        (b ? y: null).ToString();
        (b ? null: null).ToString();
        (b ? default : x).ToString();
        (b ? default : y).ToString();
        (b ? x: default).ToString();
        (b ? y: default).ToString();
        (b ? default: default).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between '<null>' and '<null>'
                //         (b ? null: null).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? null: null").WithArguments("<null>", "<null>").WithLocation(9, 10),
                // (14,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'default' and 'default'
                //         (b ? default: default).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? default: default").WithArguments("default", "default").WithLocation(14, 10),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : x").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : y").WithLocation(6, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: null").WithLocation(7, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y: null").WithLocation(8, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null: null").WithLocation(9, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default : x").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default : y").WithLocation(11, 10),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: default").WithLocation(12, 10),
                // (13,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y: default").WithLocation(13, 10),
                // (14,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default: default").WithLocation(14, 10));
        }

        [Fact]
        public void ConditionalOperator_07()
        {
            var source =
@"class C
{
    static void F(bool b, Unknown x, Unknown? y)
    {
        (b ? null : x).ToString();
        (b ? null : y).ToString();
        (b ? x: null).ToString();
        (b ? y: null).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,27): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(bool b, Unknown x, Unknown? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 27),
                // (3,38): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(bool b, Unknown x, Unknown? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 38),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : x").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: null").WithLocation(7, 10));
        }

        [Fact]
        public void ConditionalOperator_08()
        {
            var source =
@"class C
{
    static void F1(bool b, UnknownA x, UnknownB y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F2(bool b, UnknownA? x, UnknownB y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F3(bool b, UnknownA? x, UnknownB? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(bool b, UnknownA x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(3, 28),
                // (3,40): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(bool b, UnknownA x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(3, 40),
                // (8,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(bool b, UnknownA? x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(8, 28),
                // (8,41): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(bool b, UnknownA? x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(8, 41),
                // (13,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F3(bool b, UnknownA? x, UnknownB? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(13, 28),
                // (13,41): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F3(bool b, UnknownA? x, UnknownB? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(13, 41),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(11, 10),
                // (15,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'UnknownA?' and 'UnknownB?'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("UnknownA?", "UnknownB?").WithLocation(15, 10),
                // (16,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'UnknownB?' and 'UnknownA?'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("UnknownB?", "UnknownA?").WithLocation(16, 10),
                // (15,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(15, 10),
                // (16,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(16, 10));
        }

        [Fact]
        public void ConditionalOperator_09()
        {
            var source =
@"struct A { }
struct B { }
class C
{
    static void F1(bool b, A x, B y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F2(bool b, A x, C y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F3(bool b, B x, C? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'A' and 'B'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("A", "B").WithLocation(7, 10),
                // (8,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'B' and 'A'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("B", "A").WithLocation(8, 10),
                // (12,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'A' and 'C'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("A", "C").WithLocation(12, 10),
                // (13,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'C' and 'A'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("C", "A").WithLocation(13, 10),
                // (17,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'B' and 'C'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("B", "C").WithLocation(17, 10),
                // (18,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'C' and 'B'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("C", "B").WithLocation(18, 10),
                // (17,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(17, 10),
                // (18,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(18, 10));
        }

        [Fact]
        public void ConditionalOperator_10()
        {
            var source =
@"using System;
class C
{
    static void F(bool b, object? x, object y)
    {
        (b ? x : throw new Exception()).ToString();
        (b ? y : throw new Exception()).ToString();
        (b ? throw new Exception() : x).ToString();
        (b ? throw new Exception() : y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : throw new Exception()).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : throw new Exception()").WithLocation(6, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? throw new Exception() : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? throw new Exception() : x").WithLocation(8, 10));
        }

        [Fact]
        public void ConditionalOperator_11()
        {
            var source =
@"class C
{
    static void F(bool b, object x)
    {
        (b ? x : throw null).ToString();
        (b ? throw null : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalOperator_12()
        {
            var source =
@"using System;
class C
{
    static void F(bool b)
    {
        (b ? throw new Exception() : throw new Exception()).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between '<throw expression>' and '<throw expression>'
                //         (b ? throw new Exception() : throw new Exception()).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? throw new Exception() : throw new Exception()").WithArguments("<throw expression>", "<throw expression>").WithLocation(6, 10));
        }

        [Fact]
        public void ConditionalOperator_13()
        {
            var source =
@"class C
{
    static bool F(object? x)
    {
        return true;
    }
    static void F1(bool c, bool b1, bool b2, object v1)
    {
        object x1;
        object y1;
        object? z1 = null;
        object? w1 = null;
        if (c ? b1 && F(x1 = v1) && F(z1 = v1) : b2 && F(y1 = v1) && F(w1 = v1))
        {
            x1.ToString(); // unassigned (if)
            y1.ToString(); // unassigned (if)
            z1.ToString(); // may be null (if)
            w1.ToString(); // may be null (if)
        }
        else
        {
            x1.ToString(); // unassigned (no error) (else)
            y1.ToString(); // unassigned (no error) (else)
            z1.ToString(); // may be null (else)
            w1.ToString(); // may be null (else)
        }
    }
    static void F2(bool b1, bool b2, object v2)
    {
        object x2;
        object y2;
        object? z2 = null;
        object? w2 = null;
        if (true ? b1 && F(x2 = v2) && F(z2 = v2) : b2 && F(y2 = v2) && F(w2 = v2))
        {
            x2.ToString(); // ok (if)
            y2.ToString(); // unassigned (if)
            z2.ToString(); // ok (if)
            w2.ToString(); // may be null (if)
        }
        else
        {
            x2.ToString(); // unassigned (else)
            y2.ToString(); // unassigned (no error) (else)
            z2.ToString(); // may be null (else)
            w2.ToString(); // may be null (else)
        }
    }
    static void F3(bool b1, bool b2, object v3)
    {
        object x3;
        object y3;
        object? z3 = null;
        object? w3 = null;
        if (false ? b1 && F(x3 = v3) && F(z3 = v3) : b2 && F(y3 = v3) && F(w3 = v3))
        {
            x3.ToString(); // unassigned (if)
            y3.ToString(); // ok (if)
            z3.ToString(); // may be null (if)
            w3.ToString(); // ok (if)
        }
        else
        {
            x3.ToString(); // unassigned (no error) (else)
            y3.ToString(); // unassigned (else)
            z3.ToString(); // may be null (else)
            w3.ToString(); // may be null (else)
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,13): error CS0165: Use of unassigned local variable 'x1'
                //             x1.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x1").WithArguments("x1").WithLocation(15, 13),
                // (16,13): error CS0165: Use of unassigned local variable 'y1'
                //             y1.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(16, 13),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             z1.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(17, 13),
                // (18,13): warning CS8602: Possible dereference of a null reference.
                //             w1.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w1").WithLocation(18, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             z1.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(24, 13),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             w1.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w1").WithLocation(25, 13),
                // (37,13): error CS0165: Use of unassigned local variable 'y2'
                //             y2.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(37, 13),
                // (43,13): error CS0165: Use of unassigned local variable 'x2'
                //             x2.ToString(); // unassigned (else)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x2").WithArguments("x2").WithLocation(43, 13),
                // (39,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(39, 13),
                // (45,13): warning CS8602: Possible dereference of a null reference.
                //             z2.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(45, 13),
                // (46,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(46, 13),
                // (57,13): error CS0165: Use of unassigned local variable 'x3'
                //             x3.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(57, 13),
                // (65,13): error CS0165: Use of unassigned local variable 'y3'
                //             y3.ToString(); // unassigned (else)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y3").WithArguments("y3").WithLocation(65, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             z3.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z3").WithLocation(59, 13),
                // (66,13): warning CS8602: Possible dereference of a null reference.
                //             z3.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z3").WithLocation(66, 13),
                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             w3.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w3").WithLocation(67, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29869: Review /*T:...*/ and diagnostics.
        [Fact]
        public void ConditionalOperator_14()
        {
            var source =
@"interface I<T> { T P { get; } }
interface IIn<in T> { }
interface IOut<out T> { T P { get; } }
class C
{
    static void F1(bool b, ref string? x1, ref string y1)
    {
        (b ? ref x1 : ref x1)/*T:string?*/.ToString();
        (b ? ref x1 : ref y1)/*T:string?*/.ToString();
        (b ? ref y1 : ref x1)/*T:string?*/.ToString();
        (b ? ref y1 : ref y1)/*T:string!*/.ToString();
    }
    static void F2(bool b, ref I<string?> x2, ref I<string> y2)
    {
        (b ? ref x2 : ref x2)/*T:I<string?>!*/.P.ToString();
        (b ? ref y2 : ref x2)/*T:I<string>!*/.P.ToString();
        (b ? ref x2 : ref y2)/*T:I<string>!*/.P.ToString();
        (b ? ref y2 : ref y2)/*T:I<string!>!*/.P.ToString();
    }
    static void F3(bool b, ref IIn<string?> x3, ref IIn<string> y3)
    {
        (b ? ref x3 : ref x3)/*T:IIn<string?>!*/.ToString();
        (b ? ref y3 : ref x3)/*T:IIn<string!>!*/.ToString();
        (b ? ref x3 : ref y3)/*T:IIn<string!>!*/.ToString();
        (b ? ref y3 : ref y3)/*T:IIn<string!>!*/.ToString();
    }
    static void F4(bool b, ref IOut<string?> x4, ref IOut<string> y4)
    {
        (b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref y4 : ref y4)/*T:IOut<string!>!*/.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x1 : ref x1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref x1 : ref x1").WithLocation(8, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x1 : ref y1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref x1 : ref y1").WithLocation(9, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref y1 : ref x1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref y1 : ref x1").WithLocation(10, 10),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x2 : ref x2)/*T:I<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x2 : ref x2)/*T:I<string?>!*/.P").WithLocation(15, 9),
                // (16,10): warning CS8626: No best nullability for operands of conditional expression 'I<string>' and 'I<string?>'.
                //         (b ? ref y2 : ref x2)/*T:I<string>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? ref y2 : ref x2").WithArguments("I<string>", "I<string?>").WithLocation(16, 10),
                // (17,10): warning CS8626: No best nullability for operands of conditional expression 'I<string?>' and 'I<string>'.
                //         (b ? ref x2 : ref y2)/*T:I<string>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? ref x2 : ref y2").WithArguments("I<string?>", "I<string>").WithLocation(17, 10),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P").WithLocation(30, 9),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P").WithLocation(31, 9));
        }

        [Fact]
        public void ConditionalOperator_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(bool b, object? x, object y)
    {
        var z = A.F/*T:object*/;
        object? o;
        o = (b ? x : x)/*T:object?*/;
        o = (b ? x : y)/*T:object?*/;
        o = (b ? x : z)/*T:object?*/;
        o = (b ? y : x)/*T:object?*/;
        o = (b ? y : y)/*T:object!*/;
        o = (b ? y : z)/*T:object*/;
        o = (b ? z : x)/*T:object?*/;
        o = (b ? z : y)/*T:object*/;
        o = (b ? z : z)/*T:object*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [Fact]
        public void ConditionalOperator_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static B<T> CreateB<T>(T t)
    {
        throw null;
    }
    static void F(bool b, B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        object o;
        o = (b ? x : x)/*T:B<object?>!*/;
        o = (b ? x : y)/*T:B<object>!*/;
        o = (b ? x : z)/*T:B<object?>!*/;
        o = (b ? y : x)/*T:B<object>!*/;
        o = (b ? y : y)/*T:B<object!>!*/;
        o = (b ? y : z)/*T:B<object!>!*/;
        o = (b ? z : x)/*T:B<object?>!*/;
        o = (b ? z : y)/*T:B<object!>!*/;
        o = (b ? z : z)/*T:B<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (13,14): warning CS8626: No best nullability for operands of conditional expression 'B<object?>' and 'B<object>'.
                //         o = (b ? x : y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? x : y").WithArguments("B<object?>", "B<object>").WithLocation(13, 14),
                // (15,14): warning CS8626: No best nullability for operands of conditional expression 'B<object>' and 'B<object?>'.
                //         o = (b ? y : x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? y : x").WithArguments("B<object>", "B<object?>").WithLocation(15, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ConditionalOperator_NestedNullability_Variant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(bool b, I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (b ? x : x)/*T:I<object!>!*/;
        o = (b ? x : y)/*T:I<object>!*/;
        o = (b ? x : z)/*T:I<object!>!*/;
        o = (b ? y : x)/*T:I<object>!*/;
        o = (b ? y : y)/*T:I<object?>!*/;
        o = (b ? y : z)/*T:I<object?>!*/;
        o = (b ? z : x)/*T:I<object!>!*/;
        o = (b ? z : y)/*T:I<object?>!*/;
        o = (b ? z : z)/*T:I<object>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(bool b, IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        object o;
        o = (b ? x : x)/*T:IIn<object!>!*/;
        o = (b ? x : y)/*T:IIn<object!>!*/;
        o = (b ? x : z)/*T:IIn<object!>!*/;
        o = (b ? y : x)/*T:IIn<object!>!*/;
        o = (b ? y : y)/*T:IIn<object?>!*/;
        o = (b ? y : z)/*T:IIn<object>!*/;
        o = (b ? z : x)/*T:IIn<object!>!*/;
        o = (b ? z : y)/*T:IIn<object>!*/;
        o = (b ? z : z)/*T:IIn<object>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(bool b, IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        object o;
        o = (b ? x : x)/*T:IOut<object!>!*/;
        o = (b ? x : y)/*T:IOut<object?>!*/;
        o = (b ? x : z)/*T:IOut<object>!*/;
        o = (b ? y : x)/*T:IOut<object?>!*/;
        o = (b ? y : y)/*T:IOut<object?>!*/;
        o = (b ? y : z)/*T:IOut<object?>!*/;
        o = (b ? z : x)/*T:IOut<object>!*/;
        o = (b ? z : y)/*T:IOut<object?>!*/;
        o = (b ? z : z)/*T:IOut<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,14): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         o = (b ? x : y)/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(12, 14),
                // (14,14): warning CS8626: No best nullability for operands of conditional expression 'I<object?>' and 'I<object>'.
                //         o = (b ? y : x)/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? y : x").WithArguments("I<object?>", "I<object>").WithLocation(14, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ConditionalOperator_NestedNullability_VariantAndInvariant()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T, U> { }
interface IOut<T, out U> { }
class C
{
    static IIn<T, U> CreateIIn<T, U>(T t, U u) => throw null;
    static void F1(bool b, IIn<object, string> x1, IIn<object?, string?> y1)
    {
        var z1 = CreateIIn(A.F1, A.F2)/*T:IIn<object, string>!*/;
        object o;
        o = (b ? x1 : x1)/*T:IIn<object!, string!>!*/;
        o = (b ? x1 : y1)/*T:IIn<object!, string>!*/;
        o = (b ? x1 : z1)/*T:IIn<object!, string!>!*/;
        o = (b ? y1 : x1)/*T:IIn<object!, string>!*/;
        o = (b ? y1 : y1)/*T:IIn<object?, string?>!*/;
        o = (b ? y1 : z1)/*T:IIn<object, string?>!*/;
        o = (b ? z1 : x1)/*T:IIn<object!, string!>!*/;
        o = (b ? z1 : y1)/*T:IIn<object, string?>!*/;
        o = (b ? z1 : z1)/*T:IIn<object, string>!*/;
    }
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void F2(bool b, IOut<object, string> x2, IOut<object?, string?> y2)
    {
        var z2 = CreateIOut(A.F1, A.F2)/*T:IOut<object, string>!*/;
        object o;
        o = (b ? x2 : x2)/*T:IOut<object!, string!>!*/;
        o = (b ? x2 : y2)/*T:IOut<object, string?>!*/;
        o = (b ? x2 : z2)/*T:IOut<object!, string>!*/;
        o = (b ? y2 : x2)/*T:IOut<object, string?>!*/;
        o = (b ? y2 : y2)/*T:IOut<object?, string?>!*/;
        o = (b ? y2 : z2)/*T:IOut<object?, string?>!*/;
        o = (b ? z2 : x2)/*T:IOut<object!, string>!*/;
        o = (b ? z2 : y2)/*T:IOut<object?, string?>!*/;
        o = (b ? z2 : z2)/*T:IOut<object, string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,14): warning CS8626: No best nullability for operands of conditional expression 'IIn<object, string>' and 'IIn<object?, string?>'.
                //         o = (b ? x1 : y1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? x1 : y1").WithArguments("IIn<object, string>", "IIn<object?, string?>").WithLocation(11, 14),
                // (11,23): warning CS8619: Nullability of reference types in value of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>'.
                //         o = (b ? x1 : y1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>").WithLocation(11, 23),
                // (13,14): warning CS8626: No best nullability for operands of conditional expression 'IIn<object?, string?>' and 'IIn<object, string>'.
                //         o = (b ? y1 : x1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? y1 : x1").WithArguments("IIn<object?, string?>", "IIn<object, string>").WithLocation(13, 14),
                // (13,18): warning CS8619: Nullability of reference types in value of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>'.
                //         o = (b ? y1 : x1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>").WithLocation(13, 18),
                // (26,14): warning CS8626: No best nullability for operands of conditional expression 'IOut<object, string>' and 'IOut<object?, string?>'.
                //         o = (b ? x2 : y2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? x2 : y2").WithArguments("IOut<object, string>", "IOut<object?, string?>").WithLocation(26, 14),
                // (26,18): warning CS8619: Nullability of reference types in value of type 'IOut<object, string>' doesn't match target type 'IOut<object, string?>'.
                //         o = (b ? x2 : y2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IOut<object, string>", "IOut<object, string?>").WithLocation(26, 18),
                // (28,14): warning CS8626: No best nullability for operands of conditional expression 'IOut<object?, string?>' and 'IOut<object, string>'.
                //         o = (b ? y2 : x2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? y2 : x2").WithArguments("IOut<object?, string?>", "IOut<object, string>").WithLocation(28, 14),
                // (28,23): warning CS8619: Nullability of reference types in value of type 'IOut<object, string>' doesn't match target type 'IOut<object, string?>'.
                //         o = (b ? y2 : x2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IOut<object, string>", "IOut<object, string?>").WithLocation(28, 23));
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void ConditionalOperator_TopLevelNullability_Ref()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(bool b, object? x, object y)
    {
        var z = A.F/*T:object*/;
        ref var xx = ref b ? ref x : ref x;
        ref var xy = ref b ? ref x : ref y;
        ref var xz = ref b ? ref x : ref z;
        ref var yx = ref b ? ref y : ref x;
        ref var yy = ref b ? ref y : ref y;
        ref var yz = ref b ? ref y : ref z;
        ref var zx = ref b ? ref z : ref x;
        ref var zy = ref b ? ref z : ref y;
        ref var zz = ref b ? ref z : ref z;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `object?` and `object!`.
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void ConditionalOperator_NestedNullability_Ref()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(bool b, I<object> x1, I<object?> y1)
    {
        var z1 = CreateI(A.F)/*T:I<object>!*/;
        ref var xx = ref b ? ref x1 : ref x1;
        ref var xy = ref b ? ref x1 : ref y1;
        ref var xz = ref b ? ref x1 : ref z1;
        ref var yx = ref b ? ref y1 : ref x1;
        ref var yy = ref b ? ref y1 : ref y1;
        ref var yz = ref b ? ref y1 : ref z1;
        ref var zx = ref b ? ref z1 : ref x1;
        ref var zy = ref b ? ref z1 : ref y1;
        ref var zz = ref b ? ref z1 : ref z1;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(bool b, IIn<object> x2, IIn<object?> y2)
    {
        var z2 = CreateIIn(A.F)/*T:IIn<object>!*/;
        ref var xx = ref b ? ref x2 : ref x2;
        ref var xy = ref b ? ref x2 : ref y2;
        ref var xz = ref b ? ref x2 : ref z2;
        ref var yx = ref b ? ref y2 : ref x2;
        ref var yy = ref b ? ref y2 : ref y2;
        ref var yz = ref b ? ref y2 : ref z2;
        ref var zx = ref b ? ref z2 : ref x2;
        ref var zy = ref b ? ref z2 : ref y2;
        ref var zz = ref b ? ref z2 : ref z2;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(bool b, IOut<object> x3, IOut<object?> y3)
    {
        var z3 = CreateIOut(A.F)/*T:IOut<object>!*/;
        ref var xx = ref b ? ref x3 : ref x3;
        ref var xy = ref b ? ref x3 : ref y3;
        ref var xz = ref b ? ref x3 : ref z3;
        ref var yx = ref b ? ref y3 : ref x3;
        ref var yy = ref b ? ref y3 : ref y3;
        ref var yz = ref b ? ref y3 : ref z3;
        ref var zx = ref b ? ref z3 : ref x3;
        ref var zy = ref b ? ref z3 : ref y3;
        ref var zz = ref b ? ref z3 : ref z3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `IIn<object?>` and `IIn<object!>`
            // and combinations of  `IOut<object?>` and `IOut<object!>`.
            comp.VerifyDiagnostics(
                // (11,26): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         ref var xy = ref b ? ref x1 : ref y1;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? ref x1 : ref y1").WithArguments("I<object>", "I<object?>").WithLocation(11, 26),
                // (13,26): warning CS8626: No best nullability for operands of conditional expression 'I<object?>' and 'I<object>'.
                //         ref var yx = ref b ? ref y1 : ref x1;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "b ? ref y1 : ref x1").WithArguments("I<object?>", "I<object>").WithLocation(13, 26));
            comp.VerifyTypes();
        }

        [Fact]
        public void IdentityConversion_ConditionalOperator()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(bool c, I<object> x, I<object?> y)
    {
        I<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y;
        I<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
    static void F(bool c, IIn<object> x, IIn<object?> y)
    {
        IIn<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y;
        IIn<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
    static void F(bool c, IOut<object> x, IOut<object?> y)
    {
        IOut<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y;
        IOut<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         a = c ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(9, 13),
                // (10,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         a = false ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "false ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(10, 13),
                // (11,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         a = true ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "true ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(11, 13),
                // (13,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         b = c ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(13, 13),
                // (14,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         b = false ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "false ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(14, 13),
                // (15,13): warning CS8626: No best nullability for operands of conditional expression 'I<object>' and 'I<object?>'.
                //         b = true ? x : y;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "true ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(15, 13),
                // (24,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(24, 13),
                // (25,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "false ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(25, 13),
                // (26,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = true ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "true ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(26, 13),
                // (31,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(31, 13),
                // (32,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "false ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(32, 13),
                // (33,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = true ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "true ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(33, 13));
        }

        [Fact]
        public void NullCoalescingOperator_01()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        var z = x ?? y;
        z.ToString();
        if (y == null) return;
        var w = x ?? y;
        w.ToString();
        var v = null ?? x;
        v.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(6, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         v.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v").WithLocation(11, 9));
        }

        [Fact]
        public void NullCoalescingOperator_02()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        (x ?? y).ToString();
        if (y != null) (x ?? y).ToString();
        if (y != null) (y ?? x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x ?? y").WithLocation(5, 10),
                // (7,25): hidden CS8607: Expression is probably never null.
                //         if (y != null) (y ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(7, 25));
        }

        [Fact]
        public void NullCoalescingOperator_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (null ?? null).ToString();
        (null ?? x).ToString();
        (null ?? y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type '<null>' and '<null>'
                //         (null ?? null).ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "null ?? null").WithArguments("??", "<null>", "<null>").WithLocation(5, 10),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (null ?? null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "null ?? null").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (null ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "null ?? y").WithLocation(7, 10));
        }

        [Fact]
        public void NullCoalescingOperator_04()
        {
            var source =
@"class C
{
    static void F(string x, string? y)
    {
        ("""" ?? x).ToString();
        ("""" ?? y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): hidden CS8607: Expression is probably never null.
                //         ("" ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"""""").WithLocation(5, 10),
                // (6,10): hidden CS8607: Expression is probably never null.
                //         ("" ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"""""").WithLocation(6, 10));
        }

        [Fact]
        public void NullCoalescingOperator_05()
        {
            var source0 =
@"public class A { }
public class B { }
public class UnknownNull
{
    public A A;
    public B B;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"public class MaybeNull
{
    public A? A;
    public B? B;
}
public class NotNull
{
    public A A = new A();
    public B B = new B();
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        (x1.A ?? y1.B)/*T:*/.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        (x2.A ?? y2.B)/*T:?*/.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        (x3.A ?? y3.B)/*T:*/.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        (x4.A ?? y4.B)/*T:?*/.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        (x5.A ?? y5.B)/*T:!*/.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        (x6.A ?? y6.B)/*T:!*/.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        (x7.A ?? y7.B)/*T:!*/.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        (x8.A ?? y8.B)/*T:!*/.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        (x9.A ?? y9.B)/*T:!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x1.A ?? y1.B)/*T:*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x1.A ?? y1.B").WithArguments("??", "A", "B").WithLocation(5, 10),
                // (9,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x2.A ?? y2.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x2.A ?? y2.B").WithArguments("??", "A", "B").WithLocation(9, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (x2.A ?? y2.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2.A ?? y2.B").WithLocation(9, 10),
                // (13,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x3.A ?? y3.B)/*T:*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x3.A ?? y3.B").WithArguments("??", "A", "B").WithLocation(13, 10),
                // (17,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x4.A ?? y4.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x4.A ?? y4.B").WithArguments("??", "A", "B").WithLocation(17, 10),
                // (17,10): warning CS8602: Possible dereference of a null reference.
                //         (x4.A ?? y4.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4.A ?? y4.B").WithLocation(17, 10),
                // (21,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x5.A ?? y5.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x5.A ?? y5.B").WithArguments("??", "A", "B").WithLocation(21, 10),
                // (25,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x6.A ?? y6.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x6.A ?? y6.B").WithArguments("??", "A", "B").WithLocation(25, 10),
                // (25,10): hidden CS8607: Expression is probably never null.
                //         (x6.A ?? y6.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6.A").WithLocation(25, 10),
                // (29,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x7.A ?? y7.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x7.A ?? y7.B").WithArguments("??", "A", "B").WithLocation(29, 10),
                // (33,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x8.A ?? y8.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x8.A ?? y8.B").WithArguments("??", "A", "B").WithLocation(33, 10),
                // (33,10): hidden CS8607: Expression is probably never null.
                //         (x8.A ?? y8.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8.A").WithLocation(33, 10),
                // (37,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x9.A ?? y9.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x9.A ?? y9.B").WithArguments("??", "A", "B").WithLocation(37, 10),
                // (37,10): hidden CS8607: Expression is probably never null.
                //         (x9.A ?? y9.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x9.A").WithLocation(37, 10));
        }

        [Fact]
        public void NullCoalescingOperator_06()
        {
            var source =
@"class C
{
    static void F1(C x1, Unknown? y1)
    {
        (x1 ?? y1)/*T:!*/.ToString();
        (y1 ?? x1)/*T:!*/.ToString();
        (null ?? y1)/*T:Unknown?*/.ToString();
        (y1 ?? null)/*T:Unknown?*/.ToString();
    }
    static void F2(C? x2, Unknown y2)
    {
        (x2 ?? y2)/*T:!*/.ToString();
        (y2 ?? x2)/*T:!*/.ToString();
        (null ?? y2)/*T:!*/.ToString();
        (y2 ?? null)/*T:!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            // Note: Unknown type is treated as a value type
            comp.VerifyDiagnostics(
                // (3,26): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(C x1, Unknown? y1)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 26),
                // (10,27): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(C? x2, Unknown y2)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(10, 27),
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type 'C' and 'Unknown?'
                //         (x1 ?? y1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x1 ?? y1").WithArguments("??", "C", "Unknown?").WithLocation(5, 10),
                // (6,10): error CS0019: Operator '??' cannot be applied to operands of type 'Unknown?' and 'C'
                //         (y1 ?? x1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "y1 ?? x1").WithArguments("??", "Unknown?", "C").WithLocation(6, 10),
                // (5,10): hidden CS8607: Expression is probably never null.
                //         (x1 ?? y1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(5, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (y1 ?? null)/*T:Unknown?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1 ?? null").WithLocation(8, 10),
                // (13,10): hidden CS8607: Expression is probably never null.
                //         (y2 ?? x2)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(13, 10),
                // (15,10): hidden CS8607: Expression is probably never null.
                //         (y2 ?? null)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(15, 10));
        }

        [Fact]
        public void NullCoalescingOperator_07()
        {
            var source =
@"class C
{
    static void F(object? o, object[]? a, object?[]? b)
    {
        if (o == null)
        {
            var c = new[] { o };
            (a ?? c)[0].ToString();
            (b ?? c)[0].ToString();
        }
        else
        {
            var c = new[] { o };
            (a ?? c)[0].ToString();
            (b ?? c)[0].ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             (a ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(a ?? c)[0]").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             (b ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ?? c)[0]").WithLocation(9, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             (b ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ?? c)[0]").WithLocation(15, 13));
        }

        [Fact]
        public void NullCoalescingOperator_08()
        {
            var source =
@"interface I<T> { }
class C
{
    static object? F((I<object>, I<object?>)? x, (I<object?>, I<object>)? y)
    {
        return x ?? y;
    }
    static object F((I<object>, I<object?>)? x, (I<object?>, I<object>) y)
    {
        return x ?? y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,21): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object>)?' doesn't match target type '(I<object>, I<object?>)?'.
                //         return x ?? y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("(I<object?>, I<object>)?", "(I<object>, I<object?>)?").WithLocation(6, 21),
                // (10,21): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object>)' doesn't match target type '(I<object>, I<object?>)'.
                //         return x ?? y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("(I<object?>, I<object>)", "(I<object>, I<object?>)").WithLocation(10, 21));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F1(I<object>? x1, I<object?> y1)
    {
        I<object> z1 = x1 ?? y1;
        I<object?> w1 = y1 ?? x1;
    }
    static void F2(IIn<object>? x2, IIn<object?> y2)
    {
        IIn<object> z2 = x2 ?? y2;
        IIn<object?> w2 = y2 ?? x2;
    }
    static void F3(IOut<object>? x3, IOut<object?> y3)
    {
        IOut<object> z3 = x3 ?? y3;
        IOut<object?> w3 = y3 ?? x3;
    }
    static void F4(IIn<object>? x4, IIn<object> y4)
    {
        IIn<object> z4;
        z4 = ((IIn<object?>)x4) ?? y4;
        z4 = x4 ?? (IIn<object?>)y4;
    }
    static void F5(IIn<object?>? x5, IIn<object?> y5)
    {
        IIn<object> z5;
        z5 = ((IIn<object>)x5) ?? y5;
        z5 = x5 ?? (IIn<object>)y5;
    }
    static void F6(IOut<object?>? x6, IOut<object?> y6)
    {
        IOut<object?> z6;
        z6 = ((IOut<object>)x6) ?? y6;
        z6 = x6 ?? (IOut<object>)y6;
    }
    static void F7(IOut<object>? x7, IOut<object> y7)
    {
        IOut<object?> z7;
        z7 = ((IOut<object?>)x7) ?? y7;
        z7 = x7 ?? (IOut<object?>)y7;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,30): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         I<object> z1 = x1 ?? y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("I<object?>", "I<object>").WithLocation(8, 30),
                // (9,25): hidden CS8607: Expression is probably never null.
                //         I<object?> w1 = y1 ?? x1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(9, 25),
                // (9,31): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         I<object?> w1 = y1 ?? x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(9, 31),
                // (14,27): hidden CS8607: Expression is probably never null.
                //         IIn<object?> w2 = y2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(14, 27),
                // (14,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> w2 = y2 ?? x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2 ?? x2").WithArguments("IIn<object>", "IIn<object?>").WithLocation(14, 27),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> z3 = x3 ?? y3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3 ?? y3").WithArguments("IOut<object?>", "IOut<object>").WithLocation(18, 27),
                // (19,28): hidden CS8607: Expression is probably never null.
                //         IOut<object?> w3 = y3 ?? x3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y3").WithLocation(19, 28),
                // (24,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z4 = ((IIn<object?>)x4) ?? y4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IIn<object?>)x4").WithLocation(24, 15),
                // (30,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z5 = ((IIn<object>)x5) ?? y5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IIn<object>)x5").WithLocation(30, 15),
                // (36,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z6 = ((IOut<object>)x6) ?? y6;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IOut<object>)x6").WithLocation(36, 15),
                // (42,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z7 = ((IOut<object?>)x7) ?? y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IOut<object?>)x7").WithLocation(42, 15));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_02()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static IIn<T>? FIn<T>(T x)
    {
        return null;
    }
    static IOut<T>? FOut<T>(T x)
    {
        return null;
    }
    static void FIn(IIn<object?>? x)
    {
    }
    static T FOut<T>(IOut<T>? x)
    {
        throw new System.Exception();
    }
    static void F1(IIn<object>? x1, IIn<object?>? y1)
    {
        FIn((x1 ?? y1)/*T:IIn<object!>?*/);
        FIn((y1 ?? x1)/*T:IIn<object!>?*/);
    }
    static void F2(IOut<object>? x2, IOut<object?>? y2)
    {
        FOut((x2 ?? y2)/*T:IOut<object?>?*/).ToString();
        FOut((y2 ?? x2)/*T:IOut<object?>?*/).ToString();
    }
    static void F3(object? x3, object? y3)
    {
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object?>?*/); // A
        if (x3 == null) return;
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // B
        FIn((FIn(y3) ?? FIn(x3))/*T:IIn<object!>?*/); // C
        if (y3 == null) return;
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // D
    }
    static void F4(object? x4, object? y4)
    {
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // A
        if (x4 == null) return;
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // B
        FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/).ToString(); // C
        if (y4 == null) return;
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object!>?*/).ToString(); // D
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (22,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((x1 ?? y1)/*T:IIn<object!>?*/);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1 ?? y1").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(22, 14),
                // (23,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((y1 ?? x1)/*T:IIn<object!>?*/);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1 ?? x1").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(23, 14),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((x2 ?? y2)/*T:IOut<object?>?*/).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((x2 ?? y2)/*T:IOut<object?>?*/)").WithLocation(27, 9),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((y2 ?? x2)/*T:IOut<object?>?*/).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((y2 ?? x2)/*T:IOut<object?>?*/)").WithLocation(28, 9),
                // (34,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // B
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(x3) ?? FIn(y3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(34, 14),
                // (35,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(y3) ?? FIn(x3))/*T:IIn<object!>?*/); // C
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(y3) ?? FIn(x3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(35, 14),
                // (37,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // D
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(x3) ?? FIn(y3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(37, 14),
                // (41,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // A
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/)").WithLocation(41, 9),
                // (43,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // B
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/)").WithLocation(43, 9),
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/).ToString(); // C
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/)").WithLocation(44, 9));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_03()
        {
            var source =
@"class C
{
    static void F((object?, object?)? x, (object, object) y)
    {
        (x ?? y).Item1.ToString();
    }
    static void G((object, object)? x, (object?, object?) y)
    {
        (x ?? y).Item1.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x ?? y).Item1").WithLocation(5, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x ?? y).Item1").WithLocation(9, 9));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_04()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => default;
}
struct B<T>
{
    internal T F;
}
class C
{
    static void F1(A<object>? x1, B<object?> y1)
    {
        (x1 ?? y1)/*T:B<object?>*/.F.ToString();
    }
    static void F2(A<object?>? x2, B<object> y2)
    {
        (x2 ?? y2)/*T:B<object!>*/.F.ToString();
    }
    static void F3(A<object> x3, B<object?>? y3)
    {
        (y3 ?? x3)/*T:B<object?>*/.F.ToString();
    }
    static void F4(A<object?> x4, B<object>? y4)
    {
        (y4 ?? x4)/*T:B<object!>*/.F.ToString();
    }
    static void F5(A<object>? x5, B<object?>? y5)
    {
        (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
        (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
    }
    static void F6(A<object?>? x6, B<object>? y6)
    {
        (x6 ?? y6)/*T:B<object!>?*/.Value.F.ToString();
        (y6 ?? x6)/*T:B<object!>?*/.Value.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x1 ?? y1)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("A<object>", "B<object?>").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (x1 ?? y1)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x1 ?? y1)/*T:B<object?>*/.F").WithLocation(14, 9),
                // (18,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x2 ?? y2)/*T:B<object!>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("A<object?>", "B<object>").WithLocation(18, 10),
                // (22,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y3 ?? x3)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "B<object?>").WithLocation(22, 16),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (y3 ?? x3)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y3 ?? x3)/*T:B<object?>*/.F").WithLocation(22, 9),
                // (26,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y4 ?? x4)/*T:B<object!>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x4").WithArguments("B<object?>", "B<object>").WithLocation(26, 16),
                // (30,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>?'.
                //         (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("A<object>", "B<object?>?").WithLocation(30, 10),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x5 ?? y5)/*T:B<object?>?*/.Value.F").WithLocation(30, 9),
                // (31,16): warning CS8619: Nullability of reference types in value of type 'B<object>?' doesn't match target type 'B<object?>?'.
                //         (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("B<object>?", "B<object?>?").WithLocation(31, 16),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y5 ?? x5)/*T:B<object?>?*/.Value.F").WithLocation(31, 9),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>?'.
                //         (x6 ?? y6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("A<object?>", "B<object>?").WithLocation(35, 10),
                // (36,16): warning CS8619: Nullability of reference types in value of type 'B<object?>?' doesn't match target type 'B<object>?'.
                //         (y6 ?? x6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("B<object?>?", "B<object>?").WithLocation(36, 16));
        }

        // https://github.com/dotnet/roslyn/issues/29871: Conversions: Conversion
        // (VisitConversion ignores nullability of operand in conversion from A<T> to B<T>.)
        [Fact]
        [WorkItem(29871, "https://github.com/dotnet/roslyn/issues/29871")]
        public void IdentityConversion_NullCoalescingOperator_05()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => new B<T>();
}
class B<T>
{
    internal T F;
}
class C
{
    static void F1(A<object>? x1, B<object?> y1)
    {
        (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
    }
    static void F2(A<object?>? x2, B<object> y2)
    {
        (x2 ?? y2)/*T:B<object!>!*/.F.ToString();
    }
    static void F3(A<object> x3, B<object?>? y3)
    {
        (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
    }
    static void F4(A<object?> x4, B<object>? y4)
    {
        (y4 ?? x4)/*T:B<object!>!*/.F.ToString();
    }
    static void F5(A<object>? x5, B<object?>? y5)
    {
        (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
        (y5 ?? x5)/*T:B<object?>!*/.F.ToString();
    }
    static void F6(A<object?>? x6, B<object>? y6)
    {
        (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
        (y6 ?? x6)/*T:B<object!>!*/.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (6,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class B<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "B").WithArguments("field", "F").WithLocation(6, 7),
                // (14,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("A<object>", "B<object?>").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x1 ?? y1)/*T:B<object?>!*/.F").WithLocation(14, 9),
                // (18,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x2 ?? y2)/*T:B<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("A<object?>", "B<object>").WithLocation(18, 10),
                // (22,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "B<object?>").WithLocation(22, 16),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y3 ?? x3)/*T:B<object?>!*/.F").WithLocation(22, 9),
                // (26,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y4 ?? x4)/*T:B<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x4").WithArguments("B<object?>", "B<object>").WithLocation(26, 16),
                // (30,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("A<object>", "B<object?>").WithLocation(30, 10),
                // (30,10): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x5 ?? y5").WithLocation(30, 10),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x5 ?? y5)/*T:B<object?>?*/.F").WithLocation(30, 9),
                // (31,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y5 ?? x5)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("B<object>", "B<object?>").WithLocation(31, 16),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (y5 ?? x5)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y5 ?? x5)/*T:B<object?>!*/.F").WithLocation(31, 9),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("A<object?>", "B<object>").WithLocation(35, 10),
                // (35,10): warning CS8602: Possible dereference of a null reference.
                //         (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x6 ?? y6").WithLocation(35, 10),
                // (36,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y6 ?? x6)/*T:B<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("B<object?>", "B<object>").WithLocation(36, 16));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_06()
        {
            var source =
@"class C
{
    static void F1(object? x, dynamic? y, dynamic z)
    {
        (x ?? y).ToString();
        (x ?? z).ToString(); // ok
        (y ?? x).ToString();
        (y ?? z).ToString(); // ok
        (z ?? x).ToString();
        (z ?? y).ToString();
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x ?? y").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (y ?? x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y ?? x").WithLocation(7, 10),
                // (9,10): hidden CS8607: Expression is probably never null.
                //         (z ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(9, 10),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (z ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(10, 10));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_01()
        {
            var source0 =
@"public class UnknownNull
{
    public object Object;
    public string String;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"public class MaybeNull
{
    public object? Object;
    public string? String;
}
public class NotNull
{
    public object Object = new object();
    public string String = string.Empty;
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        (x1.Object ?? y1.String)/*T:object*/.ToString();
        (y1.String ?? x1.Object)/*T:object*/.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        (x2.Object ?? y2.String)/*T:object?*/.ToString();
        (y2.String ?? x2.Object)/*T:object*/.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        (x3.Object ?? y3.String)/*T:object*/.ToString();
        (y3.String ?? x3.Object)/*T:object?*/.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        (x4.Object ?? y4.String)/*T:object?*/.ToString();
        (y4.String ?? x4.Object)/*T:object?*/.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        (x5.Object ?? y5.String)/*T:object!*/.ToString();
        (y5.String ?? x5.Object)/*T:object!*/.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        (x6.Object ?? y6.String)/*T:object!*/.ToString();
        (y6.String ?? x6.Object)/*T:object!*/.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        (x7.Object ?? y7.String)/*T:object!*/.ToString();
        (y7.String ?? x7.Object)/*T:object!*/.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        (x8.Object ?? y8.String)/*T:object!*/.ToString();
        (y8.String ?? x8.Object)/*T:object!*/.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        (x9.Object ?? y9.String)/*T:object!*/.ToString();
        (y9.String ?? x9.Object)/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (x2.Object ?? y2.String)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2.Object ?? y2.String").WithLocation(10, 10),
                // (16,10): warning CS8602: Possible dereference of a null reference.
                //         (y3.String ?? x3.Object)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3.String ?? x3.Object").WithLocation(16, 10),
                // (20,10): warning CS8602: Possible dereference of a null reference.
                //         (x4.Object ?? y4.String)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4.Object ?? y4.String").WithLocation(20, 10),
                // (21,10): warning CS8602: Possible dereference of a null reference.
                //         (y4.String ?? x4.Object)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y4.String ?? x4.Object").WithLocation(21, 10),
                // (26,10): hidden CS8607: Expression is probably never null.
                //         (y5.String ?? x5.Object)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y5.String").WithLocation(26, 10),
                // (30,10): hidden CS8607: Expression is probably never null.
                //         (x6.Object ?? y6.String)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6.Object").WithLocation(30, 10),
                // (36,10): hidden CS8607: Expression is probably never null.
                //         (y7.String ?? x7.Object)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y7.String").WithLocation(36, 10),
                // (40,10): hidden CS8607: Expression is probably never null.
                //         (x8.Object ?? y8.String)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8.Object").WithLocation(40, 10),
                // (45,10): hidden CS8607: Expression is probably never null.
                //         (x9.Object ?? y9.String)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x9.Object").WithLocation(45, 10),
                // (46,10): hidden CS8607: Expression is probably never null.
                //         (y9.String ?? x9.Object)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y9.String").WithLocation(46, 10));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_02()
        {
            var source =
@"#pragma warning disable 0649
class A<T>
{
    internal T F;
}
class B<T> : A<T> { }
class C
{
    static void F(A<object>? x, B<object?> y)
    {
        (x ?? y).F.ToString(); // 1
        (y ?? x).F.ToString(); // 2
    }
    static void G(A<object?> z, B<object>? w)
    {
        (z ?? w).F.ToString(); // 3
        (w ?? z).F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(2, 7),
                // (11,15): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         (x ?? y).F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(11, 15),
                // (12,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x).F.ToString(); // 2
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(12, 10),
                // (12,10): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         (y ?? x).F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(12, 10),
                // (16,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(16, 10),
                // (16,15): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B<object>", "A<object?>").WithLocation(16, 15),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(z ?? w).F").WithLocation(16, 9),
                // (17,10): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         (w ?? z).F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B<object>", "A<object?>").WithLocation(17, 10),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         (w ?? z).F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(w ?? z).F").WithLocation(17, 9));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_03()
        {
            var source =
@"interface IIn<in T>
{
    void F(T x, T y);
}
class C
{
    static void F(IIn<object>? x, IIn<string?> y)
    {
        (x ?? y)/*T:IIn<string?>!*/.F(string.Empty, null);
        (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
    }
    static void G(IIn<object?> z, IIn<string>? w)
    {
        (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
        (w ?? z)/*T:IIn<string!>!*/.F(string.Empty, null);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (9,10): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         (x ?? y)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(9, 10),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(10, 10),
                // (10,15): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(10, 15),
                // (14,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(14, 10),
                // (14,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 53),
                // (15,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         (w ?? z)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 53));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_04()
        {
            var source =
@"interface IOut<out T>
{
    T P { get; }
}
class C
{
    static void F(IOut<object>? x, IOut<string?> y)
    {
        (x ?? y)/*T:IOut<object!>!*/.P.ToString();
        (y ?? x)/*T:IOut<object!>!*/.P.ToString();
    }
    static void G(IOut<object?> z, IOut<string>? w)
    {
        (z ?? w)/*T:IOut<object?>!*/.P.ToString();
        (w ?? z)/*T:IOut<object?>!*/.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (9,15): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         (x ?? y)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(9, 15),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(10, 10),
                // (10,10): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         (y ?? x)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(10, 10),
                // (14,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (z ?? w)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(z ?? w)/*T:IOut<object?>!*/.P").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         (w ?? z)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(w ?? z)/*T:IOut<object?>!*/.P").WithLocation(15, 9));
        }

        [Fact]
        public void Loop_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL1 y1, CL1? z1)
    {
        x1 = y1;
        x1.M1(); // 1

        for (int i = 0; i < 2; i++)
        {
            x1.M1(); // 2
            x1 = z1;
        }
    }

    CL1 Test2(CL1? x2, CL1 y2, CL1? z2)
    {
        x2 = y2;
        x2.M1(); // 1

        for (int i = 0; i < 2; i++)
        {
            x2 = z2;
            x2.M1(); // 2
            y2 = z2;
            y2.M2(y2);

            if (i == 1)
            {
                return x2;
            }
        }

        return y2;
    }
}

class CL1
{
    public void M1() { }
    public void M2(CL1 x) { }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             x1.M1(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(15, 13),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //             x2.M1(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(28, 13),
                // (29,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             y2 = z2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "z2").WithLocation(29, 18),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             y2.M2(y2);
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(30, 13));
        }

        [Fact]
        public void Loop_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL1 y1, CL1? z1)
    {
        x1 = y1;
        if (x1 == null) {} // 1

        for (int i = 0; i < 2; i++)
        {
            if (x1 == null) {} // 2
            x1 = z1;
        }
    }

    void Test2(CL1? x2, CL1 y2, CL1? z2)
    {
        x2 = y2;
        if (x2 == null) {} // 1

        for (int i = 0; i < 2; i++)
        {
            x2 = z2;
            if (x2 == null) {} // 2
        }
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (11,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (x1 == null) {} // 1
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x1 == null").WithLocation(11, 13),
                 // (23,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (x2 == null) {} // 1
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x2 == null").WithLocation(23, 13)
                );
        }

        [Fact]
        public void Loop_03()
        {
            var source0 =
@"public class A
{
    public object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var source1 =
@"#pragma warning disable 8618
class B
{
    object G;
    static object F1(B b1, object? o)
    {
        for (int i = 0; i < 2; i++)
        {
            b1.G = o;
        }
        return b1.G;
    }
    static object F2(B b2, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            b2.G = a.F;
        }
        return b2.G;
    }
    static object F3(B b3, object? o, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            if (i % 2 == 0)
                b3.G = o;
            else
                b3.G = a.F;
        }
        return b3.G;
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (9,20): warning CS8601: Possible null reference assignment.
                //             b1.G = o;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "o").WithLocation(9, 20),
                // (11,16): warning CS8603: Possible null reference return.
                //         return b1.G;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "b1.G").WithLocation(11, 16),
                // (26,24): warning CS8601: Possible null reference assignment.
                //                 b3.G = o;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "o").WithLocation(26, 24),
                // (30,16): warning CS8603: Possible null reference return.
                //         return b3.G;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "b3.G").WithLocation(30, 16));
        }

        [Fact]
        public void Loop_04()
        {
            var source0 =
@"public class A
{
    public object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var source1 =
@"#pragma warning disable 8618
class C
{
    static object F1(A a1, object? o)
    {
        for (int i = 0; i < 2; i++)
        {
            a1.F = o;
        }
        return a1.F;
    }
    static object F2(A a2, object o)
    {
        for (int i = 0; i < 2; i++)
        {
            a2.F = o;
        }
        return a2.F;
    }
    static object F3(A a3, object? o, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            if (i % 2 == 0)
                a3.F = o;
            else
                a3.F = a.F;
        }
        return a3.F;
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (10,16): warning CS8603: Possible null reference return.
                //         return a1.F;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "a1.F").WithLocation(10, 16),
                // (29,16): warning CS8603: Possible null reference return.
                //         return a3.F;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "a3.F").WithLocation(29, 16));
        }

        [Fact]
        public void Var_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? Test1()
    {
        var x1 = (CL1)null;
        return x1;
    }

    CL1? Test2(CL1 x2)
    {
        var y2 = x2;
        y2 = null;
        return y2;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var x1 = (CL1)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(CL1)null").WithLocation(10, 18),
                // (17,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y2 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(17, 14));
        }

        [Fact]
        public void Var_NonNull()
        {
            var source =
@"class C
{
    static void F(string str)
    {
        var s = str;
        s.ToString();
        s = null;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 13),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(false, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_NonNull_CSharp7()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = string.Empty;
        s.ToString();
        s = null;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(null, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_01()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        var t = s;
        t.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_02()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        t = null;
        var t = s;
        t.ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0841: Cannot use local variable 't' before it is declared
                //         t = null;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "t").WithArguments("t").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(7, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_03()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        if (s == null)
        {
            return;
        }
        var t = s;
        t.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            // https://github.com/dotnet/roslyn/issues/29856: Type should be `string!`.
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            // https://github.com/dotnet/roslyn/issues/29856: IsNullable should be inferred nullable state: false.
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_04()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_05()
        {
            var source =
@"class C
{
    static void F(int n, string? s)
    {
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            s = string.Empty;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_06()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            if (n % 2 == 0) s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_07()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            if (n % 2 == 0) s = string.Empty;
            else s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_FlowAnalysis_08()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        var t = s!;
        t/*T:string!*/.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 13));
            comp.VerifyTypes();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(null, symbol.Type.IsNullable);
        }

        [Fact]
        public void Var_Cycle()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = s;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,17): error CS0841: Cannot use local variable 's' before it is declared
                //         var s = s;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "s").WithArguments("s").WithLocation(5, 17));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            var type = symbol.Type;
            Assert.True(type.IsErrorType());
            Assert.Equal("var", type.ToTestDisplayString());
            Assert.Equal(null, type.IsNullable);
        }

        [Fact]
        public void Var_ConditionalOperator()
        {
            var source =
@"class C
{
    static void F(bool b, string s)
    {
        var s0 = b ? s : s;
        var s1 = b ? s : null;
        var s2 = b ? null : s;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();

            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(null, symbol.Type.IsNullable);  // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: false

            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(null, symbol.Type.IsNullable); // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: true

            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[2]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(null, symbol.Type.IsNullable); // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: true
        }

        [Fact]
        public void Var_Array_01()
        {
            var source =
@"class C
{
    static void F(string str)
    {
        var s = new[] { str };
        s[0].ToString();
        var t = new[] { str, null };
        t[0].ToString();
        var u = new[] { 1, null };
        u[0].ToString();
        var v = new[] { null, (int?)2 };
        v[0].ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,28): error CS0037: Cannot convert null to 'int' because it is a non-nullable value type
                //         var u = new[] { 1, null };
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "null").WithArguments("int").WithLocation(9, 28),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t[0]").WithLocation(8, 9));
        }

        [Fact]
        public void Var_Array_02()
        {
            var source =
@"delegate void D();
class C
{
    static void Main()
    {
        var a = new[] { new D(Main), () => { } };
        a[0].ToString();
        var b = new[] { new D(Main), null };
        b[0].ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(9, 9));
        }

        [Fact]
        public void Array_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? [] x1)
    {
        CL1? y1 = x1[0];
        CL1 z1 = x1[0];
    }

    void Test2(CL1 [] x2, CL1 y2, CL1? z2)
    {
        x2[0] = y2;
        x2[1] = z2;
    }

    void Test3(CL1 [] x3)
    {
        CL1? y3 = x3[0];
        CL1 z3 = x3[0];
    }

    void Test4(CL1? [] x4, CL1 y4, CL1? z4)
    {
        x4[0] = y4;
        x4[1] = z4;
    }

    void Test5(CL1 y5, CL1? z5)
    {
        var x5 = new CL1 [] { y5, z5 };
    }

    void Test6(CL1 y6, CL1? z6)
    {
        var x6 = new CL1 [,] { {y6}, {z6} };
    }

    void Test7(CL1 y7, CL1? z7)
    {
        var u7 = new CL1? [] { y7, z7 };
        var v7 = new CL1? [,] { {y7}, {z7} };
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z1 = x1[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[0]").WithLocation(11, 18),
                // (17,17): warning CS8601: Possible null reference assignment.
                //         x2[1] = z2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z2").WithLocation(17, 17),
                // (34,35): warning CS8601: Possible null reference assignment.
                //         var x5 = new CL1 [] { y5, z5 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z5").WithLocation(34, 35),
                // (39,39): warning CS8601: Possible null reference assignment.
                //         var x6 = new CL1 [,] { {y6}, {z6} };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z6").WithLocation(39, 39)
                );
        }

        [Fact]
        public void Array_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 y1, CL1? z1)
    {
        CL1? [] u1 = new [] { y1, z1 };
        CL1? [,] v1 = new [,] { {y1}, {z1} };
    }

    void Test2(CL1 y2, CL1? z2)
    {
        var u2 = new [] { y2, z2 };
        var v2 = new [,] { {y2}, {z2} };

        u2[0] = z2;
        v2[0,0] = z2;
    }

    void Test3(CL1 y3, CL1? z3)
    {
        CL1? [] u3;
        CL1? [,] v3;

        u3 = new [] { y3, z3 };
        v3 = new [,] { {y3}, {z3} };
    }

    void Test4(CL1 y4, CL1? z4)
    {
        var u4 = new [] { y4 };
        var v4 = new [,] {{y4}};

        u4[0] = z4;
        v4[0,0] = z4;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (37,17): warning CS8601: Possible null reference assignment.
                //         u4[0] = z4;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z4").WithLocation(37, 17),
                // (38,19): warning CS8601: Possible null reference assignment.
                //         v4[0,0] = z4;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z4").WithLocation(38, 19)
                );
        }

        [Fact]
        public void Array_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        int[]? u1 = new [] { 1, 2 };
        u1 = null;
        var z1 = u1[0];
    }

    void Test2()
    {
        int[]? u1 = new [] { 1, 2 };
        u1 = null;
        var z1 = u1?[u1[0]];
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,18): warning CS8602: Possible dereference of a null reference.
                //         var z1 = u1[0];
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void Array_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 y1, CL1? z1)
    {
        CL1 [] u1;
        CL1 [,] v1;

        u1 = new [] { y1, z1 };
        v1 = new [,] { {y1}, {z1} };
    }

    void Test3(CL1 y2, CL1? z2)
    {
        CL1 [] u2;
        CL1 [,] v2;

        var a2 = new [] { y2, z2 };
        var b2 = new [,] { {y2}, {z2} };

        u2 = a2;
        v2 = b2;
    }

    void Test8(CL1 y8, CL1? z8)
    {
        CL1 [] x8 = new [] { y8, z8 };
    }

    void Test9(CL1 y9, CL1? z9)
    {
        CL1 [,] x9 = new [,] { {y9}, {z9} };
    }

    void Test11(CL1 y11, CL1? z11)
    {
        CL1? [] u11;
        CL1? [,] v11;

        u11 = new [] { y11, z11 };
        v11 = new [,] { {y11}, {z11} };
    }

    void Test13(CL1 y12, CL1? z12)
    {
        CL1? [] u12;
        CL1? [,] v12;

        var a12 = new [] { y12, z12 };
        var b12 = new [,] { {y12}, {z12} };

        u12 = a12;
        v12 = b12;
    }

    void Test18(CL1 y18, CL1? z18)
    {
        CL1? [] x18 = new [] { y18, z18 };
    }

    void Test19(CL1 y19, CL1? z19)
    {
        CL1? [,] x19 = new [,] { {y19}, {z19} };
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,14): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         u1 = new [] { y1, z1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { y1, z1 }").WithArguments("CL1?[]", "CL1[]").WithLocation(13, 14),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         v1 = new [,] { {y1}, {z1} };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [,] { {y1}, {z1} }").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(14, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         u2 = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("CL1?[]", "CL1[]").WithLocation(25, 14),
                // (26,14): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         v2 = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(26, 14),
                // (31,21): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         CL1 [] x8 = new [] { y8, z8 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { y8, z8 }").WithArguments("CL1?[]", "CL1[]").WithLocation(31, 21),
                // (36,22): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         CL1 [,] x9 = new [,] { {y9}, {z9} };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [,] { {y9}, {z9} }").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(36, 22)
                );
        }

        [Fact]
        public void Array_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        int[]? u1 = new [] { 1, 2 };
        var z1 = u1.Length;
    }

    void Test2()
    {
        int[]? u2 = new [] { 1, 2 };
        u2 = null;
        var z2 = u2.Length;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (18,18): warning CS8602: Possible dereference of a null reference.
                //         var z2 = u2.Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u2").WithLocation(18, 18)
                );
        }

        [Fact]
        public void Array_06()
        {
            CSharpCompilation c = CreateCompilation(@"
class C
{
    static void Main()
    {
    }

    object Test1()
    {
        object []? u1 = null;
        return u1;
    }
    object Test2()
    {
        object [][]? u2 = null;
        return u2;
    }
    object Test3()
    {
        object []?[]? u3 = null;
        return u3;
    }
}
", parseOptions: TestOptions.Regular7);

            c.VerifyDiagnostics(
                // (10,18): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         object []? u1 = null;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(10, 18),
                // (15,20): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         object [][]? u2 = null;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(15, 20),
                // (20,18): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         object []?[]? u3 = null;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(20, 18),
                // (20,21): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         object []?[]? u3 = null;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(20, 21)
                );
        }

        [Fact]
        public void Array_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        object? [] u1 = new [] { null, new object() };
        u1 = null;
    }

    void Test2()
    {
        object [] u2 = new [] { null, new object() };
    }

    void Test3()
    {
        var u3 = new object [] { null, new object() };
    }

    object? Test4()
    {
        object []? u4 = null;
        return u4;
    }

    object Test5()
    {
        object? [] u5 = null;
        return u5;
    }

    void Test6()
    {
        object [][,]? u6 = null;
        u6[0] = null;
        u6[0][0,0] = null;
        u6[0][0,0].ToString();
    }

    void Test7()
    {
        object [][,] u7 = null;
        u7[0] = null;
        u7[0][0,0] = null;
    }

    void Test8()
    {
        object []?[,] u8 = null;
        u8[0] = null;
        u8[0][0,0] = null;
        u8[0][0,0].ToString();
    }

    void Test9()
    {
        object []?[,]? u9 = null;
        u9[0] = null;
        u9[0][0,0] = null;
        u9[0][0,0].ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u1 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (16,24): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         object [] u2 = new [] { null, new object() };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { null, new object() }").WithArguments("object?[]", "object[]").WithLocation(16, 24),
                // (21,34): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var u3 = new object [] { null, new object() };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 34),
                // (32,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object? [] u5 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(32, 25),
                // (33,16): warning CS8603: Possible null reference return.
                //         return u5;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u5").WithLocation(33, 16),
                // (38,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object [][,]? u6 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(38, 28),
                // (39,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6").WithLocation(39, 9),
                // (40,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(40, 9),
                // (40,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(40, 22),
                // (41,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(41, 9),
                // (46,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object [][,] u7 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(46, 27),
                // (47,9): warning CS8602: Possible dereference of a null reference.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u7").WithLocation(47, 9),
                // (47,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 17),
                // (48,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 22),
                // (54,9): warning CS8602: Possible dereference of a null reference.
                //         u8[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u8").WithLocation(54, 9),
                // (54,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 17),
                // (55,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(55, 22),
                // (62,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9").WithLocation(62, 9),
                // (63,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(63, 9),
                // (63,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(63, 22),
                // (64,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(64, 9)
                );
        }

        [Fact]
        public void Array_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test3()
    {
        var u3 = new object? [] { null };
    }

    void Test6()
    {
        var u6 = new object [][,]? {null, 
                                    new object[,]? {{null}}};
        u6[0] = null;
        u6[0][0,0] = null;
        u6[0][0,0].ToString();
    }

    void Test7()
    {
        var u7 = new object [][,] {null, 
                                   new object[,] {{null}}};
        u7[0] = null;
        u7[0][0,0] = null;
    }

    void Test8()
    {
        var u8 = new object []?[,] {null, 
                                    new object[,] {{null}}};
        u8[0] = null;
        u8[0][0,0] = null;
        u8[0][0,0].ToString();
    }

    void Test9()
    {
        var u9 = new object []?[,]? {null, 
                                     new object[,]? {{null}}};
        u9[0] = null;
        u9[0][0,0] = null;
        u9[0][0,0].ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (16,54): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                     new object[,]? {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(16, 54),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(18, 9),
                // (18,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(18, 22),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(19, 9),
                // (25,52): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                    new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(25, 52),
                // (24,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var u7 = new object [][,] {null, 
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(24, 36),
                // (26,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(26, 17),
                // (27,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(27, 22),
                // (33,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                     new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(33, 53),
                // (32,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var u8 = new object []?[,] {null, 
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(32, 37),
                // (34,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(34, 17),
                // (35,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(35, 22),
                // (42,55): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                      new object[,]? {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(42, 55),
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(44, 9),
                // (44,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(44, 22),
                // (45,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(45, 9)
                );
        }

        [Fact]
        public void Array_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0<string?> x1, CL0<string> y1)
    {
        var u1 = new [] { x1, y1 };
        var a1 = new [] { y1, x1 };
        var v1 = new CL0<string?>[] { x1, y1 };
        var w1 = new CL0<string>[] { x1, y1 };
    }
}

class CL0<T>
{}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var u1 = new [] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new [] { x1, y1 }").WithLocation(10, 18),
                // (11,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var a1 = new [] { y1, x1 };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new [] { y1, x1 }").WithLocation(11, 18),
                // (12,43): warning CS8619: Nullability of reference types in value of type 'CL0<string>' doesn't match target type 'CL0<string?>'.
                //         var v1 = new CL0<string?>[] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("CL0<string>", "CL0<string?>").WithLocation(12, 43),
                // (13,38): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         var w1 = new CL0<string>[] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(13, 38)
                );
        }

        [Fact]
        public void Array_10()
        {
            var source =
@"class C
{
    static void F1<T>()
    {
        T[] a1;
        a1 = new T[] { default }; // 1
        a1 = new T[] { default(T) }; // 2
    }
    static void F2<T>() where T : class
    {
        T[] a2;
        a2 = new T[] { null }; // 3
        a2 = new T[] { default }; // 4
        a2 = new T[] { default(T) }; // 5
    }
    static void F3<T>() where T : struct
    {
        T[] a3;
        a3 = new T[] { default };
        a3 = new T[] { default(T) };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a1 = new T[] { default }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(6, 24),
                // (7,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a1 = new T[] { default(T) }; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(7, 24),
                // (12,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { null }; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 24),
                // (13,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { default }; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(13, 24),
                // (14,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { default(T) }; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(14, 24));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_01()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new[] { x, x };
        a.ToString();
        a[0].ToString();
        var b = new[] { x, y };
        b.ToString();
        b[0].ToString();
        var c = new[] { b };
        c[0].ToString();
        c[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c[0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0][0]").WithLocation(13, 9));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_02()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new[] { x };
        a[0].ToString();
        var b = new[] { y };
        b[0].ToString();
    }
    static void F(object[] a, object?[] b)
    {
        var c = new[] { a, b };
        c[0][0].ToString();
        var d = new[] { a, b! };
        d[0][0].ToString();
        var e = new[] { b!, a };
        e[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30376: `!` should suppress conversion warnings.
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9),
                // (12,17): warning CS8639: No best nullability found for implicitly-typed array.
                //         var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { a, b }").WithLocation(12, 17),
                // (14,17): warning CS8639: No best nullability found for implicitly-typed array.
                //         var d = new[] { a, b! };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { a, b! }").WithLocation(14, 17),
                // (16,17): warning CS8639: No best nullability found for implicitly-typed array.
                //         var e = new[] { b!, a };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { b!, a }").WithLocation(16, 17));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (new[] { x, x })[1].ToString();
        (new[] { y, x })[1].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, x })[1].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, x })[1]").WithLocation(6, 9));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_04()
        {
            var source =
@"class C
{
    static void F()
    {
        object? o = new object();
        var a = new[] { o };
        a[0].ToString();
        var b = new[] { a };
        b[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_05()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        object? o = new object();
        while (n-- > 0)
        {
            var a = new[] { o };
            a[0].ToString();
            var b = new[] { a };
            b[0][0].ToString();
            o = null;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             a[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0]").WithLocation(9, 13),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             b[0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0][0]").WithLocation(11, 13));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_06()
        {
            var source =
@"class C
{
    static void F(string s)
    {
        var a = new[] { new object(), (string)null };
        a[0].ToString();
        var b = new[] { (object)null, s };
        b[0].ToString();
        var c = new[] { s, (object)null };
        c[0].ToString();
        var d = new[] { (string)null, new object() };
        d[0].ToString();
        var e = new[] { new object(), (string)null! };
        e[0].ToString();
        var f = new[] { (object)null!, s };
        f[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,39): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var a = new[] { new object(), (string)null };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(5, 39),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0]").WithLocation(6, 9),
                // (7,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var b = new[] { (object)null, s };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(7, 25),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9),
                // (9,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var c = new[] { s, (object)null };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(9, 28),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0]").WithLocation(10, 9),
                // (11,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var d = new[] { (string)null, new object() };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(11, 25),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         d[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d[0]").WithLocation(12, 9));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Derived()
        {
            var source0 =
@"public class A
{
    public static object F;
}
public class B<T>
{
}
public class C0 : B<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C1 : B<object?> { }
class C2 : B<object> { }
class Program
{
    static B<T> CreateB<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y, C0 cz, C1 cx, C2 cy)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        object o;
        o = (new[] { x, cx })[0]/*B<object?>*/;
        o = (new[] { x, cy })[0]/*B<object>*/;
        o = (new[] { x, cz })[0]/*B<object?>*/;
        o = (new[] { y, cx })[0]/*B<object>*/;
        o = (new[] { cy, y })[0]/*B<object!>*/;
        o = (new[] { cz, y })[0]/*B<object!>*/;
        o = (new[] { cx, z })[0]/*B<object?>*/;
        o = (new[] { cy, z })[0]/*B<object!>*/;
        o = (new[] { cz, z })[0]/*B<object>*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,25): warning CS8619: Nullability of reference types in value of type 'C2' doesn't match target type 'B<object?>'.
                //         o = (new[] { x, cy })[0]/*B<object>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "cy").WithArguments("C2", "B<object?>").WithLocation(11, 25),
                // (13,25): warning CS8619: Nullability of reference types in value of type 'C1' doesn't match target type 'B<object>'.
                //         o = (new[] { y, cx })[0]/*B<object>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "cx").WithArguments("C1", "B<object>").WithLocation(13, 25));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29888, "https://github.com/dotnet/roslyn/issues/29888")]
        public void ImplicitlyTypedArrayCreation_08()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object>? a, C<object?> b)
    {
        if (a == null)
        {
            var c = new[] { a, b };
            c[0].ToString();
            var d = new[] { b, a };
            d[0].ToString();
        }
        else
        {
            var c = new[] { a, b };
            c[0].ToString();
            var d = new[] { b, a };
            d[0].ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,21): warning CS8639: No best nullability found for implicitly-typed array.
                //             var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { a, b }").WithLocation(8, 21),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0]").WithLocation(9, 13),
                // (10,21): warning CS8639: No best nullability found for implicitly-typed array.
                //             var d = new[] { b, a };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { b, a }").WithLocation(10, 21),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             d[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d[0]").WithLocation(11, 13),
                // (15,21): warning CS8639: No best nullability found for implicitly-typed array.
                //             var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { a, b }").WithLocation(15, 21),
                // (17,21): warning CS8639: No best nullability found for implicitly-typed array.
                //             var d = new[] { b, a };
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { b, a }").WithLocation(17, 21));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_09()
        {
            var source =
@"class C
{
    static void F(C x1, Unknown? y1)
    {
        var a1 = new[] { x1, y1 };
        a1[0].ToString();
        var b1 = new[] { y1, x1 };
        b1[0].ToString();
    }
    static void G(C? x2, Unknown y2)
    {
        var a2 = new[] { x2, y2 };
        a2[0].ToString();
        var b2 = new[] { y2, x2 };
        b2[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,26): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void G(C? x2, Unknown y2)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(10, 26),
                // (3,25): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(C x1, Unknown? y1)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 25),
                // (5,18): error CS0826: No best type found for implicitly-typed array
                //         var a1 = new[] { x1, y1 };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { x1, y1 }").WithLocation(5, 18),
                // (7,18): error CS0826: No best type found for implicitly-typed array
                //         var b1 = new[] { y1, x1 };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { y1, x1 }").WithLocation(7, 18));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(object? x, object y)
    {
        var z = A.F/*T:object*/;
        object? o;
        o = (new[] { x, x })[0]/*T:object?*/;
        o = (new[] { x, y })[0]/*T:object?*/;
        o = (new[] { x, z })[0]/*T:object?*/;
        o = (new[] { y, x })[0]/*T:object?*/;
        o = (new[] { y, y })[0]/*T:object!*/;
        o = (new[] { y, z })[0]/*T:object*/;
        o = (new[] { z, x })[0]/*T:object?*/;
        o = (new[] { z, y })[0]/*T:object*/;
        o = (new[] { z, z })[0]/*T:object*/;
        o = (new[] { x, y, z })[0]/*T:object?*/;
        o = (new[] { z, y, x })[0]/*T:object?*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_TopLevelNullability_02()
        {
            var source =
@"class C
{
    static void F<T, U>(T t, U u)
        where T : class?
        where U : class, T
    {
        object? o;
        o = (new[] { t, t })[0]/*T:T*/;
        o = (new[] { t, u })[0]/*T:T*/;
        o = (new[] { u, t })[0]/*T:T*/;
        o = (new[] { u, u })[0]/*T:U!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class Program
{
    static B<T> Create<T>(T t)
    {
        throw null;
    }
    static void F(bool b, B<object?> x, B<object> y)
    {
        var z = Create(A.F); // B<object~>
        object o;
        o = (new[] { x, y })[0]/*T:B<object>!*/;
        o = (new[] { x, z })[0]/*T:B<object?>!*/;
        o = (new[] { y, x })[0]/*T:B<object>!*/;
        o = (new[] { y, z })[0]/*T:B<object!>!*/;
        o = (new[] { z, x })[0]/*T:B<object?>!*/;
        o = (new[] { z, y })[0]/*T:B<object!>!*/;
        o = (new[] { x, y, z })[0]/*T:B<object>!*/;
        o = (new[] { z, y, x })[0]/*T:B<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x, y })[0]/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y }").WithLocation(12, 14),
                // (14,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y, x })[0]/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y, x }").WithLocation(14, 14),
                // (18,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x, y, z })[0]/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y, z }").WithLocation(18, 14),
                // (19,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { z, y, x })[0]/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { z, y, x }").WithLocation(19, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F(I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:I<object!>!*/;
        o = (new[] { x, y })[0]/*T:I<object>!*/;
        o = (new[] { x, z })[0]/*T:I<object!>!*/;
        o = (new[] { y, x })[0]/*T:I<object>!*/;
        o = (new[] { y, y })[0]/*T:I<object?>!*/;
        o = (new[] { y, z })[0]/*T:I<object?>!*/;
        o = (new[] { z, x })[0]/*T:I<object!>!*/;
        o = (new[] { z, y })[0]/*T:I<object?>!*/;
        o = (new[] { z, z })[0]/*T:I<object>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F(IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { x, y })[0]/*T:IIn<object!>!*/;
        o = (new[] { x, z })[0]/*T:IIn<object!>!*/;
        o = (new[] { y, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { y, y })[0]/*T:IIn<object?>!*/;
        o = (new[] { y, z })[0]/*T:IIn<object>!*/;
        o = (new[] { z, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { z, y })[0]/*T:IIn<object>!*/;
        o = (new[] { z, z })[0]/*T:IIn<object>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F(IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:IOut<object!>!*/;
        o = (new[] { x, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { x, z })[0]/*T:IOut<object>!*/;
        o = (new[] { y, x })[0]/*T:IOut<object?>!*/;
        o = (new[] { y, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { y, z })[0]/*T:IOut<object?>!*/;
        o = (new[] { z, x })[0]/*T:IOut<object>!*/;
        o = (new[] { z, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { z, z })[0]/*T:IOut<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x, y })[0]/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y }").WithLocation(12, 14),
                // (14,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y, x })[0]/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y, x }").WithLocation(14, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<IOut<T>> Create1<T>(T t) => throw null;
    static void G1(I<IOut<string?>> x1, I<IOut<string>> y1)
    {
        var z1 = Create1(A.F)/*T:I<IOut<string>!>!*/;
        object o;
        o = (new [] { x1, x1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { x1, y1 })[0]/*T:I<IOut<string>!>!*/; // 1
        o = (new [] { x1, z1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { y1, x1 })[0]/*T:I<IOut<string>!>!*/; // 2
        o = (new [] { y1, y1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { y1, z1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { z1, x1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { z1, y1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { z1, z1 })[0]/*T:I<IOut<string>!>!*/;
    }
    static IOut<IIn<T>> Create2<T>(T t) => throw null;
    static void G2(IOut<IIn<string?>> x2, IOut<IIn<string>> y2)
    {
        var z2 = Create2(A.F)/*T:IOut<IIn<string>!>!*/;
        object o;
        o = (new [] { x2, x2 })[0]/*T:IOut<IIn<string?>!>!*/;
        o = (new [] { x2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { x2, z2 })[0]/*T:IOut<IIn<string>!>!*/;
        o = (new [] { y2, x2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { y2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { y2, z2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { z2, x2 })[0]/*T:IOut<IIn<string>!>!*/;
        o = (new [] { z2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { z2, z2 })[0]/*T:IOut<IIn<string>!>!*/;
    }
    static IIn<IOut<T>> Create3<T>(T t) => throw null;
    static void G3(IIn<IOut<string?>> x3, IIn<IOut<string>> y3)
    {
        var z3 = Create3(A.F)/*T:IIn<IOut<string>!>!*/;
        object o;
        o = (new [] { x3, x3 })[0]/*T:IIn<IOut<string?>!>!*/;
        o = (new [] { x3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { x3, z3 })[0]/*T:IIn<IOut<string>!>!*/;
        o = (new [] { y3, x3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { y3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { y3, z3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { z3, x3 })[0]/*T:IIn<IOut<string>!>!*/;
        o = (new [] { z3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { z3, z3 })[0]/*T:IIn<IOut<string>!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (13,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new [] { x1, y1 })[0]/*T:I<IOut<string>>*/; // 1
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new [] { x1, y1 }").WithLocation(13, 14),
                // (15,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new [] { y1, x1 })[0]/*T:I<IOut<string>>*/; // 2
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new [] { y1, x1 }").WithLocation(15, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_03()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T>
{
    internal interface INone { }
    internal interface I<U> { }
    internal interface IIn<in U> { }
    internal interface IOut<out U> { }
}
class C
{
    static T F<T>(T x, T y) => throw null;
    static B<T>.INone CreateINone<T>(T t) => throw null;
    static void G0(B<object>.INone x0, B<object?>.INone y0)
    {
        var z0 = CreateINone(A.F1)/*T:B<object>.INone!*/;
        object o;
        o = (new[] { x0, x0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { x0, y0 })[0]/*T:B<object>.INone!*/;
        o = (new[] { x0, z0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { y0, x0 })[0]/*T:B<object>.INone!*/;
        o = (new[] { y0, y0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { y0, z0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { z0, x0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { z0, y0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { z0, z0 })[0]/*T:B<object>.INone!*/;
    }
    static B<T>.I<U> CreateI<T, U>(T t, U u) => throw null;
    static void G1(B<object>.I<string> x1, B<object?>.I<string?> y1)
    {
        var z1 = CreateI(A.F1, A.F2)/*T:B<object>.I<string>!*/;
        object o;
        o = (new[] { x1, x1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { x1, y1 })[0]/*T:B<object>.I<string>!*/;
        o = (new[] { x1, z1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { y1, x1 })[0]/*T:B<object>.I<string>!*/;
        o = (new[] { y1, y1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { y1, z1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { z1, x1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { z1, y1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { z1, z1 })[0]/*T:B<object>.I<string>!*/;
    }
    static B<T>.IIn<U> CreateIIn<T, U>(T t, U u) => throw null;
    static void G2(B<object>.IIn<string> x2, B<object?>.IIn<string?> y2)
    {
        var z2 = CreateIIn(A.F1, A.F2)/*T:B<object>.IIn<string>!*/;
        object o;
        o = (new[] { x2, x2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { x2, y2 })[0]/*T:B<object>.IIn<string!>!*/;
        o = (new[] { x2, z2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { y2, x2 })[0]/*T:B<object>.IIn<string!>!*/;
        o = (new[] { y2, y2 })[0]/*T:B<object?>.IIn<string?>!*/;
        o = (new[] { y2, z2 })[0]/*T:B<object?>.IIn<string>!*/;
        o = (new[] { z2, x2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { z2, y2 })[0]/*T:B<object?>.IIn<string>!*/;
        o = (new[] { z2, z2 })[0]/*T:B<object>.IIn<string>!*/;
    }
    static B<T>.IOut<U> CreateIOut<T, U>(T t, U u) => throw null;
    static void G3(B<object>.IOut<string> x3, B<object?>.IOut<string?> y3)
    {
        var z3 = CreateIOut(A.F1, A.F2)/*T:B<object>.IOut<string>!*/;
        object o;
        o = (new[] { x3, x3 })[0]/*T:B<object!>.IOut<string!>!*/;
        o = (new[] { x3, y3 })[0]/*T:B<object>.IOut<string?>!*/;
        o = (new[] { x3, z3 })[0]/*T:B<object!>.IOut<string>!*/;
        o = (new[] { y3, x3 })[0]/*T:B<object>.IOut<string?>!*/;
        o = (new[] { y3, y3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { y3, z3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { z3, x3 })[0]/*T:B<object!>.IOut<string>!*/;
        o = (new[] { z3, y3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { z3, z3 })[0]/*T:B<object>.IOut<string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (17,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x0, y0 })[0]/*T:B<object>.INone!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x0, y0 }").WithLocation(17, 14),
                // (19,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y0, x0 })[0]/*T:B<object>.INone!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y0, x0 }").WithLocation(19, 14),
                // (32,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x1, y1 })[0]/*T:B<object>.I<string>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x1, y1 }").WithLocation(32, 14),
                // (34,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y1, x1 })[0]/*T:B<object>.I<string>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y1, x1 }").WithLocation(34, 14),
                // (47,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x2, y2 })[0]/*T:B<object>.IIn<string!>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x2, y2 }").WithLocation(47, 14),
                // (49,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y2, x2 })[0]/*T:B<object>.IIn<string!>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y2, x2 }").WithLocation(49, 14),
                // (62,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { x3, y3 })[0]/*T:B<object>.IOut<string?>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x3, y3 }").WithLocation(62, 14),
                // (64,14): warning CS8639: No best nullability found for implicitly-typed array.
                //         o = (new[] { y3, x3 })[0]/*T:B<object>.IOut<string?>!*/;
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y3, x3 }").WithLocation(64, 14));
            comp.VerifyTypes();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_Empty()
        {
            var source =
@"class Program
{
    static void Main()
    {
        var a = new[] { };
        var b = new[] { null };
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (5,17): error CS0826: No best type found for implicitly-typed array
                //         var a = new[] { };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { }").WithLocation(5, 17),
                // (6,17): error CS0826: No best type found for implicitly-typed array
                //         var b = new[] { null };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { null }").WithLocation(6, 17));
        }

        [Fact]
        public void ExplicitlyTypedArrayCreation()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new object[] { x, y };
        a[0].ToString();
        var b = new object?[] { x, y };
        b[0].ToString();
        var c = new object[] { x, y! };
        c[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,35): warning CS8601: Possible null reference assignment.
                //         var a = new object[] { x, y };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(5, 35),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object> x, I<object?> y, I<object>? z, I<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // A1
        (new[] { x, z })[0].ToString(); // A2
        (new[] { x, w })[0].ToString(); // A3
        (new[] { y, z })[0].ToString(); // A4
        (new[] { y, w })[0].ToString(); // A5
        (new[] { w, z })[0].ToString(); // A6
    }
    static void F(IIn<object> x, IIn<object?> y, IIn<object>? z, IIn<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // B1
        (new[] { x, z })[0].ToString(); // B2
        (new[] { x, w })[0].ToString(); // B3
        (new[] { y, z })[0].ToString(); // B4
        (new[] { y, w })[0].ToString(); // B5
        (new[] { w, z })[0].ToString(); // B6
    }
    static void F(IOut<object> x, IOut<object?> y, IOut<object>? z, IOut<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // C1
        (new[] { x, z })[0].ToString(); // C2
        (new[] { x, w })[0].ToString(); // C3
        (new[] { y, z })[0].ToString(); // C4
        (new[] { y, w })[0].ToString(); // C5
        (new[] { w, z })[0].ToString(); // C6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,10): warning CS8639: No best nullability found for implicitly-typed array.
                //         (new[] { x, y })[0].ToString(); // A1
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y }").WithLocation(8, 10),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // A2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(9, 9),
                // (10,10): warning CS8639: No best nullability found for implicitly-typed array.
                //         (new[] { x, w })[0].ToString(); // A3
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, w }").WithLocation(10, 10),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // A3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(10, 9),
                // (11,10): warning CS8639: No best nullability found for implicitly-typed array.
                //         (new[] { y, z })[0].ToString(); // A4
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { y, z }").WithLocation(11, 10),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // A4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // A5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(12, 9),
                // (13,10): warning CS8639: No best nullability found for implicitly-typed array.
                //         (new[] { w, z })[0].ToString(); // A6
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { w, z }").WithLocation(13, 10),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // A6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(13, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // B2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // B3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // B4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(20, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // B5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(21, 9),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // B6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(22, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // C2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(27, 9),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // C3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(28, 9),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // C4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // C5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(30, 9),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // C6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(31, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_IsNullableNull()
        {
            var source0 =
@"#pragma warning disable 8618
public class A<T>
{
    public T F;
}
public class B : A<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(object? x, B b)
    {
        var y = b.F/*T:object*/;
        (new[] { x, x! })[0].ToString(); // 1
        (new[] { x!, x })[0].ToString(); // 2
        (new[] { x!, x! })[0].ToString();
        (new[] { y, y! })[0].ToString();
        (new[] { y!, y })[0].ToString();
        (new[] { x, y })[0].ToString(); // 3
        (new[] { x, y! })[0].ToString(); // 4
        (new[] { x!, y })[0].ToString();
        (new[] { x!, y! })[0].ToString();
    }
    static void F(A<object?> z, B w)
    {
        (new[] { z, z! })[0].F.ToString(); // 5
        (new[] { z!, z })[0].F.ToString(); // 6
        (new[] { z!, z! })[0].F.ToString(); // 7
        (new[] { w, w! })[0].F.ToString();
        (new[] { w!, w })[0].F.ToString();
        (new[] { z, w })[0].F.ToString(); // 8
        (new[] { z, w! })[0].F.ToString(); // 9
        (new[] { z!, w })[0].F.ToString(); // 10
        (new[] { z!, w! })[0].F.ToString(); // 11
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            // https://github.com/dotnet/roslyn/issues/30376: `!` should suppress conversion warnings.
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, x! })[0].ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, x! })[0]").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x!, x })[0].ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x!, x })[0]").WithLocation(7, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y })[0].ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y })[0]").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y! })[0].ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y! })[0]").WithLocation(12, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, z! })[0].F.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, z! })[0].F").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, z })[0].F.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, z })[0].F").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, z! })[0].F.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, z! })[0].F").WithLocation(20, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, w })[0].F.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, w })[0].F").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, w! })[0].F.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, w! })[0].F").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, w })[0].F.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, w })[0].F").WithLocation(25, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, w! })[0].F.ToString(); // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, w! })[0].F").WithLocation(26, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_ExplicitType()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object>? x, I<object?>? y)
    {
        I<object?>?[] a = new[] { x };
        I<object?>[] b = new[] { y };
        I<object>?[] c = new[] { y };
        I<object>[] d = new[] { x };
    }
    static void F(IIn<object>? x, IIn<object?>? y)
    {
        IIn<object?>?[] a = new[] { x };
        IIn<object?>[] b = new[] { y };
        IIn<object>?[] c = new[] { y };
        IIn<object>[] d = new[] { x };
    }
    static void F(IOut<object>? x, IOut<object?>? y)
    {
        IOut<object?>?[] a = new[] { x };
        IOut<object?>[] b = new[] { y };
        IOut<object>?[] c = new[] { y };
        IOut<object>[] d = new[] { x };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,27): warning CS8619: Nullability of reference types in value of type 'I<object>?[]' doesn't match target type 'I<object?>?[]'.
                //         I<object?>?[] a = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("I<object>?[]", "I<object?>?[]").WithLocation(8, 27),
                // (9,26): warning CS8619: Nullability of reference types in value of type 'I<object?>?[]' doesn't match target type 'I<object?>[]'.
                //         I<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("I<object?>?[]", "I<object?>[]").WithLocation(9, 26),
                // (10,26): warning CS8619: Nullability of reference types in value of type 'I<object?>?[]' doesn't match target type 'I<object>?[]'.
                //         I<object>?[] c = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("I<object?>?[]", "I<object>?[]").WithLocation(10, 26),
                // (11,25): warning CS8619: Nullability of reference types in value of type 'I<object>?[]' doesn't match target type 'I<object>[]'.
                //         I<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("I<object>?[]", "I<object>[]").WithLocation(11, 25),
                // (15,29): warning CS8619: Nullability of reference types in value of type 'IIn<object>?[]' doesn't match target type 'IIn<object?>?[]'.
                //         IIn<object?>?[] a = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IIn<object>?[]", "IIn<object?>?[]").WithLocation(15, 29),
                // (16,28): warning CS8619: Nullability of reference types in value of type 'IIn<object?>?[]' doesn't match target type 'IIn<object?>[]'.
                //         IIn<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IIn<object?>?[]", "IIn<object?>[]").WithLocation(16, 28),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>?[]' doesn't match target type 'IIn<object>[]'.
                //         IIn<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IIn<object>?[]", "IIn<object>[]").WithLocation(18, 27),
                // (23,29): warning CS8619: Nullability of reference types in value of type 'IOut<object?>?[]' doesn't match target type 'IOut<object?>[]'.
                //         IOut<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IOut<object?>?[]", "IOut<object?>[]").WithLocation(23, 29),
                // (24,29): warning CS8619: Nullability of reference types in value of type 'IOut<object?>?[]' doesn't match target type 'IOut<object>?[]'.
                //         IOut<object>?[] c = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IOut<object?>?[]", "IOut<object>?[]").WithLocation(24, 29),
                // (25,28): warning CS8619: Nullability of reference types in value of type 'IOut<object>?[]' doesn't match target type 'IOut<object>[]'.
                //         IOut<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IOut<object>?[]", "IOut<object>[]").WithLocation(25, 28));
        }

        [Fact]
        public void ImplicitConversion_ArrayInitializer_ExplicitType_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F(A<object> x, B<object?> y)
    {
        var z = new A<object>[] { x, y };
        var w = new A<object?>[] { x, y };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,38): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         var z = new A<object>[] { x, y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(7, 38),
                // (8,36): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         var w = new A<object?>[] { x, y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "A<object?>").WithLocation(8, 36));
        }

        [Fact]
        public void ImplicitConversion_ArrayInitializer_ExplicitType_02()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(IIn<object> x, IIn<object?> y)
    {
        var a = new IIn<string?>[] { x };
        var b = new IIn<string>[] { y };
    }
    static void F(IOut<string> x, IOut<string?> y)
    {
        var a = new IOut<object?>[] { x };
        var b = new IOut<object>[] { y };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,38): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         var a = new IIn<string?>[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(7, 38),
                // (13,38): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         var b = new IOut<object>[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(13, 38));
        }

        [Fact]
        public void MultipleConversions_ArrayInitializer()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F(B x, C? y)
    {
        (new[] { x, y })[0].ToString();
        (new[] { y, x })[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y })[0]").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, x })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, x })[0]").WithLocation(13, 9));
        }

        [Fact]
        public void ObjectInitializer_01()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {}

    void Test1(CL1? x1, CL1? y1)
    {
        var z1 = new CL1() { F1 = x1, F2 = y1 };
    }

    void Test2(CL1? x2, CL1? y2)
    {
        var z2 = new CL1() { P1 = x2, P2 = y2 };
    }

    void Test3(CL1 x3, CL1 y3)
    {
        var z31 = new CL1() { F1 = x3, F2 = y3 };
        var z32 = new CL1() { P1 = x3, P2 = y3 };
    }
}

class CL1
{
    public CL1 F1;
    public CL1? F2;

    public CL1 P1 {get; set;}
    public CL1? P2 {get; set;}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,35): warning CS8601: Possible null reference assignment.
                //         var z1 = new CL1() { F1 = x1, F2 = y1 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(9, 35),
                // (14,35): warning CS8601: Possible null reference assignment.
                //         var z2 = new CL1() { P1 = x2, P2 = y2 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x2").WithLocation(14, 35)
                );
        }

        [Fact]
        public void ObjectInitializer_02()
        {
            var source =
@"class C
{
    C(object o) { }
    static void F(object? x)
    {
        var y = new C(x);
        if (x != null) y = new C(x);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,23): warning CS8604: Possible null reference argument for parameter 'o' in 'C.C(object o)'.
                //         var y = new C(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "C.C(object o)").WithLocation(6, 23));
        }

        [Fact]
        public void ObjectInitializer_03()
        {
            var source =
@"class A
{
    internal B F = new B();
}
class B
{
    internal object? G;
}
class C
{
    static void Main()
    {
        var o = new A() { F = { G = new object() } };
        o.F.G.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void IdentityConversion_ObjectElementInitializerArgumentsOrder()
        {
            var source =
@"interface I<T> { }
class C
{
    static C F(I<string> x, I<object> y)
    {
        return new C() { [
            y: y, // warn 1
            x: x]
            = 1 };
    }
    static object G(C c, I<string?> x, I<object?> y)
    {
        return new C() { [
            y: y,
            x: x] // warn 2
            = 2 };
    }
    int this[I<string> x, I<object?> y]
    {
        get { return 0; }
        set { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,16): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'int C.this[I<string> x, I<object?> y]'.
                //             y: y, // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object>", "I<object?>", "y", "int C.this[I<string> x, I<object?> y]").WithLocation(7, 16),
                // (15,16): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'int C.this[I<string> x, I<object?> y]'.
                //             x: x] // warn 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<string?>", "I<string>", "x", "int C.this[I<string> x, I<object?> y]").WithLocation(15, 16));
        }

        [Fact]
        public void ImplicitConversion_CollectionInitializer()
        {
            var source =
@"using System.Collections.Generic;
class A<T> { }
class B<T> : A<T> { }
class C
{
    static void M(B<object>? x, B<object?> y)
    {
        var c = new List<A<object>>
        {
            x, // 1
            y, // 2
        };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8604: Possible null reference argument for parameter 'item' in 'void List<A<object>>.Add(A<object> item)'.
                //             x, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("item", "void List<A<object>>.Add(A<object> item)").WithLocation(10, 13),
                // (11,13): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'A<object>' for parameter 'item' in 'void List<A<object>>.Add(A<object> item)'.
                //             y, // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("B<object?>", "A<object>", "item", "void List<A<object>>.Add(A<object> item)").WithLocation(11, 13));
        }

        [Fact]
        public void Structs_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        S1 y1 = new S1();
        y1.F1 = x1;
        y1 = new S1();
        x1 = y1.F1;
    }

    void M1(ref S1 x) {}

    void Test2(CL1 x2)
    {
        S1 y2 = new S1();
        y2.F1 = x2;
        M1(ref y2);
        x2 = y2.F1;
    }

    void Test3(CL1 x3)
    {
        S1 y3 = new S1() { F1 = x3 };
        x3 = y3.F1;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        var y4 = new S2() { F2 = new S1() { F1 = x4, F3 = z4 } };
        x4 = y4.F2.F1 ?? x4;
        x4 = y4.F2.F3;
    }

    void Test5(CL1 x5, CL1? z5)
    {
        var y5 = new S2() { F2 = new S1() { F1 = x5, F3 = z5 } };
        var u5 = y5.F2;
        x5 = u5.F1 ?? x5;
        x5 = u5.F3;
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
    public CL1? F3;
}

struct S2
{
    public S1 F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x1 = y1.F1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1.F1").WithLocation(12, 14),
                 // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x2 = y2.F1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2.F1").WithLocation(22, 14),
                 // (34,14): hidden CS8607: Expression is probably never null.
                 //         x4 = y4.F2.F1 ?? x4;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y4.F2.F1").WithLocation(34, 14),
                 // (35,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x4 = y4.F2.F3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4.F2.F3").WithLocation(35, 14),
                 // (42,14): hidden CS8607: Expression is probably never null.
                 //         x5 = u5.F1 ?? x5;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u5.F1").WithLocation(42, 14),
                 // (43,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x5 = u5.F3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u5.F3").WithLocation(43, 14)
                );
        }

        [Fact]
        public void Structs_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        S1 y1;
        y1.F1 = x1;
        S1 z1 = y1;
        x1 = z1.F3;
        x1 = z1.F3 ?? x1;
        z1.F3 = null;
    }

    struct Test2
    {
        S1 z2 {get;}

        public Test2(CL1 x2)
        {
            S1 y2;
            y2.F1 = x2;
            z2 = y2;
            x2 = z2.F3;
            x2 = z2.F3 ?? x2;
        }
    }

    void Test3(CL1 x3)
    {
        S1 y3;
        CL1? z3 = y3.F3;
        x3 = z3;
        x3 = z3 ?? x3;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        S1 y4;
        z4 = y4.F3;
        x4 = z4;
        x4 = z4 ?? x4;
    }

    void Test5(CL1 x5)
    {
        S1 y5;
        var z5 = new { F3 = y5.F3 };
        x5 = z5.F3;
        x5 = z5.F3 ?? x5;
    }

    void Test6(CL1 x6, S1 z6)
    {
        S1 y6;
        y6.F1 = x6;
        z6 = y6;
        x6 = z6.F3;
        x6 = z6.F3 ?? x6;
    }

    void Test7(CL1 x7)
    {
        S1 y7;
        y7.F1 = x7;
        var z7 = new { F3 = y7 };
        x7 = z7.F3.F3;
        x7 = z7.F3.F3 ?? x7;
    }

    struct Test8
    {
        CL1? z8 {get;}

        public Test8(CL1 x8)
        {
            S1 y8;
            y8.F1 = x8;
            z8 = y8.F3;
            x8 = z8;
            x8 = z8 ?? x8;
        }
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
    public CL1? F3;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,17): error CS0165: Use of unassigned local variable 'y1'
                //         S1 z1 = y1;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(11, 17),
                // (25,18): error CS0165: Use of unassigned local variable 'y2'
                //             z2 = y2;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(25, 18),
                // (34,19): error CS0170: Use of possibly unassigned field 'F3'
                //         CL1? z3 = y3.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y3.F3").WithArguments("F3").WithLocation(34, 19),
                // (42,14): error CS0170: Use of possibly unassigned field 'F3'
                //         z4 = y4.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y4.F3").WithArguments("F3").WithLocation(42, 14),
                // (50,29): error CS0170: Use of possibly unassigned field 'F3'
                //         var z5 = new { F3 = y5.F3 };
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y5.F3").WithArguments("F3").WithLocation(50, 29),
                // (59,14): error CS0165: Use of unassigned local variable 'y6'
                //         z6 = y6;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y6").WithArguments("y6").WithLocation(59, 14),
                // (68,29): error CS0165: Use of unassigned local variable 'y7'
                //         var z7 = new { F3 = y7 };
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y7").WithArguments("y7").WithLocation(68, 29),
                // (81,18): error CS0170: Use of possibly unassigned field 'F3'
                //             z8 = y8.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y8.F3").WithArguments("F3").WithLocation(81, 18)
                );
        }

        [Fact]
        public void Structs_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        x1 = new S1().F1;
    }

    void Test2(CL1 x2)
    {
        x2 = new S1() {F1 = x2}.F1;
    }

    void Test3(CL1 x3)
    {
        x3 = new S1() {F1 = x3}.F1 ?? x3;
    }

    void Test4(CL1 x4)
    {
        x4 = new S2().F2;
    }

    void Test5(CL1 x5)
    {
        x5 = new S2().F2 ?? x5;
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
}

struct S2
{
    public CL1 F2;

    S2(CL1 x) { F2 = x; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x1 = new S1().F1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "new S1().F1").WithLocation(9, 14),
                 // (19,14): hidden CS8607: Expression is probably never null.
                 //         x3 = new S1() {F1 = x3}.F1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new S1() {F1 = x3}.F1").WithLocation(19, 14),
                 // (29,14): hidden CS8607: Expression is probably never null.
                 //         x5 = new S2().F2 ?? x5;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new S2().F2").WithLocation(29, 14)
                );
        }

        [Fact]
        public void Structs_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}
}

struct TS2
{
    System.Action? E2;

    TS2(System.Action x2)
    {
        this = new TS2();
        System.Action z2 = E2;
        System.Action y2 = E2 ?? x2;
    }

    void Dummy()
    {
        E2 = null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action z2 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(15, 28)
                );
        }

        [Fact]
        [WorkItem(29889, "https://github.com/dotnet/roslyn/issues/29889")]
        public void AnonymousTypes_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1, CL1? z1)
    {
        var y1 = new { p1 = x1, p2 = z1 };
        x1 = y1.p1 ?? x1;
        x1 = y1.p2;
    }

    void Test2(CL1 x2, CL1? z2)
    {
        var u2 = new { p1 = x2, p2 = z2 };
        var v2 = new { p1 = z2, p2 = x2 };
        u2 = v2;
        x2 = u2.p2 ?? x2;
        x2 = u2.p1;
        x2 = v2.p2 ?? x2;
        x2 = v2.p1;
    }

    void Test3(CL1 x3, CL1? z3)
    {
        var u3 = new { p1 = x3, p2 = z3 };
        var v3 = u3;
        x3 = v3.p1 ?? x3;
        x3 = v3.p2;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        var u4 = new { p0 = new { p1 = x4, p2 = z4 } };
        var v4 = new { p0 = new { p1 = z4, p2 = x4 } };
        u4 = v4;
        x4 = u4.p0.p2 ?? x4;
        x4 = u4.p0.p1;
        x4 = v4.p0.p2 ?? x4;
        x4 = v4.p0.p1;
    }

    void Test5(CL1 x5, CL1? z5)
    {
        var u5 = new { p0 = new { p1 = x5, p2 = z5 } };
        var v5 = u5;
        x5 = v5.p0.p1 ?? x5;
        x5 = v5.p0.p2;
    }

    void Test6(CL1 x6, CL1? z6)
    {
        var u6 = new { p0 = new { p1 = x6, p2 = z6 } };
        var v6 = u6.p0;
        x6 = v6.p1 ?? x6;
        x6 = v6.p2;
    }

    void Test7(CL1 x7, CL1? z7)
    {
        var u7 = new { p0 = new S1() { p1 = x7, p2 = z7 } };
        var v7 = new { p0 = new S1() { p1 = z7, p2 = x7 } };
        u7 = v7;
        x7 = u7.p0.p2 ?? x7;
        x7 = u7.p0.p1;
        x7 = v7.p0.p2 ?? x7;
        x7 = v7.p0.p1;
    }

    void Test8(CL1 x8, CL1? z8)
    {
        var u8 = new { p0 = new S1() { p1 = x8, p2 = z8 } };
        var v8 = u8;
        x8 = v8.p0.p1 ?? x8;
        x8 = v8.p0.p2;
    }

    void Test9(CL1 x9, CL1? z9)
    {
        var u9 = new { p0 = new S1() { p1 = x9, p2 = z9 } };
        var v9 = u9.p0;
        x9 = v9.p1 ?? x9;
        x9 = v9.p2;
    }

    void M1<T>(ref T x) {}

    void Test10(CL1 x10)
    {
        var u10 = new { a0 = x10, a1 = new { p1 = x10 }, a2 = new S1() { p2 = x10 } };
        x10 = u10.a0; // 1
        x10 = u10.a1.p1; // 2
        x10 = u10.a2.p2; // 3 

        M1(ref u10);

        x10 = u10.a0; // 4
        x10 = u10.a1.p1; // 5
        x10 = u10.a2.p2; // 6 
    }
}

class CL1
{
}

struct S1
{
    public CL1? p1;
    public CL1? p2;
}" }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29889: Why isn't u2 = v2 causing a warning?
            c.VerifyDiagnostics(
                // (10,14): hidden CS8607: Expression is probably never null.
                //         x1 = y1.p1 ?? x1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1.p1").WithLocation(10, 14),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = y1.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1.p2").WithLocation(11, 14),
                // (19,14): hidden CS8607: Expression is probably never null.
                //         x2 = u2.p2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2.p2").WithLocation(19, 14),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = u2.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u2.p1").WithLocation(20, 14),
                // (21,14): hidden CS8607: Expression is probably never null.
                //         x2 = v2.p2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v2.p2").WithLocation(21, 14),
                // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = v2.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v2.p1").WithLocation(22, 14),
                // (29,14): hidden CS8607: Expression is probably never null.
                //         x3 = v3.p1 ?? x3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v3.p1").WithLocation(29, 14),
                // (30,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = v3.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v3.p2").WithLocation(30, 14),
                // (38,14): hidden CS8607: Expression is probably never null.
                //         x4 = u4.p0.p2 ?? x4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4.p0.p2").WithLocation(38, 14),
                // (39,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = u4.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u4.p0.p1").WithLocation(39, 14),
                // (40,14): hidden CS8607: Expression is probably never null.
                //         x4 = v4.p0.p2 ?? x4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v4.p0.p2").WithLocation(40, 14),
                // (41,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = v4.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v4.p0.p1").WithLocation(41, 14),
                // (48,14): hidden CS8607: Expression is probably never null.
                //         x5 = v5.p0.p1 ?? x5;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v5.p0.p1").WithLocation(48, 14),
                // (49,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x5 = v5.p0.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v5.p0.p2").WithLocation(49, 14),
                // (56,14): hidden CS8607: Expression is probably never null.
                //         x6 = v6.p1 ?? x6;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v6.p1").WithLocation(56, 14),
                // (57,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x6 = v6.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v6.p2").WithLocation(57, 14),
                // (65,14): hidden CS8607: Expression is probably never null.
                //         x7 = u7.p0.p2 ?? x7;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u7.p0.p2").WithLocation(65, 14),
                // (66,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x7 = u7.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u7.p0.p1").WithLocation(66, 14),
                // (67,14): hidden CS8607: Expression is probably never null.
                //         x7 = v7.p0.p2 ?? x7;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v7.p0.p2").WithLocation(67, 14),
                // (68,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x7 = v7.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v7.p0.p1").WithLocation(68, 14),
                // (75,14): hidden CS8607: Expression is probably never null.
                //         x8 = v8.p0.p1 ?? x8;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v8.p0.p1").WithLocation(75, 14),
                // (76,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x8 = v8.p0.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v8.p0.p2").WithLocation(76, 14),
                // (83,14): hidden CS8607: Expression is probably never null.
                //         x9 = v9.p1 ?? x9;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v9.p1").WithLocation(83, 14),
                // (84,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x9 = v9.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v9.p2").WithLocation(84, 14),
                // (98,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a0; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a0").WithLocation(98, 15),
                // (99,15): warning CS8602: Possible dereference of a null reference.
                //         x10 = u10.a1.p1; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u10.a1").WithLocation(99, 15),
                // (99,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a1.p1; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a1.p1").WithLocation(99, 15),
                // (100,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a2.p2; // 6 
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a2.p2").WithLocation(100, 15)
                );
        }

        [Fact]
        public void AnonymousTypes_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1? x1)
    {
        var y1 = new { p1 = x1 };
        y1.p1?.
               M1(y1.p1);
    }

    void Test2(CL1? x2)
    {
        var y2 = new { p1 = x2 };
        if (y2.p1 != null)
        {
            y2.p1.M1(y2.p1);
        }
    }

    void Test3(out CL1? x3, CL1 z3)
    {
        var y3 = new { p1 = x3 };
        x3 = y3.p1 ?? 
                      z3.M1(y3.p1);
        CL1 v3 = y3.p1;
    }
}

class CL1
{
    public CL1? M1(CL1 x) { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (25,29): error CS0269: Use of unassigned out parameter 'x3'
                 //         var y3 = new { p1 = x3 };
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x3").WithArguments("x3").WithLocation(25, 29)
                );
        }

        [Fact]
        public void AnonymousTypes_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test2(CL1 x2)
    {
        x2 = new {F1 = x2}.F1;
    }

    void Test3(CL1 x3)
    {
        x3 = new {F1 = x3}.F1 ?? x3;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x3 = new {F1 = x3}.F1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new {F1 = x3}.F1").WithLocation(14, 14)
                );
        }

        [Fact]
        public void AnonymousTypes_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1<string> x1, CL1<string?> y1)
    {
        var u1 = new { F1 = x1 };
        var v1 = new { F1 = y1 };

        u1 = v1;
        v1 = u1;
    }
}

class CL1<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: CL1<string?> F1>' doesn't match target type '<anonymous type: CL1<string> F1>'.
                 //         u1 = v1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "v1").WithArguments("<anonymous type: CL1<string?> F1>", "<anonymous type: CL1<string> F1>").WithLocation(12, 14),
                 // (13,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: CL1<string> F1>' doesn't match target type '<anonymous type: CL1<string?> F1>'.
                 //         v1 = u1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "u1").WithArguments("<anonymous type: CL1<string> F1>", "<anonymous type: CL1<string?> F1>").WithLocation(13, 14)
                );
        }

        [Fact]
        [WorkItem(29889, "https://github.com/dotnet/roslyn/issues/29889")]
        public void AnonymousTypes_05()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F0(string x0, string? y0)
    {
        var a0 = new { F = x0 };
        var b0 = new { F = y0 };
        a0 = b0;
        b0 = a0;
    }
    static void F1(I<string> x1, I<string?> y1)
    {
        var a1 = new { F = x1 };
        var b1 = new { F = y1 };
        a1 = b1;
        b1 = a1;
    }
    static void F2(IIn<string> x2, IIn<string?> y2)
    {
        var a2 = new { F = x2 };
        var b2 = new { F = y2 };
        a2 = b2;
        b2 = a2;
    }
    static void F3(IOut<string> x3, IOut<string?> y3)
    {
        var a3 = new { F = x3 };
        var b3 = new { F = y3 };
        a3 = b3;
        b3 = a3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29889: Should report a warning for `a0 = b0`.
            // https://github.com/dotnet/roslyn/issues/29889: Should not report a warning for `b3 = a3`.
            comp.VerifyDiagnostics(
                // (17,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: I<string?> F>' doesn't match target type '<anonymous type: I<string> F>'.
                //         a1 = b1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("<anonymous type: I<string?> F>", "<anonymous type: I<string> F>").WithLocation(17, 14),
                // (18,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: I<string> F>' doesn't match target type '<anonymous type: I<string?> F>'.
                //         b1 = a1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("<anonymous type: I<string> F>", "<anonymous type: I<string?> F>").WithLocation(18, 14),
                // (24,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IIn<string?> F>' doesn't match target type '<anonymous type: IIn<string> F>'.
                //         a2 = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("<anonymous type: IIn<string?> F>", "<anonymous type: IIn<string> F>").WithLocation(24, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IIn<string> F>' doesn't match target type '<anonymous type: IIn<string?> F>'.
                //         b2 = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("<anonymous type: IIn<string> F>", "<anonymous type: IIn<string?> F>").WithLocation(25, 14),
                // (31,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IOut<string?> F>' doesn't match target type '<anonymous type: IOut<string> F>'.
                //         a3 = b3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b3").WithArguments("<anonymous type: IOut<string?> F>", "<anonymous type: IOut<string> F>").WithLocation(31, 14),
                // (32,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IOut<string> F>' doesn't match target type '<anonymous type: IOut<string?> F>'.
                //         b3 = a3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a3").WithArguments("<anonymous type: IOut<string> F>", "<anonymous type: IOut<string?> F>").WithLocation(32, 14));
        }

        [Fact]
        [WorkItem(29890, "https://github.com/dotnet/roslyn/issues/29890")]
        public void AnonymousTypes_06()
        {
            var source =
@"class C
{
    static void F(string x, string y)
    {
        x = new { x, y }.x ?? x;
        y = new { x, y = y }.y ?? y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29890: Should report ErrorCode.HDN_ExpressionIsProbablyNeverNull.
            // See comment in DataFlowPass.VisitAnonymousObjectCreationExpression.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void AnonymousObjectCreation_01()
        {
            var source =
@"class C
{
    static void F(object? o)
    {
        (new { P = o }).P.ToString();
        if (o == null) return;
        (new { Q = o }).Q.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (new { P = o }).P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new { P = o }).P").WithLocation(5, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29891: NullableWalker.VisitAnonymousObjectCreationExpression
        // should support initializers with inferred nullability.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29891")]
        [WorkItem(29891, "https://github.com/dotnet/roslyn/issues/29891")]
        public void AnonymousObjectCreation_02()
        {
            var source =
@"class C
{
    static void F(object? o)
    {
        (new { P = new[] { o }}).P[0].ToString();
        if (o == null) return;
        (new { Q = new[] { o }}).Q[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (new { P = new[] { o }}).P[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new { P = new[] { o }}).P[0]").WithLocation(5, 9));
        }

        [Fact]
        public void This()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1()
    {
        this.Test2();
    }

    void Test2()
    {
        this?.Test1();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,9): hidden CS8607: Expression is probably never null.
                 //         this?.Test1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "this").WithLocation(14, 9)
                );
        }

        [Fact]
        public void ReadonlyAutoProperties_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C1
{
    static void Main()
    {
    }

    C1 P1 {get;}

    public C1(C1? x1)
    {
        P1 = x1;
    }
}

class C2
{
    C2? P2 {get;}

    public C2(C2 x2)
    {
        x2 = P2;
    }
}

class C3
{
    C3? P3 {get;}

    public C3(C3 x3, C3? y3)
    {
        P3 = y3;
        x3 = P3;
    }
}

class C4
{
    C4? P4 {get;}

    public C4(C4 x4)
    {
        P4 = x4;
        x4 = P4;
    }
}

class C5
{
    S1 P5 {get;}

    public C5(C0 x5)
    {
        P5 = new S1() { F1 = x5 };
        x5 = P5.F1;
    }
}

class C0
{}

struct S1
{
    public C0? F1;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P2").WithLocation(22, 14),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = P3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P3").WithLocation(33, 14),
                // (12,14): warning CS8601: Possible null reference assignment.
                //         P1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(12, 14)
                );
        }

        [Fact]
        public void ReadonlyAutoProperties_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
struct C1
{
    static void Main()
    {
    }

    C0 P1 {get;}

    public C1(C0? x1)
    {
        P1 = x1;
    }
}

struct C2
{
    C0? P2 {get;}

    public C2(C0 x2)
    {
        x2 = P2;
        P2 = null;
    }
}

struct C3
{
    C0? P3 {get;}

    public C3(C0 x3, C0? y3)
    {
        P3 = y3;
        x3 = P3;
    }
}

struct C4
{
    C0? P4 {get;}

    public C4(C0 x4)
    {
        P4 = x4;
        x4 = P4;
    }
}

struct C5
{
    S1 P5 {get;}

    public C5(C0 x5)
    {
        P5 = new S1() { F1 = x5 };
        x5 = P5.F1 ?? x5;
    }
}

class C0
{}

struct S1
{
    public C0? F1;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,14): warning CS8601: Possible null reference assignment.
                //         P1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(12, 14),
                // (34,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = P3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P3").WithLocation(34, 14),
                // (22,14): error CS8079: Use of possibly unassigned auto-implemented property 'P2'
                //         x2 = P2;
                Diagnostic(ErrorCode.ERR_UseDefViolationProperty, "P2").WithArguments("P2").WithLocation(22, 14),
                // (56,14): hidden CS8607: Expression is probably never null.
                //         x5 = P5.F1 ?? x5;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "P5.F1").WithLocation(56, 14)
                );
        }

        [Fact]
        public void NotAssigned()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(object? x1)
    {
        CL1? y1;

        if (x1 == null)
        {
            y1 = null;
            return;
        }

        CL1 z1 = y1;
    }

    void Test2(object? x2, out CL1? y2)
    {
        if (x2 == null)
        {
            y2 = null;
            return;
        }

        CL1 z2 = y2;
        y2 = null;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (17,18): error CS0165: Use of unassigned local variable 'y1'
                 //         CL1 z1 = y1;
                 Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(17, 18),
                 // (28,18): error CS0269: Use of unassigned out parameter 'y2'
                 //         CL1 z2 = y2;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "y2").WithArguments("y2").WithLocation(28, 18)
                );
        }

        [Fact]
        public void Lambda_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Func<CL1?> x1 = () => M1();
    }

    void Test2()
    {
        System.Func<CL1?> x2 = delegate { return M1(); };
    }

    delegate CL1? D1();

    void Test3()
    {
        D1 x3 = () => M1();
    }

    void Test4()
    {
        D1 x4 = delegate { return M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (p1) => p1 = M1();
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (p3) => p3 = M1();
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Func<CL1> x1 = () => M1();
    }

    void Test2()
    {
        System.Func<CL1> x2 = delegate { return M1(); };
    }

    delegate CL1 D1();

    void Test3()
    {
        D1 x3 = () => M1();
    }

    void Test4()
    {
        D1 x4 = delegate { return M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,37): warning CS8603: Possible null reference return.
                 //         System.Func<CL1> x1 = () => M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(12, 37),
                 // (17,49): warning CS8603: Possible null reference return.
                 //         System.Func<CL1> x2 = delegate { return M1(); };
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(17, 49),
                 // (24,23): warning CS8603: Possible null reference return.
                 //         D1 x3 = () => M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(24, 23),
                 // (29,35): warning CS8603: Possible null reference return.
                 //         D1 x4 = delegate { return M1(); };
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(29, 35)
                );
        }

        [Fact]
        public void Lambda_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (p1) => p1 = M1();
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (p3) => p3 = M1();
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,46): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x1 = (p1) => p1 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 46),
                 // (19,30): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x3 = (p3) => p3 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(19, 30)
                );
        }

        [Fact]
        public void Lambda_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate CL1 D1();
    delegate CL1? D2();

    void M2(int x, D1 y) {}
    void M2(long x, D2 y) {}

    void M3(long x, D2 y) {}
    void M3(int x, D1 y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (20,22): warning CS8603: Possible null reference return.
                 //         M2(x1, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(20, 22),
                 // (25,22): warning CS8603: Possible null reference return.
                 //         M3(x2, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(25, 22),
                 // (30,34): warning CS8603: Possible null reference return.
                 //         M2(x3, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(30, 34),
                 // (35,34): warning CS8603: Possible null reference return.
                 //         M3(x4, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(35, 34)
                );
        }

        [Fact]
        public void Lambda_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate CL1 D1();
    delegate CL1? D2();

    void M2(int x, D2 y) {}
    void M2(long x, D1 y) {}

    void M3(long x, D1 y) {}
    void M3(int x, D2 y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T D<T>();

    void M2(int x, D<CL1> y) {}
    void M2<T>(int x, D<T> y) {}

    void M3<T>(int x, D<T> y) {}
    void M3(int x, D<CL1> y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (19,22): warning CS8603: Possible null reference return.
                 //         M2(x1, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(19, 22),
                 // (24,22): warning CS8603: Possible null reference return.
                 //         M3(x2, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(24, 22),
                 // (29,34): warning CS8603: Possible null reference return.
                 //         M2(x3, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(29, 34),
                 // (34,34): warning CS8603: Possible null reference return.
                 //         M3(x4, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(34, 34)
                );
        }

        [Fact]
        public void Lambda_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T D<T>();

    void M2(int x, D<CL1?> y) {}
    void M2<T>(int x, D<T> y) {}

    void M3<T>(int x, D<T> y) {}
    void M3(int x, D<CL1?> y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T1 D<T1, T2>(T2 y);

    void M2(int x, D<CL1, CL1> y) {}
    void M2<T>(int x, D<T, CL1> y) {}

    void M3<T>(int x, D<T, CL1> y) {}
    void M3(int x, D<CL1, CL1> y) {}

    void Test1(int x1)
    {
        M2(x1, (y1) => 
                {
                    y1 = M1();
                    return y1;
                });
    }

    void Test2(int x2)
    {
        M3(x2, (y2) => 
                {
                    y2 = M1();
                    return y2;
                });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (21,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     y1 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(21, 26),
                // (22,28): warning CS8603: Possible null reference return.
                //                     return y1;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y1").WithLocation(22, 28),
                // (30,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     y2 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(30, 26),
                // (31,28): warning CS8603: Possible null reference return.
                //                     return y2;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y2").WithLocation(31, 28)
                );
        }

        [Fact]
        public void Lambda_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T1 D<T1, T2>(T2 y);

    void M2(int x, D<CL1, CL1?> y) {}
    void M2<T>(int x, D<T, CL1> y) {}

    void M3<T>(int x, D<T, CL1> y) {}
    void M3(int x, D<CL1, CL1?> y) {}

    void Test1(int x1)
    {
        M2(x1, (y1) => 
                {
                    y1 = M1();
                    return y1;
                });
    }

    void Test2(int x2)
    {
        M3(x2, (y2) => 
                {
                    y2 = M1();
                    return y2;
                });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (22,28): warning CS8603: Possible null reference return.
                 //                     return y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y1").WithLocation(22, 28),
                 // (31,28): warning CS8603: Possible null reference return.
                 //                     return y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y2").WithLocation(31, 28)
                );
        }

        [Fact]
        public void Lambda_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (CL1 p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1> x2 = delegate (CL1 p2) { p2 = M1(); };
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (CL1 p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1 p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x1 = (CL1 p1) => p1 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 50),
                 // (17,58): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x2 = delegate (CL1 p2) { p2 = M1(); };
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(17, 58),
                 // (24,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x3 = (CL1 p3) => p3 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(24, 34),
                 // (29,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(29, 42)
                );
        }

        [Fact]
        public void Lambda_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (CL1 p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1 p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 51),
                // (12,34): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1?>'.
                //         System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1 p1) => p1 = M1()").WithArguments("p1", "lambda expression", "System.Action<CL1?>").WithLocation(12, 34),
                // (17,59): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(17, 59),
                // (17,34): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'anonymous method' doesn't match the target delegate 'Action<CL1?>'.
                //         System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1 p2) { p2 = M1(); }").WithArguments("p2", "anonymous method", "System.Action<CL1?>").WithLocation(17, 34),
                // (24,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         D1 x3 = (CL1 p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(24, 34),
                // (24,17): warning CS8622: Nullability of reference types in type of parameter 'p3' of 'lambda expression' doesn't match the target delegate 'C.D1'.
                //         D1 x3 = (CL1 p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1 p3) => p3 = M1()").WithArguments("p3", "lambda expression", "C.D1").WithLocation(24, 17),
                // (29,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(29, 42),
                // (29,17): warning CS8622: Nullability of reference types in type of parameter 'p4' of 'anonymous method' doesn't match the target delegate 'C.D1'.
                //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1 p4) { p4 = M1(); }").WithArguments("p4", "anonymous method", "C.D1").WithLocation(29, 17)
                );
        }

        [Fact]
        public void Lambda_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (CL1? p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1> x2 = delegate (CL1? p2) { p2 = M1(); };
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (CL1? p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1? p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,33): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1>'.
                //         System.Action<CL1> x1 = (CL1? p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1? p1) => p1 = M1()").WithArguments("p1", "lambda expression", "System.Action<CL1>").WithLocation(12, 33),
                // (17,33): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'anonymous method' doesn't match the target delegate 'Action<CL1>'.
                //         System.Action<CL1> x2 = delegate (CL1? p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1? p2) { p2 = M1(); }").WithArguments("p2", "anonymous method", "System.Action<CL1>").WithLocation(17, 33),
                // (24,17): warning CS8622: Nullability of reference types in type of parameter 'p3' of 'lambda expression' doesn't match the target delegate 'C.D1'.
                //         D1 x3 = (CL1? p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1? p3) => p3 = M1()").WithArguments("p3", "lambda expression", "C.D1").WithLocation(24, 17),
                // (29,17): warning CS8622: Nullability of reference types in type of parameter 'p4' of 'anonymous method' doesn't match the target delegate 'C.D1'.
                //         D1 x4 = delegate (CL1? p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1? p4) { p4 = M1(); }").WithArguments("p4", "anonymous method", "C.D1").WithLocation(29, 17)
                );
        }

        [Fact]
        public void Lambda_14()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (CL1? p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1?> x2 = delegate (CL1? p2) { p2 = M1(); };
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (CL1? p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1? p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_15()
        {
            CSharpCompilation notAnnotated = CreateCompilation(@"
public class CL0 
{
    public static void M1(System.Func<CL1<CL0>, CL0> x) {}
}

public class CL1<T>
{
    public T F1;

    public CL1()
    {
        F1 = default(T);
    }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main() {}

    static void Test1()
    {
        CL0.M1(p1 =>
                {
                    p1.F1 = null;
                    p1 = null;
                    return null;
                });
    }

    static void Test2()
    {
        System.Func<CL1<CL0>, CL0> l2 = p2 =>
                {
                    p2.F1 = null; // 1
                    p2 = null; // 2
                    return null; // 3
                };
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { notAnnotated.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (20,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                     p2.F1 = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 29),
                // (21,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     p2 = null; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(21, 26),
                // (22,28): warning CS8603: Possible null reference return.
                //                     return null; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(22, 28)
                );
        }

        [Fact]
        public void Lambda_16()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        System.Action<CL1<string?>> x1 = (CL1<string> p1) => System.Console.WriteLine();
    }

    void Test2()
    {
        System.Action<CL1<string>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
    }
}

class CL1<T>
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,42): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string?>>'.
                 //         System.Action<CL1<string?>> x1 = (CL1<string> p1) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string> p1) => System.Console.WriteLine()").WithArguments("p1", "lambda expression", "System.Action<CL1<string?>>").WithLocation(10, 42),
                 // (15,41): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string>>'.
                 //         System.Action<CL1<string>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string?> p2) => System.Console.WriteLine()").WithArguments("p2", "lambda expression", "System.Action<CL1<string>>").WithLocation(15, 41)
                );
        }

        [Fact]
        public void Lambda_17()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Linq.Expressions;

class C
{
    static void Main()
    {
    }

    void Test1()
    {
        Expression<System.Action<CL1<string?>>> x1 = (CL1<string> p1) => System.Console.WriteLine();
    }

    void Test2()
    {
        Expression<System.Action<CL1<string>>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
    }
}

class CL1<T>
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,54): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string?>>'.
                 //         Expression<System.Action<CL1<string?>>> x1 = (CL1<string> p1) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string> p1) => System.Console.WriteLine()").WithArguments("p1", "lambda expression", "System.Action<CL1<string?>>").WithLocation(12, 54),
                 // (17,53): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string>>'.
                 //         Expression<System.Action<CL1<string>>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string?> p2) => System.Console.WriteLine()").WithArguments("p2", "lambda expression", "System.Action<CL1<string>>").WithLocation(17, 53)
                );
        }

        [Fact]
        public void Lambda_18()
        {
            var source =
@"delegate T D<T>(T t) where T : class;
class C
{
    static void F()
    {
        var d1 = (D<string?>)((string s1) =>
            {
                s1 = null;
                return s1;
            });
        var d2 = (D<string>)((string? s2) =>
            {
                s2.ToString();
                return s2;
            });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,21): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'D<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         var d1 = (D<string?>)((string s1) =>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("D<T>", "T", "string?").WithLocation(6, 21),
                // (8,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                 s1 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 22),
                // (13,17): warning CS8602: Possible dereference of a null reference.
                //                 s2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(13, 17));
        }

        /// <summary>
        /// To track nullability of captured variables inside and outside a lambda,
        /// the lambda should be considered executed at the location the lambda
        /// is converted to a delegate.
        /// </summary>
        [Fact]
        public void Lambda_19()
        {
            var source =
@"using System;
class C
{
    static void F1(object? x1, object y1)
    {
        object z1 = y1;
        Action f = () =>
        {
            z1 = x1; // warning
        };
        f();
        z1.ToString();
    }
    static void F2(object? x2, object y2)
    {
        object z2 = x2; // warning
        Action f = () =>
        {
            z2 = y2;
        };
        f();
        z2.ToString(); // warning
    }
    static void F3(object? x3, object y3)
    {
        object z3 = y3;
        if (x3 == null) return;
        Action f = () =>
        {
            z3 = x3; // warning
        };
        f();
        z3.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z1 = x1; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(9, 18),
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z2 = x2; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(16, 21),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         z2.ToString(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(22, 9),
                // (30,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z3 = x3; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(30, 18));
        }

        [Fact]
        public void LambdaReturnValue_01()
        {
            var source =
@"using System;
class C
{
    static void F(Func<object> f)
    {
    }
    static void G(string x, object? y)
    {
        F(() => { if ((object)x == y) return x; return y; });
        F(() => { if (y == null) return x; return y; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,56): warning CS8603: Possible null reference return.
                //         F(() => { if ((object)x == y) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(9, 56));
        }

        [Fact]
        public void LambdaReturnValue_02()
        {
            var source =
@"using System;
class C
{
    static void F(Func<object> f)
    {
    }
    static void G(bool b, object x, string? y)
    {
        F(() => { if (b) return x; return y; });
        F(() => { if (b) return y; return x; });
    }
    static void H(bool b, object? x, string y)
    {
        F(() => { if (b) return x; return y; });
        F(() => { if (b) return y; return x; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,43): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(9, 43),
                // (10,33): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return y; return x; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(10, 33),
                // (14,33): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x").WithLocation(14, 33),
                // (15,43): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return y; return x; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x").WithLocation(15, 43));
        }

        [Fact]
        public void LambdaReturnValue_03()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<T> f)
    {
        throw null;
    }
    static void G(bool b, object x, string? y)
    {
        F(() => { if (b) return x; return y; }).ToString();
    }
    static void H(bool b, object? x, string y)
    {
        F(() => { if (b) return x; return y; }).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (b) return x; return y; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (b) return x; return y; })").WithLocation(10, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (b) return x; return y; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (b) return x; return y; })").WithLocation(14, 9));
        }

        [Fact]
        public void LambdaReturnValue_04()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<T> f)
    {
        throw null;
    }
    static void G(object? o)
    {
        F(() => o).ToString();
        if (o != null) F(() => o).ToString();
        F(() => { return o; }).ToString();
        if (o != null) F(() => { return o; }).ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => o)").WithLocation(10, 9),
                // (11,24): warning CS8602: Possible dereference of a null reference.
                //         if (o != null) F(() => o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => o)").WithLocation(11, 24),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { return o; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { return o; })").WithLocation(12, 9),
                // (13,24): warning CS8602: Possible dereference of a null reference.
                //         if (o != null) F(() => { return o; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { return o; })").WithLocation(13, 24));
        }

        [Fact]
        public void LambdaReturnValue_05()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<object?, T> f)
    {
        throw null;
    }
    static void G()
    {
        F(o => { if (o == null) throw new ArgumentException(); return o; }).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void LambdaReturnValue_06()
        {
            var source =
@"using System;
class C
{
    static U F<T, U>(Func<T, U> f, T t)
    {
        return f(t);
    }
    static void M(object? x)
    {
        F(y => F(z => z, y), x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(y => F(z => z, y), x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y => F(z => z, y), x)").WithLocation(10, 9));
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B<T> { }
class C
{
    static T F<T>(Func<int, T> f) => throw null;
    static B<T> Create<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y)
    {
        var z = Create(A.F)/*T:B<object>!*/;
        F(i => { switch (i) { case 0: return x; default: return x; }})/*T:B<object?>!*/;
        F(i => { switch (i) { case 0: return x; default: return y; }})/*T:B<object>*/;
        F(i => { switch (i) { case 0: return x; default: return z; }})/*T:B<object?>*/;
        F(i => { switch (i) { case 0: return y; default: return x; }})/*T:B<object>*/;
        F(i => { switch (i) { case 0: return y; default: return y; }})/*T:B<object!>!*/;
        F(i => { switch (i) { case 0: return y; default: return z; }})/*T:B<object!>*/;
        F(i => { switch (i) { case 0: return z; default: return x; }})/*T:B<object?>*/;
        F(i => { switch (i) { case 0: return z; default: return y; }})/*T:B<object!>*/;
        F(i => { switch (i) { case 0: return z; default: return z; }})/*T:B<object>*/;
        F(i => { switch (i) { case 0: return x; case 1: return y; default: return z; }})/*T:B<object>*/;
        F(i => { switch (i) { case 0: return z; case 1: return y; default: return x; }})/*T:B<object>*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30480: Should report WRN_CantInferNullabilityOfMethodTypeArgs for { B<object>, B<object?> }.
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void LambdaReturnValue_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(Func<bool, T> f) => throw null;
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:I<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:I<object>*/;
        F(b => { if (b) return x; else return z; })/*T:I<object!>*/;
        F(b => { if (b) return y; else return x; })/*T:I<object>*/;
        F(b => { if (b) return y; else return y; })/*T:I<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:I<object?>*/;
        F(b => { if (b) return z; else return x; })/*T:I<object!>*/;
        F(b => { if (b) return z; else return y; })/*T:I<object?>*/;
        F(b => { if (b) return z; else return z; })/*T:I<object>*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:IIn<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:IIn<object!>!*/;
        F(b => { if (b) return x; else return z; })/*T:IIn<object!>*/;
        F(b => { if (b) return y; else return x; })/*T:IIn<object!>!*/;
        F(b => { if (b) return y; else return y; })/*T:IIn<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:IIn<object>*/;
        F(b => { if (b) return z; else return x; })/*T:IIn<object!>*/;
        F(b => { if (b) return z; else return y; })/*T:IIn<object>*/;
        F(b => { if (b) return z; else return z; })/*T:IIn<object>*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:IOut<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:IOut<object?>!*/;
        F(b => { if (b) return x; else return z; })/*T:IOut<object>*/;
        F(b => { if (b) return y; else return x; })/*T:IOut<object?>!*/;
        F(b => { if (b) return y; else return y; })/*T:IOut<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:IOut<object?>*/;
        F(b => { if (b) return z; else return x; })/*T:IOut<object>*/;
        F(b => { if (b) return z; else return y; })/*T:IOut<object?>*/;
        F(b => { if (b) return z; else return z; })/*T:IOut<object>*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            // https://github.com/dotnet/roslyn/issues/30480: Should report WRN_CantInferNullabilityOfMethodTypeArgs for { I<object>, I<object?> }.
            comp.VerifyDiagnostics();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B<T> { }
class C
{
    static B<T> CreateB<T>(T t) => throw null;
    static Func<int, T> CreateFunc<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        var f = CreateFunc(y)/*Func<B<object!>>!*/;
        f = i => { switch (i) { case 0: return x; default: return x; }};
        f = i => { switch (i) { case 0: return x; default: return y; }};
        f = i => { switch (i) { case 0: return x; default: return z; }};
        f = i => { switch (i) { case 0: return y; default: return x; }};
        f = i => { switch (i) { case 0: return y; default: return y; }};
        f = i => { switch (i) { case 0: return y; default: return z; }};
        f = i => { switch (i) { case 0: return z; default: return x; }};
        f = i => { switch (i) { case 0: return z; default: return y; }};
        f = i => { switch (i) { case 0: return z; default: return z; }};
        f = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
        f = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
        var g = CreateFunc(z)/*Func<B<object>>*/;
        g = i => { switch (i) { case 0: return x; default: return x; }};
        g = i => { switch (i) { case 0: return x; default: return y; }};
        g = i => { switch (i) { case 0: return x; default: return z; }};
        g = i => { switch (i) { case 0: return y; default: return x; }};
        g = i => { switch (i) { case 0: return y; default: return y; }};
        g = i => { switch (i) { case 0: return y; default: return z; }};
        g = i => { switch (i) { case 0: return z; default: return x; }};
        g = i => { switch (i) { case 0: return z; default: return y; }};
        g = i => { switch (i) { case 0: return z; default: return z; }};
        g = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
        g = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(11, 48),
                // (11,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(11, 67),
                // (12,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return y; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(12, 48),
                // (13,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return z; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(13, 48),
                // (14,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return y; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(14, 67),
                // (17,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return z; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(17, 67),
                // (20,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(20, 48),
                // (21,85): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(21, 85));
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void LambdaReturnValue_TopLevelNullability_Ref()
        {
            var source =
@"delegate ref V D<T, U, V>(ref T t, ref U u);
class C
{
    static V F<T, U, V>(D<T, U, V> d) => throw null;
    static void G(bool b)
    {
        F((ref object? x1, ref object? y1) => { if (b) return ref x1; return ref y1; });
        F((ref object? x2, ref object y2) => { if (b) return ref x2; return ref y2; });
        F((ref object x3, ref object? y3) => { if (b) return ref x3; return ref y3; });
        F((ref object x4, ref object y4) => { if (b) return ref x4; return ref y4; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `object?` and `object!`.
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Ref()
        {
            var source =
@"delegate ref V D<T, U, V>(ref T t, ref U u);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static V F<T, U, V>(D<T, U, V> d) => throw null;
    static void G(bool b)
    {
        // I<object>
        F((ref I<object?> a1, ref I<object?> b1) => { if (b) return ref a1; return ref b1; });
        F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; });
        F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; });
        F((ref I<object> a4, ref I<object> b4) => { if (b) return ref a4; return ref b4; });
        // IIn<object>
        F((ref IIn<object?> c1, ref IIn<object?> d1) => { if (b) return ref c1; return ref d1; });
        F((ref IIn<object?> c2, ref IIn<object> d2) => { if (b) return ref c2; return ref d2; });
        F((ref IIn<object> c3, ref IIn<object?> d3) => { if (b) return ref c3; return ref d3; });
        F((ref IIn<object> c4, ref IIn<object> d4) => { if (b) return ref c4; return ref d4; });
        // IOut<object>
        F((ref IOut<object?> e1, ref IOut<object?> f1) => { if (b) return ref e1; return ref f1; });
        F((ref IOut<object?> e2, ref IOut<object> f2) => { if (b) return ref e2; return ref f2; });
        F((ref IOut<object> e3, ref IOut<object?> f3) => { if (b) return ref e3; return ref f3; });
        F((ref IOut<object> e4, ref IOut<object> f4) => { if (b) return ref e4; return ref f4; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `IIn<object?>` and `IIn<object!>`
            // and combinations of  `IOut<object?>` and `IOut<object!>`.
            comp.VerifyDiagnostics(
                // (12,11): warning CS8622: Nullability of reference types in type of parameter 'a2' of 'lambda expression' doesn't match the target delegate 'D<I<object>, I<object>, I<object>>'.
                //         F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; }").WithArguments("a2", "lambda expression", "D<I<object>, I<object>, I<object>>").WithLocation(12, 11),
                // (12,11): warning CS8622: Nullability of reference types in type of parameter 'b2' of 'lambda expression' doesn't match the target delegate 'D<I<object>, I<object>, I<object>>'.
                //         F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; }").WithArguments("b2", "lambda expression", "D<I<object>, I<object>, I<object>>").WithLocation(12, 11),
                // (13,11): warning CS8622: Nullability of reference types in type of parameter 'a3' of 'lambda expression' doesn't match the target delegate 'D<I<object>, I<object>, I<object>>'.
                //         F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; }").WithArguments("a3", "lambda expression", "D<I<object>, I<object>, I<object>>").WithLocation(13, 11),
                // (13,11): warning CS8622: Nullability of reference types in type of parameter 'b3' of 'lambda expression' doesn't match the target delegate 'D<I<object>, I<object>, I<object>>'.
                //         F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; }").WithArguments("b3", "lambda expression", "D<I<object>, I<object>, I<object>>").WithLocation(13, 11));
            comp.VerifyTypes();
        }

        [Fact]
        public void LambdaParameterValue()
        {
            var source =
@"using System;
class C
{
    static void F<T>(T t, Action<T> f)
    {
    }
    static void G(object? x)
    {
        F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
        if (x != null) F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,31): warning CS8602: Possible dereference of a null reference.
                //         F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 31),
                // (9,45): warning CS8602: Possible dereference of a null reference.
                //         F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(9, 45));
        }

        [Fact]
        public void IdentityConversion_LambdaReturnType()
        {
            var source =
@"delegate T D<T>();
interface I<T> { }
class C
{
    static void F(object x, object? y)
    {
        D<object?> a = () => x;
        D<object> b = () => y;
        if (y == null) return;
        a = () => y;
        b = () => y;
        a = (D<object?>)(() => y);
        b = (D<object>)(() => y);
    }
    static void F(I<object> x, I<object?> y)
    {
        D<I<object?>> a = () => x;
        D<I<object>> b = () => y;
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,29): warning CS8603: Possible null reference return.
                //         D<object> b = () => y;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(8, 29),
                // (11,19): warning CS8603: Possible null reference return.
                //         b = () => y;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(11, 19),
                // (13,31): warning CS8603: Possible null reference return.
                //         b = (D<object>)(() => y);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(13, 31),
                // (17,33): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         D<I<object?>> a = () => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(17, 33),
                // (18,32): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         D<I<object>> b = () => y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(18, 32));
        }

        [Fact]
        public void IdentityConversion_LambdaParameter()
        {
            var source =
@"delegate void D<T>(T t);
interface I<T> { }
class C
{
    static void F()
    {
        D<object?> a = (object o) => { };
        D<object> b = (object? o) => { };
        D<I<object?>> c = (I<object> o) => { };
        D<I<object>> d = (I<object?> o) => { };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,24): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<object?>'.
                //         D<object?> a = (object o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(object o) => { }").WithArguments("o", "lambda expression", "D<object?>").WithLocation(7, 24),
                // (8,23): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<object>'.
                //         D<object> b = (object? o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(object? o) => { }").WithArguments("o", "lambda expression", "D<object>").WithLocation(8, 23),
                // (9,27): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> c = (I<object> o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(I<object> o) => { }").WithArguments("o", "lambda expression", "D<I<object?>>").WithLocation(9, 27),
                // (10,26): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> d = (I<object?> o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(I<object?> o) => { }").WithArguments("o", "lambda expression", "D<I<object>>").WithLocation(10, 26));
        }

        [Fact]
        public void ReturnTypeInference_01()
        {
            var source =
@"class C
{
    static T F<T>(System.Func<T> f)
    {
        return f();
    }
    static void G(string x, string? y)
    {
        F(() => x).ToString();
        F(() => y).ToString();
        if (y != null) F(() => y).ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => y)").WithLocation(10, 9),
                // (11,24): warning CS8602: Possible dereference of a null reference.
                //         if (y != null) F(() => y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => y)").WithLocation(11, 24));
        }

        // Multiple returns, one of which is null.
        [Fact]
        public void ReturnTypeInference_02()
        {
            var source =
@"class C
{
    static T F<T>(System.Func<T> f)
    {
        return f();
    }
    static void G(string x)
    {
        F(() => { if (x.Length > 0) return x; return null; }).ToString();
        F(() => { if (x.Length == 0) return null; return x; }).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (x.Length > 0) return x; return null; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (x.Length > 0) return x; return null; })").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (x.Length == 0) return null; return x; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (x.Length == 0) return null; return x; })").WithLocation(10, 9));
        }

        [Fact]
        public void ReturnTypeInference_CSharp7()
        {
            var source =
@"using System;
class C
{
    static void Main(string[] args)
    {
        args.F(arg => arg.Length);
    }
}
static class E
{
    internal static U[] F<T, U>(this T[] a, Func<T, U> f) => throw new Exception();
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnboundLambda_01()
        {
            var source =
@"class C
{
    static void F()
    {
        var y = x => x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): error CS0815: Cannot assign lambda expression to an implicitly-typed variable
                //         var y = x => x;
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, "y = x => x").WithArguments("lambda expression").WithLocation(5, 13));
        }

        [Fact]
        public void UnboundLambda_02()
        {
            var source =
@"class C
{
    static void F(object? x)
    {
        var z = y => y ?? x.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): error CS0815: Cannot assign lambda expression to an implicitly-typed variable
                //         var z = y => y ?? x.ToString();
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, "z = y => y ?? x.ToString()").WithArguments("lambda expression").WithLocation(5, 13),
                // (5,27): warning CS8602: Possible dereference of a null reference.
                //         var z = y => y ?? x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 27));
        }

        /// <summary>
        /// Inferred nullability of captured variables should be tracked across
        /// local function invocations, as if the local function was inlined.
        /// </summary>
        [Fact]
        [WorkItem(29892, "https://github.com/dotnet/roslyn/issues/29892")]
        public void LocalFunction_01()
        {
            var source =
@"class C
{
    static void F1(object? x1, object y1)
    {
        object z1 = y1;
        f();
        z1.ToString(); // warning
        void f()
        {
            z1 = x1; // warning
        }
    }
    static void F2(object? x2, object y2)
    {
        object z2 = x2; // warning
        f();
        z2.ToString();
        void f()
        {
            z2 = y2;
        }
    }
    static void F3(object? x3, object y3)
    {
        object z3 = y3;
        void f()
        {
            z3 = x3;
        }
        if (x3 == null) return;
        f();
        z3.ToString();
    }
    static void F4(object? x4)
    {
        f().ToString(); // warning
        if (x4 != null) f().ToString();
        object? f() => x4;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29892: Should report warnings as indicated in source above.
            comp.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z1 = x1; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(10, 18),
                // (15,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z2 = x2; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(15, 21),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         z2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(17, 9),
                // (28,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(28, 18),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         f().ToString(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "f()").WithLocation(36, 9),
                // (37,25): warning CS8602: Possible dereference of a null reference.
                //         if (x4 != null) f().ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "f()").WithLocation(37, 25));
        }

        /// <summary>
        /// Should report warnings within unused local functions.
        /// </summary>
        [Fact]
        [WorkItem(29892, "https://github.com/dotnet/roslyn/issues/29892")]
        public void LocalFunction_NoCallers()
        {
            var source =
@"#pragma warning disable 8321
class C
{
    static void F1(object? x1)
    {
        void f1()
        {
            x1.ToString(); // 1
        }
    }
    static void F2(object? x2)
    {
        if (x2 == null) return;
        void f2()
        {
            x2.ToString(); // 2
        }
    }
    static void F3(object? x3)
    {
        object? y3 = x3;
        void f3()
        {
            y3.ToString(); // 3
        }
        if (y3 == null) return;
        void g3()
        {
            y3.ToString(); // 4
        }
    }
    static void F4()
    {
        void f4(object? x4)
        {
            x4.ToString(); // 5
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29892: Should report warnings for `y3.ToString()`.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(8, 13),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(16, 13),
                // (36,13): warning CS8602: Possible dereference of a null reference.
                //             x4.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4").WithLocation(36, 13));
        }

        [Fact]
        public void New_01()
        {
            var source =
@"class C
{
    static void F1()
    {
        object? x1;
        x1 = new object?(); // error 1
        x1 = new object? { }; // error 2
        x1 = (new object?[1])[0];
    }
    static void F2<T2>()
    {
        object? x2;
        x2 = new T2?(); // error 3 and 4
        x2 = new T2? { }; // error 5 and 6
        x2 = (new T2?[1])[0];
    }
    static void F3<T3>() where T3 : class, new()
    {
        object? x3;
        x3 = new T3?(); // error 7
        x3 = new T3? { }; // error 8
        x3 = (new T3?[1])[0];
    }
    static void F4<T4>() where T4 : new()
    {
        object? x4;
        x4 = new T4?(); // error 9
        x4 = new T4? { }; // error 10
        x4 = (new T4?[1])[0];
        x4 = new System.Nullable<int>? { }; // error 11
    }
    static void F5<T5>() where T5 : class
    {
        object? x5;
        x5 = new T5?(); // error 12 and 13
        x5 = new T5? { }; // error 14 and 15
        x5 = (new T5?[1])[0]; // error 16
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x1 = new object?(); // error 1
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new object?()").WithArguments("object").WithLocation(6, 14),
                // (7,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x1 = new object? { }; // error 2
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new object? { }").WithArguments("object").WithLocation(7, 14),
                // (13,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x2 = new T2?(); // error 3 and 4
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T2?()").WithArguments("T2").WithLocation(13, 14),
                // (13,14): error CS0304: Cannot create an instance of the variable type 'T2' because it does not have the new() constraint
                //         x2 = new T2?(); // error 3 and 4
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T2?()").WithArguments("T2").WithLocation(13, 14),
                // (13,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = new T2?(); // error 3 and 4
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(13, 18),
                // (14,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x2 = new T2? { }; // error 5 and 6
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T2? { }").WithArguments("T2").WithLocation(14, 14),
                // (14,14): error CS0304: Cannot create an instance of the variable type 'T2' because it does not have the new() constraint
                //         x2 = new T2? { }; // error 5 and 6
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T2? { }").WithArguments("T2").WithLocation(14, 14),
                // (14,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = new T2? { }; // error 5 and 6
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(14, 18),
                // (15,19): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = (new T2?[1])[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(15, 19),
                // (20,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x3 = new T3?(); // error 7
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T3?()").WithArguments("T3").WithLocation(20, 14),
                // (21,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x3 = new T3? { }; // error 8
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T3? { }").WithArguments("T3").WithLocation(21, 14),
                // (27,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x4 = new T4?(); // error 9
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T4?()").WithArguments("T4").WithLocation(27, 14),
                // (27,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = new T4?(); // error 9
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(27, 18),
                // (28,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x4 = new T4? { }; // error 10
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T4? { }").WithArguments("T4").WithLocation(28, 14),
                // (28,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = new T4? { }; // error 10
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(28, 18),
                // (30,18): error CS0453: The type 'int?' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                //         x4 = new System.Nullable<int>? { }; // error 11
                Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "System.Nullable<int>?").WithArguments("System.Nullable<T>", "T", "int?").WithLocation(30, 18),
                // (29,19): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = (new T4?[1])[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(29, 19),
                // (35,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x5 = new T5?(); // error 12 and 13
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T5?()").WithArguments("T5").WithLocation(35, 14),
                // (35,14): error CS0304: Cannot create an instance of the variable type 'T5' because it does not have the new() constraint
                //         x5 = new T5?(); // error 12 and 13
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T5?()").WithArguments("T5").WithLocation(35, 14),
                // (36,14): error CS8630: Cannot use a nullable reference type in object creation.
                //         x5 = new T5? { }; // error 14 and 15
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T5? { }").WithArguments("T5").WithLocation(36, 14),
                // (36,14): error CS0304: Cannot create an instance of the variable type 'T5' because it does not have the new() constraint
                //         x5 = new T5? { }; // error 14 and 15
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T5? { }").WithArguments("T5").WithLocation(36, 14)
                );
        }

        [Fact]
        public void New_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T1>(T1 x1) where T1 : class, new()
    {
        x1 = new T1();
    }

    void Test2<T2>(T2 x2) where T2 : class, new()
    {
        x2 = new T2() ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new T2() ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new T2()").WithLocation(14, 14)
                );
        }

        // `where T : new()` does not imply T is non-nullable.
        [Fact]
        public void New_03()
        {
            var source =
@"class C
{
    static void F1<T>() where T : new() { }
    static void F2<T>(T t) where T : new() { }
    static void G<U>() where U : class, new()
    {
        object? x = null;
        F1<object?>();
        F2(x);
        U? y = null;
        F1<U?>();
        F2(y);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicObjectCreation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = new CL0((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = new CL0((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0(int x) {}
    public CL0(long x) {}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new CL0((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL0((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicObjectCreation_02()
        {
            var source =
@"class C
{
    C(object x, object y)
    {
    }
    static void G(object? x, dynamic y)
    {
        var o = new C(x, y);
        if (x != null) o = new C(y, x);
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29893: We should be able to report warnings
            // when all applicable methods agree on the nullability of particular parameters.
            // (For instance, x in F(x, y) above.)
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicObjectCreation_03()
        {
            var source =
@"class C
{
    C(object f)
    {
        F = f;
    }
    object? F;
    object? G;
    static void M(dynamic d)
    {
        var o = new C(d) { G = new object() };
        o.G.ToString();
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicIndexerAccess_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0? this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic y1 = x1[(dynamic)0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0? this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0? this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0? this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public int this[int x]
    {
        get { return x; }
        set { }
    }

    public int this[long x]
    {
        get { return (int)x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public int this[int x]
    {
        get { return x; }
        set { }
    }

    public long this[long x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1[0];
    }

    void Test2(dynamic x2)
    {
        x2 = x2[0] ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void DynamicIndexerAccess_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T>(CL0<T> x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2<T>(CL0<T> x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0<T>
{
    public T this[int x]
    {
        get { return default(T); }
        set { }
    }

    public long this[long x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         get { return default(T); }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(22, 22)
            );
        }

        [Fact]
        public void DynamicIndexerAccess_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1, dynamic y1)
    {
        x1[(dynamic)0] = y1;
    }

    void Test2(CL0 x2, dynamic? y2, CL1 z2)
    {
        x2[(dynamic)0] = y2;
        z2[0] = y2;
    }
} 

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}

class CL1
{
    public dynamic this[int x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (14,26): warning CS8601: Possible null reference assignment.
                //         x2[(dynamic)0] = y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y2").WithLocation(14, 26),
                // (15,17): warning CS8601: Possible null reference assignment.
                //         z2[0] = y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y2").WithLocation(15, 17)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0? x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0? x2)
    {
        x2 = x2[0];
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,14): warning CS8602: Possible dereference of a null reference.
                 //         x1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 14),
                 // (14,14): warning CS8602: Possible dereference of a null reference.
                 //         x2 = x2[0];
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0 M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0? M1(int x)
    {
        return new CL0(); 
    }

    public CL0  M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0? M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0? M1(int x)
    {
        return new CL0(); 
    }

    public CL0? M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public int M1(int x)
    {
        return x; 
    }

    public int M1(long x)
    {
        return (int)x; 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public int M1(int x)
    {
        return x; 
    }

    public long M1(long x)
    {
        return x; 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1.M1(0);
    }

    void Test2(dynamic x2)
    {
        x2 = x2.M1(0) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void DynamicInvocation_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T>(CL0<T> x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2<T>(CL0<T> x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0<T>
{
    public T M1(int x)
    {
        return default(T);
    }
    public long M1(long x)
    {
        return x;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         return default(T);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(22, 16)
            );
        }

        [Fact]
        public void DynamicInvocation_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0? x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0? x2)
    {
        x2 = x2.M1(0);
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0 M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,14): warning CS8602: Possible dereference of a null reference.
                 //         x1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 14),
                 // (14,14): warning CS8602: Possible dereference of a null reference.
                 //         x2 = x2.M1(0);
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicMemberAccess_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1.M1;
    }

    void Test2(dynamic x2)
    {
        x2 = x2.M1 ?? x2;
    }

    void Test3(dynamic? x3)
    {
        dynamic y3 = x3.M1;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (19,22): warning CS8602: Possible dereference of a null reference.
                 //         dynamic y3 = x3.M1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(19, 22)
                );
        }

        [Fact]
        public void DynamicMemberAccess_02()
        {
            var source =
@"class C
{
    static void M(dynamic x)
    {
        x.F/*T:dynamic*/.ToString();
        var y = x.F;
        y/*T:dynamic*/.ToString();
        y = null;
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void DynamicObjectCreationExpression_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1()
    {
        dynamic? x1 = null;
        CL0 y1 = new CL0(x1);
    }

    void Test2(CL0 y2)
    {
        dynamic? x2 = null;
        CL0 z2 = new CL0(x2) ?? y2;
    }
}

class CL0
{
    public CL0(int x)
    {
    }

    public CL0(long x)
    {
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): hidden CS8607: Expression is probably never null.
                 //         CL0 z2 = new CL0(x2) ?? y2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL0(x2)").WithLocation(16, 18)
                );
        }

        [Fact]
        public void DynamicInvocation()
        {
            var source =
@"class C
{
    static void F(object x, object y)
    {
    }
    static void G(object? x, dynamic y)
    {
        F(x, y);
        if (x != null) F(y, x);
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29893: We should be able to report warnings
            // when all applicable methods agree on the nullability of particular parameters.
            // (For instance, x in F(x, y) above.)
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NameOf_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string x1, string? y1)
    {
        x1 = nameof(y1);
    }

    void Test2(string x2, string? y2)
    {
        string? z2 = nameof(y2);
        x2 = z2 ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,14): hidden CS8607: Expression is probably never null.
                 //         x2 = z2 ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z2").WithLocation(16, 14)
                );
        }

        [Fact]
        public void StringInterpolation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string x1, string? y1)
    {
        x1 = $""{y1}"";
    }

    void Test2(string x2, string? y2)
    {
        x2 = $""{y2}"" ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = $"{y2}" ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"$""{y2}""").WithLocation(15, 14)
                );
        }

        [Fact]
        public void DelegateCreation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Action x1)
    {
        x1 = new System.Action(Main);
    }

    void Test2(System.Action x2)
    {
        x2 = new System.Action(Main) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new System.Action(Main) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new System.Action(Main)").WithLocation(15, 14)
                );
        }

        // WRN_NullabilityMismatch* warnings should not be
        // reported for explicit delegate creation.
        [Fact]
        public void DelegateCreation_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL0<string?> M1(CL0<string> x) { throw new System.Exception(); }
    delegate CL0<string> D1(CL0<string?> x);

    void Test1()
    {
        D1 x1 = new D1(M1);
    }

    CL0<string> M2(CL0<string?> x) { throw new System.Exception(); }
    delegate CL0<string?> D2(CL0<string> x);

    void Test2()
    {
        D2 x2 = new D2(M2);
    }
}

class CL0<T>{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void IdentityConversion_DelegateReturnType()
        {
            var source =
@"delegate T D<T>();
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>() => throw new System.Exception();
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8621: Nullability of reference types in return type of 'object? C.F<object?>()' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<object?>").WithArguments("object? C.F<object?>()", "D<object>").WithLocation(10, 23),
                // (12,26): warning CS8621: Nullability of reference types in return type of 'I<object?> C.F<I<object?>>()' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<I<object?>>").WithArguments("I<object?> C.F<I<object?>>()", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8621: Nullability of reference types in return type of 'I<object> C.F<I<object>>()' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<I<object>>").WithArguments("I<object> C.F<I<object>>()", "D<I<object?>>").WithLocation(13, 27),
                // (15,29): warning CS8621: Nullability of reference types in return type of 'IIn<object> C.F<IIn<object>>()' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("IIn<object> C.F<IIn<object>>()", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8621: Nullability of reference types in return type of 'IOut<object?> C.F<IOut<object?>>()' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("IOut<object?> C.F<IOut<object?>>()", "D<IOut<object>>").WithLocation(16, 29));
        }

        [Fact]
        public void IdentityConversion_DelegateParameter_01()
        {
            var source =
@"delegate void D<T>(T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(T t) { }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        [WorkItem(29844, "https://github.com/dotnet/roslyn/issues/29844")]
        public void IdentityConversion_DelegateParameter_02()
        {
            var source =
@"delegate T D<T>();
class A<T>
{
    internal T M() => throw new System.NotImplementedException();
}
class B
{
    static A<T> F<T>(T t) => throw null;
    static void G(object? o)
    {
        var x = F(o);
        D<object?> d = x.M;
        D<object> e = x.M;
        if (o == null) return;
        var y = F(o);
        d = y.M;
        e = y.M;
        d = (D<object?>)y.M;
        e = (D<object>)y.M;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Should report WRN_NullabilityMismatchInReturnTypeOfTargetDelegate for `e = x.M`.
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29844, "https://github.com/dotnet/roslyn/issues/29844")]
        public void IdentityConversion_DelegateOutParameter()
        {
            var source =
@"delegate void D<T>(out T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(out T t) { t = default; }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Should not warn for `b`, `e`, `h`.
            comp.VerifyDiagnostics(
                // (7,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F<T>(out T t) { t = default; }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 37),
                // (10,23): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object?>(out object? t)' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object?>").WithArguments("t", "void C.F<object?>(out object? t)", "D<object>").WithLocation(10, 23),
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(out object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(out object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(out I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(out I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(out I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(out I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(out IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(out IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (15,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object>>(out IIn<object> t)' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("t", "void C.F<IIn<object>>(out IIn<object> t)", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object?>>(out IOut<object?> t)' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("t", "void C.F<IOut<object?>>(out IOut<object?> t)", "D<IOut<object>>").WithLocation(16, 29),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(out IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(out IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        public void IdentityConversion_DelegateRefParameter()
        {
            var source =
@"delegate void D<T>(ref T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(ref T t) { }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object?>(ref object? t)' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object?>").WithArguments("t", "void C.F<object?>(ref object? t)", "D<object>").WithLocation(10, 23),
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(ref object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(ref object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(ref I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(ref I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(ref I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(ref I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(ref IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(ref IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (15,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object>>(ref IIn<object> t)' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("t", "void C.F<IIn<object>>(ref IIn<object> t)", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object?>>(ref IOut<object?> t)' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("t", "void C.F<IOut<object?>>(ref IOut<object?> t)", "D<IOut<object>>").WithLocation(16, 29),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(ref IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(ref IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        public void Base_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Base
{
    public virtual void Test() {}
}

class C : Base
{
    static void Main()
    {
    }

    public override void Test()
    {
        base.Test();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void TypeOf_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Type x1)
    {
        x1 = typeof(C);
    }

    void Test2(System.Type x2)
    {
        x2 = typeof(C) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = typeof(C) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "typeof(C)").WithLocation(15, 14)
                );
        }

        [Fact]
        [WorkItem(29894, "https://github.com/dotnet/roslyn/issues/29894")]
        public void TypeOf_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class List<T> { }
class C<T, TClass, TStruct>
    where TClass : class
    where TStruct : struct
{
    void M()
    {
        _ = typeof(C<int, object, int>?);
        _ = typeof(T?);
        _ = typeof(TClass?);
        _ = typeof(TStruct?);
        _ = typeof(List<T?>);
        _ = typeof(List<TClass?>);
        _ = typeof(List<TStruct?>);
    }
}
" }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29894: should nullable reference types be disallowed in `typeof`?
            c.VerifyDiagnostics(
                // (10,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         _ = typeof(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 20),
                // (13,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         _ = typeof(List<T?>);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(13, 25)
                );
        }

        [Fact]
        public void Default_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(C x1)
    {
        x1 = default(C);
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = default(C);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(C)").WithLocation(10, 14)
                );
        }

        [Fact]
        public void Default_NonNullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = default(string);
        s.ToString();
        var i = default(int);
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(false, symbol.Type.IsNullable);
        }

        [Fact]
        public void Default_Nullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = default(string?);
        s.ToString();
        var i = default(int?);
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void Default_TUnconstrained()
        {
            var source =
@"class C
{
    static void F<T>()
    {
        var s = default(T);
        s.ToString();
        var t = default(T?);
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (7,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         var t = default(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 25),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(null, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            // https://github.com/dotnet/roslyn/issues/29856: Is T correct?
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(null, symbol.Type.IsNullable);
        }

        [Fact]
        public void Default_TClass()
        {
            var source =
@"class C
{
    static void F<T>() where T : class
    {
        var s = default(T);
        s.ToString();
        var t = default(T?);
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void DefaultInferred_NonNullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        string s = default;
        s.ToString();
        int i = default;
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string s = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 20),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String!", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(false, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(false, symbol.Type.IsNullable);
        }

        [Fact]
        public void DefaultInferred_Nullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        string? s = default;
        s.ToString();
        int? i = default;
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void DefaultInferred_TUnconstrained()
        {
            var source =
@"class C
{
    static void F<T>()
    {
        T s = default;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            // https://github.com/dotnet/roslyn/issues/29895: Improve this diagnostic. default is the cause of the error, but is not mentioned in the diagnostic.
            comp.VerifyDiagnostics(
                // (5,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         T s = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(5, 15),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        [Fact]
        public void DefaultInferred_TClass()
        {
            var source =
@"class C
{
    static void F<T>() where T : class
    {
        T s = default;
        s.ToString();
        T? t = default;
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T s = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 15),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T!", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(false, symbol.Type.IsNullable);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(true, symbol.Type.IsNullable);
        }

        // https://github.com/dotnet/roslyn/issues/29618: Track nullability through deconstruction assignment.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29618")]
        [WorkItem(29896, "https://github.com/dotnet/roslyn/issues/29618")]
        public void DeconstructionTypeInference()
        {
            var source =
@"class C
{
    static void F((object? a, object? b) t)
    {
        if (t.b == null) return;
        object? x;
        object? y;
        (x, y) = t;
        x.ToString();
        y.ToString();
    }
    static void F(object? a, object? b)
    {
        if (b == null) return;
        object? x;
        object? y;
        (x, y) = (a, b);
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                references: new[] { ValueTupleRef, SystemRuntimeFacadeRef },
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(18, 9));
        }

        [Fact]
        public void IdentityConversion_DeconstructionAssignment()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C<T>
{
    void Deconstruct(out IIn<T> x, out IOut<T> y)
    {
        throw new System.NotImplementedException();
    }
    static void F(C<object> c)
    {
        IIn<object?> x;
        IOut<object?> y;
        (x, y) = c;
    }
    static void G(C<object?> c)
    {
        IIn<object> x;
        IOut<object> y;
        (x, y) = c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Assign each of the deconstructed values.
            // The expected warning is confusing: "warning CS8619: Nullability of
            // reference types in value of type 'C<object>' doesn't match target type '(IIn<object?> x, IOut<object?> y)'".
            comp.VerifyDiagnostics();
            //// (13,18): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type '(IIn<object?> x, IOut<object?> y)'.
            ////         (x, y) = c;
            //Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c").WithArguments("C<object>", "(IIn<object?> x, IOut<object?> y)").WithLocation(13, 18),
            //// (19,18): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type '(IIn<object> x, IOut<object> y)'.
            ////         (x, y) = c;
            //Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c").WithArguments("C<object?>", "(IIn<object> x, IOut<object> y)").WithLocation(19, 18));
        }

        [Fact]
        public void DeconstructionTypeInference_01()
        {
            var source =
@"class C
{
    static void M()
    {
        (var x, var y) = ((string?)null, string.Empty);
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer `string?` for `var x`.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(9, 13));
        }

        [Fact]
        public void DeconstructionTypeInference_02()
        {
            var source =
@"class C
{
    static (string?, string) F() => (string.Empty, string.Empty);
    static void G()
    {
        (var x, var y) = F();
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer `string?` for `var x`.
            comp.VerifyDiagnostics(
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(9, 13),
                // (10,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(10, 13));
        }

        [Fact]
        public void DeconstructionTypeInference_03()
        {
            var source =
@"class C
{
    void Deconstruct(out string? x, out string y)
    {
        x = string.Empty;
        y = string.Empty;
    }
    static void M()
    {
        (var x, var y) = new C();
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer `string?` for `var x`.
            comp.VerifyDiagnostics(
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(13, 13),
                // (14,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(14, 13));
        }

        [Fact]
        public void DeconstructionTypeInference_04()
        {
            var source =
@"class C
{
    static (string?, string) F() => (null, string.Empty);
    static void G()
    {
        string x;
        string? y;
        var t = ((x, y) = F());
        t.x.ToString();
        t.y.ToString();
        t.x = null;
        t.y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(10, 9),
                // (11,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t.x = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(11, 15));
        }

        [Fact]
        public void DeconstructionTypeInference_05()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static IEnumerable<(string, string?)> F() => throw new Exception();
    static void G()
    {
        foreach ((var x, var y) in F())
        {
            x.ToString();
            y.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer `string?` for `var y`.
            comp.VerifyDiagnostics();
            //// (11,13): warning CS8602: Possible dereference of a null reference.
            ////             y.ToString();
            //Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 13));
        }

        [Fact]
        public void Discard_01()
        {
            var source =
@"class C
{
    static void F((object, object?) t)
    {
        object? x;
        ((_, x) = t).Item1.ToString();
        ((x, _) = t).Item2.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29618: Should report WRN_NullReferenceReceiver.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            //// (7,9): warning CS8602: Possible dereference of a null reference.
            ////         ((x, _) = t).Item2.ToString();
            //Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((x, _) = t).Item2").WithLocation(7, 9));
        }

        [Fact]
        public void Discard_02()
        {
            // https://github.com/dotnet/roslyn/issues/29635 Need to re-infer discards
            var source =
@"class C<T>
{
" + NonNullTypesOn() + @"
    void F(object o1, object? o2, C<object> o3, C<object?> o4)
    {
        _ /*T:object*/ = o1;
        _ /*T:object*/ = o2;
        _ /*T:C<object!>*/ = o3;
        _ /*T:C<object?>*/ = o4;
    }
" + NonNullTypesOff() + @"
    void F(C<object> o)
    {
        _ /*T:C<object>*/ = o;
    }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BinaryOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string? x1, string? y1)
    {
        string z1 = x1 + y1;
    }

    void Test2(string? x2, string? y2)
    {
        string z2 = x2 + y2 ?? """";
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,21): hidden CS8607: Expression is probably never null.
                 //         string z2 = x2 + y2 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 + y2").WithLocation(15, 21)
                );
        }

        [Fact]
        public void BinaryOperator_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(dynamic? x1, dynamic? y1)
    {
        dynamic z1 = x1 + y1;
    }

    void Test2(dynamic? x2, dynamic? y2)
    {
        dynamic z2 = x2 + y2 ?? """";
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string? x1, CL0? y1)
    {
        CL0? z1 = x1 + y1;
        CL0 u1 = z1 ?? new CL0();
    }

    void Test2(string? x2, CL1? y2)
    {
        CL1 z2 = x2 + y2;
    }

    void Test3(string x3, CL0? y3, CL2 z3)
    {
        CL2 u3 = x3 + y3 + z3;
    }

    void Test4(string x4, CL1 y4, CL2 z4)
    {
        CL2 u4 = x4 + y4 + z4;
    }
}

class CL0 
{

    public static CL0 operator + (string? x, CL0 y)
    {
        return y;
    }
}

class CL1 
{

    public static CL1? operator + (string x, CL1? y)
    {
        return y;
    }
}

class CL2 
{

    public static CL2 operator + (CL0 x, CL2 y)
    {
        return y;
    }

    public static CL2 operator + (CL1 x, CL2 y)
    {
        return y;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,24): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator +(string? x, CL0 y)'.
                 //         CL0? z1 = x1 + y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL0 CL0.operator +(string? x, CL0 y)").WithLocation(10, 24),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL0 u1 = z1 ?? new CL0();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z1").WithLocation(11, 18),
                 // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1? CL1.operator +(string x, CL1? y)'.
                 //         CL1 z2 = x2 + y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL1? CL1.operator +(string x, CL1? y)").WithLocation(16, 18),
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z2 = x2 + y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 + y2").WithLocation(16, 18),
                 // (21,23): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator +(string? x, CL0 y)'.
                 //         CL2 u3 = x3 + y3 + z3;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y3").WithArguments("y", "CL0 CL0.operator +(string? x, CL0 y)").WithLocation(21, 23),
                 // (26,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL2 CL2.operator +(CL1 x, CL2 y)'.
                 //         CL2 u4 = x4 + y4 + z4;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4 + y4").WithArguments("x", "CL2 CL2.operator +(CL1 x, CL2 y)").WithLocation(26, 18)
                );
        }

        [Fact]
        public void BinaryOperator_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
        CL0 u1 = z1;
    }

    void Test2(CL0 x2, CL0? y2)
    {
        CL0? z2 = x2 && y2;
        CL0 u2 = z2 ?? new CL0();
    }
}

class CL0
{
    public static CL0 operator &(CL0 x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator false(CL0 x)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator false(CL0 x)").WithLocation(10, 19),
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator &(CL0 x, CL0? y)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator &(CL0 x, CL0? y)").WithLocation(10, 19),
                 // (17,18): hidden CS8607: Expression is probably never null.
                 //         CL0 u2 = z2 ?? new CL0();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z2").WithLocation(17, 18)
                );
        }

        [Fact]
        public void BinaryOperator_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator false(CL0 x)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator false(CL0 x)").WithLocation(10, 19),
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator &(CL0? x, CL0 y)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL0 CL0.operator &(CL0? x, CL0 y)").WithLocation(10, 25)
                );
        }

        [Fact]
        public void BinaryOperator_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 || y1;
    }
}

class CL0
{
    public static CL0 operator |(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator true(CL0 x)'.
                 //         CL0? z1 = x1 || y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator true(CL0 x)").WithLocation(10, 19)
                );
        }

        [Fact]
        public void BinaryOperator_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 || y1;
    }
}

class CL0
{
    public static CL0 operator |(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0? x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1, CL0 z1)
    {
        CL0? u1 = x1 && y1 || z1;
    }
}

class CL0
{
    public static CL0? operator &(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static CL0 operator |(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator true(CL0 x)'.
                 //         CL0? u1 = x1 && y1 || z1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1 && y1").WithArguments("x", "bool CL0.operator true(CL0 x)").WithLocation(10, 19),
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator |(CL0 x, CL0 y)'.
                 //         CL0? u1 = x1 && y1 || z1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1 && y1").WithArguments("x", "CL0 CL0.operator |(CL0 x, CL0 y)").WithLocation(10, 19)
                );
        }

        [Fact]
        public void BinaryOperator_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1, CL0? z1)
    {
        CL0? u1 = x1 && y1 || z1;
    }

    void Test2(CL0 x2, CL0? y2, CL0? z2)
    {
        CL0? u1 = x2 && y2 || z2;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static CL0 operator |(CL0 x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Action x1, System.Action y1)
    {
        System.Action u1 = x1 + y1;
    }

    void Test2(System.Action x2, System.Action y2)
    {
        System.Action u2 = x2 + y2 ?? x2;
    }

    void Test3(System.Action? x3, System.Action y3)
    {
        System.Action u3 = x3 + y3;
    }

    void Test4(System.Action? x4, System.Action y4)
    {
        System.Action u4 = x4 + y4 ?? y4;
    }

    void Test5(System.Action x5, System.Action? y5)
    {
        System.Action u5 = x5 + y5;
    }

    void Test6(System.Action x6, System.Action? y6)
    {
        System.Action u6 = x6 + y6 ?? x6;
    }

    void Test7(System.Action? x7, System.Action? y7)
    {
        System.Action u7 = x7 + y7;
    }

    void Test8(System.Action x8, System.Action y8)
    {
        System.Action u8 = x8 - y8;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,28): hidden CS8607: Expression is probably never null.
                //         System.Action u2 = x2 + y2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 + y2").WithLocation(15, 28),
                // (25,28): hidden CS8607: Expression is probably never null.
                //         System.Action u4 = x4 + y4 ?? y4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4 + y4").WithLocation(25, 28),
                // (35,28): hidden CS8607: Expression is probably never null.
                //         System.Action u6 = x6 + y6 ?? x6;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6 + y6").WithLocation(35, 28),
                // (40,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action u7 = x7 + y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7 + y7").WithLocation(40, 28),
                // (45,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action u8 = x8 - y8;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x8 - y8").WithLocation(45, 28)
                );
        }

        [Fact]
        public void BinaryOperator_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1)
    {
        CL0? u1 = x1 && !y1;
    }

    void Test2(bool x2, bool y2)
    {
        bool u2 = x2 && !y2;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0? x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }

    public static CL0? operator !(CL0 x)
    {
        return null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator &(CL0? x, CL0 y)'.
                 //         CL0? u1 = x1 && !y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "!y1").WithArguments("y", "CL0 CL0.operator &(CL0? x, CL0 y)").WithLocation(10, 25)
                );
        }

        [Fact]
        public void BinaryOperator_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1)
    {
        CL0 z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0? operator &(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 z1 = x1 && y1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1 && y1").WithLocation(10, 18)
                );
        }

        [Fact]
        public void BinaryOperator_14()
        {
            var source =
@"struct S
{
    public static S operator&(S a, S b) => a;
    public static S operator|(S a, S b) => b;
    public static bool operator true(S? s) => true;
    public static bool operator false(S? s) => false;
    static void And(S x, S? y)
    {
        if (x && x) { }
        if (x && y) { }
        if (y && x) { }
        if (y && y) { }
    }
    static void Or(S x, S? y)
    {
        if (x || x) { }
        if (x || y) { }
        if (y || x) { }
        if (y || y) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void BinaryOperator_15()
        {
            var source =
@"struct S
{
    public static S operator+(S a, S b) => a;
    static void F(S x, S? y)
    {
        S? s;
        s = x + x;
        s = x + y;
        s = y + x;
        s = y + y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void BinaryOperator_16()
        {
            var source =
@"struct S
{
    public static bool operator<(S a, S b) => true;
    public static bool operator<=(S a, S b) => true;
    public static bool operator>(S a, S b) => true;
    public static bool operator>=(S a, S b) => true;
    public static bool operator==(S a, S b) => true;
    public static bool operator!=(S a, S b) => true;
    public override bool Equals(object other) => true;
    public override int GetHashCode() => 0;
    static void F(S x, S? y)
    {
        if (x < y) { }
        if (x <= y) { }
        if (x > y) { }
        if (x >= y) { }
        if (x == y) { }
        if (x != y) { }
        if (y < x) { }
        if (y <= x) { }
        if (y > x) { }
        if (y >= x) { }
        if (y == x) { }
        if (y != x) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MethodGroupConversion_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        System.Action u1 = x1.M1;
    }

    void Test2(CL0 x2)
    {
        System.Action u2 = x2.M1;
    }
}

class CL0
{
    public void M1() {}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action u1 = x1.M1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 28)
                );
        }

        [Fact]
        public void MethodGroupConversion_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1<T>(T x){}

    void Test1()
    {
        System.Action<string?> u1 = M1<string>;
    }

    void Test2()
    {
        System.Action<string> u2 = M1<string?>;
    }

    void Test3()
    {
        System.Action<CL0<string?>> u3 = M1<CL0<string>>;
    }

    void Test4()
    {
        System.Action<CL0<string>> u4 = M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,37): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<string>(string x)' doesn't match the target delegate 'Action<string?>'.
                //         System.Action<string?> u1 = M1<string>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<string>").WithArguments("x", "void C.M1<string>(string x)", "System.Action<string?>").WithLocation(12, 37),
                // (22,42): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string>>(CL0<string> x)' doesn't match the target delegate 'Action<CL0<string?>>'.
                //         System.Action<CL0<string?>> u3 = M1<CL0<string>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<CL0<string>>").WithArguments("x", "void C.M1<CL0<string>>(CL0<string> x)", "System.Action<CL0<string?>>").WithLocation(22, 42),
                // (27,41): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string?>>(CL0<string?> x)' doesn't match the target delegate 'Action<CL0<string>>'.
                //         System.Action<CL0<string>> u4 = M1<CL0<string?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<CL0<string?>>").WithArguments("x", "void C.M1<CL0<string?>>(CL0<string?> x)", "System.Action<CL0<string>>").WithLocation(27, 41)
                );
        }

        [Fact]
        public void MethodGroupConversion_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1<T>(T x){}

    void Test1()
    {
        System.Action<string?> u1 = (System.Action<string?>)M1<string>;
    }

    void Test2()
    {
        System.Action<string> u2 = (System.Action<string>)M1<string?>;
    }

    void Test3()
    {
        System.Action<CL0<string?>> u3 = (System.Action<CL0<string?>>)M1<CL0<string>>;
    }

    void Test4()
    {
        System.Action<CL0<string>> u4 = (System.Action<CL0<string>>)M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void MethodGroupConversion_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    T M1<T>(){throw new System.Exception();}

    void Test1()
    {
        System.Func<string?> u1 = M1<string>;
    }

    void Test2()
    {
        System.Func<string> u2 = M1<string?>;
    }

    void Test3()
    {
        System.Func<CL0<string?>> u3 = M1<CL0<string>>;
    }

    void Test4()
    {
        System.Func<CL0<string>> u4 = M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (17,34): warning CS8621: Nullability of reference types in return type of 'string? C.M1<string?>()' doesn't match the target delegate 'Func<string>'.
                 //         System.Func<string> u2 = M1<string?>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<string?>").WithArguments("string? C.M1<string?>()", "System.Func<string>").WithLocation(17, 34),
                 // (22,40): warning CS8621: Nullability of reference types in return type of 'CL0<string> C.M1<CL0<string>>()' doesn't match the target delegate 'Func<CL0<string?>>'.
                 //         System.Func<CL0<string?>> u3 = M1<CL0<string>>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<CL0<string>>").WithArguments("CL0<string> C.M1<CL0<string>>()", "System.Func<CL0<string?>>").WithLocation(22, 40),
                 // (27,39): warning CS8621: Nullability of reference types in return type of 'CL0<string?> C.M1<CL0<string?>>()' doesn't match the target delegate 'Func<CL0<string>>'.
                 //         System.Func<CL0<string>> u4 = M1<CL0<string?>>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<CL0<string?>>").WithArguments("CL0<string?> C.M1<CL0<string?>>()", "System.Func<CL0<string>>").WithLocation(27, 39)
                );
        }

        [Fact]
        public void MethodGroupConversion_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    T M1<T>(){throw new System.Exception();}

    void Test1()
    {
        System.Func<string?> u1 = (System.Func<string?>)M1<string>;
    }

    void Test2()
    {
        System.Func<string> u2 = (System.Func<string>)M1<string?>;
    }

    void Test3()
    {
        System.Func<CL0<string?>> u3 = (System.Func<CL0<string?>>)M1<CL0<string>>;
    }

    void Test4()
    {
        System.Func<CL0<string>> u4 = (System.Func<CL0<string>>)M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void MethodGroupConversion_06()
        {
            var source =
@"delegate void D<T>(T t) where T : A;
class A { }
class B<T>
{
    internal void F(T t) { }
}
class C
{
    static B<T> Create<T>(T t) => new B<T>();
    static void G(A x, A? y)
    {
        D<A> d;
        d = Create(x).F;
        d = Create(y).F; // warning
        x = y;
        d = Create(x).F; // warning
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Report conversion warnings.
            comp.VerifyDiagnostics(
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(15, 13));
        }

        [Fact]
        public void UnaryOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL0 u1 = !x1;
    }

    void Test2(CL1 x2)
    {
        CL1 u2 = !x2;
    }

    void Test3(CL2? x3)
    {
        CL2 u3 = !x3;
    }

    void Test4(CL1 x4)
    {
        dynamic y4 = x4; 
        CL1 u4 = !y4;
        dynamic v4 = !y4 ?? y4; 
    }

    void Test5(bool x5)
    {
        bool u5 = !x5;
    }
}

class CL0
{
    public static CL0 operator !(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator !(CL1 x)
    {
        return new CL1();
    }
}

class CL2
{
    public static CL2 operator !(CL2? x)
    {
        return new CL2();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator !(CL0 x)'.
                //         CL0 u1 = !x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator !(CL0 x)").WithLocation(10, 19),
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u2 = !x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "!x2").WithLocation(15, 18)
                );
        }

        [Fact]
        public void UnaryOperator_02()
        {
            var source =
@"struct S
{
    public static S operator~(S s) => s;
    static void F(S? s)
    {
        s = ~s;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Conversion_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL1 u1 = x1;
    }

    void Test2(CL0? x2, CL0 y2)
    {
        int u2 = x2;
        long v2 = x2;
        int w2 = y2;
    }

    void Test3(CL0 x3)
    {
        CL2 u3 = x3;
    }

    void Test4(CL0 x4)
    {
        CL3? u4 = x4;
        CL3 v4 = u4 ?? new CL3();
    }

    void Test5(dynamic? x5)
    {
        CL3 u5 = x5;
    }

    void Test6(dynamic? x6)
    {
        CL3? u6 = x6;
        CL3 v6 = u6 ?? new CL3();
    }

    void Test7(CL0? x7)
    {
        dynamic u7 = x7;
    }

    void Test8(CL0 x8)
    {
        dynamic? u8 = x8;
        dynamic v8 = u8 ?? x8;
    }

    void Test9(dynamic? x9)
    {
        object u9 = x9;
    }

    void Test10(object? x10)
    {
        dynamic u10 = x10;
    }

    void Test11(CL4? x11)
    {
        CL3 u11 = x11;
    }

    void Test12(CL3? x12)
    {
        CL4 u12 = (CL4)x12;
    }

    void Test13(int x13)
    {
        object? u13 = x13;
        object v13 = u13 ?? new object();
    }

    void Test14<T>(T x14)
    {
        object u14 = x14;
        object v14 = ((object)x14) ?? new object();
    }

    void Test15(int? x15)
    {
        object u15 = x15;
    }

    void Test16()
    {
        System.IFormattable? u16 = $""{3}"";
        object v16 = u16 ?? new object();
    }
}

class CL0
{
    public static implicit operator CL1(CL0 x) { return new CL1(); }
    public static implicit operator int(CL0 x) { return 0; }
    public static implicit operator long(CL0? x) { return 0; }
    public static implicit operator CL2?(CL0 x) { return new CL2(); }
    public static implicit operator CL3(CL0? x) { return new CL3(); }
}

class CL1 {}
class CL2 {}
class CL3 {}
class CL4 : CL3 {}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0.implicit operator CL1(CL0 x)'.
                //         CL1 u1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0.implicit operator CL1(CL0 x)").WithLocation(10, 18),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0.implicit operator int(CL0 x)'.
                //         int u2 = x2;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0.implicit operator int(CL0 x)").WithLocation(15, 18),
                // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL2 u3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(22, 18),
                // (28,18): hidden CS8607: Expression is probably never null.
                //         CL3 v4 = u4 ?? new CL3();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(28, 18),
                // (33,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL3 u5 = x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(33, 18),
                // (44,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u7 = x7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7").WithLocation(44, 22),
                // (50,22): hidden CS8607: Expression is probably never null.
                //         dynamic v8 = u8 ?? x8;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u8").WithLocation(50, 22),
                // (55,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u9 = x9;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x9").WithLocation(55, 21),
                // (60,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u10 = x10;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10").WithLocation(60, 23),
                // (65,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL3 u11 = x11;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(65, 19),
                // (70,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL4 u12 = (CL4)x12;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(CL4)x12").WithLocation(70, 19),
                // (70,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL4 u12 = (CL4)x12;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(CL4)x12").WithLocation(70, 19),
                // (76,22): hidden CS8607: Expression is probably never null.
                //         object v13 = u13 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u13").WithLocation(76, 22),
                // (81,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u14 = x14;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x14").WithLocation(81, 22),
                // (82,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object v14 = ((object)x14) ?? new object();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x14").WithLocation(82, 23),
                // (87,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u15 = x15;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x15").WithLocation(87, 22),
                // (93,22): hidden CS8607: Expression is probably never null.
                //         object v16 = u16 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u16").WithLocation(93, 22)
                );
        }

        [Fact]
        public void Conversion_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0<string?> x1)
    {
        CL0<string> u1 = x1;
        CL0<string> v1 = (CL0<string>)x1;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,26): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         CL0<string> u1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(10, 26),
                // (11,26): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         CL0<string> v1 = (CL0<string>)x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(CL0<string>)x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(11, 26)
                );
        }

        [Fact]
        public void ImplicitConversions_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F1(B<object> x1)
    {
        A<object?> y1 = x1;
        y1 = x1;
        y1 = x1!;
    }
    static void F2(B<object?> x2)
    {
        A<object> y2 = x2;
        y2 = x2;
        y2 = x2!;
    }
    static void F3(B<object>? x3)
    {
        A<object?> y3 = x3;
        y3 = x3;
        y3 = x3!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,25): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         A<object?> y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("B<object>", "A<object?>").WithLocation(7, 25),
                // (8,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("B<object>", "A<object?>").WithLocation(8, 14),
                // (9,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y1 = x1!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1!").WithArguments("B<object>", "A<object?>").WithLocation(9, 14),
                // (13,24): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         A<object> y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("B<object?>", "A<object>").WithLocation(13, 24),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("B<object?>", "A<object>").WithLocation(14, 14),
                // (15,14): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         y2 = x2!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2!").WithArguments("B<object?>", "A<object>").WithLocation(15, 14),
                // (19,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(19, 25),
                // (19,25): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         A<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "A<object?>").WithLocation(19, 25),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(20, 14),
                // (20,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "A<object?>").WithLocation(20, 14),
                // (21,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y3 = x3!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3!").WithArguments("B<object>", "A<object?>").WithLocation(21, 14)
                );
        }

        [Fact]
        public void ImplicitConversions_02()
        {
            var source =
@"interface IA<T> { }
interface IB<T> : IA<T> { }
class C
{
    static void F1(IB<object> x1)
    {
        IA<object?> y1 = x1;
        y1 = x1;
        y1 = x1!;
    }
    static void F2(IB<object?> x2)
    {
        IA<object> y2 = x2;
        y2 = x2;
        y2 = x2!;
    }
    static void F3(IB<object>? x3)
    {
        IA<object?> y3 = x3;
        y3 = x3;
        y3 = x3!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,26): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         IA<object?> y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("IB<object>", "IA<object?>").WithLocation(7, 26),
                // (8,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("IB<object>", "IA<object?>").WithLocation(8, 14),
                // (9,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y1 = x1!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1!").WithArguments("IB<object>", "IA<object?>").WithLocation(9, 14),
                // (13,25): warning CS8619: Nullability of reference types in value of type 'IB<object?>' doesn't match target type 'IA<object>'.
                //         IA<object> y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IB<object?>", "IA<object>").WithLocation(13, 25),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'IB<object?>' doesn't match target type 'IA<object>'.
                //         y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IB<object?>", "IA<object>").WithLocation(14, 14),
                // (15,14): warning CS8619: Nullability of reference types in value of type 'IB<object?>' doesn't match target type 'IA<object>'.
                //         y2 = x2!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2!").WithArguments("IB<object?>", "IA<object>").WithLocation(15, 14),
                // (19,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         IA<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(19, 26),
                // (19,26): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         IA<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("IB<object>", "IA<object?>").WithLocation(19, 26),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(20, 14),
                // (20,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("IB<object>", "IA<object?>").WithLocation(20, 14),
                // (21,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y3 = x3!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3!").WithArguments("IB<object>", "IA<object?>").WithLocation(21, 14));
        }

        [Fact]
        public void ImplicitConversions_03()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static void F(IOut<object> x)
    {
        IOut<object?> y = x;
    }
    static void G(IOut<object?> x)
    {
        IOut<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,26): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(10, 26));
        }

        [Fact]
        public void ImplicitConversions_04()
        {
            var source =
@"interface IIn<in T> { }
class C
{
    static void F(IIn<object> x)
    {
        IIn<object?> y = x;
    }
    static void G(IIn<object?> x)
    {
        IIn<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,26): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(6, 26));
        }

        [Fact]
        public void ImplicitConversions_05()
        {
            var source =
@"interface IOut<out T> { }
class A<T> : IOut<T> { }
class C
{
    static void F(A<string> x)
    {
        IOut<object?> y = x;
    }
    static void G(A<string?> x)
    {
        IOut<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,26): warning CS8619: Nullability of reference types in value of type 'A<string?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<string?>", "IOut<object>").WithLocation(11, 26));
        }

        [Fact]
        public void ImplicitConversions_06()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : IIn<object>, IOut<object?> { }
class B : IIn<object>, IOut<object?> { }
class C
{
    static void F(A<string> a1, B b1)
    {
        IIn<object?> y = a1;
        y = b1;
        IOut<object?> z = a1;
        z = b1;
    }
    static void G(A<string> a2, B b2)
    {
        IIn<object> y = a2;
        y = b2;
        IOut<object> z = a2;
        z = b2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29897: Report the base types that did not match
            // rather than the derived or implementing type. For instance, report `'IIn<object>'
            // doesn't match ... 'IIn<object?>'` rather than `'A<string>' doesn't match ...`.
            comp.VerifyDiagnostics(
                // (9,26): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> y = a1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("A<string>", "IIn<object?>").WithLocation(9, 26),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'B' doesn't match target type 'IIn<object?>'.
                //         y = b1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("B", "IIn<object?>").WithLocation(10, 13),
                // (18,26): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'IOut<object>'.
                //         IOut<object> z = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("A<string>", "IOut<object>").WithLocation(18, 26),
                // (19,13): warning CS8619: Nullability of reference types in value of type 'B' doesn't match target type 'IOut<object>'.
                //         z = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("B", "IOut<object>").WithLocation(19, 13));
        }

        [Fact]
        public void ImplicitConversions_07()
        {
            var source =
@"class A<T>
{
}
class B<T>
{
    public static implicit operator A<T>(B<T> b) => throw null;
}
class C
{
    static B<T> F<T>(T t) => throw null;
    static void G(A<object?> a) => throw null;
    static void Main(object? x)
    {
        var y = F(x);
        G(y);
        if (x == null) return;
        var z =  F(x);
        G(z); // warning
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29898: Report warning for `G(z)`?
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void IdentityConversion_LocalDeclaration()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
interface IBoth<in T, out U> { }
class C
{
    static void F1(I<object> x1, IIn<object> y1, IOut<object> z1, IBoth<object, object> w1)
    {
        I<object?> a1 = x1;
        IIn<object?> b1 = y1;
        IOut<object?> c1 = z1;
        IBoth<object?, object?> d1 = w1;
    }
    static void F2(I<object?> x2, IIn<object?> y2, IOut<object?> z2, IBoth<object?, object?> w2)
    {
        I<object> a2 = x2;
        IIn<object> b2 = y2;
        IOut<object> c2 = z2;
        IBoth<object, object> d2 = w2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,25): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         I<object?> a1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(9, 25),
                // (10,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> b1 = y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object>", "IIn<object?>").WithLocation(10, 27),
                // (12,38): warning CS8619: Nullability of reference types in value of type 'IBoth<object, object>' doesn't match target type 'IBoth<object?, object?>'.
                //         IBoth<object?, object?> d1 = w1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w1").WithArguments("IBoth<object, object>", "IBoth<object?, object?>").WithLocation(12, 38),
                // (16,24): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         I<object> a2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<object?>", "I<object>").WithLocation(16, 24),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> c2 = z2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z2").WithArguments("IOut<object?>", "IOut<object>").WithLocation(18, 27),
                // (19,36): warning CS8619: Nullability of reference types in value of type 'IBoth<object?, object?>' doesn't match target type 'IBoth<object, object>'.
                //         IBoth<object, object> d2 = w2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w2").WithArguments("IBoth<object?, object?>", "IBoth<object, object>").WithLocation(19, 36));
        }

        [Fact]
        public void IdentityConversion_Assignment()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
interface IBoth<in T, out U> { }
class C
{
    static void F1(I<object> x1, IIn<object> y1, IOut<object> z1, IBoth<object, object> w1)
    {
        I<object?> a1;
        a1 = x1;
        IIn<object?> b1;
        b1 = y1;
        IOut<object?> c1;
        c1 = z1;
        IBoth<object?, object?> d1;
        d1 = w1;
    }
    static void F2(I<object?> x2, IIn<object?> y2, IOut<object?> z2, IBoth<object?, object?> w2)
    {
        I<object> a2;
        a2 = x2;
        IIn<object> b2;
        b2 = y2;
        IOut<object> c2;
        c2 = z2;
        IBoth<object, object> d2;
        d2 = w2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,14): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         a1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(10, 14),
                // (12,14): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b1 = y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object>", "IIn<object?>").WithLocation(12, 14),
                // (16,14): warning CS8619: Nullability of reference types in value of type 'IBoth<object, object>' doesn't match target type 'IBoth<object?, object?>'.
                //         d1 = w1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w1").WithArguments("IBoth<object, object>", "IBoth<object?, object?>").WithLocation(16, 14),
                // (21,14): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<object?>", "I<object>").WithLocation(21, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         c2 = z2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z2").WithArguments("IOut<object?>", "IOut<object>").WithLocation(25, 14),
                // (27,14): warning CS8619: Nullability of reference types in value of type 'IBoth<object?, object?>' doesn't match target type 'IBoth<object, object>'.
                //         d2 = w2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w2").WithArguments("IBoth<object?, object?>", "IBoth<object, object>").WithLocation(27, 14));
        }

        [Fact]
        public void IdentityConversion_Argument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object> x, IIn<object> y, IOut<object> z)
    {
        G(x, y, z);
    }
    static void G(I<object?> x, IIn<object?> y, IOut<object?> z)
    {
        F(x, y, z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)'.
                //         G(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)").WithLocation(8, 11),
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)'.
                //         G(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)").WithLocation(8, 14),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(I<object> x, IIn<object> y, IOut<object> z)'.
                //         F(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(I<object> x, IIn<object> y, IOut<object> z)").WithLocation(12, 11),
                // (12,17): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(I<object> x, IIn<object> y, IOut<object> z)'.
                //         F(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(I<object> x, IIn<object> y, IOut<object> z)").WithLocation(12, 17));
        }

        [Fact]
        public void IdentityConversion_OutArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(out I<object> x, out IIn<object> y, out IOut<object> z)
    {
        G(out x, out y, out z);
    }
    static void G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)
    {
        F(out x, out y, out z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,15): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)'.
                //         G(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)").WithLocation(8, 15),
                // (8,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object>' doesn't match target type 'IOut<object?>' for parameter 'z' in 'void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)'.
                //         G(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object>", "IOut<object?>", "z", "void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)").WithLocation(8, 29),
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)'.
                //         F(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)").WithLocation(12, 15),
                // (12,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object?>' doesn't match target type 'IIn<object>' for parameter 'y' in 'void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)'.
                //         F(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object?>", "IIn<object>", "y", "void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)").WithLocation(12, 22));
        }

        [Fact]
        public void IdentityConversion_RefArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)
    {
        G(ref x, ref y, ref z);
    }
    static void G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)
    {
        F(ref x, ref y, ref z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,15): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 15),
                // (8,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 22),
                // (8,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object>' doesn't match target type 'IOut<object?>' for parameter 'z' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object>", "IOut<object?>", "z", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 29),
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 15),
                // (12,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object?>' doesn't match target type 'IIn<object>' for parameter 'y' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object?>", "IIn<object>", "y", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 22),
                // (12,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 29));
        }

        [Fact]
        public void IdentityConversion_InArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(in I<object> x, in IIn<object> y, in IOut<object> z)
    {
        G(in x, in y, in z);
    }
    static void G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)
    {
        F(in x, in y, in z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)'.
                //         G(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)").WithLocation(8, 14),
                // (8,20): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)'.
                //         G(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)").WithLocation(8, 20),
                // (12,14): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)'.
                //         F(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)").WithLocation(12, 14),
                // (12,26): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)'.
                //         F(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)").WithLocation(12, 26));
        }

        [Fact]
        public void IdentityConversion_ExtensionThis()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
static class E
{
    static void F1(object x, object? y)
    {
        x.F1A();
        y.F1A();
        x.F1B();
        y.F1B(); // 1
    }
    static void F1A(this object? o) { }
    static void F1B(this object o) { }
    static void F2(I<object> x, I<object?> y)
    {
        x.F2A(); // 2
        y.F2A();
        x.F2B();
        y.F2B(); // 3
    }
    static void F2A(this I<object?> o) { }
    static void F2B(this I<object> o) { }
    static void F3(IIn<object> x, IIn<object?> y)
    {
        x.F3A(); // 4
        y.F3A();
        x.F3B();
        y.F3B();
    }
    static void F3A(this IIn<object?> o) { }
    static void F3B(this IIn<object> o) { }
    static void F4(IOut<object> x, IOut<object?> y)
    {
        x.F4A();
        y.F4A();
        x.F4B();
        y.F4B(); // 5
    }
    static void F4A(this IOut<object?> o) { }
    static void F4B(this IOut<object> o) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8604: Possible null reference argument for parameter 'o' in 'void E.F1B(object o)'.
                //         y.F1B(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("o", "void E.F1B(object o)").WithLocation(11, 9),
                // (17,9): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'o' in 'void E.F2A(I<object?> o)'.
                //         x.F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "o", "void E.F2A(I<object?> o)").WithLocation(17, 9),
                // (20,9): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'o' in 'void E.F2B(I<object> o)'.
                //         y.F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "o", "void E.F2B(I<object> o)").WithLocation(20, 9),
                // (26,9): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'o' in 'void E.F3A(IIn<object?> o)'.
                //         x.F3A(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<object>", "IIn<object?>", "o", "void E.F3A(IIn<object?> o)").WithLocation(26, 9),
                // (38,9): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'o' in 'void E.F4B(IOut<object> o)'.
                //         y.F4B(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IOut<object?>", "IOut<object>", "o", "void E.F4B(IOut<object> o)").WithLocation(38, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29899: Clone this method using types from unannotated assemblies
        // rather than `x!`, particularly because `x!` results in IsNullable=false rather than IsNullable=null.
        [Fact]
        public void IdentityConversion_TypeInference_IsNullableNull()
        {
            var source =
@"class A<T>
{
}
class B
{
    static T F1<T>(T x, T y)
    {
        return x;
    }
    static void G1(object? x, object y)
    {
        F1(x, x!).ToString();
        F1(x!, x).ToString();
        F1(y, y!).ToString();
        F1(y!, y).ToString();
    }
    static T F2<T>(A<T> x, A<T> y)
    {
        throw new System.Exception();
    }
    static void G(A<object?> z, A<object> w)
    {
        F2(z, z!).ToString();
        F2(z!, z).ToString();
        F2(w, w!).ToString();
        F2(w!, w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         F1(x, x!).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(x, x!)").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         F1(x!, x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(x!, x)").WithLocation(13, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         F2(z, z!).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F2(z, z!)").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         F2(z!, z).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F2(z!, z)").WithLocation(24, 9));
        }

        [Fact]
        public void IdentityConversion_IndexerArgumentsOrder()
        {
            var source =
@"interface I<T> { }
class C
{
    static object F(C c, I<string> x, I<object> y)
    {
        return c[
            y: y, // warn 1
            x: x];
    }
    static object G(C c, I<string?> x, I<object?> y)
    {
        return c[
            y: y,
            x: x]; // warn 2
    }
    object this[I<string> x, I<object?> y] => new object();
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,16): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'object C.this[I<string> x, I<object?> y]'.
                //             y: y, // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object>", "I<object?>", "y", "object C.this[I<string> x, I<object?> y]").WithLocation(7, 16),
                // (14,16): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'object C.this[I<string> x, I<object?> y]'.
                //             x: x]; // warn 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<string?>", "I<string>", "x", "object C.this[I<string> x, I<object?> y]").WithLocation(14, 16));
        }

        [Fact]
        public void IncrementOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL0? u1 = ++x1;
        CL0 v1 = u1 ?? new CL0(); 
        CL0 w1 = x1 ?? new CL0(); 
    }
    void Test2(CL0? x2)
    {
        CL0 u2 = x2++;
        CL0 v2 = x2 ?? new CL0();
    }
    void Test3(CL1? x3)
    {
        CL1 u3 = --x3;
        CL1 v3 = x3;
    }
    void Test4(CL1 x4)
    {
        CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable parameter.
        CL1 v4 = u4 ?? new CL1(); 
        CL1 w4 = x4 ?? new CL1();
    }
    void Test5(CL1 x5)
    {
        CL1 u5 = --x5;
    }

    void Test6(CL1 x6)
    {
        x6--; 
    }

    void Test7()
    {
        CL1 x7;
        x7--; 
    }
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         CL0 w1 = x1 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 18),
                // (17,18): hidden CS8607: Expression is probably never null.
                //         CL0 v2 = x2 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(17, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 18),
                // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 v3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(22, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable parameter.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5").WithLocation(32, 18),
                // (37,9): warning CS8601: Possible null reference assignment.
                //         x6--; 
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6--").WithLocation(37, 9),
                // (43,9): error CS0165: Use of unassigned local variable 'x7'
                //         x7--; 
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x7").WithArguments("x7").WithLocation(43, 9)
                );
        }

        [Fact]
        public void IncrementOperator_02()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        CL0? u1 = ++x1;
        CL0 v1 = u1 ?? new CL0(); 
    }

    void Test2()
    {
        CL0 u2 = x2++;
    }

    void Test3()
    {
        CL1 u3 = --x3;
    }

    void Test4()
    {
        CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable property.
        CL1 v4 = u4 ?? new CL1(); 
    }

    void Test5(CL1 x5)
    {
        CL1 u5 = --x5;
    }

    CL0? x1 {get; set;}
    CL0? x2 {get; set;}
    CL1? x3 {get; set;}
    CL1 x4 {get; set;}
    CL1 x5 {get; set;}
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable property.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5").WithLocation(32, 18)
                );
        }

        [Fact]
        public void IncrementOperator_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(X1 x1)
    {
        CL0? u1 = ++x1[0];
        CL0 v1 = u1 ?? new CL0(); 
    }

    void Test2(X1 x2)
    {
        CL0 u2 = x2[0]++;
    }

    void Test3(X3 x3)
    {
        CL1 u3 = --x3[0];
    }

    void Test4(X4 x4)
    {
        CL1? u4 = x4[0]--; // Result of increment is nullable, storing it in not nullable parameter.
        CL1 v4 = u4 ?? new CL1(); 
    }

    void Test5(X4 x5)
    {
        CL1 u5 = --x5[0];
    }
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}

class X1
{
    public CL0? this[int x]
    {
        get { return null; }
        set { }
    }
}

class X3
{
    public CL1? this[int x]
    {
        get { return null; }
        set { }
    }
}

class X4
{
    public CL1 this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1[0];
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1[0]").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2[0]++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2[0]").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2[0]++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2[0]++").WithLocation(16, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3[0]").WithLocation(21, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4[0]--; // Result of increment is nullable, storing it in not nullable parameter.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4[0]--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5[0];
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5[0]").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5[0]").WithLocation(32, 18)
                );
        }

        [Fact]
        public void IncrementOperator_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(dynamic? x1)
    {
        dynamic? u1 = ++x1;
        dynamic v1 = u1 ?? new object(); 
    }

    void Test2(dynamic? x2)
    {
        dynamic u2 = x2++;
    }

    void Test3(dynamic? x3)
    {
        dynamic u3 = --x3;
    }

    void Test4(dynamic x4)
    {
        dynamic? u4 = x4--; 
        dynamic v4 = u4 ?? new object(); 
    }

    void Test5(dynamic x5)
    {
        dynamic u5 = --x5;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (16,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 22),
                // (21,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 22),
                // (27,22): hidden CS8607: Expression is probably never null.
                //         dynamic v4 = u4 ?? new object(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 22)
                );
        }

        [Fact]
        public void IncrementOperator_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(B? x1)
    {
        B? u1 = ++x1;
        B v1 = u1 ?? new B(); 
    }
}

class A
{
    public static C? operator ++(A x)
    {
        return new C();
    }
}

class C : A
{
    public static implicit operator B(C x)
    {
        return new B();
    }
}

class B : A
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'C? A.operator ++(A x)'.
                 //         B? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "C? A.operator ++(A x)").WithLocation(10, 19),
                 // (10,17): warning CS8604: Possible null reference argument for parameter 'x' in 'C.implicit operator B(C x)'.
                 //         B? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "++x1").WithArguments("x", "C.implicit operator B(C x)").WithLocation(10, 17),
                 // (11,16): hidden CS8607: Expression is probably never null.
                 //         B v1 = u1 ?? new B(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 16)
                );
        }

        [Fact]
        public void IncrementOperator_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(B x1)
    {
        B u1 = ++x1;
    }
}

class A
{
    public static C operator ++(A x)
    {
        return new C();
    }
}

class C : A
{
    public static implicit operator B?(C x)
    {
        return new B();
    }
}

class B : A
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,16): warning CS8601: Possible null reference assignment.
                //         B u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "++x1").WithLocation(10, 16),
                // (10,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         B u1 = ++x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "++x1").WithLocation(10, 16)
                );
        }

        [Fact]
        public void IncrementOperator_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(Convertible? x1)
    {
        Convertible? u1 = ++x1;
        Convertible v1 = u1 ?? new Convertible(); 
    }

    void Test2(int? x2)
    {
        var u2 = ++x2;
    }

    void Test3(byte x3)
    {
        var u3 = ++x3;
    }
}

class Convertible
{
    public static implicit operator int(Convertible c)
    {
        return 0;
    }

    public static implicit operator Convertible(int i)
    {
        return new Convertible();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,29): warning CS8604: Possible null reference argument for parameter 'c' in 'Convertible.implicit operator int(Convertible c)'.
                 //         Convertible? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("c", "Convertible.implicit operator int(Convertible c)").WithLocation(10, 29),
                 // (11,26): hidden CS8607: Expression is probably never null.
                 //         Convertible v1 = u1 ?? new Convertible(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 26)
                );
        }

        [Fact]
        public void CompoundAssignment_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0 y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1? x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL1 CL0.operator +(CL0 x, CL0 y)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL1 CL0.operator +(CL0 x, CL0 y)").WithLocation(10, 25),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }

    void Test2(CL0? x2, CL0 y2)
    {
        CL0 u2 = x2 += y2;
        CL0 w2 = x2; 
    }

    void Test3(CL0? x3, CL0 y3)
    {
        x3 = new CL0();
        CL0 u3 = x3 += y3;
        CL0 w3 = x3; 
    }

    void Test4(CL0? x4, CL0 y4)
    {
        x4 = new CL0();
        x4 += y4;
        CL0 w4 = x4; 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0? y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0?(CL1? x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL0.operator +(CL0 x, CL0? y)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1 CL0.operator +(CL0 x, CL0? y)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                 // (17,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL0.operator +(CL0 x, CL0? y)'.
                 //         CL0 u2 = x2 += y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL1 CL0.operator +(CL0 x, CL0? y)").WithLocation(17, 18),
                 // (17,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 u2 = x2 += y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 += y2").WithLocation(17, 18),
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w2 = x2; 
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(18, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 u3 = x3 += y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 += y3").WithLocation(24, 18),
                 // (25,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w3 = x3; 
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(25, 18),
                 // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w4 = x4; 
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4").WithLocation(32, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        x1 = new CL1();
        CL1? u1 = x1 += y1;
        CL1 w1 = x1;
        w1 = u1; 
    }

    void Test2(CL1 x2, CL0 y2)
    {
        CL1 u2 = x2 += y2;
        CL1 w2 = x2; 
    }

    void Test3(CL1 x3, CL0 y3)
    {
        x3 += y3;
    }

    void Test4(CL0? x4, CL0 y4)
    {
        CL0? u4 = x4 += y4;
        CL0 v4 = u4 ?? new CL0(); 
        CL0 w4 = x4 ?? new CL0(); 
    }

    void Test5(CL0 x5, CL0 y5)
    {
        x5 += y5;
    }

    void Test6(CL0 y6)
    {
        CL1 x6;
        x6 += y6;
    }
}

class CL0
{
    public static CL1? operator +(CL0 x, CL0? y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 w1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(12, 18),
                // (13,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         w1 = u1; 
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u1").WithLocation(13, 14),
                // (18,18): warning CS8601: Possible null reference assignment.
                //         CL1 u2 = x2 += y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x2 += y2").WithLocation(18, 18),
                // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u2 = x2 += y2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 += y2").WithLocation(18, 18),
                // (19,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 w2 = x2; 
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(19, 18),
                // (24,9): warning CS8601: Possible null reference assignment.
                //         x3 += y3;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x3 += y3").WithLocation(24, 9),
                // (29,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1? CL0.operator +(CL0 x, CL0? y)'.
                //         CL0? u4 = x4 += y4;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("x", "CL1? CL0.operator +(CL0 x, CL0? y)").WithLocation(29, 19),
                // (29,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         CL0? u4 = x4 += y4;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4 += y4").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(29, 19),
                // (30,18): hidden CS8607: Expression is probably never null.
                //         CL0 v4 = u4 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(30, 18),
                // (31,18): hidden CS8607: Expression is probably never null.
                //         CL0 w4 = x4 ?? new CL0(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4").WithLocation(31, 18),
                // (36,9): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         x5 += y5;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x5 += y5").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(36, 9),
                // (42,9): error CS0165: Use of unassigned local variable 'x6'
                //         x6 += y6;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x6").WithArguments("x6").WithLocation(42, 9),
                // (42,9): warning CS8601: Possible null reference assignment.
                //         x6 += y6;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6 += y6").WithLocation(42, 9));
        }

        [Fact]
        public void CompoundAssignment_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(int x1, int y1)
    {
        var u1 = x1 += y1;
    }

    void Test2(int? x2, int y2)
    {
        var u2 = x2 += y2;
    }

    void Test3(dynamic? x3, dynamic? y3)
    {
        dynamic? u3 = x3 += y3;
        dynamic v3 = u3;
        dynamic w3 = u3 ?? v3;
    }

    void Test4(dynamic? x4, dynamic? y4)
    {
        dynamic u4 = x4 += y4;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void CompoundAssignment_06()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class Test
{
    static void Main()
    {
    }

    void Test1(CL0 y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }

    void Test2(CL0 y2)
    {
        CL1? u2 = x2 += y2;
        CL1 v2 = u2 ?? new CL1(); 
        CL1 w2 = x2 ?? new CL1(); 
    }

    CL1? x1 {get; set;}
    CL1 x2 {get; set;}
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         CL1? u1 = x1 += y1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL1 v1 = u1 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         CL1 w1 = x1 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                // (18,18): hidden CS8607: Expression is probably never null.
                //         CL1 v2 = u2 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2").WithLocation(18, 18),
                // (19,18): hidden CS8607: Expression is probably never null.
                //         CL1 w2 = x2 ?? new CL1(); 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(19, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL2 x1, CL0 y1)
    {
        CL1? u1 = x1[0] += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1[0] ?? new CL1(); 
    }

    void Test2(CL3 x2, CL0 y2)
    {
        CL1? u2 = x2[0] += y2;
        CL1 v2 = u2 ?? new CL1(); 
        CL1 w2 = x2[0] ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}

class CL2
{
    public CL1? this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}

class CL3
{
    public CL1 this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                 //         CL1? u1 = x1[0] += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1[0]").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (18,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v2 = u2 ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2").WithLocation(18, 18),
                 // (19,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w2 = x2[0] ?? new CL1(); 
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[0]").WithLocation(19, 18)
                );
        }

        [Fact]
        public void IdentityConversion_CompoundAssignment()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    public static I<object> operator+(I<object> x, C y) => x;
    public static IIn<object> operator+(IIn<object> x, C y) => x;
    public static IOut<object> operator+(IOut<object> x, C y) => x;
    static void F(C c, I<object> x, I<object?> y)
    {
        x += c;
        y += c;
    }
    static void F(C c, IIn<object> x, IIn<object?> y)
    {
        x += c;
        y += c;
    }
    static void F(C c, IOut<object> x, IOut<object?> y)
    {
        x += c;
        y += c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // https://github.com/dotnet/roslyn/issues/29900: Report WRN_NullabilityMismatchInAssignment for compound assignment.
                //// (12,9): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                ////         y += c;
                //Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(12, 9),
                // (12,9): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y += c").WithArguments("I<object>", "I<object?>").WithLocation(12, 9),
                // (17,9): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y += c").WithArguments("IIn<object>", "IIn<object?>").WithLocation(17, 9)
                //// (22,9): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                ////         y += c;
                //Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(22, 9)
                );
        }

        [Fact]
        public void Events_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    event System.Action? E1;

    void Test1()
    {
        E1();
    }

    delegate void D2 (object x);
    event D2 E2;

    void Test2()
    {
        E2(null);
    }

    delegate object? D3 ();
    event D3 E3;

    void Test3()
    {
        object x3 = E3();
    }

    void Test4()
    {
                    //E1?();
        System.Action? x4 = E1;
                    //x4?();
    }

    void Test5()
    {
        System.Action x5 = E1;
    }

    void Test6(D2? x6)
    {
        E2 = x6;
    }

    void Test7(D2? x7)
    {
        E2 += x7;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         E1();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "E1").WithLocation(12, 9),
                // (20,12): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         E2(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 12),
                // (28,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x3 = E3();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E3()").WithLocation(28, 21),
                // (40,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action x5 = E1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E1").WithLocation(40, 28),
                // (45,14): warning CS8601: Possible null reference assignment.
                //         E2 = x6;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6").WithLocation(45, 14)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29901: Events are not tracked for structs.
        // (This should be fixed if/when struct member state is populated lazily.)
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29901")]
        [WorkItem(29901, "https://github.com/dotnet/roslyn/issues/29901")]
        public void Events_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }
}

struct TS1
{
    event System.Action? E1;

    TS1(System.Action x1) 
    {
        E1 = x1;
        System.Action y1 = E1 ?? x1;

        E1 = x1;
        TS1 z1 = this;
        y1 = z1.E1 ?? x1;
    }

    void Test3(System.Action x3)
    {
        TS1 s3;
        s3.E1 = x3;
        System.Action y3 = s3.E1 ?? x3;

        s3.E1 = x3;
        TS1 z3 = s3;
        y3 = z3.E1 ?? x3;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,28): hidden CS8607: Expression is probably never null.
                 //         System.Action y1 = E1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(16, 28),
                 // (20,14): hidden CS8607: Expression is probably never null.
                 //         y1 = z1.E1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z1.E1").WithLocation(20, 14),
                 // (27,28): hidden CS8607: Expression is probably never null.
                 //         System.Action y3 = s3.E1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "s3.E1").WithLocation(27, 28),
                 // (31,14): hidden CS8607: Expression is probably never null.
                 //         y3 = z3.E1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z3.E1").WithLocation(31, 14)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29901: Events are not tracked for structs.
        // (This should be fixed if/when struct member state is populated lazily.)
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29901")]
        [WorkItem(29901, "https://github.com/dotnet/roslyn/issues/29901")]
        public void Events_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }
}

struct TS2
{
    event System.Action? E2;

    TS2(System.Action x2) 
    {
        this = new TS2();
        System.Action z2 = E2;
        System.Action y2 = E2 ?? x2;
    }
}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action z2 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(16, 28)
                );
        }

        [Fact]
        public void Events_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL0? x1, System.Action? y1)
    {
        System.Action v1 = x1.E1 += y1;
    }

    void Test2(CL0? x2, System.Action? y2)
    {
        System.Action v2 = x2.E1 -= y2;
    }
}

class CL0
{
    public event System.Action? E1;

    void Dummy()
    {
        var x = E1;
    }
}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,28): error CS0029: Cannot implicitly convert type 'void' to 'System.Action'
                 //         System.Action v1 = x1.E1 += y1;
                 Diagnostic(ErrorCode.ERR_NoImplicitConv, "x1.E1 += y1").WithArguments("void", "System.Action").WithLocation(10, 28),
                 // (10,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v1 = x1.E1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 28),
                 // (15,28): error CS0029: Cannot implicitly convert type 'void' to 'System.Action'
                 //         System.Action v2 = x2.E1 -= y2;
                 Diagnostic(ErrorCode.ERR_NoImplicitConv, "x2.E1 -= y2").WithArguments("void", "System.Action").WithLocation(15, 28),
                 // (15,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v2 = x2.E1 -= y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(15, 28)
                );
        }

        [Fact]
        public void Events_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    public event System.Action E1;

    void Test1(Test? x1)
    {
        System.Action v1 = x1.E1;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v1 = x1.E1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 28)
                );
        }

        [Fact]
        public void AsOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1 x1)
    {
        object y1 = x1 as object ?? new object();
    }

    void Test2(int x2)
    {
        object y2 = x2 as object ?? new object();
    }

    void Test3(CL1? x3)
    {
        object y3 = x3 as object;
    }

    void Test4(int? x4)
    {
        object y4 = x4 as object;
    }

    void Test5(object x5)
    {
        CL1 y5 = x5 as CL1;
    }

    void Test6()
    {
        CL1 y6 = null as CL1;
    }

    void Test7<T>(T x7)
    {
        CL1 y7 = x7 as CL1;
    }
}

class CL1 {}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,21): hidden CS8607: Expression is probably never null.
                 //         object y1 = x1 as object ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1 as object").WithLocation(10, 21),
                 // (15,21): hidden CS8607: Expression is probably never null.
                 //         object y2 = x2 as object ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 as object").WithLocation(15, 21),
                 // (20,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object y3 = x3 as object;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 as object").WithLocation(20, 21),
                 // (25,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object y4 = x4 as object;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4 as object").WithLocation(25, 21),
                 // (30,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y5 = x5 as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5 as CL1").WithLocation(30, 18),
                 // (35,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y6 = null as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null as CL1").WithLocation(35, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y7 = x7 as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7 as CL1").WithLocation(40, 18)
                );
        }

        [Fact]
        public void Await_01()
        {
            var source = @"
using System;

static class Program
{
    static void Main() { }

    static async void f()
    {
        object x = await new D() ?? new object();
    }
}

class D
{
    public Awaiter GetAwaiter() { return new Awaiter(); }
}

class Awaiter : System.Runtime.CompilerServices.INotifyCompletion
{
    public void OnCompleted(Action x) { }

    public object GetResult() { throw new Exception(); }

    public bool IsCompleted { get { return true; } }
}";
            CreateCompilationWithMscorlib45(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                 // (10,20): hidden CS8607: Expression is probably never null.
                 //         object x = await new D() ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "await new D()").WithLocation(10, 20)
                );
        }

        [Fact]
        public void Await_02()
        {
            var source = @"
using System;

static class Program
{
    static void Main() { }

    static async void f()
    {
        object x = await new D();
    }
}

class D
{
    public Awaiter GetAwaiter() { return new Awaiter(); }
}

class Awaiter : System.Runtime.CompilerServices.INotifyCompletion
{
    public void OnCompleted(Action x) { }

    public object? GetResult() { throw new Exception(); }

    public bool IsCompleted { get { return true; } }
}";
            CreateCompilationWithMscorlib45(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                 // (10,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x = await new D();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "await new D()").WithLocation(10, 20)
                );
        }

        [Fact]
        public void NoPiaObjectCreation_01()
        {
            string pia = @"
using System;
using System.Runtime.InteropServices;

[assembly: ImportedFromTypeLib(""GeneralPIA.dll"")]
[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58277"")]
[CoClass(typeof(ClassITest28))]
public interface ITest28
{
}

[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58278"")]
public abstract class ClassITest28 //: ITest28
{
    public ClassITest28(int x){} 
}
";

            var piaCompilation = CreateCompilationWithMscorlib45(pia, options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CompileAndVerify(piaCompilation);

            string source = @"
class UsePia
{
    public static void Main()
    {
    }

    void Test1(ITest28 x1)
    {
        x1 = new ITest28();
    }

    void Test2(ITest28 x2)
    {
        x2 = new ITest28() ?? x2;
    }
}";

            var compilation = CreateCompilationWithMscorlib45(new[] { source },
                                                new MetadataReference[] { new CSharpCompilationReference(piaCompilation, embedInteropTypes: true) },
                                                options: WithNonNullTypesTrue(TestOptions.DebugExe));

            compilation.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new ITest28() ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new ITest28()").WithLocation(15, 14)
                );
        }

        [Fact]
        public void SymbolDisplay_01()
        {
            var source = @"
abstract class B
{
    string? F1; 
    event System.Action? E1;
    string? P1 {get; set;}
    string?[][,] P2 {get; set;}
    System.Action<string?> M1(string? x) {return null;}
    string[]?[,] M2(string[][,]? x) {return null;}
    void M3(string?* x) {}
    public abstract string? this[System.Action? x] {get; set;} 

    public static implicit operator B?(int x) { return null; }
}

delegate string? D1();

interface I1<T>{}
interface I2<T>{}

class C<T> {}

class F : C<F?>, I1<C<B?>>, I2<C<B>?>
{}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var b = compilation.GetTypeByMetadataName("B");
            Assert.Equal("System.String? B.F1", b.GetMember("F1").ToTestDisplayString());
            Assert.Equal("event System.Action? B.E1", b.GetMember("E1").ToTestDisplayString());
            Assert.Equal("System.String? B.P1 { get; set; }", b.GetMember("P1").ToTestDisplayString());
            Assert.Equal("System.String?[][,] B.P2 { get; set; }", b.GetMember("P2").ToTestDisplayString());
            Assert.Equal("System.Action<System.String?> B.M1(System.String? x)", b.GetMember("M1").ToTestDisplayString());
            Assert.Equal("System.String[]?[,] B.M2(System.String[][,]? x)", b.GetMember("M2").ToTestDisplayString());
            Assert.Equal("void B.M3(System.String?* x)", b.GetMember("M3").ToTestDisplayString());
            Assert.Equal("System.String? B.this[System.Action? x] { get; set; }", b.GetMember("this[]").ToTestDisplayString());
            Assert.Equal("B.implicit operator B?(int)", b.GetMember("op_Implicit").ToDisplayString());

            Assert.Equal("String? D1()", compilation.GetTypeByMetadataName("D1")
                .ToDisplayString(new SymbolDisplayFormat(delegateStyle: SymbolDisplayDelegateStyle.NameAndSignature,
                    miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));

            var f = compilation.GetTypeByMetadataName("F");
            Assert.Equal("C<F?>", f.BaseType().ToTestDisplayString());
            Assert.Equal("I1<C<B?>>", f.Interfaces()[0].ToTestDisplayString());
            Assert.Equal("I2<C<B>?>", f.Interfaces()[1].ToTestDisplayString());
        }

        [Fact]
        public void NullableAttribute_01()
        {
            var source =
@"#pragma warning disable 8618
public abstract class B
{
    public string? F1; 
    public event System.Action? E1;
    public string? P1 {get; set;}
    public string?[][,] P2 {get; set;}
    public System.Action<string?> M1(string? x) {throw new System.NotImplementedException();}
    public string[]?[,] M2(string[][,]? x) {throw new System.NotImplementedException();}
    public abstract string? this[System.Action? x] {get; set;} 

    public static implicit operator B?(int x) {throw new System.NotImplementedException();}
    public event System.Action? E2
    {
        add { }
        remove { }
    }
}

public delegate string? D1();

public interface I1<T>{}
public interface I2<T>{}

public class C<T> {}

public class F : C<F?>, I1<C<B?>>, I2<C<B>?>
{}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (5,33): warning CS0067: The event 'B.E1' is never used
                //     public event System.Action? E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("B.E1").WithLocation(5, 33)
                );

            CompileAndVerify(compilation,
                             symbolValidator: m =>
                                {
                                    var b = ((PEModuleSymbol)m).GlobalNamespace.GetTypeMember("B");
                                    Assert.Equal("System.String? B.F1", b.GetMember("F1").ToTestDisplayString());
                                    Assert.Equal("event System.Action? B.E1", b.GetMember("E1").ToTestDisplayString());
                                    Assert.Equal("System.String? B.P1 { get; set; }", b.GetMember("P1").ToTestDisplayString());
                                    Assert.Equal("System.String?[][,] B.P2 { get; set; }", b.GetMember("P2").ToTestDisplayString());
                                    Assert.Equal("System.Action<System.String?> B.M1(System.String? x)", b.GetMember("M1").ToTestDisplayString());
                                    Assert.Equal("System.String[]?[,] B.M2(System.String[][,]? x)", b.GetMember("M2").ToTestDisplayString());
                                    Assert.Equal("System.String? B.this[System.Action? x] { get; set; }", b.GetMember("this[]").ToTestDisplayString());
                                    Assert.Equal("B.implicit operator B?(int)", b.GetMember("op_Implicit").ToDisplayString());
                                    Assert.Equal("event System.Action? B.E2", b.GetMember("E2").ToTestDisplayString());

                                    Assert.Equal("String? D1()", compilation.GetTypeByMetadataName("D1")
                                        .ToDisplayString(new SymbolDisplayFormat(delegateStyle: SymbolDisplayDelegateStyle.NameAndSignature,
                                            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));

                                    var f = ((PEModuleSymbol)m).GlobalNamespace.GetTypeMember("F");
                                    Assert.Equal("C<F?>", f.BaseType().ToTestDisplayString());

                                    Assert.Equal("I1<C<B?>>", f.Interfaces()[0].ToTestDisplayString());
                                    Assert.Equal("I2<C<B>?>", f.Interfaces()[1].ToTestDisplayString());
                                });
        }

        [Fact]
        public void NullableAttribute_02()
        {
            CSharpCompilation c0 = CreateCompilation(new[] { @"
public class CL0 
{
    public object F1;

    public object? P1 { get; set;}
}
" }, options: WithNonNullTypesTrue(TestOptions.DebugDll));

            string source = @"
class C 
{
    static void Main()
    {
    }

    void Test1(CL0 x1, object? y1)
    {
        x1.F1 = y1;
    }

    void Test2(CL0 x2, object y2)
    {
        y2 = x2.P1;
    }
}
";
            var expected = new[]
            {
                // (10,17): warning CS8601: Possible null reference assignment.
                //         x1.F1 = y1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y1").WithLocation(10, 17),
                // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y2 = x2.P1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2.P1").WithLocation(15, 14)
            };

            CSharpCompilation c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.EmitToImageReference() });
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.ToMetadataReference() });
            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NullableAttribute_03()
        {
            CSharpCompilation c0 = CreateCompilation(new[] { @"
public class CL0 
{
    public object F1;
}
" }, options: WithNonNullTypesTrue(TestOptions.DebugDll));

            string source = @"
class C 
{
    static void Main()
    {
    }

    void Test1(CL0 x1, object? y1)
    {
        x1.F1 = y1;
    }
}
";
            var expected = new[]
            {
                // (10,17): warning CS8601: Possible null reference assignment.
                //         x1.F1 = y1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y1").WithLocation(10, 17)
            };

            CSharpCompilation c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.EmitToImageReference() });
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.ToMetadataReference() });
            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NullableAttribute_04()
        {
            var source =
@"#pragma warning disable 8618
using System.Runtime.CompilerServices;

public abstract class B
{
    [Nullable] public string F1; 
    [Nullable] public event System.Action E1;
    [Nullable] public string[][,] P2 {get; set;}
    [return:Nullable] public System.Action<string?> M1(string? x) 
    {throw new System.NotImplementedException();}
    public string[][,] M2([Nullable] string[][,] x) 
    {throw new System.NotImplementedException();}
}

public class C<T> {}

[Nullable] public class F : C<F>
{}
";
            var compilation = CreateCompilation(new[] { source, NullableAttributeDefinition }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (7,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable] public event System.Action E1;
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (8,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable] public string[][,] P2 {get; set;}
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (9,13): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [return:Nullable] public System.Action<string?> M1(string? x) 
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (11,28): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     public string[][,] M2([Nullable] string[][,] x) 
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (6,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable] public string F1; 
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (17,2): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                // [Nullable] public class F : C<F>
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable"),
                // (7,43): warning CS0067: The event 'B.E1' is never used
                //     [Nullable] public event System.Action E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("B.E1").WithLocation(7, 43)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_01()
        {
            string lib = @"
using System;

public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

" + NonNullTypesOff() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOff() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOff() + @"
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOff() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOff() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOff() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_02()
        {
            string lib =
@"#pragma warning disable 8618
using System;

" + NonNullTypesOff() + @"
public class CL0 
{
" + NonNullTypesOff() + @"
    public class CL1 
    {
" + NonNullTypesOn() + @"
        public Action F1;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; }
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 =
@"#pragma warning disable 8618
using System;


partial class C 
{

    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

" + NonNullTypesOn() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOn() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOn() + @"
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 =
@"#pragma warning disable 8618
using System;

" + NonNullTypesOff() + @"
partial class C 
{
" + NonNullTypesOff() + @"
    partial class B 
    {
" + NonNullTypesOn() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOn() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOn() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(
                // (18,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(18, 18),
                // (24,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                // (13,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(13, 20),
                // (14,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(13, 20),
                // (14,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_03()
        {
            string lib = @"
using System;

public class CL0
{
    public class CL1
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C
{

    partial class B
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;
" + NonNullTypesOff() + @"
        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C
{
    partial class B
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5
            c.P1 = x21; // 6
            c.M3(x21); // 7
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8
            x22 = c.P1 ?? x22; // 9
            x22 = c.M1() ?? x22; // 10
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(
                // (15,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test11(Action? x11) // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 27),
                // (8,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 38)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c1.VerifyDiagnostics();

            var expectedDiagnostics = new[] {
                // (8,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 38)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expectedDiagnostics);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expectedDiagnostics);

            expectedDiagnostics = new[] {
                // (10,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(10, 20),
                // (11,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(11, 20),
                // (12,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(12, 18),
                // (17,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22; // 8
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(17, 19),
                // (18,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22; // 9
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(18, 19),
                // (19,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22; // 10
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(19, 19),
                // (24,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(24, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(25, 19),
                // (26,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(26, 19)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expectedDiagnostics);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expectedDiagnostics);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_04()
        {
            string lib = @"
using System;

" + NonNullTypesOff() + @"
public class CL0 
{
    public class CL1 
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3 
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

" + NonNullTypesOff() + @"
partial class C 
{
    partial class B 
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5 
            c.P1 = x21; // 6 
            c.M3(x21); // 7 
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8 
            x22 = c.P1 ?? x22; // 9 
            x22 = c.M1() ?? x22; // 10 
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 38),
                // (15,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(15, 18),
                // (20,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12; // 3 
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(20, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(25, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics();

            var expected = new[]
            {
                // (9,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 38)
            };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_05()
        {
            string lib = @"
using System;

" + NonNullTypesOn() + @"
public class CL0 
{
" + NonNullTypesOff() + @"
    public class CL1 
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

" + NonNullTypesOn() + @"
partial class C 
{
" + NonNullTypesOff() + @"
    partial class B 
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5 
            c.P1 = x21; // 6 
            c.M3(x21); // 7 
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8 
            x22 = c.P1 ?? x22; // 9 
            x22 = c.M1() ?? x22; // 10 
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 38),
                // (15,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(15, 18),
                // (20,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12; // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(20, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(25, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics();

            var expected = new[]
            {
                // (10,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 38)
            };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NonNullTypes_06()
        {
            string lib = @"
using System;

" + NonNullTypesOn() + @"
public class CL0 
{
" + NonNullTypesOn() + @"
    public class CL1 
    {
" + NonNullTypesOff() + @"
        public Action F1 = null!;
" + NonNullTypesOff() + @"
        public Action? F2;

" + NonNullTypesOff() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOff() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOff() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOff() + @"
        public Action? M2() { return null; }
" + NonNullTypesOff() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

" + NonNullTypesOn() + @"
partial class C 
{
" + NonNullTypesOn() + @"
    partial class B 
    {
" + NonNullTypesOff() + @"
        public event Action E1;
" + NonNullTypesOff() + @"
        public event Action? E2;

" + NonNullTypesOn() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOn() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOn() + @"
        void Test13(Action x13)
        {
            x13 = E2; // warn 1
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOn() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOn() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2; // warn 2
            x23 = c.P2; // warn 3
            x23 = c.M2(); // warn 4
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 22),
                // (18,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? P2 { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 22),
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? M2() { return null; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22),
                // (13,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public event Action? E2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 28),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics(
                // (13,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 22),
                // (18,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? P2 { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 22),
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? M2() { return null; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22)
                );

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_07()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
public class CL0 
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
partial class C 
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_08()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_09()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_10()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
public class CL0 
{
    [System.Runtime.CompilerServices.NonNullTypes(true)]
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
partial class C 
{
    [System.Runtime.CompilerServices.NonNullTypes(true)]
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_11()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
public class CL0 
{
    
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
partial class C 
{
    
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_12()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;


public class CL0 
{
    
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;


partial class C 
{
    
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_13()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    string?[]? M1()
    {
        return null;
    }

    void Test1()
    {
        M1().ToString();
        M1()[0].ToString();
        var x1 = M1()[0] ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    string[] M2()
    {
        return null;
    }

    void Test2()
    {
        M2()[0] = null;
        var x2 = M2()[0] ?? """";
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_14()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1()
    {
        return null;
    }

    void Test1()
    {
        M1().ToString();
        M1().P1.ToString();
        var x1 = M1().P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2()
    {
        return null;
    }

    void Test2()
    {
        M2().P1 = null;
        var x2 = M2().P1 ?? """";
    }

    CL1<string?> M3()
    {
         return new CL1<string?>();
    }

    void Test3()
    {
        M3().ToString();
        M3().P1.ToString();
        var x3 = M3().P1 ?? """";
    }

    CL1<string> M4()
    {
        return new CL1<string>();
    }

    void Test4()
    {
        M4().P1 = null;
        var x4 = M4().P1 ?? """";
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (39,9): warning CS8602: Possible dereference of a null reference.
                 //         M3().P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3().P1").WithLocation(39, 9),
                 // (50,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4().P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(50, 19),
                 // (51,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4().P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4().P1").WithLocation(51, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_15()
        {
            string source = @"
class C 
{
    void Main() {}
}

class CL1<T>
{
    public virtual CL1<T> M1()
    {
        return new CL1<T>();
    }
}

class CL2 : CL1<string>
{
    public override CL1<string?> M1() // 2
    {
        return base.M1();
    }
}

class CL3 : CL1<string?>
{
    public override CL1<string?> M1()
    {
        return base.M1();
    }
}

class CL4<T> where T : class
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public virtual CL4<T?> M4()
    {
        return new CL4<T?>();
    }
}

class CL5 : CL4<string>
{
    public override CL4<string> M4()
    {
        return base.M4();
    }
}

class CL6 : CL4<string?>
{
    public override CL4<string> M4() // 6
    {
        return base.M4();
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (17,34): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override CL1<string?> M1() // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(17, 34),
                 // (19,16): warning CS8619: Nullability of reference types in value of type 'CL1<string>' doesn't match target type 'CL1<string?>'.
                 //         return base.M1();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "base.M1()").WithArguments("CL1<string>", "CL1<string?>").WithLocation(19, 16),
                 // (50,33): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override CL4<string> M4() // 6
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M4").WithLocation(50, 33),
                 // (52,16): warning CS8619: Nullability of reference types in value of type 'CL4<string?>' doesn't match target type 'CL4<string>'.
                 //         return base.M4();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "base.M4()").WithArguments("CL4<string?>", "CL4<string>").WithLocation(52, 16)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_16()
        {
            string source = @"
class C 
{
    void Main() {}
}

class CL1<T>
{
    public virtual void M1(CL1<T> x1)
    {
    }
}

class CL2 : CL1<string>
{
    public override void M1(CL1<string?> x2) // 2
    {
    }
}

class CL3 : CL1<string?>
{
    public override void M1(CL1<string?> x3)
    {
    }
}

class CL4<T> where T : class
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public virtual void M4(CL4<T?> x4)
    {
    }
}

class CL5 : CL4<string>
{
    public override void M4(CL4<string> x5)
    {
    }
}

class CL6 : CL4<string?>
{
    public override void M4(CL4<string> x6) // 6
    {
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (16,26): warning CS8610: Nullability of reference types in type of parameter 'x2' doesn't match overridden member.
                 //     public override void M1(CL1<string?> x2) // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x2").WithLocation(16, 26),
                 // (45,26): warning CS8610: Nullability of reference types in type of parameter 'x6' doesn't match overridden member.
                 //     public override void M4(CL4<string> x6) // 6
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M4").WithArguments("x6").WithLocation(45, 26)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_17()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1().ToString();
        var x1 = CL0<string?>.M1() ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1()
    {
        return default(T);
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1().ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1()").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_18()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1 { get; set; }

    void Test1()
    {
        M1.ToString();
        M1.P1.ToString();
        var x1 = M1.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2 { get; set; }

    void Test2()
    {
        M2.P1 = null;
        var x2 = M2.P1 ?? """";
    }

    CL1<string?> M3 { get; set; }

    void Test3()
    {
        M3.ToString();
        M3.P1.ToString();
        var x3 = M3.P1 ?? """";
    }

    CL1<string> M4 { get; set; }

    void Test4()
    {
        M4.P1 = null;
        var x4 = M4.P1 ?? """";
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (30,9): warning CS8602: Possible dereference of a null reference.
                 //         M3.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3.P1").WithLocation(30, 9),
                 // (38,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4.P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(38, 17),
                 // (39,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4.P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4.P1").WithLocation(39, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_19()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1.ToString();
        var x1 = CL0<string?>.M1 ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1 { get; set; }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_20()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1;

    void Test1()
    {
        M1.ToString();
        M1.P1.ToString();
        var x1 = M1.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2;

    void Test2()
    {
        M2.P1 = null;
        var x2 = M2.P1 ?? """";
    }

    CL1<string?> M3;

    void Test3()
    {
        M3.ToString();
        M3.P1.ToString();
        var x3 = M3.P1 ?? """";
    }

    CL1<string> M4;

    void Test4()
    {
        M4.P1 = null;
        var x4 = M4.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void Assign()
    {
        M1 = null;
        M2 = null;
        M3 = null;
        M4 = null;
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (30,9): warning CS8602: Possible dereference of a null reference.
                 //         M3.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3.P1").WithLocation(30, 9),
                 // (38,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4.P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(38, 17),
                 // (39,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4.P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4.P1").WithLocation(39, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_21()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1.ToString();
        var x1 = CL0<string?>.M1 ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1 = default(T);
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_22()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    event System.Func<string?>? M1;

    void Test1()
    {
        M1.ToString();
        M1().ToString();
        var x1 = M1() ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    event System.Func<string> M2;

    void Test2()
    {
        var x2 = M2() ?? """";
    }

    event System.Func<string?> M3;

    void Test3()
    {
        M3.ToString();
        M3().ToString();
        var x3 = M3() ?? """";
    }

    event System.Func<string> M4;

    void Test4()
    {
        var x4 = M4() ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void Assign()
    {
        M1 = null;
        M2 = null;
        M3 = null;
        M4 = null;
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (29,9): warning CS8602: Possible dereference of a null reference.
                 //         M3().ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3()").WithLocation(29, 9),
                 // (37,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4() ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4()").WithLocation(37, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_23()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate void D1 (CL1<string?>? x1);

    void M1(D1 x1) {}

    void Test1()
    {
        M1(a1 => a1.ToString());
        M1(b1 => b1.P1.ToString());
        M1(c1 => {var x1 = c1.P1 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate void D2(CL1<string> x2);
    
    void M2(D2 x2) {}

    void Test2()
    {
        M2(a2 => {a2.P1 = null;});
        M2(b2 => {var x2 = b2.P1 ?? """";});
    }

    delegate void D3 (CL1<string?> x3);
    void M3(D3 x3) {}

    void Test3()
    {
        M3(a3 => a3.ToString());
        M3(b3 => b3.P1.ToString());
        M3(c3 => {var x3 = c3.P1 ?? """";});
    }

    delegate void D4(CL1<string> x4);
    void M4(D4 x4) {}

    void Test4()
    {
        M4(a4 => {a4.P1 = null;});
        M4(b4 => {var x4 = b4.P1 ?? """";});
    }

    void Test11()
    {
        D1 u11 = a11 => a11.ToString();
        D1 v11 = b11 => b11.P1.ToString();
        D1 w11 = c11 => {var x11 = c11.P1 ?? """";};
    }

    void Test21()
    {
        D2 u21 = a21 => {a21.P1 = null;};
        D2 v21 = b21 => {var x21 = b21.P1 ?? """";};
    }

    void Test31()
    {
        D3 u31 = a31 => a31.ToString();
        D3 v31 = b31 => b31.P1.ToString();
        D3 w31 = c31 => {var x31 = c31.P1 ?? """";};
    }

    void Test41()
    {
        D4 u41 = a41 => {a41.P1 = null;};
        D4 v41 = b41 => {var x41 = b41.P1 ?? """";};
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (35,18): warning CS8602: Possible dereference of a null reference.
                 //         M3(b3 => b3.P1.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b3.P1").WithLocation(35, 18),
                 // (44,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4(a4 => {a4.P1 = null;});
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(44, 27),
                 // (45,28): hidden CS8607: Expression is probably never null.
                 //         M4(b4 => {var x4 = b4.P1 ?? "";});
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "b4.P1").WithLocation(45, 28),
                 // (64,25): warning CS8602: Possible dereference of a null reference.
                 //         D3 v31 = b31 => b31.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b31.P1").WithLocation(64, 25),
                 // (70,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D4 u41 = a41 => {a41.P1 = null;};
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(70, 35),
                 // (71,36): hidden CS8607: Expression is probably never null.
                 //         D4 v41 = b41 => {var x41 = b41.P1 ?? "";};
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "b41.P1").WithLocation(71, 36)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_24()
        {
            string source = @"
class C 
{
    void Main() {}

    void M1(CL0<string?> x1) {}

    void Test1()
    {
        M1(a1 => a1.ToString());
        M1(b1 => {var x1 = b1 ?? """";});
    }

    void Test2()
    {
        CL0<string?> u2 = a2 => a2.ToString();
        CL0<string?> v2 = b2 => {var x2 = b2 ?? """";};
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M2(CL0<string?> x1) {}

    void Test3()
    {
        M2(a3 => a3.ToString());
        M2(b3 => {var x3 = b3 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M3(CL1<string?> x1) {}

    void Test4()
    {
        M3(a4 => a4.ToString());
        M3(b4 => {var x4 = b4 ?? """";});
    }

    void M4(CL1<string?> x1) {}

    void Test5()
    {
        M4(a5 => a5.ToString());
        M4(b5 => {var x5 = b5 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M5(CL2<string?> x1) {}

    void Test6()
    {
        M5(a6 => a6.ToString());
        M5(b6 => {var x6 = b6 ?? """";});
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate void CL0<T>(T x); 

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate void CL1<T>(T? x) where T : class; 

delegate void CL2<T>(T? x) where T : class; 
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (10,18): warning CS8602: Possible dereference of a null reference.
                 //         M1(a1 => a1.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1").WithLocation(10, 18),
                 // (16,33): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?> u2 = a2 => a2.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2").WithLocation(16, 33),
                 // (42,18): warning CS8602: Possible dereference of a null reference.
                 //         M4(a5 => a5.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a5").WithLocation(42, 18),
                 // (51,18): warning CS8602: Possible dereference of a null reference.
                 //         M5(a6 => a6.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a6").WithLocation(51, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_25()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate string D1 ();

    void M1(D1 x1) {}

    void Test1()
    {
        M1(() => null);
    }

    void Test2()
    {
        D1 x2 = () => null;
    }

    delegate T D3<T> ();

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M3(D3<string> x3) {}

    void Test3()
    {
        M3(() => null);
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_26()
        {
            string source = @"
class C 
{
    void Main() {}

    void M1(CL0<string> x1) {}

    void Test1()
    {
        M1(() => null);
    }

    void Test2()
    {
        CL0<string> x2 =() => null;
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M2(D2 x2) {}

    void Test3()
    {
        M2(() => null);
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate T CL0<T>(); 

delegate string D2();
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (10,18): warning CS8603: Possible null reference return.
                 //         M1(() => null);
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 18),
                 // (15,31): warning CS8603: Possible null reference return.
                 //         CL0<string> x2 =() => null;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(15, 31),
                 // (23,18): warning CS8603: Possible null reference return.
                 //         M2(() => null);
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(23, 18)
                );
        }

        [Fact]
        public void Covariance_Interface()
        {
            var source =
@"interface I<out T> { }
class C
{
    static I<string?> F1(I<string> i) => i;
    static I<object?> F2(I<string> i) => i;
    static I<string> F3(I<string?> i) => i;
    static I<object> F4(I<string?> i) => i;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,42): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<string>'.
                //     static I<string> F3(I<string?> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string?>", "I<string>").WithLocation(6, 42),
                // (7,42): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<object>'.
                //     static I<object> F4(I<string?> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string?>", "I<object>").WithLocation(7, 42));
        }

        [Fact]
        public void Contravariance_Interface()
        {
            var source =
@"interface I<in T> { }
class C
{
    static I<string?> F1(I<string> i) => i;
    static I<string?> F2(I<object> i) => i;
    static I<string> F3(I<string?> i) => i;
    static I<string> F4(I<object?> i) => i;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,42): warning CS8619: Nullability of reference types in value of type 'I<string>' doesn't match target type 'I<string?>'.
                //     static I<string?> F1(I<string> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string>", "I<string?>").WithLocation(4, 42),
                // (5,42): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<string?>'.
                //     static I<string?> F2(I<object> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<object>", "I<string?>").WithLocation(5, 42));
        }

        [Fact]
        public void Covariance_Delegate()
        {
            var source =
@"delegate void D<in T>(T t);
class C
{
    static void F1(string s) { }
    static void F2(string? s) { }
    static void F3(object o) { }
    static void F4(object? o) { }
    static void F<T>(D<T> d) { }
    static void Main()
    {
        F<string>(F1);
        F<string>(F2);
        F<string>(F3);
        F<string>(F4);
        F<string?>(F1); // warning
        F<string?>(F2);
        F<string?>(F3); // warning
        F<string?>(F4);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (15,20): warning CS8622: Nullability of reference types in type of parameter 's' of 'void C.F1(string s)' doesn't match the target delegate 'D<string?>'.
                //         F<string?>(F1); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F1").WithArguments("s", "void C.F1(string s)", "D<string?>").WithLocation(15, 20),
                // (17,20): warning CS8622: Nullability of reference types in type of parameter 'o' of 'void C.F3(object o)' doesn't match the target delegate 'D<string?>'.
                //         F<string?>(F3); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F3").WithArguments("o", "void C.F3(object o)", "D<string?>").WithLocation(17, 20));
        }

        [Fact]
        public void Contravariance_Delegate()
        {
            var source =
@"delegate T D<out T>();
class C
{
    static string F1() => string.Empty;
    static string? F2() => string.Empty;
    static object F3() => string.Empty;
    static object? F4() => string.Empty;
    static T F<T>(D<T> d) => d();
    static void Main()
    {
        F<object>(F1);
        F<object>(F2); // warning
        F<object>(F3);
        F<object>(F4); // warning
        F<object?>(F1);
        F<object?>(F2);
        F<object?>(F3);
        F<object?>(F4);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,19): warning CS8621: Nullability of reference types in return type of 'string? C.F2()' doesn't match the target delegate 'D<object>'.
                //         F<object>(F2); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F2").WithArguments("string? C.F2()", "D<object>").WithLocation(12, 19),
                // (14,19): warning CS8621: Nullability of reference types in return type of 'object? C.F4()' doesn't match the target delegate 'D<object>'.
                //         F<object>(F4); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F4").WithArguments("object? C.F4()", "D<object>").WithLocation(14, 19));
        }

        [Fact]
        public void TypeArgumentInference_01()
        {
            string source = @"
class C 
{
    void Main() {}

    T M1<T>(T? x) where T: class {throw new System.NotImplementedException();}

    void Test1(string? x1)
    {
        M1(x1).ToString();
    }

    void Test2(string?[] x2)
    {
        M1(x2)[0].ToString();
    }

    void Test3(CL0<string?>? x3)
    {
        M1(x3).P1.ToString();
    }

    void Test11(string? x11)
    {
        M1<string?>(x11).ToString();
    }

    void Test12(string?[] x12)
    {
        M1<string?[]>(x12)[0].ToString();
    }

    void Test13(CL0<string?>? x13)
    {
        M1<CL0<string?>?>(x13).P1.ToString();
    }
}

class CL0<T>
{
    public T P1 {get;set;}
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x2)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x2)[0]").WithLocation(15, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x3).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x3).P1").WithLocation(20, 9),
                // (25,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.M1<T>(T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(x11).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("C.M1<T>(T?)", "T", "string?").WithLocation(25, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         M1<string?>(x11).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<string?>(x11)").WithLocation(25, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         M1<string?[]>(x12)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<string?[]>(x12)[0]").WithLocation(30, 9),
                // (35,9): warning CS8634: The type 'CL0<string?>?' cannot be used as type parameter 'T' in the generic type or method 'C.M1<T>(T?)'. Nullability of type argument 'CL0<string?>?' doesn't match 'class' constraint.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<CL0<string?>?>").WithArguments("C.M1<T>(T?)", "T", "CL0<string?>?").WithLocation(35, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<CL0<string?>?>(x13)").WithLocation(35, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<CL0<string?>?>(x13).P1").WithLocation(35, 9),
                // (39,7): warning CS8618: Non-nullable property 'P1' is uninitialized.
                // class CL0<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "CL0").WithArguments("property", "P1").WithLocation(39, 7)
                );
        }

        [Fact]
        public void ExplicitImplementations_LazyMethodChecks()
        {
            var source =
@"interface I
{
    void M<T>(T? x) where T : class;
}
class C : I
{
    void I.M<T>(T? x) { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            var method = compilation.GetMember<NamedTypeSymbol>("C").GetMethod("I.M");
            var implementations = method.ExplicitInterfaceImplementations;
            Assert.Equal(new[] { "void I.M<T>(T? x)" }, implementations.SelectAsArray(m => m.ToTestDisplayString()));
        }

        [Fact]
        public void EmptyStructDifferentAssembly()
        {
            var sourceA =
@"using System.Collections;
public struct S
{
    public S(string f, IEnumerable g)
    {
        F = f;
        G = g;
    }
    private string F { get; }
    private IEnumerable G { get; }
}";
            var compA = CreateCompilation(sourceA, parseOptions: TestOptions.Regular7);
            var sourceB =
@"using System.Collections.Generic;
class C
{
    static void Main()
    {
        var c = new List<object>();
        c.Add(new S(string.Empty, new object[0]));
    }
}";
            var compB = CreateCompilation(
                sourceB,
                options: TestOptions.ReleaseExe,
                parseOptions: TestOptions.Regular8,
                references: new[] { compA.EmitToImageReference() });
            CompileAndVerify(compB, expectedOutput: "");
        }

        [Fact]
        public void EmptyStructField()
        {
            var source =
@"#pragma warning disable 8618
class A { }
struct B { }
struct S
{
    public readonly A A;
    public readonly B B;
    public S(B b) : this(null, b)
    {
    }
    public S(A a, B b)
    {
        this.A = a;
        this.B = b;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,26): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public S(B b) : this(null, b)
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 26));
        }

        [Fact]
        public void WarningOnConversion_Assignment()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        p.LastName = null;
        p.LastName = (string)null;
        p.LastName = (string?)null;
        p.LastName = null as string;
        p.LastName = null as string?;
        p.LastName = default(string);
        p.LastName = default;
        p.FirstName = p.MiddleName;
        p.LastName = p.MiddleName ?? null;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 22),
                // (13,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         p.LastName = (string)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(13, 22),
                // (13,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = (string)null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(13, 22),
                // (14,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = (string?)null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(14, 22),
                // (15,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = null as string;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "null as string").WithLocation(15, 22),
                // (16,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = null as string?;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "null as string?").WithLocation(16, 22),
                // (17,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = default(string);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(17, 22),
                // (18,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 22),
                // (19,23): warning CS8601: Possible null reference assignment.
                //         p.FirstName = p.MiddleName;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "p.MiddleName").WithLocation(19, 23),
                // (20,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = p.MiddleName ?? null;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "p.MiddleName ?? null").WithLocation(20, 22));
        }

        [Fact]
        public void WarningOnConversion_Receiver()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        ((string)null).F();
        ((string?)null).F();
        (null as string).F();
        (null as string?).F();
        default(string).F();
        ((p != null) ? p.MiddleName : null).F();
        (p.MiddleName ?? null).F();
    }
}
static class Extensions
{
    internal static void F(this string s)
    {
    }
}";

            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((string)null).F();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(12, 10),
                // (12,10): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((string)null).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(12, 10),
                // (13,10): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((string?)null).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(13, 10),
                // (14,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         (null as string).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string").WithArguments("s", "void Extensions.F(string s)").WithLocation(14, 10),
                // (15,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         (null as string?).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string?").WithArguments("s", "void Extensions.F(string s)").WithLocation(15, 10),
                // (16,9): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         default(string).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(16, 9),
                // (17,11): hidden CS8605: Result of the comparison is possibly always true.
                //         ((p != null) ? p.MiddleName : null).F();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(17, 11),
                // (17,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         ((p != null) ? p.MiddleName : null).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(p != null) ? p.MiddleName : null").WithArguments("s", "void Extensions.F(string s)").WithLocation(17, 10),
                // (18,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         (p.MiddleName ?? null).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "p.MiddleName ?? null").WithArguments("s", "void Extensions.F(string s)").WithLocation(18, 10));
        }

        [Fact]
        public void WarningOnConversion_Argument()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        G(null);
        G((string)null);
        G((string?)null);
        G(null as string);
        G(null as string?);
        G(default(string));
        G(default);
        G((p != null) ? p.MiddleName : null);
        G(p.MiddleName ?? null);
    }
    static void G(string name)
    {
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 11),
                // (13,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G((string)null);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(13, 11),
                // (13,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G((string)null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(13, 11),
                // (14,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G((string?)null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(14, 11),
                // (15,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G(null as string);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string").WithArguments("name", "void Program.G(string name)").WithLocation(15, 11),
                // (16,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G(null as string?);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string?").WithArguments("name", "void Program.G(string name)").WithLocation(16, 11),
                // (17,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(default(string));
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(17, 11),
                // (18,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 11),
                // (19,12): hidden CS8605: Result of the comparison is possibly always true.
                //         G((p != null) ? p.MiddleName : null);
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(19, 12),
                // (19,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G((p != null) ? p.MiddleName : null);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(p != null) ? p.MiddleName : null").WithArguments("name", "void Program.G(string name)").WithLocation(19, 11),
                // (20,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G(p.MiddleName ?? null);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "p.MiddleName ?? null").WithArguments("name", "void Program.G(string name)").WithLocation(20, 11));
        }

        [Fact]
        public void WarningOnConversion_Return()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static string F1() => null;
    static string F2() => (string)null;
    static string F3() => (string?)null;
    static string F4() => null as string;
    static string F5() => null as string?;
    static string F6() => default(string);
    static string F7() => default;
    static string F8(Person p) => (p != null) ? p.MiddleName : null;
    static string F9(Person p) => p.MiddleName ?? null;
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,27): warning CS8603: Possible null reference return.
                //     static string F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 27),
                // (11,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static string F2() => (string)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(11, 27),
                // (11,27): warning CS8603: Possible null reference return.
                //     static string F2() => (string)null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(string)null").WithLocation(11, 27),
                // (12,27): warning CS8603: Possible null reference return.
                //     static string F3() => (string?)null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(string?)null").WithLocation(12, 27),
                // (13,27): warning CS8603: Possible null reference return.
                //     static string F4() => null as string;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null as string").WithLocation(13, 27),
                // (14,27): warning CS8603: Possible null reference return.
                //     static string F5() => null as string?;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null as string?").WithLocation(14, 27),
                // (15,27): warning CS8603: Possible null reference return.
                //     static string F6() => default(string);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(string)").WithLocation(15, 27),
                // (16,27): warning CS8603: Possible null reference return.
                //     static string F7() => default;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(16, 27),
                // (17,36): hidden CS8605: Result of the comparison is possibly always true.
                //     static string F8(Person p) => (p != null) ? p.MiddleName : null;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(17, 36),
                // (17,35): warning CS8603: Possible null reference return.
                //     static string F8(Person p) => (p != null) ? p.MiddleName : null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(p != null) ? p.MiddleName : null").WithLocation(17, 35),
                // (18,35): warning CS8603: Possible null reference return.
                //     static string F9(Person p) => p.MiddleName ?? null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "p.MiddleName ?? null").WithLocation(18, 35));
        }

        [Fact]
        public void SuppressNullableWarning()
        {
            var source =
@"class C
{
    static void F(string? s) // 1
    {
        G(null!); // 2, 3
        G((null as string)!); // 4, 5
        G(default(string)!); // 6, 7
        G(default!); // 8, 9, 10
        G(s!); // 11, 12
    }
    static void G(string s)
    {
    }
}";

            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // (5,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(null!); // 2, 3
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "null!").WithArguments("nullable reference types", "8.0").WithLocation(5, 11),
                // (6,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G((null as string)!); // 4, 5
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "(null as string)!").WithArguments("nullable reference types", "8.0").WithLocation(6, 11),
                // (7,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(default(string)!); // 6, 7
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "default(string)!").WithArguments("nullable reference types", "8.0").WithLocation(7, 11),
                // (8,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(default!); // 8, 9, 10
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "default!").WithArguments("nullable reference types", "8.0").WithLocation(8, 11),
                // (8,11): error CS8107: Feature 'default literal' is not available in C# 7.0. Please use language version 7.1 or greater.
                //         G(default!); // 8, 9, 10
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "default").WithArguments("default literal", "7.1").WithLocation(8, 11),
                // (9,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(s!); // 11, 12
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "s!").WithArguments("nullable reference types", "8.0").WithLocation(9, 11),
                // (3,25): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //     static void F(string? s) // 1
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "?").WithArguments("nullable reference types", "8.0").WithLocation(3, 25),
                // (5,15): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(null!); // 2, 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(5, 15),
                // (6,27): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G((null as string)!); // 4, 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 27),
                // (7,26): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(default(string)!); // 6, 7
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 26),
                // (8,18): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(default!); // 8, 9, 10
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 18),
                // (9,12): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(s!); // 11, 12
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(9, 12));

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_ReferenceType()
        {
            var source =
@"class C
{
    static C F(C? o)
    {
        C other;
        other = o!;
        o = other;
        o!.F();
        G(o!);
        return o!;
    }
    void F() { }
    static void G(C o) { }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_Array()
        {
            var source =
@"class C
{
    static object[] F(object?[] o)
    {
        object[] other;
        other = o!;
        o = other!;
        o!.F();
        G(o!);
        return o!;
    }
    static void G(object[] o) { }
}
static class E
{
    internal static void F(this object[] o) { }
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,17): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         other = o!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "o!").WithArguments("object?[]", "object[]").WithLocation(6, 17),
                // (8,9): warning CS8620: Nullability of reference types in argument of type 'object?[]' doesn't match target type 'object[]' for parameter 'o' in 'void E.F(object[] o)'.
                //         o!.F();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "o!").WithArguments("object?[]", "object[]", "o", "void E.F(object[] o)").WithLocation(8, 9),
                // (9,11): warning CS8620: Nullability of reference types in argument of type 'object?[]' doesn't match target type 'object[]' for parameter 'o' in 'void C.G(object[] o)'.
                //         G(o!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "o!").WithArguments("object?[]", "object[]", "o", "void C.G(object[] o)").WithLocation(9, 11),
                // (10,16): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         return o!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "o!").WithArguments("object?[]", "object[]").WithLocation(10, 16)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ConstructedType()
        {
            var source =
@"class C
{
    static C<object> F(C<object?> o)
    {
        C<object> other;
        other = o!; // 1
        o = other!; // 2
        o!.F();
        G(o!); // 3
        return o!; // 4
    }
    static void G(C<object> o) { }
}
class C<T>
{
    internal void F() { }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,17): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         other = o!; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "o!").WithArguments("C<object?>", "C<object>").WithLocation(6, 17),
                // (7,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         o = other!; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "other!").WithArguments("C<object>", "C<object?>").WithLocation(7, 13),
                // (9,11): warning CS8620: Nullability of reference types in argument of type 'C<object?>' doesn't match target type 'C<object>' for parameter 'o' in 'void C.G(C<object> o)'.
                //         G(o!); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "o!").WithArguments("C<object?>", "C<object>", "o", "void C.G(C<object> o)").WithLocation(9, 11),
                // (10,16): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         return o!; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "o!").WithArguments("C<object?>", "C<object>").WithLocation(10, 16)
                );
        }

        [Fact]
        [WorkItem(29902, "https://github.com/dotnet/roslyn/issues/29902")]
        public void SuppressNullableWarning_Multiple()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        G(default!!);
        G(s!!);
        G((s!)!);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_Nested()
        {
            var source =
@"class C<T> where T : class
{
    static T? F(T t) => t;
    static T? G(T t) => t;
    static void M(T? t)
    {
        F(G(t!));
        F(G(t)!);
        F(G(t!)!);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,11): warning CS8604: Possible null reference argument for parameter 't' in 'T? C<T>.F(T t)'.
                //         F(G(t!));
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "G(t!)").WithArguments("t", "T? C<T>.F(T t)").WithLocation(7, 11),
                // (8,13): warning CS8604: Possible null reference argument for parameter 't' in 'T? C<T>.G(T t)'.
                //         F(G(t)!);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t").WithArguments("t", "T? C<T>.G(T t)").WithLocation(8, 13));
        }

        [Fact]
        public void SuppressNullableWarning_Conditional()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object>? x, C<object?> y, bool c)
    {
        C<object> a;
        a = c ? x : y; // 1 and 2
        a = c ? y : x; // 3 and 4
        a = c ? x : y!; // 5 and 6
        a = c ? x! : y; // 7
        a = c ? x! : y!; // 8
        C<object?> b;
        b = c ? x : y; // 9 and 10
        b = c ? x : y!; // 11 and 12
        b = c ? x! : y; // 13
        b = c ? x! : y!; // 14
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         a = c ? x : y; // 1 and 2
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y").WithArguments("C<object>", "C<object?>").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? x : y; // 1 and 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y").WithLocation(7, 13),
                // (8,13): warning CS8626: No best nullability for operands of conditional expression 'C<object?>' and 'C<object>'.
                //         a = c ? y : x; // 3 and 4
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? y : x").WithArguments("C<object?>", "C<object>").WithLocation(8, 13),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? y : x; // 3 and 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? y : x").WithLocation(8, 13),
                // (9,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         a = c ? x : y!; // 5 and 6
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y!").WithArguments("C<object>", "C<object?>").WithLocation(9, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? x : y!; // 5 and 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y!").WithLocation(9, 13),
                // (10,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         a = c ? x! : y; // 7
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x! : y").WithArguments("C<object>", "C<object?>").WithLocation(10, 13),
                // (11,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         a = c ? x! : y!; // 8
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x! : y!").WithArguments("C<object>", "C<object?>").WithLocation(11, 13),
                // (13,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         b = c ? x : y; // 9 and 10
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y").WithArguments("C<object>", "C<object?>").WithLocation(13, 13),
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = c ? x : y; // 9 and 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y").WithLocation(13, 13),
                // (14,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         b = c ? x : y!; // 11 and 12
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x : y!").WithArguments("C<object>", "C<object?>").WithLocation(14, 13),
                // (14,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = c ? x : y!; // 11 and 12
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y!").WithLocation(14, 13),
                // (15,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         b = c ? x! : y; // 13
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x! : y").WithArguments("C<object>", "C<object?>").WithLocation(15, 13),
                // (16,13): warning CS8626: No best nullability for operands of conditional expression 'C<object>' and 'C<object?>'.
                //         b = c ? x! : y!; // 14
                Diagnostic(ErrorCode.WRN_NoBestNullabilityConditionalExpression, "c ? x! : y!").WithArguments("C<object>", "C<object?>").WithLocation(16, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_NullCoalescing()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var t1 = x ?? y; // 1
        var t2 = y ?? x; // 2 and 3
        var t3 = x! ?? y; // 4 and 5
        var t4 = y! ?? x; // 6 and 7
        var t5 = x ?? y!; // 8
        var t6 = y ?? x!; // 9 and 10
        var t7 = x! ?? y!; // 11 and 12
        var t8 = y! ?? x!; // 13 and 14
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,23): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t1 = x ?? y; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(6, 23),
                // (7,18): hidden CS8607: Expression is probably never null.
                //         var t2 = y ?? x; // 2 and 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(7, 18),
                // (7,23): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t2 = y ?? x; // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(7, 23),
                // (8,18): hidden CS8607: Expression is probably never null.
                //         var t3 = x! ?? y; // 4 and 5
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x!").WithLocation(8, 18),
                // (8,24): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t3 = x! ?? y; // 4 and 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 24),
                // (9,18): hidden CS8607: Expression is probably never null.
                //         var t4 = y! ?? x; // 6 and 7
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y!").WithLocation(9, 18),
                // (9,24): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t4 = y! ?? x; // 6 and 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(9, 24),
                // (10,23): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t5 = x ?? y!; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object?>", "C<object>").WithLocation(10, 23),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         var t6 = y ?? x!; // 9 and 10
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(11, 18),
                // (11,23): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t6 = y ?? x!; // 9 and 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object>", "C<object?>").WithLocation(11, 23),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         var t7 = x! ?? y!; // 11 and 12
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x!").WithLocation(12, 18),
                // (12,24): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t7 = x! ?? y!; // 11 and 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object?>", "C<object>").WithLocation(12, 24),
                // (13,18): hidden CS8607: Expression is probably never null.
                //         var t8 = y! ?? x!; // 13 and 14
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y!").WithLocation(13, 18),
                // (13,24): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t8 = y! ?? x!; // 13 and 14
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object>", "C<object?>").WithLocation(13, 24)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ArrayInitializer()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var a1 = new[] { x, y }; // 1
        var a2 = new[] { x!, y }; // 2
        var a3 = new[] { x, y! }; // 3
        var a4 = new[] { x!, y! }; // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30151: ! should suppress WRN_NoBestNullabilityArrayElements.
            comp.VerifyDiagnostics(
                // (6,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var a1 = new[] { x, y }; // 1
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y }").WithLocation(6, 18),
                // (7,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var a2 = new[] { x!, y }; // 2
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x!, y }").WithLocation(7, 18),
                // (8,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var a3 = new[] { x, y! }; // 3
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x, y! }").WithLocation(8, 18),
                // (9,18): warning CS8639: No best nullability found for implicitly-typed array.
                //         var a4 = new[] { x!, y! }; // 4
                Diagnostic(ErrorCode.WRN_NoBestNullabilityArrayElements, "new[] { x!, y! }").WithLocation(9, 18)
                );
        }

        [Fact]
        public void SuppressNullableWarning_LocalDeclaration()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        C<object>? c1 = y; // 1
        C<object?> c2 = x; // 2 and 3
        C<object>? c3 = y!; // 4
        C<object?> c4 = x!; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,25): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         C<object>? c1 = y; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(6, 25),
                // (7,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C<object?> c2 = x; // 2 and 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 25),
                // (7,25): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         C<object?> c2 = x; // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(7, 25),
                // (8,25): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         C<object>? c3 = y!; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object?>", "C<object>").WithLocation(8, 25),
                // (9,25): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         C<object?> c4 = x!; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object>", "C<object?>").WithLocation(9, 25)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Cast()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var c1 = (C<object>?)y;
        var c2 = (C<object?>)x; // warn
        var c3 = (C<object>?)y!;
        var c4 = (C<object?>)x!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var c1 = (C<object>?)y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object>?)y").WithArguments("C<object?>", "C<object>").WithLocation(6, 18),
                // (7,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var c2 = (C<object?>)x; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C<object?>)x").WithLocation(7, 18),
                // (7,18): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var c2 = (C<object?>)x; // warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object?>)x").WithArguments("C<object>", "C<object?>").WithLocation(7, 18),
                // (8,18): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var c3 = (C<object>?)y!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object>?)y!").WithArguments("C<object?>", "C<object>").WithLocation(8, 18),
                // (9,18): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var c4 = (C<object?>)x!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object?>)x!").WithArguments("C<object>", "C<object?>").WithLocation(9, 18)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ObjectInitializer()
        {
            var source =
@"
class C<T>
{
    public C<object>? X = null!;
    public C<object?> Y = null!;
    static void F(C<object>? x, C<object?> y)
    {
        _ = new C<int>() { X = y, Y = x };
        _ = new C<int>() { X = y!, Y = x! };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 32),
                // (8,39): warning CS8601: Possible null reference assignment.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x").WithLocation(8, 39),
                // (8,39): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(8, 39),
                // (9,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         _ = new C<int>() { X = y!, Y = x! };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object?>", "C<object>").WithLocation(9, 32),
                // (9,40): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         _ = new C<int>() { X = y!, Y = x! };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object>", "C<object?>").WithLocation(9, 40)
                );
        }

        [Fact]
        public void SuppressNullableWarning_CollectionInitializer()
        {
            var source =
@"
using System.Collections;
class C<T> : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    void Add(C<object?> key, params C<object?>[] value) => throw null;
    static void F(C<object>? x)
    {
        _ = new C<int>() { x, x }; // warn 1 and 2
        _ = new C<int>() { x!, x! }; // warn 3 and 4
    }
}
class D<T> : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    void Add(D<object>? key, params D<object>?[] value) => throw null;
    static void F(D<object?> y)
    {
        _ = new D<int>() { y,  y }; // warn 5 and 6 
        _ = new D<int>() { y!,  y! }; // warn 7 and 8
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,28): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y,  y }; // warn 5 and 6 
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(19, 28),
                // (19,32): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y,  y }; // warn 5 and 6 
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(19, 32),
                // (20,28): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y!,  y! }; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y!").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(20, 28),
                // (20,33): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y!,  y! }; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y!").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(20, 33),
                // (9,28): warning CS8604: Possible null reference argument for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 28),
                // (9,28): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 28),
                // (9,31): warning CS8604: Possible null reference argument for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 31),
                // (9,31): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 31),
                // (10,28): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x!, x! }; // warn 3 and 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x!").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(10, 28),
                // (10,32): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x!, x! }; // warn 3 and 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x!").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(10, 32)
                );
        }

        [Fact]
        public void SuppressNullableWarning_IdentityConversion()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        C<object> a;
        a = x; // 1
        a = x!; // 2
        C<object?> b;
        b = y; // 3
        b = y!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(

                // (7,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = x; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object?>", "C<object>").WithLocation(7, 13),
                // (8,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = x!; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object?>", "C<object>").WithLocation(8, 13),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = y; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object>", "C<object?>").WithLocation(10, 13),
                // (11,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = y!; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object>", "C<object?>").WithLocation(11, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ImplicitConversion()
        {
            var source =
@"interface I<T> { }
class C<T> : I<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        I<object> a;
        a = x;
        a = x!;
        I<object?> b;
        b = y;
        b = y!;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'I<object>'.
                //         a = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object?>", "I<object>").WithLocation(8, 13),
                // (9,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'I<object>'.
                //         a = x!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x!").WithArguments("C<object?>", "I<object>").WithLocation(9, 13),
                // (11,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'I<object?>'.
                //         b = y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object>", "I<object?>").WithLocation(11, 13),
                // (12,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'I<object?>'.
                //         b = y!;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y!").WithArguments("C<object>", "I<object?>").WithLocation(12, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ImplicitExtensionMethodThisConversion()
        {
            var source =
@"interface I<T> { }
class C<T> : I<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        x.F1();
        x!.F1();
        y.F2();
        y!.F2();
    }
}
static class E
{
    internal static void F1(this I<object> o) { }
    internal static void F2(this I<object?> o) { }
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,9): warning CS8620: Nullability of reference types in argument of type 'C<object?>' doesn't match target type 'I<object>' for parameter 'o' in 'void E.F1(I<object> o)'.
                //         x.F1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object?>", "I<object>", "o", "void E.F1(I<object> o)").WithLocation(7, 9),
                // (8,9): warning CS8620: Nullability of reference types in argument of type 'C<object?>' doesn't match target type 'I<object>' for parameter 'o' in 'void E.F1(I<object> o)'.
                //         x!.F1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x!").WithArguments("C<object?>", "I<object>", "o", "void E.F1(I<object> o)").WithLocation(8, 9),
                // (9,9): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'I<object?>' for parameter 'o' in 'void E.F2(I<object?> o)'.
                //         y.F2();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("C<object>", "I<object?>", "o", "void E.F2(I<object?> o)").WithLocation(9, 9),
                // (10,9): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'I<object?>' for parameter 'o' in 'void E.F2(I<object?> o)'.
                //         y!.F2();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y!").WithArguments("C<object>", "I<object?>", "o", "void E.F2(I<object?> o)").WithLocation(10, 9)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ImplicitUserDefinedConversion()
        {
            var source =
@"class A<T> { }
class B<T>
{
    public static implicit operator A<T>(B<T> b) => new A<T>();
}
class C
{
    static void F(B<object?> b1, B<object> b2)
    {
        A<object> a1;
        a1 = b1; // 1
        a1 = b1!; // 2
        A<object?> a2;
        a2 = b2; // 3
        a2 = b2!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,14): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         a1 = b1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("A<object?>", "A<object>").WithLocation(11, 14),
                // (12,14): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         a1 = b1!; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1!").WithArguments("A<object?>", "A<object>").WithLocation(12, 14),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         a2 = b2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("A<object>", "A<object?>").WithLocation(14, 14),
                // (15,14): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         a2 = b2!; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2!").WithArguments("A<object>", "A<object?>").WithLocation(15, 14)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ExplicitConversion()
        {
            var source =
@"interface I<T> { }
class C<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        I<object> a;
        a = (I<object?>)x; // 1
        a = ((I<object?>)x)!; // 2
        I<object?> b;
        b = (I<object>)y; // 3
        b = ((I<object>)y)!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,13): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a = (I<object?>)x; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object?>)x").WithArguments("I<object?>", "I<object>").WithLocation(8, 13),
                // (9,13): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a = ((I<object?>)x)!; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object?>)x)!").WithArguments("I<object?>", "I<object>").WithLocation(9, 13),
                // (11,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = (I<object>)y; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object>)y").WithArguments("I<object>", "I<object?>").WithLocation(11, 13),
                // (12,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = ((I<object>)y)!; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object>)y)!").WithArguments("I<object>", "I<object?>").WithLocation(12, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Ref()
        {
            var source =
@"class C
{
    static void F(ref string s, ref string? t)
    {
    }
    static void Main()
    {
        string? s = null;
        string t = """";
        F(ref s, ref t);
        F(ref s!, ref t!);
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (10,15): warning CS8604: Possible null reference argument for parameter 's' in 'void C.F(ref string s, ref string? t)'.
                //         F(ref s, ref t);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "s").WithArguments("s", "void C.F(ref string s, ref string? t)").WithLocation(10, 15),
                // (10,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(ref s, ref t);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(10, 22));
        }

        [Fact]
        public void SuppressNullableWarning_Ref_WithNestedDifferences()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
    }
    static void F1(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
    }
    static void F2(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,15): warning CS8604: Possible null reference argument for parameter 'a' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(10, 15),
                // (10,22): warning CS8601: Possible null reference assignment.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c").WithLocation(10, 22),
                // (10,29): warning CS8604: Possible null reference argument for parameter 'c' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "d").WithArguments("c", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(10, 29),
                // (10,36): warning CS8601: Possible null reference assignment.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "a").WithLocation(10, 36),
                // (14,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c!").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(14, 23),
                // (14,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a!").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(14, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Ref_WithUnassignedLocals()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        throw null;
    }
    static void F1()
    {
        List<string> a;
        List<string>? b;
        List<string?> c;
        List<string?>? d;
        F(ref b, ref c, ref d, ref a);
    }
    static void F2()
    {
        List<string> a;
        List<string>? b;
        List<string?> c;
        List<string?>? d;
        F(ref b!, ref c!, ref d!, ref a!);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (15,15): error CS0165: Use of unassigned local variable 'b'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "b").WithArguments("b").WithLocation(15, 15),
                // (15,22): error CS0165: Use of unassigned local variable 'c'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "c").WithArguments("c").WithLocation(15, 22),
                // (15,29): error CS0165: Use of unassigned local variable 'd'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "d").WithArguments("d").WithLocation(15, 29),
                // (15,36): error CS0165: Use of unassigned local variable 'a'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(15, 36),
                // (15,22): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(15, 22),
                // (15,36): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(15, 36),
                // (23,15): error CS0165: Use of unassigned local variable 'b'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "b").WithArguments("b").WithLocation(23, 15),
                // (23,23): error CS0165: Use of unassigned local variable 'c'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "c").WithArguments("c").WithLocation(23, 23),
                // (23,31): error CS0165: Use of unassigned local variable 'd'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "d").WithArguments("d").WithLocation(23, 31),
                // (23,39): error CS0165: Use of unassigned local variable 'a'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(23, 39),
                // (23,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c!").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(23, 23),
                // (23,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a!").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(23, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Out_WithNestedDifferences()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        throw null;
    }
    static void F1(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        F(out b, out c, out d, out a); // warn on `c` and `a`
    }
    static void F2(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,22): warning CS8601: Possible null reference assignment.
                //         F(out b, out c, out d, out a); // warn on `c` and `a`
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c").WithLocation(11, 22),
                // (11,36): warning CS8601: Possible null reference assignment.
                //         F(out b, out c, out d, out a); // warn on `c` and `a`
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "a").WithLocation(11, 36),
                // (15,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)'.
                //         F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c!").WithArguments("List<string?>", "List<string>", "b", "void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)").WithLocation(15, 23),
                // (15,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)'.
                //         F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a!").WithArguments("List<string>", "List<string?>", "d", "void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)").WithLocation(15, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Out()
        {
            var source =
@"class C
{
    static void F(out string s, out string? t)
    {
        s = string.Empty;
        t = string.Empty;
    }
    static void Main()
    {
        string? s;
        string t;
        F(out s, out t); // warn
        F(out s!, out t!); // ok
        F(out (s!), out (t!)); // errors
        F(out (s)!, out (t)!); // errors
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (15,19): error CS1525: Invalid expression term ','
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ",").WithArguments(",").WithLocation(15, 19),
                // (15,29): error CS1525: Invalid expression term ')'
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ")").WithArguments(")").WithLocation(15, 29),
                // (15,16): error CS0118: 's' is a variable but is used like a type
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_BadSKknown, "s").WithArguments("s", "variable", "type").WithLocation(15, 16),
                // (15,26): error CS0118: 't' is a variable but is used like a type
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_BadSKknown, "t").WithArguments("t", "variable", "type").WithLocation(15, 26),
                // (12,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out s, out t); // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(12, 22)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29903: 't! = s' should be an error.
        [Fact]
        [WorkItem(29903, "https://github.com/dotnet/roslyn/issues/29903")]
        public void SuppressNullableWarning_Assignment()
        {
            var source =
@"class C
{
    static void Main()
    {
        string? s = null;
        string t = string.Empty;
        t! = s;
        t! += s;
        (t!) = s;
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (7,14): warning CS8601: Possible null reference assignment.
                //         t! = s;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "s").WithLocation(7, 14),
                // (9,16): warning CS8601: Possible null reference assignment.
                //         (t!) = s;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "s").WithLocation(9, 16)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Conversion()
        {
            var source =
@"class A
{
    public static implicit operator B(A a) => new B();
}
class B
{
}
class C
{
    static void F(A? a)
    {
        G((B)a);
        G((B)a!);
    }
    static void G(B b)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,14): warning CS8604: Possible null reference argument for parameter 'a' in 'A.implicit operator B(A a)'.
                //         G((B)a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("a", "A.implicit operator B(A a)").WithLocation(12, 14));
        }

        // https://github.com/dotnet/roslyn/issues/29905: PreciseAbstractFlowPass.VisitSuppressNullableWarningExpression
        // should not assume node.Expression is an rvalue.
        [Fact]
        [WorkItem(29906, "https://github.com/dotnet/roslyn/issues/29906")]
        public void SuppressNullableWarning_Condition()
        {
            var source =
@"class C
{
    static object? F(bool b)
    {
        return (b && G(out var o))!? o : null;
    }
    static bool G(out object o)
    {
        o = new object();
        return true;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,16): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         return (b && G(out var o))!? o : null;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "(b && G(out var o))!").WithLocation(5, 16),
                // (5,38): error CS0165: Use of unassigned local variable 'o'
                //         return (b && G(out var o))!? o : null;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "o").WithArguments("o").WithLocation(5, 38)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ValueType_01()
        {
            var source =
@"struct S
{
    static void F()
    {
        G(1!);
        G(((int?)null)!);
        G(default(S)!);
        _ = new S2<object>()!;
    }
    static void G(object o)
    {
    }
    static void G<T>(T? t) where T : struct
    {
    }
}
struct S2<T>
{
}";

            // Feature enabled.
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(1!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "1!").WithLocation(5, 11),
                // (6,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "((int?)null)!").WithLocation(6, 11),
                // (7,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(default(S)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(S)!").WithLocation(7, 11),
                // (8,13): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "new S2<object>()!").WithLocation(8, 13));

            // Feature disabled.
            comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,12): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(1!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(5, 12),
                // (5,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(1!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "1!").WithLocation(5, 11),
                // (6,23): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 23),
                // (6,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "((int?)null)!").WithLocation(6, 11),
                // (7,21): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(default(S)!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 21),
                // (7,11): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(default(S)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(S)!").WithLocation(7, 11),
                // (8,29): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 29),
                // (8,13): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "new S2<object>()!").WithLocation(8, 13));

            // Feature disabled (C# 7).
            comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (5,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(1!);
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "1!").WithArguments("nullable reference types", "8.0").WithLocation(5, 11),
                // (6,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "((int?)null)!").WithArguments("nullable reference types", "8.0").WithLocation(6, 11),
                // (7,11): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         G(default(S)!);
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "default(S)!").WithArguments("nullable reference types", "8.0").WithLocation(7, 11),
                // (8,13): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "new S2<object>()!").WithArguments("nullable reference types", "8.0").WithLocation(8, 13),
                // (5,12): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(1!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(5, 12),
                // (5,11): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(1!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "1!").WithLocation(5, 11),
                // (6,23): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 23),
                // (6,11): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "((int?)null)!").WithLocation(6, 11),
                // (7,21): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         G(default(S)!);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 21),
                // (7,11): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         G(default(S)!);
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(S)!").WithLocation(7, 11),
                // (8,29): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 29),
                // (8,13): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "new S2<object>()!").WithLocation(8, 13));
        }

        [Fact]
        public void SuppressNullableWarning_ValueType_02()
        {
            var source =
@"struct S<T> where T : class
{
    static S<object> F(S<object?> s) => s!/*T:S<object?>*/;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (3,41): error CS8624: The suppression operator (!) can only be applied to reference types.
                //     static S<object> F(S<object?> s) => s!/*T:S<object?>*/;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "s!").WithLocation(3, 41),
                // (3,41): warning CS8619: Nullability of reference types in value of type 'S<object?>' doesn't match target type 'S<object>'.
                //     static S<object> F(S<object?> s) => s!/*T:S<object?>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "s!").WithArguments("S<object?>", "S<object>").WithLocation(3, 41));
            comp.VerifyTypes();
        }

        [Fact]
        public void SuppressNullableWarning_GenericType()
        {
            var source =
@"struct S
{
    static void F<TStruct, TRef, TUnconstrained>(TStruct tStruct, TRef tRef, TUnconstrained tUnconstrained)
        where TStruct : struct where TRef : class
    {
        _ = tStruct!;
        _ = tRef!;
        _ = tUnconstrained!;
    }
}";

            // Feature enabled.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,13): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "tStruct!").WithLocation(6, 13));

            // Feature disabled.
            comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,20): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 20),
                // (6,13): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "tStruct!").WithLocation(6, 13),
                // (7,17): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tRef!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 17),
                // (8,27): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tUnconstrained!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 27));

            // Feature disabled (C# 7).
            comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (6,13): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "tStruct!").WithArguments("nullable reference types", "8.0").WithLocation(6, 13),
                // (7,13): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         _ = tRef!;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "tRef!").WithArguments("nullable reference types", "8.0").WithLocation(7, 13),
                // (8,13): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                //         _ = tUnconstrained!;
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "tUnconstrained!").WithArguments("nullable reference types", "8.0").WithLocation(8, 13),
                // (6,20): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(6, 20),
                // (6,13): warning CS8624: The suppression operator (!) can only be applied to reference types.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "tStruct!").WithLocation(6, 13),
                // (7,17): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tRef!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 17),
                // (8,27): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //         _ = tUnconstrained!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(8, 27));
        }

        [Fact]
        public void SuppressNullableWarning_TypeParameters_01()
        {
            var source =
@"class C
{
    static void F1<T1>(T1 t1)
    {
        default(T1).ToString(); // 1
        default(T1)!.ToString();
        t1.ToString(); // 2
        t1!.ToString();
    }
    static void F2<T2>(T2 t2) where T2 : class
    {
        default(T2).ToString(); // 3
        default(T2)!.ToString();
        t2.ToString();
        t2!.ToString();
    }
    static void F3<T3>(T3 t3) where T3 : struct
    {
        default(T3).ToString();
        default(T3)!.ToString(); // 4
        t3.ToString();
        t3!.ToString(); // 5
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         default(T1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T1)").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 9),
                // (12,9): warning CS1720: Expression will always cause a System.NullReferenceException because the default value of 'T2' is null
                //         default(T2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_DotOnDefault, "default(T2).ToString").WithArguments("T2").WithLocation(12, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         default(T2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T2)").WithLocation(12, 9),
                // (20,9): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         default(T3)!.ToString(); // 4
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(T3)!").WithLocation(20, 9),
                // (22,9): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         t3!.ToString(); // 5
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "t3!").WithLocation(22, 9));
        }

        [Fact]
        public void SuppressNullableWarning_TypeParameters_02()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(out T t, out U u) where U : T;
}
class B1<T> : A<T> where T : class
{
    internal override void F<U>(out T t1, out U u1)
    {
        t1 = default(T)!;
        t1 = default!;
        u1 = default(U)!;
        u1 = default!;
    }
}
class B2<T> : A<T> where T : struct
{
    internal override void F<U>(out T t2, out U u2)
    {
        t2 = default(T)!; // 1
        t2 = default!; // 2
        u2 = default(U)!; // 3
        u2 = default!; // 4
    }
}
class B3<T> : A<T>
{
    internal override void F<U>(out T t3, out U u3)
    {
        t3 = default(T)!;
        t3 = default!;
        u3 = default(U)!;
        u3 = default!;
    }
}
class B4 : A<object>
{
    internal override void F<U>(out object t4, out U u4)
    {
        t4 = default(object)!;
        t4 = default!;
        u4 = default(U)!;
        u4 = default!;
    }
}
class B5 : A<int>
{
    internal override void F<U>(out int t5, out U u5)
    {
        t5 = default(int)!; // 5
        t5 = default!; // 6
        u5 = default(U)!; // 7
        u5 = default!; // 8
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            // https://github.com/dotnet/roslyn/issues/29907: Report error for `default!`.
            comp.VerifyDiagnostics(
                // (19,14): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         t2 = default(T)!; // 1
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(T)!").WithLocation(19, 14),
                // (21,14): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         u2 = default(U)!; // 3
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(U)!").WithLocation(21, 14),
                // (49,14): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         t5 = default(int)!; // 5
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(int)!").WithLocation(49, 14),
                // (51,14): error CS8624: The suppression operator (!) can only be applied to reference types.
                //         u5 = default(U)!; // 7
                Diagnostic(ErrorCode.WRN_SuppressionOperatorNotReferenceType, "default(U)!").WithLocation(51, 14));
        }

        [Fact]
        public void SuppressNullableWarning_NonNullOperand()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        G(""""!);
        G((new string('a', 1))!);
        G((s ?? """")!);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_InvalidOperand()
        {
            var source =
@"class C
{
    static void F(C c)
    {
        G(F!);
        G(c.P!);
    }
    static void G(object o)
    {
    }
    object P { set { } }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,11): error CS1503: Argument 1: cannot convert from 'method group' to 'object'
                //         G(F!);
                Diagnostic(ErrorCode.ERR_BadArgType, "F!").WithArguments("1", "method group", "object").WithLocation(5, 11),
                // (6,11): error CS0154: The property or indexer 'C.P' cannot be used in this context because it lacks the get accessor
                //         G(c.P!);
                Diagnostic(ErrorCode.ERR_PropertyLacksGet, "c.P").WithArguments("C.P").WithLocation(6, 11));
        }

        [Fact]
        public void SuppressNullableWarning_InvalidArrayInitializer()
        {
            var source =
@"class C
{
    static void F()
    {
        var a = new object[] { new object(), F! };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,46): error CS0428: Cannot convert method group 'F' to non-delegate type 'object'. Did you intend to invoke the method?
                //         var a = new object[] { new object(), F! };
                Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "F!").WithArguments("F", "object").WithLocation(5, 46));
        }

        [Fact]
        public void SuppressNullableWarning_IndexedProperty()
        {
            var source0 =
@"Imports System
Imports System.Runtime.InteropServices
<Assembly: PrimaryInteropAssembly(0, 0)> 
<Assembly: Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E210"")> 
<ComImport()>
<Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E211"")>
Public Class A
    Public ReadOnly Property P(i As Integer) As Object
        Get
            Return Nothing
        End Get
    End Property
    Public ReadOnly Property Q(Optional i As Integer = 0) As Object
        Get
            Return Nothing
        End Get
    End Property
End Class";
            var ref0 = BasicCompilationUtils.CompileToMetadata(source0);
            var source =
@"class B
{
    static object F(A a, int i)
    {
        if (i > 0)
        {
            return a.P!;
        }
        return a.Q!;
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                new[] { ref0 },
                parseOptions: TestOptions.Regular8, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0856: Indexed property 'A.P' has non-optional arguments which must be provided
                //             return a.P!;
                Diagnostic(ErrorCode.ERR_IndexedPropertyRequiresParams, "a.P").WithArguments("A.P").WithLocation(7, 20));
        }

        [Fact]
        public void LocalTypeInference()
        {
            var source =
@"class C
{
    static void F(string? s, string? t)
    {
        if (s != null)
        {
            var x = s;
            G(x); // no warning
            x = t;
        }
        else
        {
            var y = s;
            G(y); // warning
            y = t;
        }
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x = t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(9, 17),
                // (14,15): warning CS8604: Possible null reference argument for parameter 's' in 'void C.G(string s)'.
                //             G(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("s", "void C.G(string s)").WithLocation(14, 15));
        }

        [Fact]
        public void AssignmentInCondition_01()
        {
            var source =
@"class C
{
    object P => null;
    static void F(object o)
    {
        C? c;
        while ((c = o as C) != null)
        {
            o = c.P;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,17): warning CS8603: Possible null reference return.
                //     object P => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 17));
        }

        [Fact]
        public void AssignmentInCondition_02()
        {
            var source =
@"class C
{
    object? P => null;
    static void F(object? o)
    {
        C? c;
        while ((c = o as C) != null)
        {
            o = c.P;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void StructAsNullableInterface()
        {
            var source =
@"interface I
{
    void F();
}
struct S : I
{
    void I.F()
    {
    }
}
class C
{
    static void F(I? i)
    {
        i.F();
    }
    static void Main()
    {
        F(new S());
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         i.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "i").WithLocation(15, 9));
        }

        [Fact]
        public void IsNull()
        {
            var source =
@"class C
{
    static void F1(object o) { }
    static void F2(object o) { }
    static void G(object? o)
    {
        if (o is null)
        {
            F1(o);
        }
        else
        {
            F2(o);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);

            comp.VerifyDiagnostics(
                // (9,16): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F1(object o)'.
                //             F1(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.F1(object o)").WithLocation(9, 16));
        }

        [Fact]
        public void IsInvalidConstant()
        {
            var source =
@"class C
{
    static void F(object o) { }
    static void G(object? o)
    {
        if (o is F)
        {
            F(o);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS0428: Cannot convert method group 'F' to non-delegate type 'object'. Did you intend to invoke the method?
                //         if (o is F)
                Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "F").WithArguments("F", "object").WithLocation(6, 18),
                // (8,15): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //             F(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.F(object o)").WithLocation(8, 15));
        }

        [Fact]
        public void IsPattern_01()
        {
            var source =
@"class C
{
    static void F(object x) { }
    static void G(string s)
    {
        F(s is var o);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // https://github.com/dotnet/roslyn/issues/29909: Should not warn on either call to F(string).
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29909")]
        [WorkItem(29909, "https://github.com/dotnet/roslyn/issues/29909")]
        public void IsPattern_02()
        {
            var source =
@"class C
{
    static void F(string s) { }
    static void G(string? s)
    {
        if (s is string t)
        {
            F(t);
            F(s);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // https://github.com/dotnet/roslyn/issues/29909: Should only warn on F(x) in `case null`.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29909")]
        [WorkItem(29909, "https://github.com/dotnet/roslyn/issues/29909")]
        public void PatternSwitch()
        {
            var source =
@"class C
{
    static void F(object o) { }
    static void G(object? x)
    {
        switch (x)
        {
            case string s:
                F(s);
                F(x); // string s
                break;
            case object y when y is string t:
                F(y);
                F(t);
                F(x); // object y
                break;
            case null:
                F(x); // null
                break;
            default:
                F(x); // default
                break;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,19): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //                 F(x); // null
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "void C.F(object o)").WithLocation(18, 19));
        }

        [Fact]
        public void Feature()
        {
            var source =
@"class C
{
    static object F() => null;
    static object F(object? o) => o;
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking", "0"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking", "1"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));
        }

        [Fact]
        public void AllowMemberOptOut()
        {
            var source1 =
@"partial class C
{
" + NonNullTypesOff() + @"
    static void F(object o) { }
}";
            var source2 =
@"partial class C
{


    static void G(object o) { }
    static void M(object? o)
    {
        F(o);
        G(o);
    }
}";

            var comp = CreateCompilation(
                new[] { source1, source2 },
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void M(object? o)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 25)
                );

            comp = CreateCompilation(
                new[] { source1, source2 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.G(object o)'.
                //         G(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.G(object o)").WithLocation(9, 11));
        }

        [Fact]
        public void InferLocalNullability()
        {
            var source =
@"class C
{
    static string? F(string s) => s;
    static void G(string s)
    {
        string x;
        x = F(s);
        F(x);
        string? y = s;
        y = F(y);
        F(y);
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = F(s);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F(s)").WithLocation(7, 13),
                // (8,11): warning CS8604: Possible null reference argument for parameter 's' in 'string? C.F(string s)'.
                //         F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("s", "string? C.F(string s)").WithLocation(8, 11),
                // (11,11): warning CS8604: Possible null reference argument for parameter 's' in 'string? C.F(string s)'.
                //         F(y);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("s", "string? C.F(string s)").WithLocation(11, 11));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String!", symbol.Type.ToTestDisplayString(true));
        }

        [Fact]
        public void InferLocalType_UsedInDeclaration()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        var a = new[] { F(a) };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,27): error CS0841: Cannot use local variable 'a' before it is declared
                //         var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "a").WithArguments("a").WithLocation(11, 27),
                // (11,27): error CS0165: Use of unassigned local variable 'a'
                //         var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(11, 27));
        }

        [Fact]
        public void InferLocalType_UsedInDeclaration_Script()
        {
            var source =
@"using System;
using System.Collections.Generic;
static T F<T>(IEnumerable<T> e)
{
    throw new NotImplementedException();
}
var a = new[] { F(a) };";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Script.WithLanguageVersion(LanguageVersion.CSharp8));
            comp.VerifyDiagnostics(
                // (7,5): error CS7019: Type of 'a' cannot be inferred since its initializer directly or indirectly refers to the definition.
                // var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_RecursivelyTypedVariable, "a").WithArguments("a").WithLocation(7, 5));
        }

        [Fact]
        public void InferLocalType_UsedBeforeDeclaration()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        var a = new[] { F(b) };
        var b = a;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,27): error CS0841: Cannot use local variable 'b' before it is declared
                //         var a = new[] { F(b) };
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "b").WithArguments("b").WithLocation(11, 27));
        }

        [Fact]
        public void InferLocalType_OutVarError()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        dynamic d = null!;
        d.F(out var v);
        F(v).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,21): error CS8197: Cannot infer the type of implicitly-typed out variable 'v'.
                //         d.F(out var v);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedOutVariable, "v").WithArguments("v").WithLocation(12, 21));
        }

        [Fact]
        public void InferLocalType_OutVarError_Script()
        {
            var source =
@"using System;
using System.Collections.Generic;
static T F<T>(IEnumerable<T> e)
{
    throw new NotImplementedException();
}
dynamic d = null!;
d.F(out var v);
F(v).ToString();";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, parseOptions: TestOptions.Script.WithLanguageVersion(LanguageVersion.CSharp8));
            comp.VerifyDiagnostics(
                // (8,13): error CS8197: Cannot infer the type of implicitly-typed out variable 'v'.
                // d.F(out var v);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedOutVariable, "v").WithArguments("v").WithLocation(8, 13),
                // (7,17): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                // dynamic d = null!;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(7, 17));
        }

        /// <summary>
        /// Default value for non-nullable parameter
        /// should not result in a warning at the call site.
        /// </summary>
        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_FromMetadata()
        {
            var source0 =
@"public class C
{
    public static void F(object o = null)
    {
    }
}";
            var comp0 = CreateCompilation(
                new[] { source0 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp0.VerifyDiagnostics(
                // (3,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public static void F(object o = null)
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(3, 37));
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"class Program
{
    static void Main()
    {
        C.F();
        C.F(null);
    }
}";
            var comp1 = CreateCompilation(
                new[] { source1 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8,
                references: new[] { ref0 });
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
        }

        [Fact]
        public void ParameterDefaultValue_WithSuppression()
        {
            var source0 =
@"class C
{
    void F(object o = null!)
    {
    }
}";
            var comp = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_01()
        {
            var source =
@"class C
{
    const string? S0 = null;
    const string? S1 = """";
    static string? F() => string.Empty;
    static void F0(string s = null) { }
    static void F1(string s = default) { }
    static void F2(string s = default(string)) { }
    static void F3(string x = (string)null, string y = (string?)null) { }
    static void F4(string s = S0) { }
    static void F5(string s = S1) { }
    static void F6(string s = F()) { }
    static void M()
    {
        F0();
        F1();
        F2();
        F3();
        F4();
        F5();
        F6();
        F0(null);
        F0(string.Empty);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F0(string s = null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 31),
                // (7,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1(string s = default) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 31),
                // (8,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F2(string s = default(string)) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(8, 31),
                // (9,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F3(string x = (string)null, string y = (string?)null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(9, 31),
                // (9,56): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F3(string x = (string)null, string y = (string?)null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(9, 56),
                // (10,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F4(string s = S0) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "S0").WithLocation(10, 31),
                // (12,31): error CS1736: Default parameter value for 's' must be a compile-time constant
                //     static void F6(string s = F()) { }
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "F()").WithArguments("s").WithLocation(12, 31),
                // (22,12): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(22, 12));
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_02()
        {
            var source =
@"class C
{
    const string? S0 = null;
    static void F0(string s = null!) { }
    static void F1(string x = (string)null!, string y = ((string)null)!) { }
    static void F2(string x = default!, string y = default(string)!) { }
    static void F3(string s = (S0!)!) { }
    static void M()
    {
        F0();
        F1();
        F2();
        F3();
        F1(x: null);
        F1(y: null);
        F2(null!, null);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1(x: null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 15),
                // (15,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1(y: null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 15),
                // (16,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F2(null!, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(16, 19));
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [WorkItem(29910, "https://github.com/dotnet/roslyn/issues/29910")]
        [Fact]
        public void ParameterDefaultValue_03()
        {
            var source =
@"interface I { }
class C : I { }
class P
{
    static void F0<T>(T t = default) { }
    static void F1<T>(T t = null) where T : class { }
    static void F2<T>(T t = default) where T : struct { }
    static void F3<T>(T t = default) where T : new() { }
    static void F4<T>(T t = null) where T : C { }
    static void F5<T>(T t = default) where T : I { }
    static void F6<T, U>(T t = default) where T : U { }
    static void G0()
    {
        F0<object>();
        F0<object>(default);
        F0(new object());
        F1<object>();
        F1<object>(default);
        F1(new object());
        F2<int>();
        F2<int>(default);
        F2(2);
        F3<object>();
        F3<object>(default);
        F3(new object());
        F4<C>();
        F4<C>(default);
        F4(new C());
        F5<I>();
        F5<I>(default);
        F5(new C());
        F6<object, object>();
        F6<object, object>(default);
        F6<object, object>(new object());
    }
    static void G0<T>()
    {
        F0<T>(); // 0
        F0<T>(default); // 0
        F6<T, T>(); // 0
        F6<T, T>(default); // 0
    }
    static void G1<T>() where T : class
    {
        F0<T>(); // 1
        F0<T>(default); // 1
        F1<T>(); // 1
        F1<T>(default); // 1
        F6<T, T>(); // 1
        F6<T, T>(default); // 1
    }
    static void G2<T>() where T : struct
    {
        F0<T>(); // 2
        F0<T>(default); // 2
        F2<T>(); // 2
        F2<T>(default); // 2
        F3<T>(); // 2
        F3<T>(default); // 2
        F6<T, T>(); // 2
        F6<T, T>(default); // 2
    }
    static void G3<T>() where T : new()
    {
        F0<T>(); // 3
        F0<T>(default); // 3
        F0<T>(new T()); // 3
        F3<T>(); // 3
        F3<T>(default); // 3
        F3<T>(new T()); // 3
        F6<T, T>(); // 3
        F6<T, T>(default); // 3
        F6<T, T>(new T()); // 3
    }
    static void G4<T>() where T : C
    {
        F0<T>(); // 4
        F0<T>(default); // 4
        F1<T>(); // 4
        F1<T>(default); // 4
        F4<T>(); // 4
        F4<T>(default); // 4
        F5<T>(); // 4
        F5<T>(default); // 4
        F6<T, T>(); // 4
        F6<T, T>(default); // 4
    }
    static void G5<T>() where T : I
    {
        F0<T>(); // 5
        F0<T>(default); // 5
        F5<T>(); // 5
        F5<T>(default); // 5
        F6<T, T>(); // 5
        F6<T, T>(default); // 5
    }
    static void G6<T, U>() where T : U
    {
        F0<T>(); // 6
        F0<T>(default); // 6
        F6<T, U>(); // 6
        F6<T, U>(default); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29910: Duplicate WRN_NullAsNonNullable diagnoistics at some locations
            comp.VerifyDiagnostics(
                // (6,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1<T>(T t = null) where T : class { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 29),
                // (9,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F4<T>(T t = null) where T : C { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(9, 29),
                // (15,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(15, 20),
                // (18,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 20),
                // (24,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F3<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(24, 20),
                // (27,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F4<C>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(27, 15),
                // (30,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<I>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(30, 15),
                // (33,28): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<object, object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(33, 28),
                // (39,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 0
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(39, 15),
                // (41,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 0
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(41, 18),
                // (46,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(46, 15),
                // (48,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(48, 15),
                // (50,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(50, 18),
                // (66,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(66, 15),
                // (69,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F3<T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(69, 15),
                // (72,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(72, 18),
                // (78,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(78, 15),
                // (80,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(80, 15),
                // (82,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F4<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(82, 15),
                // (84,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(84, 15),
                // (86,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(86, 18),
                // (91,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(91, 15),
                // (91,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(91, 15),
                // (93,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(93, 15),
                // (93,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(93, 15),
                // (95,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(95, 18),
                // (95,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(95, 18),
                // (100,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 6
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(100, 15),
                // (102,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, U>(default); // 6
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(102, 18)
                );

            // No warnings with C#7.3.
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.3", "8.0").WithLocation(1, 1)
                );
        }

        [Fact]
        public void PoisonNonNullTypes_InMetadata()
        {
            var il = @"
.class public auto ansi sealed beforefieldinit System.Runtime.CompilerServices.NonNullTypesAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = (
        01 00 ff 7f 00 00 01 00 54 02 0d 41 6c 6c 6f 77
        4d 75 6c 74 69 70 6c 65 00
    )
    .custom instance void [mscorlib]System.ObsoleteAttribute::.ctor(string) =
        {string('The NonNullTypes attribute is not supported in this version of your compiler. Please use a C# 8.0 compiler (or above).')}

    .method public hidebysig specialname rtspecialname instance void .ctor ( [opt] bool flag ) cil managed
    {
        .param [1] = bool(true)

        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: nop
        IL_0008: ret
    }
}
";
            var comp = CreateCompilationWithIL("[module: System.Runtime.CompilerServices.NonNullTypes(true)]", il);
            comp.VerifyDiagnostics(
                // (1,10): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [module: System.Runtime.CompilerServices.NonNullTypes(true)]
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "System.Runtime.CompilerServices.NonNullTypes(true)").WithLocation(1, 10)
                );

            // Injected NNT type silently wins
            var tree = comp.SyntaxTrees.Single();
            var attribute = tree.GetRoot().DescendantNodes().OfType<AttributeSyntax>().Single();
            var model = comp.GetSemanticModel(tree);
            var type = model.GetTypeInfo(attribute.Name).Type;
            Assert.IsType<InjectedNonNullTypesAttributeSymbol>(type);
        }

        [Fact]
        public void NonNullTypesInCSharp7_InSource()
        {
            var source = @"
" + NonNullTypesOn() + @"
public class C
{
    public static string field;
}
public class D
{
" + NonNullTypesOn() + @"
    public static string field;

" + NonNullTypesOn() + @"
    public static string Method(string s) => throw null;

" + NonNullTypesOn() + @"
    public static string Property { get; set; }

" + NonNullTypesOn() + @"
    public static event System.Action Event;
" + NonNullTypesOff() + @"
    void M()
    {
        C.field = null;
        D.field = null;
        D.Method(null);
        D.Property = null;
        D.Event();
    }
}
";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // (2,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(2, 2),
                // (9,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(9, 2),
                // (12,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(12, 2),
                // (15,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(15, 2),
                // (18,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(18, 2),
                // (20,2): error CS8107: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
                // #nullable disable
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "nullable").WithArguments("nullable reference types", "8.0").WithLocation(20, 2)
                );
        }

        [Fact]
        public void NonNullTypesInCSharp7_FromMetadata()
        {
            var libSource = @"
" + NonNullTypesOn() + @"
public class C
{
    public static string field;
}
public class D
{
" + NonNullTypesOn() + @"
    public static string field;

" + NonNullTypesOn() + @"
    public static string Method(string s) => throw null;

" + NonNullTypesOn() + @"
    public static string Property { get; set; }

" + NonNullTypesOn() + @"
    public static event System.Action Event;
}
";
            var libComp = CreateCompilation(new[] { libSource });
            libComp.VerifyDiagnostics(
                // (19,39): warning CS0067: The event 'D.Event' is never used
                //     public static event System.Action Event;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "Event").WithArguments("D.Event").WithLocation(19, 39)
                );

            var source = @"
class Client
{
    void M()
    {
        C.field = null;
        D.field = null;
        D.Method(null);
        D.Property = null;
        D.Event();
    }
}
";
            var comp = CreateCompilation(source, references: new[] { libComp.EmitToImageReference() }, parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // (10,11): error CS0079: The event 'D.Event' can only appear on the left hand side of += or -=
                //         D.Event();
                Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("D.Event").WithLocation(10, 11)
                );

            var comp2 = CreateCompilation(source, references: new[] { libComp.EmitToImageReference() });
            comp2.VerifyDiagnostics(
                // (10,11): error CS0079: The event 'D.Event' can only appear on the left hand side of += or -=
                //         D.Event();
                Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("D.Event").WithLocation(10, 11)
                );
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_04()
        {
            var source =
@"partial class C
{
    static partial void F(object? x = null, object y = null);
    static partial void F(object? x, object y) { }
    static partial void G(object x, object? y);
    static partial void G(object x = null, object? y = null) { }
    static void M()
    {
        F();
        G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,34): warning CS1066: The default value specified for parameter 'x' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_DefaultValueForUnconsumedLocation, "x").WithArguments("x").WithLocation(6, 34),
                // (6,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 38),
                // (6,52): warning CS1066: The default value specified for parameter 'y' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_DefaultValueForUnconsumedLocation, "y").WithArguments("y").WithLocation(6, 52),
                // (3,56): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static partial void F(object? x = null, object y = null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(3, 56),
                // (10,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, object)'
                //         G();
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, object?)").WithLocation(10, 9));
        }

        [Fact]
        public void InvalidThrowTerm()
        {
            var source =
@"class C
{
    static string F(string s) => s + throw new System.Exception();
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (3,38): error CS1525: Invalid expression term 'throw'
                //     static string F(string s) => s + throw new System.Exception();
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "throw new System.Exception()").WithArguments("throw").WithLocation(3, 38));
        }

        [Fact]
        public void UnboxingConversion()
        {
            var source =
@"using System.Collections.Generic;
class Program
{
    static IEnumerator<T> M<T>() => default(T);
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,37): error CS0266: Cannot implicitly convert type 'T' to 'System.Collections.Generic.IEnumerator<T>'. An explicit conversion exists (are you missing a cast?)
                //     static IEnumerator<T> M<T>() => default(T);
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "default(T)").WithArguments("T", "System.Collections.Generic.IEnumerator<T>").WithLocation(4, 37));
        }

        [Fact]
        public void DeconstructionConversion_NoDeconstructMethod()
        {
            var source =
@"class C
{
    static void F(C c)
    {
        var (x, y) = c;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,22): error CS1061: 'C' does not contain a definition for 'Deconstruct' and no extension method 'Deconstruct' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "c").WithArguments("C", "Deconstruct").WithLocation(5, 22),
                // (5,22): error CS8129: No suitable Deconstruct instance or extension method was found for type 'C', with 2 out parameters and a void return type.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "c").WithArguments("C", "2").WithLocation(5, 22),
                // (5,14): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x'.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x").WithArguments("x").WithLocation(5, 14),
                // (5,17): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y'.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y").WithArguments("y").WithLocation(5, 17));
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void ConditionalAccessDelegateInvoke()
        {
            var source =
@"using System;
class C<T>
{
    static T F(Func<T>? f)
    {
        return f?.Invoke();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29916: WRN_NullabilityMismatchInAssignment is cascading, caused by the binding error.
            comp.VerifyDiagnostics(
                // (6,17): error CS0023: Operator '?' cannot be applied to operand of type 'T'
                //         return f?.Invoke();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "?").WithArguments("?", "T").WithLocation(6, 17),
                // (6,16): warning CS8619: Nullability of reference types in value of type '?' doesn't match target type 'T'.
                //         return f?.Invoke();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "f?.Invoke()").WithArguments("?", "T").WithLocation(6, 16)
                );
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_01()
        {
            var source =
@"using System.Runtime.InteropServices;
interface I
{
    int P { get; }
}
[StructLayout(LayoutKind.Auto)]
struct S : I
{
    int I.P => 0;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_01_WithEvent()
        {
            var source =
@"using System;
using System.Runtime.InteropServices;
interface I
{
    event Func<int> E;
}
[StructLayout(LayoutKind.Auto)]
struct S : I
{
    event Func<int> I.E { add => throw null; remove => throw null; }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_02()
        {
            var source =
@"[A(P)]
class A : System.Attribute
{
    string P => null;
}";
            var comp = CreateCompilation(
                 new[] { source }, options: WithNonNullTypesTrue(),
                 parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (1,4): error CS0120: An object reference is required for the non-static field, method, or property 'A.P'
                // [A(P)]
                Diagnostic(ErrorCode.ERR_ObjectRequired, "P").WithArguments("A.P").WithLocation(1, 4),
                // (1,2): error CS1729: 'A' does not contain a constructor that takes 1 arguments
                // [A(P)]
                Diagnostic(ErrorCode.ERR_BadCtorArgCount, "A(P)").WithArguments("A", "1").WithLocation(1, 2),
                // (4,17): warning CS8603: Possible null reference return.
                //     string P => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(4, 17));
        }

        [Fact]
        [WorkItem(29954, "https://github.com/dotnet/roslyn/issues/29954")]
        public void UnassignedOutParameterClass()
        {
            var source =
@"class C
{
    static void G(out C? c)
    {
        c.ToString(); // 1
        c = null;
        c.ToString(); // 2
        c = new C();
        c.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29954: Should not report warning for
            // c.ToString(); // 3
            comp.VerifyDiagnostics(
                // (5,9): error CS0269: Use of unassigned out parameter 'c'
                //         c.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolationOut, "c").WithArguments("c").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(7, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 9));
        }

        [Fact]
        public void UnassignedOutParameterClassField()
        {
            var source =
@"class C
{
#pragma warning disable 0649
    object? F;
    static void G(out C c)
    {
        object o = c.F;
        c.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0269: Use of unassigned out parameter 'c'
                //         object o = c.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationOut, "c").WithArguments("c").WithLocation(7, 20),
                // (5,17): error CS0177: The out parameter 'c' must be assigned to before control leaves the current method
                //     static void G(out C c)
                Diagnostic(ErrorCode.ERR_ParamUnassigned, "G").WithArguments("c").WithLocation(5, 17),
                // (7,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object o = c.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F").WithLocation(7, 20),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(8, 9));
        }

        [Fact]
        public void UnassignedOutParameterStructField()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    static void G(out S s)
    {
        object o = s.F;
        s.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0170: Use of possibly unassigned field 'F'
                //         object o = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(7, 20),
                // (5,17): error CS0177: The out parameter 's' must be assigned to before control leaves the current method
                //     static void G(out S s)
                Diagnostic(ErrorCode.ERR_ParamUnassigned, "G").WithArguments("s").WithLocation(5, 17));
        }

        [Fact]
        public void UnassignedLocalField()
        {
            var source =
@"class C
{
    static void F()
    {
        S s;
        C c;
        c = s.F;
        s.F.ToString();
    }
}
struct S
{
    internal C? F;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): error CS0170: Use of possibly unassigned field 'F'
                //         c = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(7, 13),
                // (13,17): warning CS0649: Field 'S.F' is never assigned to, and will always have its default value null
                //     internal C? F;
                Diagnostic(ErrorCode.WRN_UnassignedInternalField, "F").WithArguments("S.F", "null").WithLocation(13, 17));
        }

        [Fact]
        public void UnassignedLocalField_Conditional()
        {
            var source =
@"class C
{
    static void F(bool b)
    {
        S s;
        object o;
        if (b)
        {
            s.F = new object();
            s.G = new object();
        }
        else
        {
            o = s.F;
        }
        o = s.G;
    }
}
struct S
{
    internal object? F;
    internal object? G;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): error CS0170: Use of possibly unassigned field 'F'
                //             o = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(14, 17),
                // (16,13): error CS0170: Use of possibly unassigned field 'G'
                //         o = s.G;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.G").WithArguments("G").WithLocation(16, 13));
        }

        [Fact]
        public void UnassignedLocalProperty()
        {
            var source =
@"class C
{
    static void F()
    {
        S s;
        C c;
        c = s.P;
        s.P.ToString();
    }
}
struct S
{
    internal C? P { get => null; }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = s.P;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s.P").WithLocation(7, 13),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s.P").WithLocation(8, 9));
        }

        [Fact]
        public void UnassignedClassAutoProperty()
        {
            var source =
@"class C
{
    object? P { get; }
    void M(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedClassAutoProperty_Constructor()
        {
            var source =
@"class C
{
    object? P { get; }
    C(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedStructAutoProperty()
        {
            var source =
@"struct S
{
    object? P { get; }
    void M(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedStructAutoProperty_Constructor()
        {
            var source =
@"struct S
{
    object? P { get; }
    S(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): error CS8079: Use of possibly unassigned auto-implemented property 'P'
                //         o = P;
                Diagnostic(ErrorCode.ERR_UseDefViolationProperty, "P").WithArguments("P").WithLocation(6, 13),
                // (4,5): error CS0843: Auto-implemented property 'S.P' must be fully assigned before control is returned to the caller.
                //     S(out object o)
                Diagnostic(ErrorCode.ERR_UnassignedThisAutoProperty, "S").WithArguments("S.P").WithLocation(4, 5));
        }

        [Fact]
        public void ParameterField_Class()
        {
            var source =
@"class C
{
#pragma warning disable 0649
    object? F;
    static void M(C x)
    {
        C y = x;
        object z = y.F;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z = y.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y.F").WithLocation(8, 20));
        }

        [Fact]
        public void ParameterField_Struct()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    static void M(S x)
    {
        S y = x;
        object z = y.F;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z = y.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y.F").WithLocation(8, 20));
        }

        [Fact]
        public void InstanceFieldStructTypeExpressionReceiver()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    void M()
    {
        S.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS0120: An object reference is required for the non-static field, method, or property 'S.F'
                //         S.F.ToString();
                Diagnostic(ErrorCode.ERR_ObjectRequired, "S.F").WithArguments("S.F").WithLocation(7, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         S.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S.F").WithLocation(7, 9));
        }

        [Fact]
        public void InstanceFieldPrimitiveRecursiveStruct()
        {
            var source =
@"#pragma warning disable 0649
namespace System
{
    public class Object
    {
        public int GetHashCode() => 0;
    }
    public abstract class ValueType { }
    public struct Void { }
    public struct Int32
    {
        Int32 _value;
        object? _f;
        void M()
        {
            _value = _f.GetHashCode();
        }
    }
    public class String { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,22): warning CS8602: Possible dereference of a null reference.
                //             _value = _f.GetHashCode();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_f").WithLocation(16, 22)
                );
        }

        [Fact]
        public void Pointer()
        {
            var source =
@"class C
{
    static unsafe void F(int* p)
    {
        *p = 0;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(TestOptions.UnsafeReleaseDll));
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TaskMethodReturningNull()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static Task F0() => null;
    static Task<string> F1() => null;
    static Task<string?> F2() { return null; }
    static Task<T> F3<T>() { return default; }
    static Task<T> F4<T>() { return default(Task<T>); }
    static Task<T> F5<T>() where T : class { return null; }
    static Task<T?> F6<T>() where T : class => null;
    static Task? G0() => null;
    static Task<string>? G1() => null;
    static Task<T>? G3<T>() { return default; }
    static Task<T?>? G6<T>() where T : class => null;
}";
            var comp = CreateCompilationWithMscorlib46(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,25): warning CS8603: Possible null reference return.
                //     static Task F0() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(4, 25),
                // (5,33): warning CS8603: Possible null reference return.
                //     static Task<string> F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(5, 33),
                // (6,40): warning CS8603: Possible null reference return.
                //     static Task<string?> F2() { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 40),
                // (7,37): warning CS8603: Possible null reference return.
                //     static Task<T> F3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(7, 37),
                // (8,37): warning CS8603: Possible null reference return.
                //     static Task<T> F4<T>() { return default(Task<T>); }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(Task<T>)").WithLocation(8, 37),
                // (9,53): warning CS8603: Possible null reference return.
                //     static Task<T> F5<T>() where T : class { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(9, 53),
                // (10,48): warning CS8603: Possible null reference return.
                //     static Task<T?> F6<T>() where T : class => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 48));
        }

        // https://github.com/dotnet/roslyn/issues/29957: Should not report WRN_NullReferenceReturn for F0.
        [WorkItem(23275, "https://github.com/dotnet/roslyn/issues/23275")]
        [WorkItem(29957, "https://github.com/dotnet/roslyn/issues/29957")]
        [Fact]
        public void AsyncTaskMethodReturningNull()
        {
            var source =
@"#pragma warning disable 1998
using System.Threading.Tasks;
class C
{
    static async Task F0() { return null; }
    static async Task<string> F1() => null;
    static async Task<string?> F2() { return null; }
    static async Task<T> F3<T>() { return default; }
    static async Task<T> F4<T>() { return default(T); }
    static async Task<T> F5<T>() where T : class { return null; }
    static async Task<T?> F6<T>() where T : class => null;
    static async Task? G0() { return null; }
    static async Task<string>? G1() => null;
    static async Task<T>? G3<T>() { return default; }
    static async Task<T?>? G6<T>() where T : class => null;
}";
            var comp = CreateCompilationWithMscorlib46(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,30): error CS1997: Since 'C.F0()' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?
                //     static async Task F0() { return null; }
                Diagnostic(ErrorCode.ERR_TaskRetNoObjectRequired, "return").WithArguments("C.F0()").WithLocation(5, 30),
                // (5,37): warning CS8603: Possible null reference return.
                //     static async Task F0() { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(5, 37),
                // (6,39): warning CS8603: Possible null reference return.
                //     static async Task<string> F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 39),
                // (8,43): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static async Task<T> F3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(8, 43),
                // (9,43): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static async Task<T> F4<T>() { return default(T); }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(9, 43),
                // (10,59): warning CS8603: Possible null reference return.
                //     static async Task<T> F5<T>() where T : class { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 59),
                // (12,31): error CS1997: Since 'C.G0()' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?
                //     static async Task? G0() { return null; }
                Diagnostic(ErrorCode.ERR_TaskRetNoObjectRequired, "return").WithArguments("C.G0()").WithLocation(12, 31),
                // (13,40): warning CS8603: Possible null reference return.
                //     static async Task<string>? G1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(13, 40),
                // (14,44): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static async Task<T>? G3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(14, 44));
        }

        [Fact]
        public void IncrementWithErrors()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static async Task<int> F(ref int i)
    {
        return await Task.Run(() => i++);
    }
}";
            var comp = CreateCompilationWithMscorlib46(source);
            comp.VerifyDiagnostics(
                // (4,38): error CS1988: Async methods cannot have ref or out parameters
                //     static async Task<int> F(ref int i)
                Diagnostic(ErrorCode.ERR_BadAsyncArgType, "i").WithLocation(4, 38),
                // (6,37): error CS1628: Cannot use ref or out parameter 'i' inside an anonymous method, lambda expression, or query expression
                //         return await Task.Run(() => i++);
                Diagnostic(ErrorCode.ERR_AnonDelegateCantUse, "i").WithArguments("i").WithLocation(6, 37));
        }

        [Fact]
        public void NullCastToValueType()
        {
            var source =
@"struct S { }
class C
{
    static void M()
    {
        S s = (S)null;
        s.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): error CS0037: Cannot convert null to 'S' because it is a non-nullable value type
                //         S s = (S)null;
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "(S)null").WithArguments("S").WithLocation(6, 15));
        }

        [Fact]
        public void LiftedUserDefinedConversion()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => new B<T>();
}
struct B<T>
{
    internal T F;
}
class C
{
    static void F(A<object>? x, A<object?>? y)
    {
        B<object>? z = x;
        z?.F.ToString();
        B<object?>? w = y;
        w?.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,11): warning CS8602: Possible dereference of a null reference.
                //         w?.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, ".F").WithLocation(17, 11));
        }

        [Fact]
        public void GroupBy()
        {
            var source =
@"using System.Linq;
class Program
{
    static void Main()
    {
        var items = from i in Enumerable.Range(0, 3) group (long)i by i;
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // Tests for NullableWalker.HasImplicitTypeArguments.
        [Fact]
        public void ExplicitTypeArguments()
        {
            var source =
@"interface I<T> { }
class C
{
    C P => throw new System.Exception();
    I<T> F<T>(T t)
    {
        throw new System.Exception();
    }
    static void M(C c)
    {
        c.P.F<object>(string.Empty);
        (new[]{ c })[0].F<object>(string.Empty);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MultipleConversions_01()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F(B? x, B y)
    {
        C c;
        c = x; // (ImplicitUserDefined)(ImplicitReference)
        c = y; // (ImplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8604: Possible null reference argument for parameter 'a' in 'A.implicit operator C(A a)'.
                //         c = x; // (ImplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("a", "A.implicit operator C(A a)").WithLocation(13, 13));
        }

        [Fact]
        public void MultipleConversions_02()
        {
            var source =
@"class A
{
}
class B : A
{
}
class C
{
    public static implicit operator B?(C c) => null;
    static void F(C c)
    {
        A a = c; // (ImplicitReference)(ImplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = c; // (ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c").WithLocation(12, 15));
        }

        [Fact]
        public void MultipleConversions_03()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>(T t) => default;
    static void M()
    {
        S<object> s = true; // (ImplicitUserDefined)(Boxing)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MultipleConversions_04()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T> s) => throw new System.Exception();
    static void M()
    {
        bool b = new S<object>(); // (Unboxing)(ExplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS0266: Cannot implicitly convert type 'S<object>' to 'bool'. An explicit conversion exists (are you missing a cast?)
                //         bool b = new S<object>(); // (Unboxing)(ExplicitUserDefined)
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "new S<object>()").WithArguments("S<object>", "bool").WithLocation(6, 18));
        }

        [Fact]
        public void MultipleConversions_Explicit_01()
        {
            var source =
@"class A
{
    public static explicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F1(B b1)
    {
        C? c;
        c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b1; // (ExplicitUserDefined)(ImplicitReference)
    }
    static void F2(B? b2)
    {
        C? c;
        c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,16): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator C(A a)'.
                //         c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b2").WithArguments("a", "A.explicit operator C(A a)").WithLocation(19, 16),
                // (20,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator C(A a)'.
                //         c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b2").WithArguments("a", "A.explicit operator C(A a)").WithLocation(20, 17));
        }

        [Fact]
        public void MultipleConversions_Explicit_02()
        {
            var source =
@"class A
{
    public static explicit operator C?(A? a) => new D();
}
class B : A { }
class C { }
class D : C { }
class P
{
    static void F1(A a1, B b1)
    {
        C? c;
        c = (C)a1; // (ExplicitUserDefined)
        c = (C?)a1; // (ExplicitUserDefined)
        c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C)(B)a1;
        c = (C)(B?)a1;
        c = (C?)(B)a1;
        c = (C?)(B?)a1;
        D? d;
        d = (D)a1; // (ExplicitReference)(ExplicitUserDefined)
        d = (D?)a1; // (ExplicitReference)(ExplicitUserDefined)
        d = (D)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D?)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
    }
    static void F2(A? a2, B? b2)
    {
        C? c;
        c = (C)a2; // (ExplicitUserDefined)
        c = (C?)a2; // (ExplicitUserDefined)
        c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
        D? d;
        d = (D)a2; // (ExplicitReference)(ExplicitUserDefined)
        d = (D?)a2; // (ExplicitReference)(ExplicitUserDefined)
        d = (D)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D?)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D)(A)b2;
        d = (D)(A?)b2;
        d = (D?)(A)b2;
        d = (D?)(A?)b2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)a1; // (ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)a1").WithLocation(13, 13),
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)b1").WithLocation(15, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)(B)a1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)(B)a1").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)(B?)a1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)(B?)a1").WithLocation(18, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)a1; // (ExplicitReference)(ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)a1").WithLocation(22, 13),
                // (24,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)b1").WithLocation(24, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)a2; // (ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)a2").WithLocation(30, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)b2").WithLocation(32, 13),
                // (35,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)a2; // (ExplicitReference)(ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)a2").WithLocation(35, 13),
                // (37,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)b2").WithLocation(37, 13),
                // (39,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A)b2").WithLocation(39, 16),
                // (39,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)(A)b2").WithLocation(39, 13),
                // (40,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A?)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)(A?)b2").WithLocation(40, 13),
                // (41,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D?)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A)b2").WithLocation(41, 17));
        }

        [Fact]
        public void MultipleConversions_Explicit_03()
        {
            var source =
@"class A
{
    public static explicit operator S(A a) => new S();
}
class B : A { }
struct S { }
class C
{
    static void F(B? b)
    {
        S? s;
        s = (S)b; // (ExplicitUserDefined)(ImplicitReference)
        s = (S?)b; // (ImplicitNullable)(ExplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,16): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator S(A a)'.
                //         s = (S)b; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "A.explicit operator S(A a)").WithLocation(12, 16),
                // (13,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator S(A a)'.
                //         s = (S?)b; // (ImplicitNullable)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "A.explicit operator S(A a)").WithLocation(13, 17));
        }

        [Fact]
        [WorkItem(29960, "https://github.com/dotnet/roslyn/issues/29960")]
        public void MultipleConversions_Explicit_04()
        {
            var source =
@"struct S
{
    public static explicit operator A?(S s) => throw null;
}
class A
{
    internal void F() { }
}
class B : A
{
}
class C
{
    static void F(S s)
    {
        var b1 = (B)s;
        b1.F();
        B b2 = (B)s;
        b2.F();
        A a = (B)s;
        a.F();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29960: Should only report one WRN_ConvertingNullableToNonNullable
            // warning for `B b2 = (B)s;` and `A a = (B)s;`.
            comp.VerifyDiagnostics(
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var b1 = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(16, 18),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         b1.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b1").WithLocation(17, 9),
                // (18,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         B b2 = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(18, 16),
                // (18,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         B b2 = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(18, 16),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b2.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b2").WithLocation(19, 9),
                // (20,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(20, 15),
                // (20,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(20, 15),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         a.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(21, 9));
        }

        [Fact]
        public void MultipleTupleConversions_01()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F((B?, B) x, (B, B?) y)
    {
        (C, C?) c;
        c = x; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
        c = y; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29699: Report warnings for user-defined conversions on tuple elements.
            comp.VerifyDiagnostics(
                // (13,13): warning CS8619: Nullability of reference types in value of type '(B?, B)' doesn't match target type '(C, C?)'.
                //         c = x; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("(B?, B)", "(C, C?)").WithLocation(13, 13));
        }

        [Fact]
        public void MultipleTupleConversions_02()
        {
            var source =
@"class A
{
}
class B : A
{
}
class C
{
    public static implicit operator B(C c) => new C();
    static void F(C? x, C y)
    {
        (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,17): warning CS0219: The variable 't' is assigned but its value is never used
                //         (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "t").WithArguments("t").WithLocation(12, 17),
                // (12,22): warning CS8604: Possible null reference argument for parameter 'c' in 'C.implicit operator B(C c)'.
                //         (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("c", "C.implicit operator B(C c)").WithLocation(12, 22));
        }

        [Fact]
        [WorkItem(29966, "https://github.com/dotnet/roslyn/issues/29966")]
        public void Conversions_ImplicitTupleLiteral_01()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (string, string) t1 = (x, y); // 1
        (string?, string?) u1 = (x, y);
        (object, object) v1 = (x, y); // 2
        (object?, object?) w1 = (x, y);
        F1A((x, y)); // 3
        F1B((x, y));
        F1C((x, y)); // 4
        F1D((x, y));
    }
    static void F1A((string, string) t) { }
    static void F1B((string?, string?) t) { }
    static void F1C((object, object) t) { }
    static void F1D((object?, object?) t) { }
    static void F2(A<object> x, A<object?> y)
    {
        (A<object>, A<object>) t2 = (x, y); // 5
        (A<object?>, A<object?>) u2 = (x, y); // 6
        (I<object>, I<object>) v2 = (x, y); // 7
        (I<object?>, I<object?>) w2 = (x, y); // 8
        F2A((x, y)); // 9
        F2B((x, y)); // 10
        F2C((x, y)); // 11
        F2D((x, y)); // 12
    }
    static void F2A((A<object>, A<object>) t) { }
    static void F2B((A<object?>, A<object?>) t) { }
    static void F2C((I<object>, I<object>) t) { }
    static void F2D((I<object?>, I<object?>) t) { }
    static void F3(B<object> x, B<object?> y)
    {
        (B<object>, B<object>) t3 = (x, y); // 13
        (B<object?>, B<object?>) u3 = (x, y); // 14
        (IIn<object>, IIn<object>) v3 = (x, y);
        (IIn<object?>, IIn<object?>) w3 = (x, y); // 15
        F3A((x, y));
        F3B((x, y)); // 16
    }
    static void F3A((IIn<object>, IIn<object>) t) { }
    static void F3B((IIn<object?>, IIn<object?>) t) { }
    static void F4(C<object> x, C<object?> y)
    {
        (C<object>, C<object>) t4 = (x, y); // 17
        (C<object?>, C<object?>) u4 = (x, y); // 18
        (IOut<object>, IOut<object>) v4 = (x, y); // 19
        (IOut<object?>, IOut<object?>) w4 = (x, y);
        F4A((x, y)); // 20
        F4B((x, y));
    }
    static void F4A((IOut<object>, IOut<object>) t) { }
    static void F4B((IOut<object?>, IOut<object?>) t) { }
    static void F5<T, U>(U u) where U : T
    {
        (T,  T) t5 = (u, default(T));
        (object, object) v5 = (default(T), u); // 21
        (object?, object?) w5 = (default(T), u);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29966: Report WRN_NullabilityMismatchInArgument rather than ...Assignment.
            comp.VerifyDiagnostics(
                // (12,31): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)'.
                //         (string, string) t1 = (x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(string x, string? y)", "(string, string)").WithLocation(12, 31),
                // (14,31): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)'.
                //         (object, object) v1 = (x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object x, object? y)", "(object, object)").WithLocation(14, 31),
                // (16,13): warning CS8620: Nullability of reference types in argument of type '(string x, string? y)' doesn't match target type '(string, string)' for parameter 't' in 'void E.F1A((string, string) t)'.
                //         F1A((x, y)); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(string x, string? y)", "(string, string)", "t", "void E.F1A((string, string) t)").WithLocation(16, 13),
                // (18,13): warning CS8620: Nullability of reference types in argument of type '(object x, object? y)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1C((object, object) t)'.
                //         F1C((x, y)); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(object x, object? y)", "(object, object)", "t", "void E.F1C((object, object) t)").WithLocation(18, 13),
                // (27,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)'.
                //         (A<object>, A<object>) t2 = (x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)").WithLocation(27, 37),
                // (28,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)'.
                //         (A<object?>, A<object?>) u2 = (x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)").WithLocation(28, 39),
                // (29,41): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (I<object>, I<object>) v2 = (x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(29, 41),
                // (30,40): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (I<object?>, I<object?>) w2 = (x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(30, 40),
                // (31,13): warning CS8620: Nullability of reference types in argument of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)' for parameter 't' in 'void E.F2A((A<object>, A<object>) t)'.
                //         F2A((x, y)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)", "t", "void E.F2A((A<object>, A<object>) t)").WithLocation(31, 13),
                // (32,13): warning CS8620: Nullability of reference types in argument of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)' for parameter 't' in 'void E.F2B((A<object?>, A<object?>) t)'.
                //         F2B((x, y)); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)", "t", "void E.F2B((A<object?>, A<object?>) t)").WithLocation(32, 13),
                // (33,17): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         F2C((x, y)); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(33, 17),
                // (34,14): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         F2D((x, y)); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(34, 14),
                // (42,37): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?> y)' doesn't match target type '(B<object>, B<object>)'.
                //         (B<object>, B<object>) t3 = (x, y); // 13
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(B<object> x, B<object?> y)", "(B<object>, B<object>)").WithLocation(42, 37),
                // (43,39): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?> y)' doesn't match target type '(B<object?>, B<object?>)'.
                //         (B<object?>, B<object?>) u3 = (x, y); // 14
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(B<object> x, B<object?> y)", "(B<object?>, B<object?>)").WithLocation(43, 39),
                // (45,44): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (IIn<object?>, IIn<object?>) w3 = (x, y); // 15
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(45, 44),
                // (47,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         F3B((x, y)); // 16
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(47, 14),
                // (53,37): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?> y)' doesn't match target type '(C<object>, C<object>)'.
                //         (C<object>, C<object>) t4 = (x, y); // 17
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(C<object> x, C<object?> y)", "(C<object>, C<object>)").WithLocation(53, 37),
                // (54,39): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?> y)' doesn't match target type '(C<object?>, C<object?>)'.
                //         (C<object?>, C<object?>) u4 = (x, y); // 18
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(C<object> x, C<object?> y)", "(C<object?>, C<object?>)").WithLocation(54, 39),
                // (55,47): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (IOut<object>, IOut<object>) v4 = (x, y); // 19
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(55, 47),
                // (57,17): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         F4A((x, y)); // 20
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(57, 17),
                // (65,31): warning CS8619: Nullability of reference types in value of type '(object?, object? u)' doesn't match target type '(object, object)'.
                //         (object, object) v5 = (default(T), u); // 21
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default(T), u)").WithArguments("(object?, object? u)", "(object, object)").WithLocation(65, 31));
        }

        [Fact]
        public void Conversions_ImplicitTupleLiteral_02()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (string, string)? t1 = (x, y); // 1
        (string?, string?)? u1 = (x, y);
        (object, object)? v1 = (x, y); // 2
        (object?, object?)? w1 = (x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        (A<object>, A<object>)? t2 = (x, y); // 3
        (A<object?>, A<object?>)? u2 = (x, y); // 4
        (I<object>, I<object>)? v2 = (x, y); // 5
        (I<object?>, I<object?>)? w2 = (x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        (IIn<object>, IIn<object>)? v3 = (x, y);
        (IIn<object?>, IIn<object?>)? w3 = (x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        (IOut<object>, IOut<object>)? v4 = (x, y); // 8
        (IOut<object?>, IOut<object?>)? w4 = (x, y);
    }
    static void F5<T, U>(U u) where U : T
    {
        (T,  T)? t5 = (u, default(T));
        (object, object)? v5 = (default(T), u); // 9
        (object?, object?)? w5 = (default(T), u);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,32): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)?'.
                //         (string, string)? t1 = (x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(string x, string? y)", "(string, string)?").WithLocation(12, 32),
                // (14,32): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)?'.
                //         (object, object)? v1 = (x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object x, object? y)", "(object, object)?").WithLocation(14, 32),
                // (19,38): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)?'.
                //         (A<object>, A<object>)? t2 = (x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)?").WithLocation(19, 38),
                // (20,40): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)?'.
                //         (A<object?>, A<object?>)? u2 = (x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)?").WithLocation(20, 40),
                // (21,42): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (I<object>, I<object>)? v2 = (x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 42),
                // (22,41): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (I<object?>, I<object?>)? w2 = (x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 41),
                // (27,45): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (IIn<object?>, IIn<object?>)? w3 = (x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 45),
                // (31,48): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (IOut<object>, IOut<object>)? v4 = (x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 48),
                // (37,32): warning CS8619: Nullability of reference types in value of type '(object?, object? u)' doesn't match target type '(object, object)?'.
                //         (object, object)? v5 = (default(T), u); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default(T), u)").WithArguments("(object?, object? u)", "(object, object)?").WithLocation(37, 32));
        }

        [Fact]
        public void Conversions_ImplicitTuple()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
class D
{
    static void F1((string x, string?) a1)
    {
        (string, string) t1 = a1; // 1
        (string?, string?) u1 = a1;
        (object, object) v1 = a1; // 2
        (object?, object?) w1 = a1;
    }
    static void F2((A<object> x, A<object?>) a2)
    {
        (A<object>, A<object>) t2 = a2; // 3
        (A<object?>, A<object?>) u2 = a2; // 4
        (I<object>, I<object>) v2 = a2; // 5
        (I<object?>, I<object?>) w2 = a2; // 6
    }
    static void F3((B<object> x, B<object?>) a3)
    {
        (IIn<object>, IIn<object>) v3 = a3;
        (IIn<object?>, IIn<object?>) w3 = a3; // 7
    }
    static void F4((C<object> x, C<object?>) a4)
    {
        (IOut<object>, IOut<object>) v4 = a4; // 8
        (IOut<object?>, IOut<object?>) w4 = a4;
    }
    static void F5<T, U>((U, U) a5) where U : T
    {
        (U, T) t5 = a5;
        (object, object) v5 = a5; // 9
        (object?, object?) w5 = a5;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,31): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(string, string)'.
                //         (string, string) t1 = a1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("(string x, string?)", "(string, string)").WithLocation(12, 31),
                // (14,31): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(object, object)'.
                //         (object, object) v1 = a1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("(string x, string?)", "(object, object)").WithLocation(14, 31),
                // (19,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object>, A<object>)'.
                //         (A<object>, A<object>) t2 = a2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(A<object>, A<object>)").WithLocation(19, 37),
                // (20,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object?>, A<object?>)'.
                //         (A<object?>, A<object?>) u2 = a2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(A<object?>, A<object?>)").WithLocation(20, 39),
                // (21,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object>, I<object>)'.
                //         (I<object>, I<object>) v2 = a2; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(I<object>, I<object>)").WithLocation(21, 37),
                // (22,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object?>, I<object?>)'.
                //         (I<object?>, I<object?>) w2 = a2; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(I<object?>, I<object?>)").WithLocation(22, 39),
                // (27,43): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)'.
                //         (IIn<object?>, IIn<object?>) w3 = a3; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a3").WithArguments("(B<object> x, B<object?>)", "(IIn<object?>, IIn<object?>)").WithLocation(27, 43),
                // (31,43): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)'.
                //         (IOut<object>, IOut<object>) v4 = a4; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a4").WithArguments("(C<object> x, C<object?>)", "(IOut<object>, IOut<object>)").WithLocation(31, 43),
                // (37,31): warning CS8619: Nullability of reference types in value of type '(U, U)' doesn't match target type '(object, object)'.
                //         (object, object) v5 = a5; // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a5").WithArguments("(U, U)", "(object, object)").WithLocation(37, 31));
        }

        [Fact]
        public void Conversions_ExplicitTupleLiteral_01()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(string x, string? y)
    {
        var t1 = ((string, string))(x, y); // 1
        var u1 = ((string?, string?))(x, y);
        var v1 = ((object, object))(x, y); // 2
        var w1 = ((object?, object?))(x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        var t2 = ((A<object>, A<object>))(x, y); // 3
        var u2 = ((A<object?>, A<object?>))(x, y); // 4
        var v2 = ((I<object>, I<object>))(x, y); // 5
        var w2 = ((I<object?>, I<object?>))(x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        var v3 = ((IIn<object>, IIn<object>))(x, y);
        var w3 = ((IIn<object?>, IIn<object?>))(x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        var v4 = ((IOut<object>, IOut<object>))(x, y); // 8
        var w4 = ((IOut<object?>, IOut<object?>))(x, y);
    }
    static void F5<T, U>(T t) where U : T
    {
        var t5 = ((U, U))(t, default(T));
        var v5 = ((object, object))(default(T), t); // 9, 10
        var w5 = ((object?, object?))(default(T), t);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)'.
                //         var t1 = ((string, string))(x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string))(x, y)").WithArguments("(string x, string? y)", "(string, string)").WithLocation(12, 18),
                // (14,40): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v1 = ((object, object))(x, y); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(14, 40),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)'.
                //         var v1 = ((object, object))(x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))(x, y)").WithArguments("(object x, object? y)", "(object, object)").WithLocation(14, 18),
                // (19,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)'.
                //         var t2 = ((A<object>, A<object>))(x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object>, A<object>))(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)").WithLocation(19, 18),
                // (20,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)'.
                //         var u2 = ((A<object?>, A<object?>))(x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object?>, A<object?>))(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)").WithLocation(20, 18),
                // (21,46): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         var v2 = ((I<object>, I<object>))(x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 46),
                // (22,45): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         var w2 = ((I<object?>, I<object?>))(x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 45),
                // (27,49): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         var w3 = ((IIn<object?>, IIn<object?>))(x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 49),
                // (31,52): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         var v4 = ((IOut<object>, IOut<object>))(x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 52),
                // (37,37): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object))(default(T), t); // 9, 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(37, 37),
                // (37,49): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object))(default(T), t); // 9, 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(37, 49),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(object?, object? t)' doesn't match target type '(object, object)'.
                //         var v5 = ((object, object))(default(T), t); // 9, 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))(default(T), t)").WithArguments("(object?, object? t)", "(object, object)").WithLocation(37, 18));
        }

        [Fact]
        public void Conversions_ExplicitTupleLiteral_02()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(string x, string? y)
    {
        var t1 = ((string, string)?)(x, y); // 1
        var u1 = ((string?, string?)?)(x, y);
        var v1 = ((object, object)?)(x, y); // 2
        var w1 = ((object?, object?)?)(x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        var t2 = ((A<object>, A<object>)?)(x, y); // 3
        var u2 = ((A<object?>, A<object?>)?)(x, y); // 4
        var v2 = ((I<object>, I<object>)?)(x, y); // 5
        var w2 = ((I<object?>, I<object?>)?)(x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        var v3 = ((IIn<object>, IIn<object>)?)(x, y);
        var w3 = ((IIn<object?>, IIn<object?>)?)(x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        var v4 = ((IOut<object>, IOut<object>)?)(x, y); // 8
        var w4 = ((IOut<object?>, IOut<object?>)?)(x, y);
    }
    static void F5<T, U>(T t) where U : T
    {
        var t5 = ((U, U)?)(t, default(T));
        var v5 = ((object, object)?)(default(T), t); // 9
        var w5 = ((object?, object?)?)(default(T), t);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,41): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t1 = ((string, string)?)(x, y); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(12, 41),
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)?'.
                //         var t1 = ((string, string)?)(x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string)?)(x, y)").WithArguments("(string x, string? y)", "(string, string)?").WithLocation(12, 18),
                // (14,41): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v1 = ((object, object)?)(x, y); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(14, 41),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)?'.
                //         var v1 = ((object, object)?)(x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object)?)(x, y)").WithArguments("(object x, object? y)", "(object, object)?").WithLocation(14, 18),
                // (19,47): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         var t2 = ((A<object>, A<object>)?)(x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "A<object>").WithLocation(19, 47),
                // (20,46): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         var u2 = ((A<object?>, A<object?>)?)(x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "A<object?>").WithLocation(20, 46),
                // (21,47): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         var v2 = ((I<object>, I<object>)?)(x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 47),
                // (22,46): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         var w2 = ((I<object?>, I<object?>)?)(x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 46),
                // (27,50): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         var w3 = ((IIn<object?>, IIn<object?>)?)(x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 50),
                // (31,53): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         var v4 = ((IOut<object>, IOut<object>)?)(x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 53),
                // (37,38): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object)?)(default(T), t); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(37, 38),
                // (37,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object)?)(default(T), t); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(37, 50),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(object?, object? t)' doesn't match target type '(object, object)?'.
                //         var v5 = ((object, object)?)(default(T), t); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object)?)(default(T), t)").WithArguments("(object?, object? t)", "(object, object)?").WithLocation(37, 18));
        }

        [Fact]
        public void Conversions_ExplicitTuple()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1((string x, string?) a1)
    {
        var t1 = ((string, string))a1; // 1
        var u1 = ((string?, string?))a1;
        var v1 = ((object, object))a1; // 2
        var w1 = ((object?, object?))a1;
    }
    static void F2((A<object> x, A<object?>) a2)
    {
        var t2 = ((A<object>, A<object>))a2; // 3
        var u2 = ((A<object?>, A<object?>))a2; // 4
        var v2 = ((I<object>, I<object>))a2; // 5
        var w2 = ((I<object?>, I<object?>))a2; // 6
    }
    static void F3((B<object> x, B<object?>) a3)
    {
        var v3 = ((IIn<object>, IIn<object>))a3;
        var w3 = ((IIn<object?>, IIn<object?>))a3; // 7
    }
    static void F4((C<object> x, C<object?>) a4)
    {
        var v4 = ((IOut<object>, IOut<object>))a4; // 8
        var w4 = ((IOut<object?>, IOut<object?>))a4;
    }
    static void F5<T, U>((T, T) a5) where U : T
    {
        var t5 = ((U, U))a5;
        var v5 = ((object, object))default((T, T)); // 9
        var w5 = ((object?, object?))default((T, T));
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(string, string)'.
                //         var t1 = ((string, string))a1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string))a1").WithArguments("(string x, string?)", "(string, string)").WithLocation(12, 18),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(object, object)'.
                //         var v1 = ((object, object))a1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))a1").WithArguments("(string x, string?)", "(object, object)").WithLocation(14, 18),
                // (19,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object>, A<object>)'.
                //         var t2 = ((A<object>, A<object>))a2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object>, A<object>))a2").WithArguments("(A<object> x, A<object?>)", "(A<object>, A<object>)").WithLocation(19, 18),
                // (20,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object?>, A<object?>)'.
                //         var u2 = ((A<object?>, A<object?>))a2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object?>, A<object?>))a2").WithArguments("(A<object> x, A<object?>)", "(A<object?>, A<object?>)").WithLocation(20, 18),
                // (21,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object>, I<object>)'.
                //         var v2 = ((I<object>, I<object>))a2; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object>, I<object>))a2").WithArguments("(A<object> x, A<object?>)", "(I<object>, I<object>)").WithLocation(21, 18),
                // (22,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object?>, I<object?>)'.
                //         var w2 = ((I<object?>, I<object?>))a2; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object?>, I<object?>))a2").WithArguments("(A<object> x, A<object?>)", "(I<object?>, I<object?>)").WithLocation(22, 18),
                // (27,18): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)'.
                //         var w3 = ((IIn<object?>, IIn<object?>))a3; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((IIn<object?>, IIn<object?>))a3").WithArguments("(B<object> x, B<object?>)", "(IIn<object?>, IIn<object?>)").WithLocation(27, 18),
                // (31,18): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)'.
                //         var v4 = ((IOut<object>, IOut<object>))a4; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((IOut<object>, IOut<object>))a4").WithArguments("(C<object> x, C<object?>)", "(IOut<object>, IOut<object>)").WithLocation(31, 18),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(T, T)' doesn't match target type '(object, object)'.
                //         var v5 = ((object, object))default((T, T)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))default((T, T))").WithArguments("(T, T)", "(object, object)").WithLocation(37, 18));
        }

        [Fact]
        [WorkItem(29966, "https://github.com/dotnet/roslyn/issues/29966")]
        public void Conversions_ImplicitTupleLiteral_ExtensionThis()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (x, y).F1A(); // 1
        (x, y).F1B();
    }
    static void F1A(this (object, object) t) { }
    static void F1B(this (object?, object?) t) { }
    static void F2(A<object> x, A<object?> y)
    {
        (x, y).F2A(); // 2
        (x, y).F2B(); // 3
    }
    static void F2A(this (I<object>, I<object>) t) { }
    static void F2B(this (I<object?>, I<object?>) t) { }
    static void F3(B<object> x, B<object?> y)
    {
        (x, y).F3A();
        (x, y).F3B(); // 4
    }
    static void F3A(this (IIn<object>, IIn<object>) t) { }
    static void F3B(this (IIn<object?>, IIn<object?>) t) { }
    static void F4(C<object> x, C<object?> y)
    {
        (x, y).F4A(); // 5
        (x, y).F4B();
    }
    static void F4A(this (IOut<object>, IOut<object>) t) { }
    static void F4B(this (IOut<object?>, IOut<object?>) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29966: Report WRN_NullabilityMismatchInArgument rather than ...Assignment.
            comp.VerifyDiagnostics(
                // (11,9): warning CS8620: Nullability of reference types in argument of type '(object x, object? y)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1A((object, object) t)'.
                //         (x, y).F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(object x, object? y)", "(object, object)", "t", "void E.F1A((object, object) t)").WithLocation(11, 9),
                // (18,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (x, y).F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(18, 13),
                // (19,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (x, y).F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(19, 10),
                // (26,10): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (x, y).F3B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(26, 10),
                // (32,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (x, y).F4A(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(32, 13));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1((string x, string?) t1)
    {
        t1.F1A(); // 1
        t1.F1B();
    }
    static void F1A(this (object, object) t) { }
    static void F1B(this (object?, object?) t) { }
    static void F2((A<object>, A<object?>) t2)
    {
        t2.F2A(); // 2
        t2.F2B(); // 3
    }
    static void F2A(this (I<object>, I<object>) t) { }
    static void F2B(this (I<object?>, I<object?>) t) { }
    static void F3((B<object>, B<object?>) t3)
    {
        t3.F3A();
        t3.F3B(); // 4
    }
    static void F3A(this (IIn<object>, IIn<object>) t) { }
    static void F3B(this (IIn<object?>, IIn<object?>) t) { }
    static void F4((C<object>, C<object?>) t4)
    {
        t4.F4A(); // 5
        t4.F4B();
    }
    static void F4A(this (IOut<object>, IOut<object>) t) { }
    static void F4B(this (IOut<object?>, IOut<object?>) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8620: Nullability of reference types in argument of type '(string x, string?)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1A((object, object) t)'.
                //         t1.F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string x, string?)", "(object, object)", "t", "void E.F1A((object, object) t)").WithLocation(11, 9),
                // (18,9): warning CS8620: Nullability of reference types in argument of type '(A<object>, A<object?>)' doesn't match target type '(I<object>, I<object>)' for parameter 't' in 'void E.F2A((I<object>, I<object>) t)'.
                //         t2.F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(A<object>, A<object?>)", "(I<object>, I<object>)", "t", "void E.F2A((I<object>, I<object>) t)").WithLocation(18, 9),
                // (19,9): warning CS8620: Nullability of reference types in argument of type '(A<object>, A<object?>)' doesn't match target type '(I<object?>, I<object?>)' for parameter 't' in 'void E.F2B((I<object?>, I<object?>) t)'.
                //         t2.F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(A<object>, A<object?>)", "(I<object?>, I<object?>)", "t", "void E.F2B((I<object?>, I<object?>) t)").WithLocation(19, 9),
                // (26,9): warning CS8620: Nullability of reference types in argument of type '(B<object>, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)' for parameter 't' in 'void E.F3B((IIn<object?>, IIn<object?>) t)'.
                //         t3.F3B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(B<object>, B<object?>)", "(IIn<object?>, IIn<object?>)", "t", "void E.F3B((IIn<object?>, IIn<object?>) t)").WithLocation(26, 9),
                // (32,9): warning CS8620: Nullability of reference types in argument of type '(C<object>, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)' for parameter 't' in 'void E.F4A((IOut<object>, IOut<object>) t)'.
                //         t4.F4A(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(C<object>, C<object?>)", "(IOut<object>, IOut<object>)", "t", "void E.F4A((IOut<object>, IOut<object>) t)").WithLocation(32, 9));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
static class E
{
    static void F1((string, string)? t1)
    {
        t1.F1A(); // 1
        t1.F1B();
    }
    static void F1A(this (string?, string?)? t) { }
    static void F1B(this (string, string)? t) { }
    static void F2((I<object?>, I<object?>)? t2)
    {
        t2.F2A();
        t2.F2B(); // 2
    }
    static void F2A(this (I<object?>, I<object?>)? t) { }
    static void F2B(this (I<object>, I<object>)? t) { }
    static void F3((IIn<object?>, IIn<object?>)? t3)
    {
        t3.F3A();
        t3.F3B(); // 3
    }
    static void F3A(this (IIn<object?>, IIn<object?>)? t) { }
    static void F3B(this (IIn<object>, IIn<object>)? t) { }
    static void F4((IOut<object?>, IOut<object?>)? t4)
    {
        t4.F4A();
        t4.F4B(); // 4
    }
    static void F4A(this (IOut<object?>, IOut<object?>)? t) { }
    static void F4B(this (IOut<object>, IOut<object>)? t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8620: Nullability of reference types in argument of type '(string, string)?' doesn't match target type '(string?, string?)?' for parameter 't' in 'void E.F1A((string?, string?)? t)'.
                //         t1.F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string, string)?", "(string?, string?)?", "t", "void E.F1A((string?, string?)? t)").WithLocation(8, 9),
                // (16,9): warning CS8620: Nullability of reference types in argument of type '(I<object?>, I<object?>)?' doesn't match target type '(I<object>, I<object>)?' for parameter 't' in 'void E.F2B((I<object>, I<object>)? t)'.
                //         t2.F2B(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(I<object?>, I<object?>)?", "(I<object>, I<object>)?", "t", "void E.F2B((I<object>, I<object>)? t)").WithLocation(16, 9),
                // (23,9): warning CS8620: Nullability of reference types in argument of type '(IIn<object?>, IIn<object?>)?' doesn't match target type '(IIn<object>, IIn<object>)?' for parameter 't' in 'void E.F3B((IIn<object>, IIn<object>)? t)'.
                //         t3.F3B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(IIn<object?>, IIn<object?>)?", "(IIn<object>, IIn<object>)?", "t", "void E.F3B((IIn<object>, IIn<object>)? t)").WithLocation(23, 9),
                // (30,9): warning CS8620: Nullability of reference types in argument of type '(IOut<object?>, IOut<object?>)?' doesn't match target type '(IOut<object>, IOut<object>)?' for parameter 't' in 'void E.F4B((IOut<object>, IOut<object>)? t)'.
                //         t4.F4B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(IOut<object?>, IOut<object?>)?", "(IOut<object>, IOut<object>)?", "t", "void E.F4B((IOut<object>, IOut<object>)? t)").WithLocation(30, 9));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_03()
        {
            var source =
@"static class E
{
    static void F((string, (string, string)?) t)
    {
        t.FA(); // 1
        t.FB();
        FA(t);
        FB(t);
    }
    static void FA(this (object, (string?, string?)?) t) { }
    static void FB(this (object, (string, string)?) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8620: Nullability of reference types in argument of type '(string, (string, string)?)' doesn't match target type '(object, (string?, string?)?)' for parameter 't' in 'void E.FA((object, (string?, string?)?) t)'.
                //         t.FA(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t").WithArguments("(string, (string, string)?)", "(object, (string?, string?)?)", "t", "void E.FA((object, (string?, string?)?) t)").WithLocation(5, 9));
        }

        [Fact]
        public void TupleTypeInference_01()
        {
            var source =
@"class C
{
    static (T, T) F<T>((T, T) t) => t;
    static void G(string x, string? y)
    {
        F((x, x)).Item2.ToString();
        F((x, y)).Item2.ToString();
        F((y, x)).Item2.ToString();
        F((y, y)).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F((x, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((x, y)).Item2").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, x)).Item2").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, y)).Item2").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_02()
        {
            var source =
@"class C
{
    static (T, T) F<T>((T, T?) t) where T : class => (t.Item1, t.Item1);
    static void G(string x, string? y)
    {
        F((x, x)).Item2.ToString();
        F((x, y)).Item2.ToString();
        F((y, x)).Item2.ToString();
        F((y, y)).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(8, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, x)).Item2").WithLocation(8, 9),
                // (9,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(9, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, y)).Item2").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_03()
        {
            var source =
@"class C
{
    static T F<T>((T, T?) t) where T : class => t.Item1;
    static void G((string, string) x, (string, string?) y, (string?, string) z, (string?, string?) w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(8, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(z)").WithLocation(8, 9),
                // (9,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(9, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(w)").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_04_Ref()
        {
            var source =
@"class C
{
    static T F<T>(ref (T, T?) t) where T : class => throw new System.Exception();
    static void G(string x, string? y)
    {
        (string, string) t1 = (x, x);
        F(ref t1).ToString();
        (string, string?) t2 = (x, y);
        F(ref t2).ToString();
        (string?, string) t3 = (y, x);
        F(ref t3).ToString();
        (string?, string?) t4 = (y, y);
        F(ref t4).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,15): warning CS8620: Nullability of reference types in argument of type '(string, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t1).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string, string)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(7, 15),
                // (11,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(ref (T, T?))' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(ref t3).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(ref t3)").WithArguments("C.F<T>(ref (T, T?))").WithLocation(11, 9),
                // (11,15): warning CS8620: Nullability of reference types in argument of type '(string?, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t3).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(string?, string)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(11, 15),
                // (13,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(ref (T, T?))' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(ref t4).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(ref t4)").WithArguments("C.F<T>(ref (T, T?))").WithLocation(13, 9),
                // (13,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t4).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(string?, string?)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(13, 15)
                );
        }

        [Fact]
        public void TupleTypeInference_04_Out()
        {
            var source =
@"class C
{
    static T F<T>(out (T, T?) t) where T : class => throw new System.Exception();
    static void G()
    {
        F(out (string, string) t1).ToString();
        F(out (string, string?) t2).ToString();
        F(out (string?, string) t3).ToString();
        F(out (string?, string?) t4).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8620: Nullability of reference types in argument of type '(string, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string, string) t1).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string, string) t1").WithArguments("(string, string)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(6, 15),
                // (8,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(out (T, T?))' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(out (string?, string) t3).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(out (string?, string) t3)").WithArguments("C.F<T>(out (T, T?))").WithLocation(8, 9),
                // (8,15): warning CS8620: Nullability of reference types in argument of type '(string?, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string?, string) t3).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string?, string) t3").WithArguments("(string?, string)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(8, 15),
                // (9,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(out (T, T?))' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(out (string?, string?) t4).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(out (string?, string?) t4)").WithArguments("C.F<T>(out (T, T?))").WithLocation(9, 9),
                // (9,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string?, string?) t4).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string?, string?) t4").WithArguments("(string?, string?)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(9, 15)
                );
        }

        [Fact]
        public void TupleTypeInference_05()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(I<(string, string)> x, I<(string, string?)> y, I<(string?, string)> z, I<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
    static T F<T>(IIn<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(IIn<(string, string)> x, IIn<(string, string?)> y, IIn<(string?, string)> z, IIn<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
    static T F<T>(IOut<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(IOut<(string, string)> x, IOut<(string, string?)> y, IOut<(string?, string)> z, IOut<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8620: Nullability of reference types in argument of type 'I<(string, string)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<(string, string)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(9, 11),
                // (11,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(z)").WithArguments("C.F<T>(I<(T, T?)>)").WithLocation(11, 9),
                // (11,11): warning CS8620: Nullability of reference types in argument of type 'I<(string?, string)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("I<(string?, string)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(11, 11),
                // (12,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(w)").WithArguments("C.F<T>(I<(T, T?)>)").WithLocation(12, 9),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'I<(string?, string?)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("I<(string?, string?)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(12, 11),
                // (17,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string, string)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<(string, string)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(17, 11),
                // (19,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IIn<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(z)").WithArguments("C.F<T>(IIn<(T, T?)>)").WithLocation(19, 9),
                // (19,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string?, string)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IIn<(string?, string)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(19, 11),
                // (20,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IIn<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(w)").WithArguments("C.F<T>(IIn<(T, T?)>)").WithLocation(20, 9),
                // (20,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string?, string?)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("IIn<(string?, string?)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(20, 11),
                // (25,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string, string)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IOut<(string, string)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(25, 11),
                // (27,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IOut<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(z)").WithArguments("C.F<T>(IOut<(T, T?)>)").WithLocation(27, 9),
                // (27,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string?, string)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<(string?, string)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(27, 11),
                // (28,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IOut<(T, T?)>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(w)").WithArguments("C.F<T>(IOut<(T, T?)>)").WithLocation(28, 9),
                // (28,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string?, string?)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("IOut<(string?, string?)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(28, 11)
                );
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void TupleTypeInference_06()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (y != null)
        {
            ((object? x, object? y), object? z) t = ((x, y), y);
            t.Item1.Item1.ToString();
            t.Item1.Item2.ToString();
            t.Item2.ToString();
            t.Item1.x.ToString(); // warning already reported for t.Item1.Item1
            t.Item1.y.ToString(); // warning already reported for t.Item1.Item2
            t.z.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29970: Should not report warning for
            // `t.Item1.Item2`, `t.Item2`, `t.Item1.y`, or `t.z`.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item1.Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.Item1").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item1.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.Item2").WithLocation(9, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(10, 13));
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void TupleTypeInference_07()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (y != null)
        {
            (object? _1, object? _2, object? _3, object? _4, object? _5, object? _6, object? _7, object? _8, object? _9, object? _10) t = (null, null, null, null, null, null, null, x, null, y);
            t._7.ToString();
            t._8.ToString();
            t.Rest.Item1.ToString(); // warning already reported for t._8
            t.Rest.Item2.ToString();
            t._9.ToString(); // warning already reported for t.Rest.Item2
            t._10.ToString();
            t.Rest.Item3.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29970: Should not report warning for `t._10` or `t.Rest.Item3`.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t._7.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t._7").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t._8.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t._8").WithLocation(9, 13),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(11, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             t._10.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t._10").WithLocation(13, 13));
        }

        [Fact]
        public void Tuple_Constructor()
        {
            var source =
@"class C
{
    C((string x, string? y) t) { }
    static void M(string x, string? y)
    {
        C c;
        c = new C((x, x));
        c = new C((x, y));
        c = new C((y, x)); // 1
        c = new C((y, y)); // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,19): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string x, string? y)' for parameter 't' in 'C.C((string x, string? y) t)'.
                //         c = new C((y, x)); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string x, string? y)", "t", "C.C((string x, string? y) t)").WithLocation(9, 19),
                // (10,19): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string x, string? y)' for parameter 't' in 'C.C((string x, string? y) t)'.
                //         c = new C((y, y)); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string x, string? y)", "t", "C.C((string x, string? y) t)").WithLocation(10, 19));
        }

        [Fact]
        public void Tuple_Indexer()
        {
            var source =
@"class C
{
    object? this[(string x, string? y) t] => null;
    static void M(string x, string? y)
    {
        var c = new C();
        object? o;
        o = c[(x, x)];
        o = c[(x, y)];
        o = c[(y, x)]; // 1
        o = c[(y, y)]; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,15): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string x, string? y)' for parameter 't' in 'object? C.this[(string x, string? y) t]'.
                //         o = c[(y, x)]; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string x, string? y)", "t", "object? C.this[(string x, string? y) t]").WithLocation(10, 15),
                // (11,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string x, string? y)' for parameter 't' in 'object? C.this[(string x, string? y) t]'.
                //         o = c[(y, y)]; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string x, string? y)", "t", "object? C.this[(string x, string? y) t]").WithLocation(11, 15));
        }

        [Fact]
        public void Tuple_CollectionInitializer()
        {
            var source =
@"using System.Collections.Generic;
class C
{
    static void M(string x, string? y)
    {
        var c = new List<(string, string?)>
        {
            (x, x),
            (x, y),
            (y, x), // 1
            (y, y), // 2
        };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string, string?)' for parameter 'item' in 'void List<(string, string?)>.Add((string, string?) item)'.
                //             (y, x), // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string, string?)", "item", "void List<(string, string?)>.Add((string, string?) item)").WithLocation(10, 13),
                // (11,13): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 'item' in 'void List<(string, string?)>.Add((string, string?) item)'.
                //             (y, y), // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string, string?)", "item", "void List<(string, string?)>.Add((string, string?) item)").WithLocation(11, 13));
        }

        [Fact]
        public void Tuple_OtherMembers_01()
        {
            var source =
@"internal delegate T D<T>();
namespace System
{
    public struct ValueTuple<T1, T2>
    {
        public ValueTuple(T1 item1, T2 item2)
        {
            Item1 = item1;
            Item2 = item2;
            F1 = item1;
            E2 = null;
        }
        public T1 Item1;
        public T2 Item2;
        internal T1 F1;
        internal T1 P1 => Item1;
        internal event D<T2>? E2;
    }
}
class C
{
    static void F(object? x)
    {
        var y = (x, x);
        y.F1.ToString(); // 1
        y.P1.ToString(); // 2
        y.E2?.Invoke().ToString(); // 3
        if (x == null) return;
        var z = (x, x);
        z.F1.ToString();
        z.P1.ToString();
        z.E2?.Invoke().ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), targetFramework: TargetFramework.Mscorlib46);
            comp.VerifyDiagnostics(
                // (27,11): error CS0070: The event '(object, object).E2' can only appear on the left hand side of += or -= (except when used from within the type '(object, object)')
                //         y.E2?.Invoke().ToString(); // 3
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E2").WithArguments("(object, object).E2", "(object, object)").WithLocation(27, 11),
                // (32,11): error CS0070: The event '(object, object).E2' can only appear on the left hand side of += or -= (except when used from within the type '(object, object)')
                //         z.E2?.Invoke().ToString();
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E2").WithArguments("(object, object).E2", "(object, object)").WithLocation(32, 11),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         y.F1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F1").WithLocation(25, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         y.P1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.P1").WithLocation(26, 9),
                // (17,31): warning CS0414: The field 'ValueTuple<T1, T2>.E2' is assigned but its value is never used
                //         internal event D<T2>? E2;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "E2").WithArguments("System.ValueTuple<T1, T2>.E2").WithLocation(17, 31));
        }

        [Fact]
        public void Tuple_OtherMembers_02()
        {
            // Cannot test Derived<T> since tuple types are considered sealed and the base type
            // is dropped: "error CS0509: 'Derived<T>': cannot derive from sealed type '(T, T)'".
            var source =
@"namespace System
{
    public class Base<T>
    {
        public Base(T t) { F = t; }
        public T F;
    }
    public class ValueTuple<T1, T2> : Base<T1>
    {
        public ValueTuple(T1 item1, T2 item2) : base(item1)
        {
            Item1 = item1;
            Item2 = item2;
        }
        public T1 Item1;
        public T2 Item2;
    }
    //public class Derived<T> : ValueTuple<T, T>
    //{
    //    public Derived(T t) : base(t, t) { }
    //    public T P { get; set; }
    //}
}
class C
{
    static void F(object? x)
    {
        var y = (x, x);
        y.F.ToString();
        y.Item2.ToString();
        if (x == null) return;
        var z = (x, x);
        z.F.ToString();
        z.Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), targetFramework: TargetFramework.Mscorlib46);
            comp.VerifyDiagnostics(
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item2").WithLocation(30, 9));
        }

        [Fact]
        public void Tuple_OtherMembers_03()
        {
            var source =
@"namespace System
{
    public class Object
    {
        public string ToString() => throw null;
        public object? F;
    }
    public class String { }
    public abstract class ValueType
    {
        public object? P { get; set; }
    }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }

    public struct ValueTuple<T1, T2>
    {
        public ValueTuple(T1 item1, T2 item2)
        {
        }
    }
}
class C
{
    static void M(object x)
    {
        var y = (x, x);
        y.F.ToString();
        y.P.ToString();
    }
}";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyDiagnostics(
                // (6,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public object? F;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 22),
                // (11,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public object? P { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 22)
                );

            var comp2 = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(44, 9),
                // (45,9): warning CS8602: Possible dereference of a null reference.
                //         y.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.P").WithLocation(45, 9));
        }

        [Fact]
        public void TypeInference_TupleNameDifferences_01()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(object o)
    {
        var c = new C<(object x, int y)>();
        c.F((o, -1)).x.ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (13,22): error CS1061: '(object, int)' does not contain a definition for 'x' and no extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 22));

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,22): error CS1061: '(object, int)' does not contain a definition for 'x' and no extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 22));
        }

        [Fact]
        public void TypeInference_TupleNameDifferences_02()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(object o)
    {
        var c = new C<(object? x, int y)>();
        c.F((o, -1)).x.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8638: The nullability of type arguments for method 'E.F<T>(C<T>, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "c.F((o, -1))").WithArguments("E.F<T>(C<T>, T)").WithLocation(13, 9),
                // (13,22): error CS1061: '(object, int)' does not contain a definition for 'x' and no accessible extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 22));
        }

        [Fact]
        public void TypeInference_DynamicDifferences_01()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(dynamic x, object y)
    {
        var c = new C<(object, object)>();
        c.F((x, y)).Item1.G();
    }
}";

            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_DynamicDifferences_02()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(dynamic x, object y)
    {
        var c = new C<(object, object?)>();
        c.F((x, y)).Item1.G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8638: The nullability of type arguments for method 'E.F<T>(C<T>, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         c.F((x, y)).Item1.G();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "c.F((x, y))").WithArguments("E.F<T>(C<T>, T)").WithLocation(13, 9));
        }

        // Assert failure in ConversionsBase.IsValidExtensionMethodThisArgConversion.
        [WorkItem(22317, "https://github.com/dotnet/roslyn/issues/22317")]
        [Fact(Skip = "22317")]
        public void TypeInference_DynamicDifferences_03()
        {
            var source =
@"interface I<T>
{
}
static class E
{
    public static T F<T>(this I<T> i, T t) => t;
}
class C
{
    static void F(I<object> i, dynamic? d)
    {
        i.F(d).G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): error CS1929: 'I<object>' does not contain a definition for 'F' and the best extension method overload 'E.F<T>(I<T>, T)' requires a receiver of type 'I<T>'
                //         i.F(d).G();
                Diagnostic(ErrorCode.ERR_BadInstanceArgType, "i").WithArguments("I<object>", "F", "E.F<T>(I<T>, T)", "I<T>").WithLocation(12, 9));
        }

        [Fact]
        public void NullableConversionAndNullCoalescingOperator_01()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    short F;
    static ushort G(S? s)
    {
        return (ushort)(s?.F ?? 0);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableConversionAndNullCoalescingOperator_02()
        {
            var source =
@"struct S
{
    public static implicit operator int(S s) => 0;
}
class P
{
    static int F(S? x, int y) => x ?? y;
    static int G(S x, int? y) => y ?? x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConstrainedToTypeParameter_01()
        {
            var source =
@"class C<T, U> where U : T
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConstrainedToTypeParameter_02()
        {
            var source =
@"class C<T> where T : C<T>
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ArrayElementConversion()
        {
            var source =
@"class C
{
    static object F() => new sbyte[] { -1 };
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TrackNonNullableLocals()
        {
            var source =
@"class C
{
    static void F(object x)
    {
        object y = x;
        x.ToString(); // 1
        y.ToString(); // 2
        x = null;
        y = x;
        x.ToString(); // 3
        y.ToString(); // 4
        x = null;
        y = x;
        if (x == null) return;
        if (y == null) return;
        x.ToString(); // 5
        y.ToString(); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 9),
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(12, 13),
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(13, 13));
        }

        [Fact]
        public void TrackNonNullableFieldsAndProperties()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    object F;
    object P { get; set; }
    static void M(C c)
    {
        c.F.ToString(); // 1
        c.P.ToString(); // 2
        c.F = null;
        c.P = null;
        c.F.ToString(); // 3
        c.P.ToString(); // 4
        if (c.F == null) return;
        if (c.P == null) return;
        c.F.ToString(); // 5
        c.P.ToString(); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.F = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 15),
                // (11,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.P = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(11, 15),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c.P.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.P").WithLocation(13, 9),
                // (14,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (c.F == null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c.F == null").WithLocation(14, 13),
                // (15,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (c.P == null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c.P == null").WithLocation(15, 13));
        }

        [Fact]
        public void TrackUnannotatedFieldsAndProperties()
        {
            var source0 =
@"public class C
{
    public object F;
    public object P { get; set; }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var source1 =
@"class P
{
    static void M(C c, object? o)
    {
        c.F.ToString();
        c.P.ToString();
        c.F = o;
        c.P = o;
        c.F.ToString(); // 1
        c.P.ToString(); // 2
        c.F = o;
        c.P = o;
        if (c.F == null) return;
        if (c.P == null) return;
        c.F.ToString();
        c.P.ToString();
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c.P.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.P").WithLocation(10, 9));
        }

        /// <summary>
        /// Assignment warnings for local and parameters should be distinct from
        /// fields and properties because the former may be warnings from legacy
        /// method bodies and it should be possible to disable those warnings separately.
        /// </summary>
        [Fact]
        public void AssignmentWarningsDistinctForLocalsAndParameters()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    internal object F;
    internal object P { get; set; }
}
class P
{
    static void F(out object? x)
    {
        x = null;
    }
    static void Local()
    {
        object? y = null;
        object x1 = null;
        x1 = y;
        F(out x1);
    }
    static void Parameter(object x2)
    {
        object? y = null;
        x2 = null;
        x2 = y;
        F(out x2);
    }
    static void OutParameter(out object x3)
    {
        object? y = null;
        x3 = null;
        x3 = y;
        F(out x3);
    }
    static void RefParameter(ref object x4)
    {
        object? y = null;
        x4 = null;
        x4 = y;
        F(out x4);
    }
    static void Field()
    {
        var c = new C();
        object? y = null;
        c.F = null;
        c.F = y;
        F(out c.F);
    }
    static void Property()
    {
        var c = new C();
        object? y = null;
        c.P = null;
        c.P = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x1 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(17, 21),
                // (18,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(18, 14),
                // (19,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out x1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(19, 15),
                // (24,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(24, 14),
                // (25,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(25, 14),
                // (26,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out x2);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(26, 15),
                // (31,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         x3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(31, 14),
                // (32,14): warning CS8601: Possible null reference assignment.
                //         x3 = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(32, 14),
                // (33,15): warning CS8601: Possible null reference assignment.
                //         F(out x3);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x3").WithLocation(33, 15),
                // (38,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         x4 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(38, 14),
                // (39,14): warning CS8601: Possible null reference assignment.
                //         x4 = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(39, 14),
                // (40,15): warning CS8601: Possible null reference assignment.
                //         F(out x4);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4").WithLocation(40, 15),
                // (46,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.F = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(46, 15),
                // (47,15): warning CS8601: Possible null reference assignment.
                //         c.F = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(47, 15),
                // (48,15): warning CS8601: Possible null reference assignment.
                //         F(out c.F);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c.F").WithLocation(48, 15),
                // (54,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.P = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 15),
                // (55,15): warning CS8601: Possible null reference assignment.
                //         c.P = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(55, 15));
        }

        /// <summary>
        /// Explicit cast does not cast away top-level nullability.
        /// </summary>
        [Fact]
        public void ExplicitCast()
        {
            var source =
@"#pragma warning disable 0649
class A<T>
{
    internal T F;
}
class B1 : A<string> { }
class B2 : A<string?> { }
class C
{
    static void F0()
    {
        ((A<string>)null).F.ToString();
        ((A<string>?)null).F.ToString();
        ((A<string?>)default).F.ToString();
        ((A<string?>?)default).F.ToString();
    }
    static void F1(A<string> x1, A<string>? y1)
    {
        ((B2?)x1).F.ToString();
        ((B2)y1).F.ToString();
    }
    static void F2(B1 x2, B1? y2)
    {
        ((A<string?>?)x2).F.ToString();
        ((A<string?>)y2).F.ToString();
    }
    static void F3(A<string?> x3, A<string?>? y3)
    {
        ((B2?)x3).F.ToString();
        ((B2)y3).F.ToString();
    }
    static void F4(B2 x4, B2? y4)
    {
        ((A<string>?)x4).F.ToString();
        ((A<string>)y4).F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(2, 7),
                // (12,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string>)null).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string>)null").WithLocation(12, 10),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>)null).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>)null").WithLocation(12, 10),
                // (13,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>?)null).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>?)null").WithLocation(13, 10),
                // (14,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string?>)default").WithLocation(14, 10),
                // (14,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>)default").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>)default).F").WithLocation(14, 9),
                // (15,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>?)default").WithLocation(15, 10),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>?)default).F").WithLocation(15, 9),
                // (19,10): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'B2'.
                //         ((B2?)x1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B2?)x1").WithArguments("A<string>", "B2").WithLocation(19, 10),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2?)x1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2?)x1).F").WithLocation(19, 9),
                // (20,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B2)y1").WithLocation(20, 10),
                // (20,10): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'B2'.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B2)y1").WithArguments("A<string>", "B2").WithLocation(20, 10),
                // (20,10): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(B2)y1").WithLocation(20, 10),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2)y1).F").WithLocation(20, 9),
                // (24,10): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<string?>'.
                //         ((A<string?>?)x2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>?)x2").WithArguments("B1", "A<string?>").WithLocation(24, 10),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)x2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>?)x2).F").WithLocation(24, 9),
                // (25,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string?>)y2").WithLocation(25, 10),
                // (25,10): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<string?>'.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>)y2").WithArguments("B1", "A<string?>").WithLocation(25, 10),
                // (25,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>)y2").WithLocation(25, 10),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>)y2).F").WithLocation(25, 9),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2?)x3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2?)x3).F").WithLocation(29, 9),
                // (30,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B2)y3").WithLocation(30, 10),
                // (30,10): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(B2)y3").WithLocation(30, 10),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2)y3).F").WithLocation(30, 9),
                // (34,10): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<string>'.
                //         ((A<string>?)x4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>?)x4").WithArguments("B2", "A<string>").WithLocation(34, 10),
                // (35,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string>)y4").WithLocation(35, 10),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<string>'.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>)y4").WithArguments("B2", "A<string>").WithLocation(35, 10),
                // (35,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>)y4").WithLocation(35, 10));
        }

        [Fact]
        public void ExplicitCast_NestedNullability_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (B<object>)x1;
        o = (B<object?>)x1; // 1
        o = (B<object>)y1; // 2
        o = (B<object?>)y1;
    }
    static void F2(B<object> x2, B<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2; // 3
        o = (A<object>)y2; // 4
        o = (A<object?>)y2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         o = (B<object?>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object?>)x1").WithArguments("A<object>", "B<object?>").WithLocation(9, 13),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         o = (B<object>)y1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object>)y1").WithArguments("A<object?>", "B<object>").WithLocation(10, 13),
                // (17,13): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         o = (A<object?>)x2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object?>)x2").WithArguments("B<object>", "A<object?>").WithLocation(17, 13),
                // (18,13): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         o = (A<object>)y2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object>)y2").WithArguments("B<object?>", "A<object>").WithLocation(18, 13));
        }

        [Fact]
        public void ExplicitCast_NestedNullability_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
class D
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (I<object>)x1;
        o = (I<object?>)x1;
        o = (I<object>)y1;
        o = (I<object?>)y1;
    }
    static void F2(I<object> x2, I<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2;
        o = (A<object>)y2;
        o = (A<object?>)y2;
    }
    static void F3(B<object> x3, B<object?> y3)
    {
        object o;
        o = (IIn<object>)x3;
        o = (IIn<object?>)x3;
        o = (IIn<object>)y3;
        o = (IIn<object?>)y3;
    }
    static void F4(IIn<object> x4, IIn<object?> y4)
    {
        object o;
        o = (B<object>)x4;
        o = (B<object?>)x4;
        o = (B<object>)y4;
        o = (B<object?>)y4;
    }
    static void F5(C<object> x5, C<object?> y5)
    {
        object o;
        o = (IOut<object>)x5;
        o = (IOut<object?>)x5;
        o = (IOut<object>)y5;
        o = (IOut<object?>)y5;
    }
    static void F6(IOut<object> x6, IOut<object?> y6)
    {
        object o;
        o = (C<object>)x6;
        o = (C<object?>)x6;
        o = (C<object>)y6;
        o = (C<object?>)y6;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ExplicitCast_NestedNullability_03()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (I<object>)x1;
        o = (I<object?>)x1; // 1
        o = (I<object>)y1; // 2
        o = (I<object?>)y1;
    }
    static void F2(I<object> x2, I<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2; // 3
        o = (A<object>)y2; // 4
        o = (A<object?>)y2;
    }
    static void F3(B<object> x3, B<object?> y3)
    {
        object o;
        o = (IIn<object>)x3;
        o = (IIn<object?>)x3; // 5
        o = (IIn<object>)y3;
        o = (IIn<object?>)y3;
    }
    static void F4(IIn<object> x4, IIn<object?> y4)
    {
        object o;
        o = (B<object>)x4;
        o = (B<object?>)x4;
        o = (B<object>)y4; // 6
        o = (B<object?>)y4;
    }
    static void F5(C<object> x5, C<object?> y5)
    {
        object o;
        o = (IOut<object>)x5;
        o = (IOut<object?>)x5;
        o = (IOut<object>)y5; // 7
        o = (IOut<object?>)y5;
    }
    static void F6(IOut<object> x6, IOut<object?> y6)
    {
        object o;
        o = (C<object>)x6;
        o = (C<object?>)x6; // 8
        o = (C<object>)y6;
        o = (C<object?>)y6;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         o = (I<object?>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object?>)x1").WithArguments("A<object>", "I<object?>").WithLocation(13, 13),
                // (14,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         o = (I<object>)y1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object>)y1").WithArguments("A<object?>", "I<object>").WithLocation(14, 13),
                // (21,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'A<object?>'.
                //         o = (A<object?>)x2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object?>)x2").WithArguments("I<object>", "A<object?>").WithLocation(21, 13),
                // (22,13): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'A<object>'.
                //         o = (A<object>)y2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object>)y2").WithArguments("I<object?>", "A<object>").WithLocation(22, 13),
                // (29,13): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         o = (IIn<object?>)x3; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(IIn<object?>)x3").WithArguments("B<object>", "IIn<object?>").WithLocation(29, 13),
                // (38,13): warning CS8619: Nullability of reference types in value of type 'IIn<object?>' doesn't match target type 'B<object>'.
                //         o = (B<object>)y4; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object>)y4").WithArguments("IIn<object?>", "B<object>").WithLocation(38, 13),
                // (46,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         o = (IOut<object>)y5; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(IOut<object>)y5").WithArguments("C<object?>", "IOut<object>").WithLocation(46, 13),
                // (53,13): warning CS8619: Nullability of reference types in value of type 'IOut<object>' doesn't match target type 'C<object?>'.
                //         o = (C<object?>)x6; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object?>)x6").WithArguments("IOut<object>", "C<object?>").WithLocation(53, 13));
        }

        [Fact]
        public void ExplicitCast_UserDefined_01()
        {
            var source =
@"class A1
{
    public static implicit operator B?(A1? a) => new B();
}
class A2
{
    public static implicit operator B?(A2 a) => new B();
}
class A3
{
    public static implicit operator B(A3? a) => new B();
}
class A4
{
    public static implicit operator B(A4 a) => new B();
}
class B { }
class C
{
    static void F1(A1? x1, A1 y1)
    {
        B? b;
        b = ((B)x1)/*T:B?*/;
        b = ((B?)x1)/*T:B?*/;
        b = ((B)y1)/*T:B?*/;
        b = ((B?)y1)/*T:B?*/;
    }
    static void F2(A2? x2, A2 y2)
    {
        B? b;
        b = ((B)x2)/*T:B?*/;
        b = ((B?)x2)/*T:B?*/;
        b = ((B)y2)/*T:B?*/;
        b = ((B?)y2)/*T:B?*/;
    }
    static void F3(A3? x3, A3 y3)
    {
        B? b;
        b = ((B)x3)/*T:B!*/;
        b = ((B?)x3)/*T:B!*/;
        b = ((B)y3)/*T:B!*/;
        b = ((B?)y3)/*T:B!*/;
    }
    static void F4(A4? x4, A4 y4)
    {
        B? b;
        b = ((B)x4)/*T:B!*/;
        b = ((B?)x4)/*T:B!*/;
        b = ((B)y4)/*T:B!*/;
        b = ((B?)y4)/*T:B!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)x1)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)x1").WithLocation(23, 14),
                // (25,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)y1)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)y1").WithLocation(25, 14),
                // (31,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A2.implicit operator B?(A2 a)'.
                //         b = ((B)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("a", "A2.implicit operator B?(A2 a)").WithLocation(31, 17),
                // (31,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)x2").WithLocation(31, 14),
                // (32,18): warning CS8604: Possible null reference argument for parameter 'a' in 'A2.implicit operator B?(A2 a)'.
                //         b = ((B?)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("a", "A2.implicit operator B?(A2 a)").WithLocation(32, 18),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)y2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)y2").WithLocation(33, 14),
                // (47,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A4.implicit operator B(A4 a)'.
                //         b = ((B)x4)/*T:B!*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("a", "A4.implicit operator B(A4 a)").WithLocation(47, 17),
                // (48,18): warning CS8604: Possible null reference argument for parameter 'a' in 'A4.implicit operator B(A4 a)'.
                //         b = ((B?)x4)/*T:B!*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("a", "A4.implicit operator B(A4 a)").WithLocation(48, 18));
            comp.VerifyTypes();
        }

        [Fact]
        public void ExplicitCast_UserDefined_02()
        {
            var source =
@"class A<T> where T : class?
{
}
class B
{
    public static implicit operator A<string?>(B b) => throw null;
}
class C
{
    public static implicit operator A<string>(C c) => throw null;
    static void F1(B x1)
    {
        var y1 = (A<string?>)x1;
        var z1 = (A<string>)x1; // 1
    }
    static void F2(C x2)
    {
        var y2 = (A<string?>)x2; // 2
        var z2 = (A<string>)x2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,18): warning CS8619: Nullability of reference types in value of type 'A<string?>' doesn't match target type 'A<string>'.
                //         var z1 = (A<string>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>)x1").WithArguments("A<string?>", "A<string>").WithLocation(14, 18),
                // (18,18): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'A<string?>'.
                //         var y2 = (A<string?>)x2; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>)x2").WithArguments("A<string>", "A<string?>").WithLocation(18, 18));
        }

        [Fact]
        public void ExplicitCast_UserDefined_03()
        {
            var source =
@"class A1<T> where T : class
{
    public static implicit operator B<T?>(A1<T> a) => throw null;
}
class A2<T> where T : class
{
    public static implicit operator B<T>(A2<T> a) => throw null;
}
class B<T> { }
class C<T> where T : class
{
    static void F1(A1<T?> x1, A1<T> y1)
    {
        B<T?> x;
        B<T> y;
        x = ((B<T?>)x1)/*T:B<T?>!*/;
        y = ((B<T>)x1)/*T:B<T!>!*/;
        x = ((B<T?>)y1)/*T:B<T?>!*/;
        y = ((B<T>)y1)/*T:B<T!>!*/;
    }
    static void F2(A2<T?> x2, A2<T> y2)
    {
        B<T?> x;
        B<T> y;
        x = ((B<T?>)x2)/*T:B<T?>!*/;
        y = ((B<T>)x2)/*T:B<T!>!*/;
        x = ((B<T?>)y2)/*T:B<T?>!*/;
        y = ((B<T>)y2)/*T:B<T!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)x1)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)x1").WithArguments("B<T?>", "B<T>").WithLocation(17, 14),
                // (19,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)y1)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)y1").WithArguments("B<T?>", "B<T>").WithLocation(19, 14),
                // (26,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)x2)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)x2").WithArguments("B<T?>", "B<T>").WithLocation(26, 14),
                // (27,14): warning CS8619: Nullability of reference types in value of type 'B<T>' doesn't match target type 'B<T?>'.
                //         x = ((B<T?>)y2)/*T:B<T?>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T?>)y2").WithArguments("B<T>", "B<T?>").WithLocation(27, 14));
            comp.VerifyTypes();
        }

        [Fact]
        public void ExplicitCast_StaticType()
        {
            var source =
@"static class C
{
    static object F(object? x) => (C)x;
    static object? G(object? y) => (C?)y;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,35): error CS0716: Cannot convert to static type 'C'
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C)x").WithArguments("C").WithLocation(3, 35),
                // (3,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)x").WithLocation(3, 35),
                // (3,35): warning CS8603: Possible null reference return.
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(C)x").WithLocation(3, 35),
                // (4,36): error CS0716: Cannot convert to static type 'C'
                //     static object? G(object? y) => (C?)y;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C?)y").WithArguments("C").WithLocation(4, 36));
        }

        [Fact]
        public void ForEach_01()
        {
            var source =
@"class Enumerable
{
    public Enumerator GetEnumerator() => new Enumerator();
}
class Enumerator
{
    public object Current => throw null;
    public bool MoveNext() => false;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (string y in e)
            y.ToString();
        foreach (string? z in e)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_02()
        {
            var source =
@"class Enumerable
{
    public Enumerator GetEnumerator() => new Enumerator();
}
class Enumerator
{
    public object? Current => throw null;
    public bool MoveNext() => false;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (object y in e)
            y.ToString();
        foreach (object? z in e)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(15, 13),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object y in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(16, 18),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(17, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(19, 13));
        }

        [Fact]
        public void ForEach_03()
        {
            var source =
@"using System.Collections;
namespace System
{
    public class Object
    {
        public string ToString() => throw null;
    }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public class String { }
    public struct Enum { }
    public class Attribute { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
namespace System.Collections
{
    public interface IEnumerable
    {
        IEnumerator GetEnumerator();
    }
    public interface IEnumerator
    {
        object? Current { get; }
        bool MoveNext();
    }
}
class Enumerable : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (object y in e)
            y.ToString();
    }
    static void G(IEnumerable e)
    {
        foreach (var z in e)
            z.ToString();
        foreach (object w in e)
            w.ToString();
    }
}";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (50,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(50, 13),
                // (51,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object y in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(51, 18),
                // (52,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(52, 13),
                // (57,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(57, 13),
                // (58,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object w in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(58, 18),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(59, 13));
        }

        // z.ToString() should warn if IEnumerator.Current is annotated as `object?`.
        [Fact]
        public void ForEach_04()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F(IEnumerable<object?> cx, object?[] cy)
    {
        foreach (var x in cx)
            x.ToString();
        foreach (object? y in cy)
            y.ToString();
        foreach (object? z in (IEnumerable)cx)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(10, 13));
        }

        [Fact]
        public void ForEach_05()
        {
            var source =
@"class C
{
    static void F1(dynamic c)
    {
        foreach (var x in c)
            x.ToString();
        foreach (object? y in c)
            y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_06()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C<T> : IEnumerable<T> where T : class
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
class P
{
    static void F<T>(C<T?> c) where T : class
    {
        foreach (var x in c)
            x.ToString();
        foreach (T? y in c)
            y.ToString();
        foreach (T z in c)
            z.ToString();
        foreach (object w in c)
            w.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(15, 13),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (T z in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T").WithLocation(16, 18),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(17, 13),
                // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object w in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(18, 18),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(19, 13));
        }

        [Fact]
        public void ForEach_07()
        {
            var source =
@"struct S<T> where T : class
{
    public E<T> GetEnumerator() => new E<T>();
}
struct E<T> where T : class
{
    public T Current => throw null;
    public bool MoveNext() => false;
}
class P
{
    static void F1<T>() where T : class
    {
        foreach (var x1 in new S<T>())
            x1.ToString();
        foreach (T y1 in new S<T>())
            y1.ToString();
        foreach (T? z1 in new S<T>())
            z1.ToString();
        foreach (object? w1 in new S<T>())
            w1.ToString();
    }
    static void F2<T>() where T : class
    {
        foreach (var x2 in new S<T?>())
            x2.ToString();
        foreach (T y2 in new S<T?>())
            y2.ToString();
        foreach (T? z2 in new S<T?>())
            z2.ToString();
        foreach (object? w2 in new S<T?>())
            w2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,34): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (var x2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(25, 34),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(26, 13),
                // (27,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (T y2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T").WithLocation(27, 18),
                // (27,32): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (T y2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(27, 32),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //             y2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(28, 13),
                // (29,33): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (T? z2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(29, 33),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             z2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(30, 13),
                // (31,38): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (object? w2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(31, 38),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(32, 13));
        }

        [Fact]
        public void ForEach_08()
        {
            var source =
@"using System.Collections.Generic;
interface I<T> { T P { get; } }
interface IIn<in T> { }
interface IOut<out T> { T P { get; } }
static class C
{
    static void F1(IEnumerable<I<object>> x1, IEnumerable<I<object?>> y1)
    {
        foreach (I<object?> a1 in x1)
            a1.P.ToString();
        foreach (I<object> b1 in y1)
            b1.P.ToString();
    }
    static void F2(IEnumerable<IIn<object>> x2, IEnumerable<IIn<object?>> y2)
    {
        foreach (IIn<object?> a2 in x2)
            ;
        foreach (IIn<object> b2 in y2)
            ;
    }
    static void F3(IEnumerable<IOut<object>> x3, IEnumerable<IOut<object?>> y3)
    {
        foreach (IOut<object?> a3 in x3)
            a3.P.ToString();
        foreach (IOut<object> b3 in y3)
            b3.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             a1.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1.P").WithLocation(10, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             a3.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a3.P").WithLocation(24, 13));
        }

        [Fact]
        public void ForEach_09()
        {
            var source =
@"class A { }
class B : A { }
class C
{
    static void F(A?[] c)
    {
        foreach (var a1 in c)
            a1.ToString();
        foreach (A? a2 in c)
            a2.ToString();
        foreach (A a3 in c)
            a3.ToString();
        foreach (B? b1 in c)
            b1.ToString();
        foreach (B b2 in c)
            b2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             a1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1").WithLocation(8, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             a2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2").WithLocation(10, 13),
                // (11,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (A a3 in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "A").WithLocation(11, 18),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             a3.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a3").WithLocation(12, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //             b1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b1").WithLocation(14, 13),
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (B b2 in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "B").WithLocation(15, 18),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             b2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b2").WithLocation(16, 13));
        }

        [Fact]
        [WorkItem(29971, "https://github.com/dotnet/roslyn/issues/29971")]
        public void ForEach_10()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class A<T>
{
    internal T F;
}
class B : A<object> { }
class C
{
    static void F(A<object?>[] c)
    {
        foreach (var a1 in c)
            a1.F.ToString();
        foreach (A<object?> a2 in c)
            a2.F.ToString();
        foreach (A<object> a3 in c)
            a3.F.ToString();
        foreach (B b1 in c)
            b1.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29971: Should report WRN_NullabilityMismatchInAssignment
            // for `A<object> a3 in c` and `B b1 in c`.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             a1.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1.F").WithLocation(13, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             a2.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2.F").WithLocation(15, 13));
        }

        [Fact]
        public void ForEach_11()
        {
            var source =
@"using System.Collections.Generic;
class A
{
    public static implicit operator B?(A a) => null;
}
class B
{
}
class C
{
    static void F(IEnumerable<A> e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (B y in e)
            y.ToString();
        foreach (B? z in e)
        {
            z.ToString();
            if (z != null) z.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29971: Location of WRN_NullabilityMismatchInAssignment should be `y` rather than `B`.
            //                                                Reword WRN_NullabilityMismatchInAssignment since there is not an explicit assignment.
            comp.VerifyDiagnostics(
                // (15,18): warning CS8601: Possible null reference assignment.
                //         foreach (B y in e)
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "B").WithLocation(15, 18),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(16, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(19, 13),
                // (20,17): hidden CS8605: Result of the comparison is possibly always true.
                //             if (z != null) z.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "z != null").WithLocation(20, 17));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_12()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F()
    {
        foreach (var x in (IEnumerable?)null) // 1
        {
        }
        foreach (var y in (IEnumerable<object>)default) // 2
        {
        }
        foreach (var z in default(IEnumerable)) // 3
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): error CS0186: Use of null is not valid in this context
                //         foreach (var x in (IEnumerable?)null) // 1
                Diagnostic(ErrorCode.ERR_NullNotValid, "(IEnumerable?)null").WithLocation(7, 27),
                // (10,27): error CS0186: Use of null is not valid in this context
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.ERR_NullNotValid, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (13,27): error CS0186: Use of null is not valid in this context
                //         foreach (var z in default(IEnumerable)) // 3
                Diagnostic(ErrorCode.ERR_NullNotValid, "default(IEnumerable)").WithLocation(13, 27),
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in (IEnumerable?)null) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)null").WithLocation(7, 27),
                // (10,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var z in default(IEnumerable)) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(IEnumerable)").WithLocation(13, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_13()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1(object[]? c1)
    {
        foreach (var x in c1) // 1
        {
        }
        foreach (var y in (IEnumerable)c1) // 2
        {
        }
        if (c1 == null) return;
        foreach (var z in c1)
        {
        }
    }
    static void F2(IList<object>? c2)
    {
        foreach (var x in c2) // 3
        {
        }
        foreach (var y in (IEnumerable?)c2) // 4
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in c1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(7, 27),
                // (10,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var y in (IEnumerable)c1) // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)c1").WithLocation(10, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable)c1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)c1").WithLocation(10, 27),
                // (20,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in c2) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(20, 27),
                // (23,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable?)c2) // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)c2").WithLocation(23, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_14()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1<T>(T t1) where T : class?, IEnumerable<object>?
    {
        foreach (var x in t1) // 1
        {
        }
        foreach (var y in (IEnumerable<object>?)t1) // 2
        {
        }
        foreach (var z in (IEnumerable<object>)t1) // 3
        {
        }
    }
    static void F2<T>(T t2) where T : class?
    {
        foreach (var w in (IEnumerable?)t2) // 4
        {
        }
        foreach (var v in (IEnumerable)t2) // 5
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in t1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable<object>?)t1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>?)t1").WithLocation(10, 27),
                // (13,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var z in (IEnumerable<object>)t1) // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable<object>)t1").WithLocation(13, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var z in (IEnumerable<object>)t1) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>)t1").WithLocation(13, 27),
                // (19,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var w in (IEnumerable?)t2) // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)t2").WithLocation(19, 27),
                // (22,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var v in (IEnumerable)t2) // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)t2").WithLocation(22, 27),
                // (22,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var v in (IEnumerable)t2) // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)t2").WithLocation(22, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_15()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1<T>(T t1) where T : IEnumerable?
    {
        foreach (var x in t1) // 1
        {
        }
        foreach (var w in (IEnumerable?)t1) // 2
        {
        }
        foreach (var v in (IEnumerable)t1) // 3
        {
        }
    }
    static void F2<T>(T t2)
    {
        foreach (var y in (IEnumerable<object>?)t2) // 4
        {
        }
        foreach (var z in (IEnumerable<object>)t2) // 5
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in t1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var w in (IEnumerable?)t1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)t1").WithLocation(10, 27),
                // (13,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var v in (IEnumerable)t1) // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)t1").WithLocation(13, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var v in (IEnumerable)t1) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)t1").WithLocation(13, 27));
        }

        [Fact]
        [WorkItem(29972, "https://github.com/dotnet/roslyn/issues/29972")]
        public void ForEach_16()
        {
            var source =
@"using System.Collections;
class Enumerable : IEnumerable
{
    public IEnumerator? GetEnumerator() => null;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e) // 1
        {
        }
        foreach (var y in (IEnumerable?)e)
        {
        }
        foreach (var z in (IEnumerable)e)
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29972: Should report WRN_NullReferenceReceiver using Enumerable.GetEnumerator. 
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_UnconstrainedTypeParameter()
        {
            var source =
@"class C<T>
{
    void M(T parameter)
    {
        foreach (T local in new[] { parameter })
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_01()
        {
            var source =
@"class A { }
class B { }
class C
{
    static void F<T>(T? t) where T : A { }
    static void G(B? b)
    {
        F(b);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,9): error CS0311: The type 'B' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T?)'. There is no implicit reference conversion from 'B' to 'A'.
                //         F(b);
                Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedRefType, "F").WithArguments("C.F<T>(T?)", "A", "T", "B").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_02()
        {
            var source =
@"interface I<T> { }
class C
{
    static T F<T>(I<T> t)
    {
        throw new System.Exception();
    }
    static void G(I<string> x, I<string?> y)
    {
        F(x).ToString();
        F(y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F(y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y)").WithLocation(11, 9));
        }

        [Fact]
        public void TypeInference_03()
        {
            var source =
@"interface I<T> { }
class C
{
    static T F1<T>(I<T?> t)
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F1(x1).ToString(); // 1
        F1(y1).ToString(); // 2
    }
    static T F2<T>(I<T?> t) where T : class
    {
        throw new System.Exception();
    }
    static void G2(I<string> x2, I<string?> y2)
    {
        F2(x2).ToString(); // 3
        F2(y2).ToString(); // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T F1<T>(I<T?> t)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 22),
                // (10,12): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 't' in 'string C.F1<string>(I<string?> t)'.
                //         F1(x1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "t", "string C.F1<string>(I<string?> t)").WithLocation(10, 12),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F1(y1).ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(y1)").WithLocation(11, 9),
                // (19,12): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 't' in 'string C.F2<string>(I<string?> t)'.
                //         F2(x2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("I<string>", "I<string?>", "t", "string C.F2<string>(I<string?> t)").WithLocation(19, 12));
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void TypeInference_LowerBounds_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static A F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(A? x, A y)
    {
        var z = A.F;
        F(x, x)/*T:A?*/;
        F(x, y)/*T:A?*/;
        F(x, z)/*T:A?*/;
        F(y, x)/*T:A?*/;
        F(y, y)/*T:A!*/;
        F(y, z)/*T:A*/;
        F(z, x)/*T:A?*/;
        F(z, y)/*T:A*/;
        F(z, z)/*T:A*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_TopLevelNullability_02()
        {
            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G<T, U>(T t, U u)
        where T : class?
        where U : class, T
    {
        F(t, t)/*T:T*/;
        F(t, u)/*T:T*/;
        F(u, t)/*T:T*/;
        F(u, u)/*T:U!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void TypeInference_ExactBounds_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static A F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(out T x, out T y) => throw null;
    static void G(A? x, A y)
    {
        var z = A.F;
        F(out x, out x)/*T:A?*/;
        F(out x, out y)/*T:A*/;
        F(out x, out z)/*T:A?*/;
        F(out y, out x)/*T:A*/;
        F(out y, out y)/*T:A!*/;
        F(out y, out z)/*T:A!*/;
        F(out z, out x)/*T:A?*/;
        F(out z, out y)/*T:A!*/;
        F(out z, out z)/*T:A*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (8,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(out T, out T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(out x, out y)/*T:A*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(out x, out y)").WithArguments("C.F<T>(out T, out T)").WithLocation(8, 9),
                // (10,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(out T, out T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(out y, out x)/*T:A*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(out y, out x)").WithArguments("C.F<T>(out T, out T)").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<T> CreateI<T>(T t) => throw null;
    static void G1(I<string> x1, I<string?> y1)
    {
        var z1 = CreateI(A.F)/*T:I<string>!*/;
        F(x1, x1)/*T:I<string!>!*/;
        F(x1, y1)/*T:I<string>!*/; // 1
        F(x1, z1)/*T:I<string!>!*/;
        F(y1, x1)/*T:I<string>!*/; // 2
        F(y1, y1)/*T:I<string?>!*/;
        F(y1, z1)/*T:I<string?>!*/;
        F(z1, x1)/*T:I<string!>!*/;
        F(z1, y1)/*T:I<string?>!*/;
        F(z1, z1)/*T:I<string>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        var z2 = CreateIIn(A.F)/*T:IIn<string>!*/;
        F(x2, x2)/*T:IIn<string!>!*/;
        F(x2, y2)/*T:IIn<string!>!*/;
        F(x2, z2)/*T:IIn<string!>!*/;
        F(y2, x2)/*T:IIn<string!>!*/;
        F(y2, y2)/*T:IIn<string?>!*/;
        F(y2, z2)/*T:IIn<string>!*/;
        F(z2, x2)/*T:IIn<string!>!*/;
        F(z2, y2)/*T:IIn<string>!*/;
        F(z2, z2)/*T:IIn<string>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        var z3 = CreateIOut(A.F)/*T:IOut<string>!*/;
        F(x3, x3)/*T:IOut<string!>!*/;
        F(x3, y3)/*T:IOut<string?>!*/;
        F(x3, z3)/*T:IOut<string>!*/;
        F(y3, x3)/*T:IOut<string?>!*/;
        F(y3, y3)/*T:IOut<string?>!*/;
        F(y3, z3)/*T:IOut<string?>!*/;
        F(z3, x3)/*T:IOut<string>!*/;
        F(z3, y3)/*T:IOut<string?>!*/;
        F(z3, z3)/*T:IOut<string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (12,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x1, y1)/*T:I<string>*/; // 1
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x1, y1)").WithArguments("C.F<T>(T, T)").WithLocation(12, 9),
                // (14,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, x1)/*T:I<string>*/; // 2
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, x1)").WithArguments("C.F<T>(T, T)").WithLocation(14, 9));
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IOut<out T, out U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static T F<T>(T x, T y, T z) => throw null;
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void G(string x, string? y)
    {
        var z = A.F/*T:string*/;
        F(CreateIOut(x, x), CreateIOut(x, y))/*T:IOut<string!, string?>!*/;
        F(CreateIOut(x, x), CreateIOut(x, z))/*T:IOut<string!, string>!*/;
        F(CreateIOut(y, x), CreateIOut(x, x))/*T:IOut<string?, string!>!*/;
        F(CreateIOut(y, z), CreateIOut(z, x))/*T:IOut<string?, string>!*/;
        F(CreateIOut(x, x), CreateIOut(x, y), CreateIOut(x, z))/*T:IOut<string!, string?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_03()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<IOut<T>> Create1<T>(T t) => throw null;
    static void G1(I<IOut<string?>> x1, I<IOut<string>> y1)
    {
        var z1 = Create1(A.F)/*T:I<IOut<string>!>!*/;
        F(x1, x1)/*T:I<IOut<string?>!>!*/;
        F(x1, y1)/*T:I<IOut<string>!>!*/; // 1
        F(x1, z1)/*T:I<IOut<string?>!>!*/;
        F(y1, x1)/*T:I<IOut<string>!>!*/; // 2
        F(y1, y1)/*T:I<IOut<string!>!>!*/;
        F(y1, z1)/*T:I<IOut<string!>!>!*/;
        F(z1, x1)/*T:I<IOut<string?>!>!*/;
        F(z1, y1)/*T:I<IOut<string!>!>!*/;
        F(z1, z1)/*T:I<IOut<string>!>!*/;
    }
    static IOut<IIn<T>> Create2<T>(T t) => throw null;
    static void G2(IOut<IIn<string?>> x2, IOut<IIn<string>> y2)
    {
        var z2 = Create2(A.F)/*T:IOut<IIn<string>!>!*/;
        F(x2, x2)/*T:IOut<IIn<string?>!>!*/;
        F(x2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(x2, z2)/*T:IOut<IIn<string>!>!*/;
        F(y2, x2)/*T:IOut<IIn<string!>!>!*/;
        F(y2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(y2, z2)/*T:IOut<IIn<string!>!>!*/;
        F(z2, x2)/*T:IOut<IIn<string>!>!*/;
        F(z2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(z2, z2)/*T:IOut<IIn<string>!>!*/;
    }
    static IIn<IOut<T>> Create3<T>(T t) => throw null;
    static void G3(IIn<IOut<string?>> x3, IIn<IOut<string>> y3)
    {
        var z3 = Create3(A.F)/*T:IIn<IOut<string>!>!*/;
        F(x3, x3)/*T:IIn<IOut<string?>!>!*/;
        F(x3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(x3, z3)/*T:IIn<IOut<string>!>!*/;
        F(y3, x3)/*T:IIn<IOut<string!>!>!*/;
        F(y3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(y3, z3)/*T:IIn<IOut<string!>!>!*/;
        F(z3, x3)/*T:IIn<IOut<string>!>!*/;
        F(z3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(z3, z3)/*T:IIn<IOut<string>!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x1, y1)/*T:I<IOut<string>>*/; // 1
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x1, y1)").WithArguments("C.F<T>(T, T)").WithLocation(12, 9),
                // (14,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, x1)/*T:I<IOut<string>>*/; // 2
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, x1)").WithArguments("C.F<T>(T, T)").WithLocation(14, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_ExactBounds_TopLevelNullability_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static T F<T>(B<T> x, B<T> y) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(B<string?> x, B<string> y)
    {
        var z = CreateB(A.F)/*T:B<string>!*/;
        F(x, x)/*T:string?*/;
        F(x, y)/*T:string*/; // 1
        F(x, z)/*T:string?*/;
        F(y, x)/*T:string*/; // 2
        F(y, y)/*T:string!*/;
        F(y, z)/*T:string!*/;
        F(z, x)/*T:string?*/;
        F(z, y)/*T:string!*/;
        F(z, z)/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(B<T>, B<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y)/*T:string*/; // 1
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y)").WithArguments("C.F<T>(B<T>, B<T>)").WithLocation(10, 9),
                // (12,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(B<T>, B<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, x)/*T:string*/; // 2
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, x)").WithArguments("C.F<T>(B<T>, B<T>)").WithLocation(12, 9));
        }

        [Fact]
        public void TypeInference_ExactBounds_NestedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class Program
{
    static T F<T>(T x, T y, T z) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        F(x, x, x)/*T:B<object?>!*/;
        F(x, x, y)/*T:B<object>!*/;
        F(x, x, z)/*T:B<object?>!*/;
        F(x, y, x)/*T:B<object>!*/;
        F(x, y, y)/*T:B<object>!*/;
        F(x, y, z)/*T:B<object>!*/;
        F(x, z, x)/*T:B<object?>!*/;
        F(x, z, y)/*T:B<object>!*/;
        F(x, z, z)/*T:B<object?>!*/;
        F(y, x, x)/*T:B<object>!*/;
        F(y, x, y)/*T:B<object>!*/;
        F(y, x, z)/*T:B<object>!*/;
        F(y, y, x)/*T:B<object>!*/;
        F(y, y, y)/*T:B<object!>!*/;
        F(y, y, z)/*T:B<object!>!*/;
        F(y, z, x)/*T:B<object>!*/;
        F(y, z, y)/*T:B<object!>!*/;
        F(y, z, z)/*T:B<object!>!*/;
        F(z, x, x)/*T:B<object?>!*/;
        F(z, x, y)/*T:B<object>!*/;
        F(z, x, z)/*T:B<object?>!*/;
        F(z, y, x)/*T:B<object>!*/;
        F(z, y, y)/*T:B<object!>!*/;
        F(z, y, z)/*T:B<object!>!*/;
        F(z, z, x)/*T:B<object?>!*/;
        F(z, z, y)/*T:B<object!>!*/;
        F(z, z, z)/*T:B<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (10,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, x, y)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, x, y)").WithArguments("Program.F<T>(T, T, T)").WithLocation(10, 9),
                // (12,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y, x)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y, x)").WithArguments("Program.F<T>(T, T, T)").WithLocation(12, 9),
                // (13,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y, y)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y, y)").WithArguments("Program.F<T>(T, T, T)").WithLocation(13, 9),
                // (14,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y, z)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y, z)").WithArguments("Program.F<T>(T, T, T)").WithLocation(14, 9),
                // (16,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, z, y)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, z, y)").WithArguments("Program.F<T>(T, T, T)").WithLocation(16, 9),
                // (18,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, x, x)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, x, x)").WithArguments("Program.F<T>(T, T, T)").WithLocation(18, 9),
                // (19,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, x, y)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, x, y)").WithArguments("Program.F<T>(T, T, T)").WithLocation(19, 9),
                // (20,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, x, z)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, x, z)").WithArguments("Program.F<T>(T, T, T)").WithLocation(20, 9),
                // (21,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, y, x)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, y, x)").WithArguments("Program.F<T>(T, T, T)").WithLocation(21, 9),
                // (24,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, z, x)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, z, x)").WithArguments("Program.F<T>(T, T, T)").WithLocation(24, 9),
                // (28,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(z, x, y)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(z, x, y)").WithArguments("Program.F<T>(T, T, T)").WithLocation(28, 9),
                // (30,9): warning CS8638: The nullability of type arguments for method 'Program.F<T>(T, T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(z, y, x)/*T:B<object>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(z, y, x)").WithArguments("Program.F<T>(T, T, T)").WithLocation(30, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_ExactAndLowerBounds_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static T F<T>(T x, B<T> y) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(string? x, string y)
    {
        var z = A.F/*T:string*/;
        F(x, CreateB(x))/*T:string?*/;
        F(x, CreateB(y))/*T:string?*/; // 1
        F(x, CreateB(z))/*T:string?*/;
        F(y, CreateB(x))/*T:string?*/;
        F(y, CreateB(y))/*T:string!*/;
        F(y, CreateB(z))/*T:string*/;
        F(z, CreateB(x))/*T:string?*/;
        F(z, CreateB(y))/*T:string*/;
        F(z, CreateB(z))/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'B<string>' doesn't match target type 'B<string?>' for parameter 'y' in 'string? C.F<string?>(string? x, B<string?> y)'.
                //         F(x, CreateB(y))/*T:string?*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateB(y)").WithArguments("B<string>", "B<string?>", "y", "string? C.F<string?>(string? x, B<string?> y)").WithLocation(10, 14));
        }

        [Fact]
        public void TypeInference_ExactAndUpperBounds_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T> { }
class B<T> { }
class C
{
    static T F<T>(IIn<T> x, B<T> y) => throw null;
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(string? x, string y)
    {
        var z = A.F/*T:string*/;
        F(CreateIIn(x), CreateB(x))/*T:string?*/;
        F(CreateIIn(x), CreateB(y))/*T:string!*/;
        F(CreateIIn(x), CreateB(z))/*T:string*/;
        F(CreateIIn(y), CreateB(x))/*T:string!*/; // 1
        F(CreateIIn(y), CreateB(y))/*T:string!*/;
        F(CreateIIn(y), CreateB(z))/*T:string!*/;
        F(CreateIIn(z), CreateB(x))/*T:string*/;
        F(CreateIIn(z), CreateB(y))/*T:string!*/;
        F(CreateIIn(z), CreateB(z))/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,25): warning CS8620: Nullability of reference types in argument of type 'B<string?>' doesn't match target type 'B<string>' for parameter 'y' in 'string C.F<string>(IIn<string> x, B<string> y)'.
                //         F(CreateIIn(y), CreateB(x))/*T:string*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateB(x)").WithArguments("B<string?>", "B<string>", "y", "string C.F<string>(IIn<string> x, B<string> y)").WithLocation(14, 25));
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_MixedBounds_NestedNullability()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T, U> { }
interface IOut<T, out U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static IIn<T, U> CreateIIn<T, U>(T t, U u) => throw null;
    static void F1(bool b, IIn<object, string> x1, IIn<object?, string?> y1)
    {
        var z1 = CreateIIn(A.F1, A.F2)/*T:IIn<object, string>!*/;
        F(x1, x1)/*T:IIn<object!, string!>!*/;
        F(x1, y1)/*T:IIn<object!, string>!*/;
        F(x1, z1)/*T:IIn<object!, string!>!*/;
        F(y1, x1)/*T:IIn<object!, string>!*/;
        F(y1, y1)/*T:IIn<object?, string?>!*/;
        F(y1, z1)/*T:IIn<object, string?>!*/;
        F(z1, x1)/*T:IIn<object!, string!>!*/;
        F(z1, y1)/*T:IIn<object, string?>!*/;
        F(z1, z1)/*T:IIn<object, string>!*/;
    }
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void F2(bool b, IOut<object, string> x2, IOut<object?, string?> y2)
    {
        var z2 = CreateIOut(A.F1, A.F2)/*T:IOut<object, string>!*/;
        F(x2, x2)/*T:IOut<object!, string!>!*/;
        F(x2, y2)/*T:IOut<object, string?>!*/;
        F(x2, z2)/*T:IOut<object!, string>!*/;
        F(y2, x2)/*T:IOut<object, string?>!*/;
        F(y2, y2)/*T:IOut<object?, string?>!*/;
        F(y2, z2)/*T:IOut<object?, string?>!*/;
        F(z2, x2)/*T:IOut<object!, string>!*/;
        F(z2, y2)/*T:IOut<object?, string?>!*/;
        F(z2, z2)/*T:IOut<object, string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x1, y1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x1, y1)").WithArguments("C.F<T>(T, T)").WithLocation(11, 9),
                // (11,15): warning CS8620: Nullability of reference types in argument of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>' for parameter 'y' in 'IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)'.
                //         F(x1, y1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>", "y", "IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)").WithLocation(11, 15),
                // (13,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, x1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, x1)").WithArguments("C.F<T>(T, T)").WithLocation(13, 9),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>' for parameter 'x' in 'IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)'.
                //         F(y1, x1)/*T:IIn<object!, string>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>", "x", "IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)").WithLocation(13, 11),
                // (25,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x2, y2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x2, y2)").WithArguments("C.F<T>(T, T)").WithLocation(25, 9),
                // (25,11): warning CS8620: Nullability of reference types in argument of type 'IOut<object, string>' doesn't match target type 'IOut<object, string?>' for parameter 'x' in 'IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)'.
                //         F(x2, y2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IOut<object, string>", "IOut<object, string?>", "x", "IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)").WithLocation(25, 11),
                // (27,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y2, x2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y2, x2)").WithArguments("C.F<T>(T, T)").WithLocation(27, 9),
                // (27,15): warning CS8620: Nullability of reference types in argument of type 'IOut<object, string>' doesn't match target type 'IOut<object, string?>' for parameter 'y' in 'IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)'.
                //         F(y2, x2)/*T:IOut<object, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IOut<object, string>", "IOut<object, string?>", "y", "IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)").WithLocation(27, 15));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_MismatchedTypes()
        {
            var source =
@"interface IOut<out T> { }
class Program
{
    static T F<T>(T x, T y) => throw null;
    static void G(IOut<object> x, IOut<string?> y)
    {
        F(x, y)/*T:IOut<object!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Ideally we'd infer IOut<object?> but the spec doesn't require merging nullability
            // across distinct types (in this case, the lower bounds IOut<object!> and IOut<string?>).
            // Instead, method type inference infers IOut<object!> and a warning is reported
            // converting the second argument to the inferred parameter type.
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (7,14): warning CS8620: Nullability of reference types in argument of type 'IOut<string?>' doesn't match target type 'IOut<object>' for parameter 'y' in 'IOut<object> Program.F<IOut<object>>(IOut<object> x, IOut<object> y)'.
                //         F(x, y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IOut<string?>", "IOut<object>", "y", "IOut<object> Program.F<IOut<object>>(IOut<object> x, IOut<object> y)").WithLocation(7, 14));
        }

        [Fact]
        public void TypeInference_LowerAndUpperBounds_NestedNullability()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class Program
{
    static T FIn<T>(T x, T y, IIn<T> z) => throw null;
    static T FOut<T>(T x, T y, IOut<T> z) => throw null;
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void G1(IIn<string?> x1, IIn<string> y1)
    {
        FIn(x1, y1, CreateIIn(x1))/*T:IIn<string!>!*/; // 1
        FIn(x1, y1, CreateIIn(y1))/*T:IIn<string!>!*/;
        FOut(x1, y1, CreateIOut(x1))/*T:IIn<string!>!*/;
        FOut(x1, y1, CreateIOut(y1))/*T:IIn<string!>!*/;
    }
    static void G2(IOut<string?> x2, IOut<string> y2)
    {
        FIn(x2, y2, CreateIIn(x2))/*T:IOut<string?>!*/;
        FIn(x2, y2, CreateIIn(y2))/*T:IOut<string?>!*/; // 2
        FOut(x2, y2, CreateIOut(x2))/*T:IOut<string?>!*/;
        FOut(x2, y2, CreateIOut(y2))/*T:IOut<string?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Ideally we'd fail to infer nullability for // 1 and // 2 rather than inferring the
            // wrong nullability and then reporting a warning converting the arguments.
            // (See MethodTypeInferrer.TryMergeAndReplaceIfStillCandidate which ignores
            // the variance used merging earlier candidates when merging later candidates.)
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (11,21): warning CS8620: Nullability of reference types in argument of type 'IIn<IIn<string?>>' doesn't match target type 'IIn<IIn<string>>' for parameter 'z' in 'IIn<string> Program.FIn<IIn<string>>(IIn<string> x, IIn<string> y, IIn<IIn<string>> z)'.
                //         FIn(x1, y1, CreateIIn(x1))/*T:IIn<string!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateIIn(x1)").WithArguments("IIn<IIn<string?>>", "IIn<IIn<string>>", "z", "IIn<string> Program.FIn<IIn<string>>(IIn<string> x, IIn<string> y, IIn<IIn<string>> z)").WithLocation(11, 21),
                // (19,21): warning CS8620: Nullability of reference types in argument of type 'IIn<IOut<string>>' doesn't match target type 'IIn<IOut<string?>>' for parameter 'z' in 'IOut<string?> Program.FIn<IOut<string?>>(IOut<string?> x, IOut<string?> y, IIn<IOut<string?>> z)'.
                //         FIn(x2, y2, CreateIIn(y2))/*T:IOut<string?>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateIIn(y2)").WithArguments("IIn<IOut<string>>", "IIn<IOut<string?>>", "z", "IOut<string?> Program.FIn<IOut<string?>>(IOut<string?> x, IOut<string?> y, IIn<IOut<string?>> z)").WithLocation(19, 21));
        }

        [Fact]
        public void TypeInference_05()
        {
            var source =
@"class C
{
    static T F<T>(T x, T? y) where T : class => x;
    static void G(C? x, C y)
    {
        F(x, x).ToString();
        F(x, y).ToString();
        F(y, x).ToString();
        F(y, y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'C?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T, T?)'. Nullability of type argument 'C?' doesn't match 'class' constraint.
                //         F(x, x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(T, T?)", "T", "C?").WithLocation(6, 9),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, x)").WithLocation(6, 9),
                // (7,9): warning CS8634: The type 'C?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T, T?)'. Nullability of type argument 'C?' doesn't match 'class' constraint.
                //         F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(T, T?)", "T", "C?").WithLocation(7, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, y)").WithLocation(7, 9));
        }

        [Fact]
        public void TypeInference_06()
        {
            var source =
@"class C
{
    static T F<T, U>(T t, U u) where U : T => t;
    static void G(C? x, C y)
    {
        F(x, x).ToString(); // warning: may be null
        F(x, y).ToString(); // warning may be null
        F(y, x).ToString(); // warning: x does not satisfy U constraint
        F(y, y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, x).ToString(); // warning: may be null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, x)").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, y).ToString(); // warning may be null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, y)").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'C?' cannot be used as type parameter 'U' in the generic type or method 'C.F<T, U>(T, U)'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         F(y, x).ToString(); // warning: x does not satisfy U constraint
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F").WithArguments("C.F<T, U>(T, U)", "C", "U", "C?").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T, U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static B<T, U> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = CreateB(t1, u2)/*T:B<object?, string!>!*/;
        var y = CreateB(t2, u1)/*T:B<object!, string?>!*/;
        var z = CreateB(t1, u3)/*T:B<object?, string>!*/;
        var w = CreateB(t3, u2)/*T:B<object, string!>!*/;
        F(x, y)/*T:B<object, string>!*/;
        F(x, z)/*T:B<object?, string!>!*/;
        F(x, w)/*T:B<object?, string!>!*/;
        F(y, z)/*T:B<object, string?>!*/;
        F(y, w)/*T:B<object!, string>!*/;
        F(w, z)/*T:B<object?, string!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y)/*T:B<object, string>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y)").WithArguments("C.F<T>(T, T)").WithLocation(14, 9),
                // (17,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, z)/*T:B<object, string?>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, z)").WithArguments("C.F<T>(T, T)").WithLocation(17, 9),
                // (18,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, w)/*T:B<object!, string>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, w)").WithArguments("C.F<T>(T, T)").WithLocation(18, 9));
        }

        [Fact]
        public void TypeInference_UpperBounds_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T> { }
class B<T, U> { }
class C
{
    static T F<T>(IIn<T> x, IIn<T> y) => throw null;
    static IIn<B<T, U>> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = CreateB(t1, u2)/*T:IIn<B<object?, string!>!>!*/;
        var y = CreateB(t2, u1)/*T:IIn<B<object!, string?>!>!*/;
        var z = CreateB(t1, u3)/*T:IIn<B<object?, string>!>!*/;
        var w = CreateB(t3, u2)/*T:IIn<B<object, string!>!>!*/;
        F(x, y)/*T:B<object, string>!*/;
        F(x, z)/*T:B<object?, string!>!*/;
        F(x, w)/*T:B<object?, string!>!*/;
        F(y, z)/*T:B<object, string?>!*/;
        F(y, w)/*T:B<object!, string>!*/;
        F(w, z)/*T:B<object?, string!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (15,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IIn<T>, IIn<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y)/*T:B<object, string>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y)").WithArguments("C.F<T>(IIn<T>, IIn<T>)").WithLocation(15, 9),
                // (18,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IIn<T>, IIn<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, z)/*T:B<object, string?>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, z)").WithArguments("C.F<T>(IIn<T>, IIn<T>)").WithLocation(18, 9),
                // (19,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(IIn<T>, IIn<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, w)/*T:B<object!, string>*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, w)").WithArguments("C.F<T>(IIn<T>, IIn<T>)").WithLocation(19, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_TypeParameters()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static void G<T>(IOut<T?> x, IOut<T> y) where T : class
    {
        F(x, x)/*T:IOut<T?>!*/;
        F(x, y)/*T:IOut<T?>!*/;
        F(y, x)/*T:IOut<T?>!*/;
        F(y, y)/*T:IOut<T!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Arrays()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(string?[] x, string[] y)
    {
        var z = (new[] { A.F })/*T:string[]!*/;
        F(x, x)/*T:string?[]!*/;
        F(x, y)/*T:string[]!*/;
        F(x, z)/*T:string?[]!*/;
        F(y, x)/*T:string[]!*/;
        F(y, y)/*T:string![]!*/;
        F(y, z)/*T:string![]!*/;
        F(z, x)/*T:string?[]!*/;
        F(z, y)/*T:string![]!*/;
        F(z, z)/*T:string[]!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (8,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y)/*T:string[]!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y)").WithArguments("C.F<T>(T, T)").WithLocation(8, 9),
                // (10,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, x)/*T:string[]!*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, x)").WithArguments("C.F<T>(T, T)").WithLocation(10, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Dynamic()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(IOut<dynamic?> x, IOut<dynamic> y)
    {
        F(x, x)/*T:IOut<dynamic?>!*/;
        F(x, y)/*T:IOut<dynamic?>!*/;
        F(y, x)/*T:IOut<dynamic?>!*/;
        F(y, y)/*T:IOut<dynamic!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Pointers()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"unsafe class C
{
    static T F<T>(T x, T y) => throw null;
    static T* CreatePointer<T>(T t) => throw null;
    static void G(object?* x, object* y)
    {
        var z = CreatePointer(A.F)/*T:object**/;
        F(x, x)/*T:object**/;
        F(x, y)/*T:object**/;
        F(x, z)/*T:object**/;
        F(y, x)/*T:object**/;
        F(y, y)/*T:object**/;
        F(y, z)/*T:object**/;
        F(z, x)/*T:object**/;
        F(z, y)/*T:object**/;
        F(z, z)/*T:object**/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(TestOptions.UnsafeDebugDll), references: new[] { ref0 });
            // NullableWalker.VisitCall is currently skipping F(x, y), etc. because
            // each BoundCall has errors.
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (4,12): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('T')
                //     static T* CreatePointer<T>(T t) => throw null;
                Diagnostic(ErrorCode.ERR_ManagedAddr, "T*").WithArguments("T").WithLocation(4, 12),
                // (5,19): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('object')
                //     static void G(object?* x, object* y)
                Diagnostic(ErrorCode.ERR_ManagedAddr, "object?*").WithArguments("object").WithLocation(5, 19),
                // (5,31): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('object')
                //     static void G(object?* x, object* y)
                Diagnostic(ErrorCode.ERR_ManagedAddr, "object*").WithArguments("object").WithLocation(5, 31),
                // (8,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, x)/*T:object?*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(8, 9),
                // (9,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, y)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(9, 9),
                // (10,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, z)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(10, 9),
                // (11,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, x)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(11, 9),
                // (12,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, y)/*T:object!*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(12, 9),
                // (13,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, z)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(13, 9),
                // (14,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, x)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(14, 9),
                // (15,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, y)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(15, 9),
                // (16,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, z)/*T:object*!*/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(16, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Tuples()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = (t1, u2)/*T:(object? t1, string! u2)*/;
        var y = (t2, u1)/*T:(object! t2, string? u1)*/;
        var z = (t1, u3)/*T:(object? t1, string u3)*/;
        var w = (t3, u2)/*T:(object t3, string! u2)*/;
        F(x, y)/*T:(object, string)*/;
        F(x, z)/*T:(object? t1, string!)*/;
        F(x, w)/*T:(object?, string! u2)*/;
        F(y, z)/*T:(object, string?)*/;
        F(y, w)/*T:(object!, string)*/;
        F(w, z)/*T:(object?, string!)*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (12,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x, y)/*T:(object, string)*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x, y)").WithArguments("C.F<T>(T, T)").WithLocation(12, 9),
                // (15,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, z)/*T:(object, string?)*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, z)").WithArguments("C.F<T>(T, T)").WithLocation(15, 9),
                // (16,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y, w)/*T:(object!, string)*/;
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y, w)").WithArguments("C.F<T>(T, T)").WithLocation(16, 9));
        }

        [Fact]
        public void Assignment_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T, U> { }
class C
{
    static B<T, U> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x0 = CreateB(t1, u2)/*T:B<object?, string!>!*/;
        var y0 = CreateB(t2, u1)/*T:B<object!, string?>!*/;
        var z0 = CreateB(t1, u3)/*T:B<object?, string>!*/;
        var w0 = CreateB(t3, u2)/*T:B<object, string!>!*/;
        var x = x0;
        var y = y0;
        var z = z0;
        var w = w0;
        x = y0; // 1
        x = z0;
        x = w0;
        y = z0; // 2
        y = w0; // 3
        w = z0;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (17,13): warning CS8619: Nullability of reference types in value of type 'B<object, string?>' doesn't match target type 'B<object?, string>'.
                //         x = y0; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y0").WithArguments("B<object, string?>", "B<object?, string>").WithLocation(17, 13),
                // (20,13): warning CS8619: Nullability of reference types in value of type 'B<object?, string>' doesn't match target type 'B<object, string?>'.
                //         y = z0; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z0").WithArguments("B<object?, string>", "B<object, string?>").WithLocation(20, 13),
                // (21,13): warning CS8619: Nullability of reference types in value of type 'B<object, string>' doesn't match target type 'B<object, string?>'.
                //         y = w0; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w0").WithArguments("B<object, string>", "B<object, string?>").WithLocation(21, 13));
        }

        [Fact]
        public void TypeInference_09()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<T> x, I<T> y)
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F(x1, x1)/*T:string!*/.ToString();
        F(x1, y1)/*T:string*/.ToString();
        F(y1, x1)/*T:string*/.ToString();
        F(y1, y1)/*T:string?*/.ToString();
    }
    static T F<T>(IIn<T> x, IIn<T> y)
    {
        throw new System.Exception();
    }
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        F(x2, x2)/*T:string!*/.ToString();
        F(x2, y2)/*T:string!*/.ToString();
        F(y2, x2)/*T:string!*/.ToString();
        F(y2, y2)/*T:string?*/.ToString();
    }
    static T F<T>(IOut<T> x, IOut<T> y)
    {
        throw new System.Exception();
    }
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        F(x3, x3)/*T:string!*/.ToString();
        F(x3, y3)/*T:string?*/.ToString();
        F(y3, x3)/*T:string?*/.ToString();
        F(y3, y3)/*T:string?*/.ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (13,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<T>, I<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x1, y1).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x1, y1)").WithArguments("C.F<T>(I<T>, I<T>)").WithLocation(13, 9),
                // (14,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<T>, I<T>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, x1).ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, x1)").WithArguments("C.F<T>(I<T>, I<T>)").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         F(y1, y1).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y1, y1)").WithLocation(15, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         F(y2, y2).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y2, y2)").WithLocation(26, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         F(x3, y3).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x3, y3)").WithLocation(35, 9),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, x3).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, x3)").WithLocation(36, 9),
                // (37,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, y3).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, y3)").WithLocation(37, 9));
        }

        [Fact]
        public void TypeInference_10()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<T> x, I<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F(x1, x1).ToString(); // 1
        F(x1, y1).ToString();
        F(y1, x1).ToString(); // 2 and 3
        F(y1, y1).ToString(); // 4
    }
    static T F<T>(IIn<T> x, IIn<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        F(x2, x2).ToString(); // 5
        F(x2, y2).ToString();
        F(y2, x2).ToString(); // 6
        F(y2, y2).ToString();
    }
    static T F<T>(IOut<T> x, IOut<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        F(x3, x3).ToString();
        F(x3, y3).ToString();
        F(y3, x3).ToString(); // 7
        F(y3, y3).ToString(); // 8
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 'y' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(x1, x1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "y", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(12, 15),
                // (14,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<T>, I<T?>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, x1).ToString(); // 2 and 3
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, x1)").WithArguments("C.F<T>(I<T>, I<T?>)").WithLocation(14, 9),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, x1).ToString(); // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(14, 11),
                // (14,15): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 'y' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, x1).ToString(); // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "y", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(14, 15),
                // (15,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(I<T>, I<T?>)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(y1, y1).ToString(); // 4
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(y1, y1)").WithArguments("C.F<T>(I<T>, I<T?>)").WithLocation(15, 9),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, y1).ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(15, 11),
                // (23,15): warning CS8620: Nullability of reference types in argument of type 'IIn<string>' doesn't match target type 'IIn<string?>' for parameter 'y' in 'string C.F<string>(IIn<string> x, IIn<string?> y)'.
                //         F(x2, x2).ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IIn<string>", "IIn<string?>", "y", "string C.F<string>(IIn<string> x, IIn<string?> y)").WithLocation(23, 15),
                // (25,15): warning CS8620: Nullability of reference types in argument of type 'IIn<string>' doesn't match target type 'IIn<string?>' for parameter 'y' in 'string C.F<string>(IIn<string> x, IIn<string?> y)'.
                //         F(y2, x2).ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IIn<string>", "IIn<string?>", "y", "string C.F<string>(IIn<string> x, IIn<string?> y)").WithLocation(25, 15),
                // (36,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(IOut<T>, IOut<T?>)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(y3, x3).ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(IOut<T>, IOut<T?>)", "T", "string?").WithLocation(36, 9),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, x3).ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, x3)").WithLocation(36, 9),
                // (37,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(IOut<T>, IOut<T?>)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(y3, y3).ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(IOut<T>, IOut<T?>)", "T", "string?").WithLocation(37, 9),
                // (37,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, y3).ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, y3)").WithLocation(37, 9));
        }

        [Fact]
        public void TypeInference_11()
        {
            var source0 =
@"public class A<T>
{
    public T F;
}
public class UnknownNull
{
    public A<object> A1;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"#pragma warning disable 8618
public class MaybeNull
{
    public A<object?> A2;
}
public class NotNull
{
    public A<object> A3;
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        F(x1.A1, y1.A1)/*T:A<object>*/.F.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        F(x2.A1, y2.A2)/*T:A<object?>*/.F.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        F(x3.A2, y3.A1)/*T:A<object?>*/.F.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        F(x4.A2, y4.A2)/*T:A<object?>!*/.F.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        F(x5.A1, y5.A3)/*T:A<object!>*/.F.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        F(x6.A3, y6.A1)/*T:A<object!>*/.F.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        F(x7.A2, y7.A3)/*T:A<object>!*/.F.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        F(x8.A3, y8.A2)/*T:A<object>!*/.F.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        F(x9.A3, y9.A3)/*T:A<object!>!*/.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(x2.A1, y2.A2)/*T:A<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x2.A1, y2.A2)/*T:A<object?>*/.F").WithLocation(10, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         F(x3.A2, y3.A1)/*T:A<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x3.A2, y3.A1)/*T:A<object?>*/.F").WithLocation(14, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         F(x4.A2, y4.A2)/*T:A<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x4.A2, y4.A2)/*T:A<object?>!*/.F").WithLocation(18, 9),
                // (30,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x7.A2, y7.A3)/*T:A<object>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x7.A2, y7.A3)").WithArguments("C.F<T>(T, T)").WithLocation(30, 9),
                // (34,9): warning CS8638: The nullability of type arguments for method 'C.F<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(x8.A3, y8.A2)/*T:A<object>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_CantInferNullabilityOfMethodTypeArgs, "F(x8.A3, y8.A2)").WithArguments("C.F<T>(T, T)").WithLocation(34, 9));
        }

        [Fact]
        public void TypeInference_12()
        {
            var source =
@"class C<T>
{
    internal T F;
}
class C
{
    static C<T> Create<T>(T t)
    {
        return new C<T>();
    }
    static void F(object? x)
    {
        if (x == null)
        {
            Create(x).F = null;
            var y = Create(x);
            y.F = null;
        }
        else
        {
            Create(x).F = null; // warn
            var y = Create(x);
            y.F = null; // warn
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "F").WithLocation(1, 7),
                // (21,27): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             Create(x).F = null; // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 27),
                // (23,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             y.F = null; // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(23, 19));
        }

        [Fact]
        public void TypeInference_ArgumentOrder()
        {
            var source =
@"interface I<T>
{
     T P { get; }
}
class C
{
    static T F<T, U>(I<T> x, I<U> y) => x.P;
    static void M(I<object?> x, I<string> y)
    {
        F(y: y, x: x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(y: y, x: x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y: y, x: x)").WithLocation(10, 9));
        }

        [Fact]
        public void TypeInference_Local()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        object x = new object();
        object? y = x;
        F(x).ToString();
        F(y).ToString();
        y = null;
        F(y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F(y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y)").WithLocation(11, 9));
        }

        [Fact]
        public void TypeInference_Call()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object F1() => new object();
    static object? F2() => null;
    static void G()
    {
        F(F1()).ToString();
        F(F2()).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(F2()).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(F2())").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_Property()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object P => new object();
    static object? Q => null;
    static void G()
    {
        F(P).ToString();
        F(Q).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(Q).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(Q)").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_FieldAccess()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object F1 = new object();
    static object? F2 = null;
    static void G()
    {
        F(F1).ToString();
        F(F2).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(F2).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(F2)").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_Literal()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(0).ToString();
        F('A').ToString();
        F(""B"").ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_Default()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(default(object)).ToString();
        F(default(int)).ToString();
        F(default(string)).ToString();
        F(default).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): error CS0411: The type arguments for method 'C.F<T>(T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(default).ToString();
                Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "F").WithArguments("C.F<T>(T)").WithLocation(9, 9),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(default(object)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(default(object))").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(default(string)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(default(string))").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_Tuple_01()
        {
            var source =
@"class C
{
    static (T, U) F<T, U>((T, U) t) => t;
    static void G(string x, string? y)
    {
        var t = (x, y);
        F(t).Item1.ToString();
        F(t).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).Item2").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_Tuple_02()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(string x, string? y)
    {
        var t = (x, y);
        F(t).Item1.ToString();
        F(t).Item2.ToString();
        F(t).x.ToString();
        F(t).y.ToString();
        var u = (a: x, b: y);
        F(u).Item1.ToString();
        F(u).Item2.ToString();
        F(u).a.ToString();
        F(u).b.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).Item2").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).y").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         F(u).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(u).Item2").WithLocation(13, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         F(u).b.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(u).b").WithLocation(15, 9));
        }

        [Fact]
        public void TypeInference_Tuple_03()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (x == null) return;
        var t = (x, y);
        t.x.ToString();
        t.y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_ObjectCreation()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(new C { }).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_DelegateCreation()
        {
            var source =
@"delegate void D();
class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(new D(G)).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_BinaryOperator()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(string x, string? y)
    {
        F(x + x).ToString();
        F(x + y).ToString();
        F(y + x).ToString();
        F(y + y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_NullCoalescingOperator()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(object x, object? y)
    {
        F(x ?? x).ToString();
        F(x ?? y).ToString();
        F(y ?? x).ToString();
        F(y ?? y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,11): hidden CS8607: Expression is probably never null.
                //         F(x ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(6, 11),
                // (7,11): hidden CS8607: Expression is probably never null.
                //         F(x ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(7, 11),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(y ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y ?? y)").WithLocation(9, 9));
        }

        [Fact]
        public void Members_Fields()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    internal string? F;
}
class Program
{
    static void F(C a)
    {
        G(a.F);
        if (a.F != null) G(a.F);
        C b = new C();
        G(b.F);
        if (b.F != null) G(b.F);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.F);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.F").WithArguments("s", "void Program.G(string s)").WithLocation(10, 11),
                // (13,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.F);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.F").WithArguments("s", "void Program.G(string s)").WithLocation(13, 11));
        }

        [Fact]
        public void Members_Fields_UnconstrainedType()
        {
            var source =
@"
class C<T>
{
    internal T field = default;

    static void F(C<T> a, bool c)
    {
        if (c) a.field.ToString();
        else if (a.field != null) a.field.ToString();
        C<T> b = new C<T>();
        if (c) b.field.ToString();
        else if (b.field != null) b.field.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,16): warning CS8602: Possible dereference of a null reference.
                //         if (c) a.field.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.field").WithLocation(8, 16),
                // (11,16): warning CS8602: Possible dereference of a null reference.
                //         if (c) b.field.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.field").WithLocation(11, 16)
                );
        }

        [Fact]
        public void Members_AutoProperties()
        {
            var source =
@"class C
{
    internal string? P { get; set; }
}
class Program
{
    static void F(C a)
    {
        G(a.P);
        if (a.P != null) G(a.P);
        C b = new C();
        G(b.P);
        if (b.P != null) G(b.P);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.P").WithArguments("s", "void Program.G(string s)").WithLocation(9, 11),
                // (12,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.P").WithArguments("s", "void Program.G(string s)").WithLocation(12, 11));
        }

        [Fact]
        public void Members_Properties()
        {
            var source =
@"class C
{
    internal string? P { get { throw new System.Exception(); } set { } }
}
class Program
{
    static void F(C a)
    {
        G(a.P);
        if (a.P != null) G(a.P);
        C b = new C();
        G(b.P);
        if (b.P != null) G(b.P);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.P").WithArguments("s", "void Program.G(string s)").WithLocation(9, 11),
                // (12,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.P").WithArguments("s", "void Program.G(string s)").WithLocation(12, 11));
        }

        [Fact]
        public void Members_AutoPropertyFromConstructor()
        {
            var source =
@"class A
{
    protected static void F(string s)
    {
    }
    protected string? P { get; set; }
    protected A()
    {
        F(P);
        if (P != null) F(P);
    }
}
class B : A
{
    B()
    {
        F(this.P);
        if (this.P != null) F(this.P);
        F(base.P);
        if (base.P != null) F(base.P);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(this.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "this.P").WithArguments("s", "void A.F(string s)").WithLocation(17, 11),
                // (19,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(base.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "base.P").WithArguments("s", "void A.F(string s)").WithLocation(19, 11),
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "P").WithArguments("s", "void A.F(string s)").WithLocation(9, 11));
        }

        [Fact]
        public void ModifyMembers_01()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? F;
    static void M(C c)
    {
        if (c.F == null) return;
        c = new C();
        c.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(9, 9));
        }

        [Fact]
        public void ModifyMembers_02()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal C? C;
}
class B
{
    internal A? A;
}
class C
{
    internal B? B;
}
class Program
{
    static void F()
    {
        object o;
        C? c = new C();
        c.B = new B();
        c.B.A = new A();
        o = c.B.A; // 1
        c.B.A = null;
        o = c.B.A; // 2
        c.B = new B();
        o = c.B.A; // 3
        c.B = null;
        o = c.B.A; // 4
        c = new C();
        o = c.B.A; // 5
        c = null;
        o = c.B.A; // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (24,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(24, 13),
                // (26,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(26, 13),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(28, 13),
                // (28,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(28, 13),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(30, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(32, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(32, 13));
        }

        [Fact]
        public void ModifyMembers_03()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? F;
}
class C
{
    internal C? A;
    internal S B;
}
class Program
{
    static void M()
    {
        object o;
        C c = new C();
        o = c.A.A; // 1
        o = c.B.F; // 1
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 2
        o = c.B.F; // 2
        c.A.A = new C();
        c.B.F = new C();
        o = c.A.A; // 3
        o = c.B.F; // 3
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 4
        o = c.B.F; // 4
        c = new C();
        o = c.A.A; // 5
        o = c.B.F; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(17, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(18, 13),
                // (21,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(21, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(22, 13),
                // (29,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(29, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(32, 13),
                // (33,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(33, 13));
        }

        [Fact]
        public void ModifyMembers_Properties()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? P { get; set; }
}
class C
{
    internal C? A { get; set; }
    internal S B;
}
class Program
{
    static void M()
    {
        object o;
        C c = new C();
        o = c.A.A; // 1
        o = c.B.P; // 1
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 2
        o = c.B.P; // 2
        c.A.A = new C();
        c.B.P = new C();
        o = c.A.A; // 3
        o = c.B.P; // 3
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 4
        o = c.B.P; // 4
        c = new C();
        o = c.A.A; // 5
        o = c.B.P; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(17, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(18, 13),
                // (21,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(21, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(22, 13),
                // (29,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(29, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(32, 13),
                // (33,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(33, 13));
        }

        [Fact]
        public void ModifyMembers_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal object? F;
}
struct B
{
    internal A A;
    internal object? G;
}
class Program
{
    static void F()
    {
        object o;
        B b = new B();
        b.G = new object();
        b.A.F = new object();
        o = b.G; // 1
        o = b.A.F; // 1
        b.A = default(A);
        o = b.G; // 2
        o = b.A.F; // 2
        b = default(B);
        o = b.G; // 3
        o = b.A.F; // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.A.F; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.A.F").WithLocation(23, 13),
                // (25,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.G; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.G").WithLocation(25, 13),
                // (26,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.A.F; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.A.F").WithLocation(26, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void ModifyMembers_StructPropertyExplicitAccessors()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    private object? _p;
    internal object? P { get { return _p; } set { _p = value; } }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(13, 13));
        }

        [Fact]
        public void ModifyMembers_StructProperty()
        {
            var source =
@"#pragma warning disable 0649
public struct S
{
    public object? P { get; set; }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(12, 13));
        }

        [Fact]
        public void ModifyMembers_StructPropertyFromMetadata()
        {
            var source0 =
@"public struct S
{
    public object? P { get; set; }
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0649
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(8, 13));
        }

        [Fact]
        public void ModifyMembers_ClassPropertyNoBackingField()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? P { get { return null; } set { } }
    void M()
    {
        object o;
        o = P; // 1
        P = new object();
        o = P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P").WithLocation(8, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void ModifyMembers_StructPropertyNoBackingField()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? P { get { return null; } set { } }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(12, 13));
        }

        // Calling a method should reset the state for members.
        [Fact]
        [WorkItem(29975, "https://github.com/dotnet/roslyn/issues/29975")]
        public void Members_CallMethod()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? P { get; set; }
}
class B
{
    internal A? Q { get; set; }
}
class Program
{
    static void M()
    {
        object o;
        B b = new B() { Q = new A() { P = new object() } };
        o = b.Q.P; // 1
        b.Q.P.ToString();
        o = b.Q.P; // 2
        b.Q.ToString();
        o = b.Q.P; // 3
        b = new B() { Q = new A() { P = new object() } };
        o = b.Q.P; // 4
        b.ToString();
        o = b.Q.P; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29975: Should report warnings.
            comp.VerifyDiagnostics(/*...*/);
        }

        [Fact]
        public void Members_ObjectInitializer()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? F1;
    internal object? F2;
}
class B
{
    internal A? G;
}
class Program
{
    static void F()
    {
        (new B() { G = new A() { F1 = new object() } }).G.F1.ToString();
        B b;
        b = new B() { G = new A() { F1 = new object() } };
        b.G.F1.ToString(); // 1
        b.G.F2.ToString(); // 1
        b = new B() { G = new A() { F2 = new object() } };
        b.G.F1.ToString(); // 2
        b.G.F2.ToString(); // 2
        b = new B() { G = new A() };
        b.G.F1.ToString(); // 3
        b.G.F2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal object? F1;
    internal object? F2;
}
struct B
{
    internal A G;
}
class Program
{
    static void F()
    {
        (new B() { G = new A() { F1 = new object() } }).G.F1.ToString();
        B b;
        b = new B() { G = new A() { F1 = new object() } };
        b.G.F1.ToString(); // 1
        b.G.F2.ToString(); // 1
        b = new B() { G = new A() { F2 = new object() } };
        b.G.F1.ToString(); // 2
        b.G.F2.ToString(); // 2
        b = new B() { G = new A() };
        b.G.F1.ToString(); // 3
        b.G.F2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Properties()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? P1 { get; set; }
    internal object? P2 { get; set; }
}
class B
{
    internal A? Q { get; set; }
}
class Program
{
    static void F()
    {
        (new B() { Q = new A() { P1 = new object() } }).Q.P1.ToString();
        B b;
        b = new B() { Q = new A() { P1 = new object() } };
        b.Q.P1.ToString(); // 1
        b.Q.P2.ToString(); // 1
        b = new B() { Q = new A() { P2 = new object() } };
        b.Q.P1.ToString(); // 2
        b.Q.P2.ToString(); // 2
        b = new B() { Q = new A() };
        b.Q.P1.ToString(); // 3
        b.Q.P2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Events()
        {
            var source =
@"delegate void D();
class C
{
    event D? E;
    static void F()
    {
        C c;
        c = new C() { };
        c.E.Invoke(); // warning
        c = new C() { E = F };
        c.E.Invoke();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.E.Invoke(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.E").WithLocation(9, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29977: Support assignment of derived type instances.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29977")]
        [WorkItem(29977, "https://github.com/dotnet/roslyn/issues/29977")]
        public void Members_ObjectInitializer_DerivedType()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal A? F;
}
class B : A
{
    internal object? G;
}
class Program
{
    static void Main()
    {
        A a;
        a = new B() { F = new A(), G = new object() };
        a.F.ToString(); // 1
        a = new A();
        a.F.ToString(); // 2
        a = new B() { F = new B() { F = new A() } };
        a.F.ToString(); // 3
        a.F.F.ToString(); // 3
        a = new B() { G = new object() };
        a.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(18, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(20, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(23, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29977: Support assignment of derived type instances.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29977")]
        [WorkItem(29977, "https://github.com/dotnet/roslyn/issues/29977")]
        public void Members_Assignment()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal A? F;
}
class B : A
{
    internal object? G;
}
class Program
{
    static void Main()
    {
        B b = new B();
        A a;
        a = b;
        a.F.ToString(); // 1
        b.F = new A();
        a = b;
        a.F.ToString(); // 2
        b = new B() { F = new B() { F = new A() } };
        a = b;
        a.F.ToString(); // 3
        a.F.F.ToString(); // 3
        b = new B() { G = new object() };
        a = b;
        a.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(17, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(27, 9));
        }

        [Fact]
        public void Members_FieldCycle_01()
        {
            var source =
@"class C
{
    C? F;
    void M()
    {
        F = this;
        F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F.F").WithLocation(7, 9));
        }

        [Fact]
        public void Members_FieldCycle_02()
        {
            var source =
@"class C
{
    C? F;
    void M()
    {
        F = new C() { F = this };
        F.F.ToString();
        F.F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F.F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F.F.F").WithLocation(8, 9));
        }

        [Fact]
        public void Members_FieldCycle_03()
        {
            var source =
@"class C
{
    C? F;
    static void M()
    {
        var x = new C();
        x.F = x;
        var y = new C() { F = x };
        y.F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F.F").WithLocation(9, 9));
        }

        [Fact]
        public void Members_FieldCycle_Struct()
        {
            var source =
@"struct S
{
    internal C F;
    internal C? G;
}
class C
{
    internal S S;
    static void Main()
    {
        var s = new S() { F = new C(), G = new C() };
        s.F.S = s;
        s.G.S = s;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // Valid struct since the property is not backed by a field.
        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void Members_PropertyCycle_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal S(object? f)
    {
        F = f;
    }
    internal object? F;
    internal S P
    {
        get { return new S(F); }
        set { F = value.F; }
    }
}
class C
{
    static void M(S s)
    {
        s.P.F.ToString(); // 1
        if (s.P.F == null) return;
        s.P.F.ToString(); // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         s.P.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s.P.F").WithLocation(19, 9));
        }

        [Fact]
        public void SelectAnonymousType()
        {
            var source =
@"using System.Collections.Generic;
using System.Linq;
class C
{
    int? E;
    static void F(IEnumerable<C> c)
    {
        const int F = 0;
        c.Select(o => new { E = o.E ?? F });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS0649: Field 'C.E' is never assigned to, and will always have its default value 
                //     int? E;
                Diagnostic(ErrorCode.WRN_UnassignedInternalField, "E").WithArguments("C.E", "").WithLocation(5, 10));
        }

        [Fact]
        public void Constraints_01()
        {
            var source =
@"interface I<T>
{
    T P { get; set; }
}
class A { }
class B
{
    static void F1<T>(T t1) where T : A
    {
        t1.ToString();
        t1 = default; // 1
    }
    static void F2<T>(T t2) where T : A?
    {
        t2.ToString(); // 2
        t2 = default; // 3
    }
    static void F3<T>(T t3) where T : I<T>
    {
        t3.P.ToString();
        t3 = default; // 6
    }
    static void F4<T>(T t4) where T : I<T>?
    {
        t4.P.ToString(); // 7 and 8
        t4.P = default; // 9
        t4 = default; // 10
    }
    static void F5<T>(T t5) where T : I<T?>
    {
        t5.P.ToString(); // 11 and 12
        t5.P = default; // 13 and 14
        t5 = default; // 15
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29978: Various differences from expected warnings.
            comp.VerifyDiagnostics(
                // (29,41): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F5<T>(T t5) where T : I<T?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(29, 41),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t1 = default; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(11, 14),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(15, 9),
                // (16,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t2 = default; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(16, 14),
                // (21,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t3 = default; // 6
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(21, 14),
                // (21,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t3 = default; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(21, 14),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t4.P.ToString(); // 7 and 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4").WithLocation(25, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t4.P.ToString(); // 7 and 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4.P").WithLocation(25, 9),
                // (26,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t4.P = default; // 9
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(26, 16),
                // (27,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t4 = default; // 10
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(27, 14),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         t5.P.ToString(); // 11 and 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t5.P").WithLocation(31, 9),
                // (32,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t5.P = default; // 13 and 14
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(32, 16),
                // (33,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t5 = default; // 15
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(33, 14),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t5 = default; // 15
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(33, 14)
            );
        }

        [Fact]
        public void Constraints_02()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class
    {
    }

    public static void F2<T2>(T2 t2) where T2 : class?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                Assert.Equal("void B.F2<T2>(T2 t2) where T2 : class", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.
                                                                                                WithMiscellaneousOptions(SymbolDisplayFormat.TestFormatWithConstraints.MiscellaneousOptions &
                                                                                                                            (~SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_03()
        {
            var source =
@"
class A<T1> where T1 : class
{
    public static void F1(T1? t1)
    {
    }
}
class B<T2> where T2 : class?
{
    public static void F2(T2 t2)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var a = (NamedTypeSymbol)m.GlobalNamespace.GetMember("A");
                Assert.Equal("A<T1> where T1 : class", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = a.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t1.GetAttributes());

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T2> where T2 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = b.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_04()
        {
            var source =
@"
#pragma warning disable CS8321

class B
{
    public static void Test()
    {
        void F1<T1>(T1? t1) where T1 : class
        {
        }

        void F2<T2>(T2 t2) where T2 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>().ToArray();
            Assert.Equal(2, localSyntaxes.Length);

            var f1 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[0]);
            Assert.Equal("void F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t1.GetAttributes());

            var f2 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[1]);
            Assert.Equal("void F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_05()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : class?
{
    public static void F2<T2>(T2 t2) where T2 : class?
    {
        void F3<T3>(T3 t3) where T3 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (4,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B<T1> where T1 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 29),
                // (6,54): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static void F2<T2>(T2 t2) where T2 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 54),
                // (8,44): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void F3<T3>(T3 t3) where T3 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 44)
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T1> where T1 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = b.TypeParameters[0];
                Assert.True(t1.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t1.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t1.GetAttributes().Single().ToString());
                }

                var f2 = (MethodSymbol)b.GetMember("F2");
                Assert.Equal("void B<T1>.F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }

            comp = CreateCompilation(source, parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            var expected = new[] {
                // (4,29): error CS8370: Feature 'nullable reference types' is not available in C# 7.3. Please use language version 8.0 or greater.
                // class B<T1> where T1 : class?
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "?").WithArguments("nullable reference types", "8.0").WithLocation(4, 29),
                // (6,54): error CS8370: Feature 'nullable reference types' is not available in C# 7.3. Please use language version 8.0 or greater.
                //     public static void F2<T2>(T2 t2) where T2 : class?
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "?").WithArguments("nullable reference types", "8.0").WithLocation(6, 54),
                // (8,44): error CS8370: Feature 'nullable reference types' is not available in C# 7.3. Please use language version 8.0 or greater.
                //         void F3<T3>(T3 t3) where T3 : class?
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "?").WithArguments("nullable reference types", "8.0").WithLocation(8, 44)
            };
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected
                .Concat(new[] {
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.3", "8.0").WithLocation(1, 1)
                }).ToArray()
                );
        }

        [Fact]
        public void Constraints_06()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : class?
{
    public static void F1(T1? t1)
    {}

    public static void F2<T2>(T2? t2) where T2 : class?
    {
        void F3<T3>(T3? t3) where T3 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : class?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(9, 31),
                // (6,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1(T1? t1)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(6, 27),
                // (11,21): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F3<T3>(T3? t3) where T3 : class?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(11, 21)
            );
        }

        [Fact]
        public void Constraints_07()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>(T12? t1) where T11 : class where T12 : T11
    {}

    public static void F2<T21, T22>(T22? t1) where T21 : class where T22 : class, T21
    {}

    public static void F3<T31, T32>(T32? t1) where T31 : B where T32 : T31
    {}

    public static void F4<T41, T42>(T42? t1) where T41 : B where T42 : T41?
    {}
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T11, T12>(T12? t1) where T11 : class where T12 : T11
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T12?").WithLocation(4, 37),
                // (13,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>(T42? t1) where T41 : B where T42 : T41?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T42?").WithLocation(13, 37)
            );
        }

        [Fact]
        public void Constraints_08()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T11, T12> where T12 : T11?
{
    public static void F2<T21, T22>() where T22 : T21?
    {
        void F3<T31, T32>() where T32 : T31?
        {
        }
    }

    public static void F4<T4>() where T4 : T4?
    {}
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T11, T12> where T12 : T11?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T11?").WithLocation(4, 31),
                // (6,51): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T21, T22>() where T22 : T21?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T21?").WithLocation(6, 51),
                // (8,41): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F3<T31, T32>() where T32 : T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T31?").WithLocation(8, 41),
                // (13,27): error CS0454: Circular constraint dependency involving 'T4' and 'T4'
                //     public static void F4<T4>() where T4 : T4?
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T4").WithArguments("T4", "T4").WithLocation(13, 27),
                // (13,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T4>() where T4 : T4?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(13, 44)
            );
        }

        [Fact]
        public void Constraints_09()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : Node<T1>?
    {}

    public static void F2<T2>() where T2 : Node<T2?>
    {}

    public static void F3<T3>() where T3 : Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,49): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : Node<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 49)
            );
        }

        [Fact]
        public void Constraints_10()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class, Node<T1>?
    {}

    public static void F2<T2>() where T2 : class, Node<T2?>
    {}

    public static void F3<T3>() where T3 : class, Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,51): error CS0450: 'Node<T2?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>() where T2 : class, Node<T2?>
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T2?>").WithArguments("Node<T2?>").WithLocation(7, 51),
                // (10,51): error CS0450: 'Node<T3?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F3<T3>() where T3 : class, Node<T3?>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T3?>?").WithArguments("Node<T3?>").WithLocation(10, 51),
                // (4,51): error CS0450: 'Node<T1>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>() where T1 : class, Node<T1>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T1>?").WithArguments("Node<T1>").WithLocation(4, 51)
            );
        }

        [Fact]
        public void Constraints_11()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class?, Node<T1>?
    {}

    public static void F2<T2>() where T2 : class?, Node<T2?>
    {}

    public static void F3<T3>() where T3 : class?, Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,52): error CS0450: 'Node<T2?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>() where T2 : class?, Node<T2?>
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T2?>").WithArguments("Node<T2?>").WithLocation(7, 52),
                // (7,57): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>() where T2 : class?, Node<T2?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 57),
                // (10,52): error CS0450: 'Node<T3?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F3<T3>() where T3 : class?, Node<T3?>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T3?>?").WithArguments("Node<T3?>").WithLocation(10, 52),
                // (10,57): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : class?, Node<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 57),
                // (4,52): error CS0450: 'Node<T1>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>() where T1 : class?, Node<T1>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T1>?").WithArguments("Node<T1>").WithLocation(4, 52)
            );
        }

        [Fact]
        public void Constraints_12()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : INode<T1>?
    {}

    public static void F2<T2>() where T2 : INode<T2?>
    {}

    public static void F3<T3>() where T3 : INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>() where T2 : INode<T2?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 50),
                // (10,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : INode<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 50)
            );
        }

        [Fact]
        public void Constraints_13()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class, INode<T1>?
    {}

    public static void F2<T2>() where T2 : class, INode<T2?>
    {}

    public static void F3<T3>() where T3 : class, INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );
        }

        [Fact]
        public void Constraints_14()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class?, INode<T1>?
    {}

    public static void F2<T2>() where T2 : class?, INode<T2?>
    {}

    public static void F3<T3>() where T3 : class?, INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,58): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : class?, INode<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 58)
            );
        }

        [Fact]
        public void Constraints_15()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>() where T11 : INode where T12 : class?, T11, INode<T12?>
    {}

    public static void F2<T21, T22>() where T21 : INode? where T22 : class?, T21, INode<T22?>
    {}

    public static void F3<T31, T32>() where T31 : INode? where T32 : class?, T31, INode<T32?>?
    {}

    public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
    {}
}

interface INode
{}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,89): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>() where T31 : INode? where T32 : class?, T31, INode<T32?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T32?").WithLocation(10, 89),
                // (13,78): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(13, 78),
                // (13,90): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T42?").WithLocation(13, 90)
            );
        }

        [Fact]
        public void Constraints_16()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>(T12? t1) where T11 : INode where T12 : class?, T11
    {}

    public static void F2<T21, T22>(T22? t2) where T21 : INode? where T22 : class?, T21
    {}

    public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
    {}
}

interface INode
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T21, T22>(T22? t2) where T21 : INode? where T22 : class?, T21
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T22?").WithLocation(7, 37),
                // (10,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T32?").WithLocation(10, 37),
                // (10,84): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T31?").WithLocation(10, 84)
            );
        }

        [Fact]
        public void Constraints_17()
        {
            var source =
@"
#pragma warning disable CS8321

class B<[System.Runtime.CompilerServices.Nullable] T1>
{
    public static void F2<[System.Runtime.CompilerServices.Nullable] T2>(T2 t2)
    {
        void F3<[System.Runtime.CompilerServices.Nullable] T3>(T3 t3)
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source, NullableAttributeDefinition });
            comp.VerifyDiagnostics(
                // (4,10): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                // class B<[System.Runtime.CompilerServices.Nullable] T1>
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable").WithLocation(4, 10),
                // (6,28): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     public static void F2<[System.Runtime.CompilerServices.Nullable] T2>(T2 t2)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable").WithLocation(6, 28),
                // (8,17): error CS8205: Attributes are not allowed on local function parameters or type parameters
                //         void F3<[System.Runtime.CompilerServices.Nullable] T3>(T3 t3)
                Diagnostic(ErrorCode.ERR_AttributesInLocalFuncDecl, "[System.Runtime.CompilerServices.Nullable]").WithLocation(8, 17),
                // (8,18): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //         void F3<[System.Runtime.CompilerServices.Nullable] T3>(T3 t3)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable").WithLocation(8, 18)
            );
        }

        [Fact]
        public void Constraints_18()
        {
            var source =
@"
class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}

class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var af1 = bf1.OverriddenMethod;
                Assert.Equal("void A<System.Int32>.F1<T1>(T1? t1) where T1 : class", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = af1.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t1.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }

                var af2 = bf2.OverriddenMethod;
                Assert.Equal("void A<System.Int32>.F2<T2>(T2 t2) where T2 : class?", af2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t2 = af2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_19()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", nullableAttribute.ToString());
                    Assert.Same(m, nullableAttribute.AttributeClass.ContainingModule);
                    Assert.Equal(Accessibility.Internal, nullableAttribute.AttributeClass.DeclaredAccessibility);
                }
            }
        }

        [Fact]
        public void Constraints_20()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(NullableAttributeDefinition);

            var source3 =
@"
class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";

            var comp3 = CreateCompilation(new[] { source3 }, options: WithNonNullTypesTrue(),
                                          references: new[] { comp1.EmitToImageReference(), comp2.EmitToImageReference() },
                                          parseOptions: TestOptions.Regular8);

            CompileAndVerify(comp3, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", nullableAttribute.ToString());
                    Assert.NotEqual(m, nullableAttribute.AttributeClass.ContainingModule);
                }
            }
        }

        [Fact]
        public void Constraints_21()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>() where T1 : class
    {
    }

    public virtual void F2<T2>() where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : A<int>
{
    public override void F1<T11>()
    {
    }

    public override void F2<T22>()
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, references: new[] { comp1.EmitToImageReference() });

            comp2.VerifyDiagnostics();

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];

                // https://github.com/dotnet/roslyn/issues/29979: It is probably wrong to have this difference between source symbol
                //                                    and emitted-then-imported symbol. What are the rules for inheriting constraints
                //                                    across different non-null contexts?
                if (isSource)
                {
                    Assert.False(t11.ReferenceTypeConstraintIsNullable);
                }
                else
                {
                    Assert.Null(t11.ReferenceTypeConstraintIsNullable);
                }

                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_22()
        {
            var source =
@"
class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}

class B : A<int>
{
    public override void F1<T11>(T11? t1) where T11 : class?
    {
    }

    public override void F2<T22>(T22 t2) where T22 : class
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,43): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void F1<T11>(T11? t1) where T11 : class?
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(15, 43),
                // (19,42): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void F2<T22>(T22 t2) where T22 : class
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(19, 42)
            );

            var bf1 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t11 = bf1.TypeParameters[0];
            Assert.False(t11.ReferenceTypeConstraintIsNullable);

            var af1 = bf1.OverriddenMethod;
            Assert.Equal("void A<System.Int32>.F1<T1>(T1? t1) where T1 : class", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = af1.TypeParameters[0];
            Assert.False(t1.ReferenceTypeConstraintIsNullable);

            var bf2 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            TypeParameterSymbol t22 = bf2.TypeParameters[0];
            Assert.True(t22.ReferenceTypeConstraintIsNullable);

            var af2 = bf2.OverriddenMethod;
            Assert.Equal("void A<System.Int32>.F2<T2>(T2 t2) where T2 : class?", af2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            TypeParameterSymbol t2 = af2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
        }

        [Fact]
        public void Constraints_23()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?;
    void F2<T2>() where T2 : class;
    void F3<T3>() where T3 : C1<C2>;
    void F4<T4>() where T4 : C1<C2>;
    void F5<T51, T52>() where T51 : class where T52 : C1<T51>;
    void F6<T61, T62>() where T61 : class where T62 : C1<T61?>;
}

public class C1<T>
{}

public class C2
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class
    {
    }

    public void F2<T22>() where T22 : class?
    {
    }

    public void F3<T33>() where T33 : C1<C2?>
    {
    }

    public void F4<T44>() where T44 : C1<C2>?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
    {
    }
}

class D : IA
{
    public void F1<T111>() where T111 : class?
    {
    }

    public void F2<T222>() where T222 : class
    {
    }

    public void F3<T333>() where T333 : C1<C2>
    {
    }

    public void F4<T444>() where T444 : C1<C2>
    {
    }

    public void F5<T5551, T5552>() where T5551 : class where T5552 : C1<T5551>
    {
    }

    public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA.F5<T51, T52>()").WithLocation(20, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA.F6<T61, T62>()").WithLocation(24, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                Assert.Equal("void B.F3<T33>() where T33 : C1<C2?>", bf3.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                Assert.Equal("void B.F4<T44>() where T44 : C1<C2>?", bf4.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA.F5<T51, T52>()").WithLocation(20, 17),
                // (20,69): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T551?").WithLocation(20, 69),
                // (51,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T6661?").WithLocation(51, 73)
            );

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA.F6<T61, T62>()").WithLocation(24, 17)
                );
        }

        [Fact]
        public void Constraints_24()
        {
            var source =
@"
interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}

class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp = CreateCompilation(new[] { source },
                                         options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)));
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_25()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp2 = CreateCompilation(new[] { source2 },
                                          options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)),
                                          references: new[] { comp1.EmitToImageReference() });

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", nullableAttribute.ToString());
                    Assert.Same(m, nullableAttribute.AttributeClass.ContainingModule);
                    Assert.Equal(Accessibility.Internal, nullableAttribute.AttributeClass.DeclaredAccessibility);
                }
            }
        }

        [Fact]
        public void Constraints_26()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(NullableAttributeDefinition);

            var source3 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp3 = CreateCompilation(new[] { source3 },
                                          options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)),
                                          references: new[] { comp1.EmitToImageReference(), comp2.EmitToImageReference() });
            comp3.VerifyDiagnostics(
            );

            CompileAndVerify(comp3, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", nullableAttribute.ToString());
                    Assert.NotEqual(m, nullableAttribute.AttributeClass.ContainingModule);
                }
            }
        }

        [Fact]
        public void Constraints_27()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, references: new[] { comp1.EmitToImageReference() });

            comp2.VerifyDiagnostics();

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];

                // https://github.com/dotnet/roslyn/issues/29979: It is probably wrong to have this difference between source symbol
                //                                    and emitted-then-imported symbol. What are the rules for inheriting constraints
                //                                    across different non-null contexts?
                if (isSource)
                {
                    Assert.False(t11.ReferenceTypeConstraintIsNullable);
                }
                else
                {
                    Assert.Null(t11.ReferenceTypeConstraintIsNullable);
                }

                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_28()
        {
            var source =
@"
interface IA
{
    void F1<T1>(T1? t1) where T1 : class;
    void F2<T2>(T2 t2) where T2 : class?;
}

class B : IA
{
    void IA.F1<T11>(T11? t1) where T11 : class?
    {
    }

    void IA.F2<T22>(T22 t2) where T22 : class
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,30): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     void IA.F1<T11>(T11? t1) where T11 : class?
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(10, 30),
                // (14,29): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     void IA.F2<T22>(T22 t2) where T22 : class
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(14, 29)
            );

            var bf1 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.IA.F1");
            Assert.Equal("void B.IA.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t11 = bf1.TypeParameters[0];
            Assert.False(t11.ReferenceTypeConstraintIsNullable);

            var bf2 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.IA.F2");
            Assert.Equal("void B.IA.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t22 = bf2.TypeParameters[0];
            Assert.True(t22.ReferenceTypeConstraintIsNullable);
        }

        [Fact]
        public void Constraints_29()
        {
            var source =
@"
class B
{
    public static void F2<T2>() where T2 : class?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_30()
        {
            var source =
@"
class B<T2> where T2 : class?
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T2> where T2 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = b.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_31()
        {
            var source =
@"
#pragma warning disable CS8321

class B
{
    public static void Test()
    {
        void F2<T2>() where T2 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>().ToArray();
            Assert.Equal(1, localSyntaxes.Length);

            var f2 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[0]);
            Assert.Equal("void F2<T2>() where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_32()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : struct?
{
    public static void F2<T2>(T2 t2) where T2 : struct?
    {
        void F3<T3>(T3 t3) where T3 : struct?
        {
        }
    }
}";
            var comp = CreateCompilation(source);

            var expected = new[] {
                // (4,30): error CS1073: Unexpected token '?'
                // class B<T1> where T1 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(4, 30),
                // (6,55): error CS1073: Unexpected token '?'
                //     public static void F2<T2>(T2 t2) where T2 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(6, 55),
                // (8,45): error CS1073: Unexpected token '?'
                //         void F3<T3>(T3 t3) where T3 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(8, 45)
            };

            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(source, parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected
                .Concat(new[] { 
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.3", "8.0").WithLocation(1, 1),
                }).ToArray()
                );
        }

        [Fact]
        public void Constraints_33()
        {
            var source =
@"
interface IA<TA>
{ }

class C<TC> where TC : IA<object>, IA<object?>
{ }

class B<TB> where TB : IA<object?>, IA<object>
{ }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,36): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TC'
                // class C<TC> where TC : IA<object>, IA<object?>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object?>").WithArguments("IA<object>", "TC").WithLocation(5, 36),
                // (8,37): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TB'
                // class B<TB> where TB : IA<object?>, IA<object>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>").WithArguments("IA<object>", "TB").WithLocation(8, 37)
            );
        }

        [Fact]
        public void Constraints_34()
        {
            var source =
@"
interface IA<TA>
{ }

class B<TB> where TB : IA<object>?, IA<object>
{ }

class C<TC> where TC : IA<object>, IA<object>?
{ }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,37): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TB'
                // class B<TB> where TB : IA<object>?, IA<object>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>").WithArguments("IA<object>", "TB").WithLocation(5, 37),
                // (8,36): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TC'
                // class C<TC> where TC : IA<object>, IA<object>?
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>?").WithArguments("IA<object>", "TC").WithLocation(8, 36)
            );
        }

        [Fact]
        public void Constraints_35()
        {
            var source1 =
@"
public interface IA<S>
{
    void F1<T1>() where T1 : class?;
    void F2<T2>() where T2 : class;
    void F3<T3>() where T3 : C1<C2>;
    void F4<T4>() where T4 : C1<C2>;
    void F5<T51, T52>() where T51 : class where T52 : C1<T51>;
    void F6<T61, T62>() where T61 : class where T62 : C1<T61?>;
}

public class C1<T>
{}

public class C2
{}
";
            var source2 =
@"
class B : IA<string>
{
    public void F1<T11>() where T11 : class
    {
    }

    public void F2<T22>() where T22 : class?
    {
    }

    public void F3<T33>() where T33 : C1<C2?>
    {
    }

    public void F4<T44>() where T44 : C1<C2>?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
    {
    }
}

class D : IA<string>
{
    public void F1<T111>() where T111 : class?
    {
    }

    public void F2<T222>() where T222 : class
    {
    }

    public void F3<T333>() where T333 : C1<C2>
    {
    }

    public void F4<T444>() where T444 : C1<C2>
    {
    }

    public void F5<T5551, T5552>() where T5551 : class where T5552 : C1<T5551>
    {
    }

    public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA<string>.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA<string>.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA<string>.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA<string>.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA<string>.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA<string>.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA<string>.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA<string>.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA<string>.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA<string>.F5<T51, T52>()").WithLocation(20, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA<string>.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA<string>.F6<T61, T62>()").WithLocation(24, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                Assert.Empty(t11.GetAttributes());

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute", t22.GetAttributes().Single().ToString());
                }

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                Assert.Equal("void B.F3<T33>() where T33 : C1<C2?>", bf3.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                Assert.Equal("void B.F4<T44>() where T44 : C1<C2>?", bf4.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA<string>.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA<string>.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA<string>.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA<string>.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA<string>.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA<string>.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA<string>.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA<string>.F5<T51, T52>()").WithLocation(20, 17),
                // (20,69): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T551?").WithLocation(20, 69),
                // (51,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T6661?").WithLocation(51, 73)
            );

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA<string>.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA<string>.F1<T1>()").WithLocation(4, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA<string>.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA<string>.F6<T61, T62>()").WithLocation(24, 17)
                );
        }

        [Fact]
        public void Constraints_36()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB, IC?;
    void F2<T2>() where T2 : class, IB?, IC?;
    void F3<T3>() where T3 : class?, IB?, IC;
    void F4<T41, T42>() where T41 : class where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : class where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : class where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : class? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : class? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class, IB, IC 
    {
    }

    public void F2<T22>() where T22 : class, IB, IC
    {
    }

    public void F3<T33>() where T33 : class, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : class where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : class where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : class where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });

            var expected = new[]
            {
                // (36,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(36, 17),
                // (28,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(28, 17)
            };

            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp3.VerifyDiagnostics(expected);

            var comp4 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp1.ToMetadataReference() });
            comp4.VerifyDiagnostics();

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp1.EmitToImageReference() });
            comp5.VerifyDiagnostics();

            var comp6 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesFalse());
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (7,55): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F4<T41, T42>() where T41 : class where T42 : T41?, IB, IC?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(7, 55),
                // (9,55): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F6<T61, T62>() where T61 : class where T62 : T61?, IB?, IC;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T61?").WithLocation(9, 55)
                );

            var comp7 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp6.ToMetadataReference() });
            comp7.VerifyDiagnostics(expected);

            var comp9 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp6.ToMetadataReference() });
            comp9.VerifyDiagnostics();
        }

        [Fact]
        public void Constraints_37()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : class, IB, IC;
    void F2<T2>() where T2 : class, IB, IC;
    void F3<T3>() where T3 : class, IB, IC;
    void F4<T41, T42>() where T41 : class where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : class where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : class where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : class where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : class where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : class where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F1<T11>() where T11 : class?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : class, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : class?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : class? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (55,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(55, 17),
                // (47,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(47, 17)
            );
        }

        [Fact]
        public void Constraints_38()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : ID?, IB, IC?;
    void F2<T2>() where T2 : ID, IB?, IC?;
    void F3<T3>() where T3 : ID?, IB?, IC;
    void F4<T41, T42>() where T41 : ID where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : ID where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : ID where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : ID? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : ID where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : ID? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}

public interface ID
{}

class B : IA
{
    public void F1<T11>() where T11 : ID, IB, IC 
    {
    }

    public void F2<T22>() where T22 : ID, IB, IC
    {
    }

    public void F3<T33>() where T33 : ID, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : ID where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : ID where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : ID where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : ID where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : ID where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : ID where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (7,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F4<T41, T42>() where T41 : ID where T42 : T41?, IB, IC?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(7, 52),
                // (9,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F6<T61, T62>() where T61 : ID where T62 : T61?, IB?, IC;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T61?").WithLocation(9, 52),
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : ID where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : ID where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_39()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : ID, IB, IC;
    void F2<T2>() where T2 : ID, IB, IC;
    void F3<T3>() where T3 : ID, IB, IC;
    void F4<T41, T42>() where T41 : ID where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : ID where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : ID where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : ID where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : ID where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : ID where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

public interface ID
{}

class B : IA
{
    public void F1<T11>() where T11 : ID?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : ID, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : ID?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : ID where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : ID where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : ID where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : ID? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : ID where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : ID? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (38,63): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F4<T441, T442>() where T441 : ID where T442 : T441?, IB, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T441?").WithLocation(38, 63),
                // (46,63): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T661, T662>() where T661 : ID where T662 : T661?, IB?, IC
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T661?").WithLocation(46, 63),
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : ID? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : ID? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_40()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : D?, IB, IC?;
    void F2<T2>() where T2 : D, IB?, IC?;
    void F3<T3>() where T3 : D?, IB?, IC;
    void F4<T41, T42>() where T41 : D where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : D where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : D where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : D? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : D where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : D? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}

public class D
{}

class B : IA
{
    public void F1<T11>() where T11 : D, IB, IC 
    {
    }

    public void F2<T22>() where T22 : D, IB, IC
    {
    }

    public void F3<T33>() where T33 : D, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : D where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : D where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : D where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : D where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : D where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : D where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : D where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : D where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_41()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : D, IB, IC;
    void F2<T2>() where T2 : D, IB, IC;
    void F3<T3>() where T3 : D, IB, IC;
    void F4<T41, T42>() where T41 : D where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : D where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : D where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : D where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : D where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : D where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

public class D
{}

class B : IA
{
    public void F1<T11>() where T11 : D?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : D, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : D?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : D where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : D where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : D where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : D? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : D where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : D? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : D? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : D? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_42()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB?, IC?;
    void F2<T2>() where T2 : class?, IB?, IC?;
    void F3<T3>() where T3 : class?, IB?, IC?;
    void F4<T41, T42>() where T41 : class? where T42 : T41, IB?, IC?;
    void F5<T51, T52>() where T51 : class? where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : class? where T62 : T61, IB?, IC?;
    void F7<T71, T72>() where T71 : class where T72 : T71?, IB?, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81?, IB?, IC?;
    void F9<T91, T92>() where T91 : class where T92 : T91?, IB?, IC?;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F1<T11>() where T11 : class?, IB?, IC? 
    {
    }

    public void F2<T22>() where T22 : class?, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : class?, IB?, IC?
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441?, IB?, IC?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551?, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC?
    {
    }

    public void F7<T771, T772>() where T771 : class? where T772 : T771, IB?, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class? where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (55,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(55, 17),
                // (35,17): warning CS8633: Nullability in constraints for type parameter 'T441' of method 'B.F4<T441, T442>()' doesn't match the constraints for type parameter 'T41' of interface method 'IA.F4<T41, T42>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T441, T442>() where T441 : class where T442 : T441?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T441", "B.F4<T441, T442>()", "T41", "IA.F4<T41, T42>()").WithLocation(35, 17),
                // (39,17): warning CS8633: Nullability in constraints for type parameter 'T551' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T51' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : T551?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T551", "B.F5<T551, T552>()", "T51", "IA.F5<T51, T52>()").WithLocation(39, 17),
                // (43,17): warning CS8633: Nullability in constraints for type parameter 'T661' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T61' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T661", "B.F6<T661, T662>()", "T61", "IA.F6<T61, T62>()").WithLocation(43, 17),
                // (47,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(47, 17),
                // (51,17): warning CS8633: Nullability in constraints for type parameter 'T881' of method 'B.F8<T881, T882>()' doesn't match the constraints for type parameter 'T81' of interface method 'IA.F8<T81, T82>()'. Consider using an explicit interface implementation instead.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("T881", "B.F8<T881, T882>()", "T81", "IA.F8<T81, T82>()").WithLocation(51, 17)
            );
        }

        [Fact]
        public void Constraints_43()
        {
            var source =
@"
public interface IA
{
    void F7<T71, T72>() where T71 : class where T72 : T71?, IB?, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81?, IB?, IC?;
    void F9<T91, T92>() where T91 : class where T92 : T91?, IB?, IC?;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (25,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T991?").WithLocation(25, 67),
                // (21,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T881?").WithLocation(21, 67),
                // (17,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T771?").WithLocation(17, 67),
                // (25,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(25, 17),
                // (21,17): warning CS8633: Nullability in constraints for type parameter 'T881' of method 'B.F8<T881, T882>()' doesn't match the constraints for type parameter 'T81' of interface method 'IA.F8<T81, T82>()'. Consider using an explicit interface implementation instead.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("T881", "B.F8<T881, T882>()", "T81", "IA.F8<T81, T82>()").WithLocation(21, 17),
                // (17,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(17, 17)
            );
        }

        [Fact]
        public void Constraints_44()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB?;
    void F2<T2>() where T2 : class, IB?;
    void F3<T3>() where T3 : C1, IB?;
    void F4<T4>() where T4 : C1?, IB?;
}

public class C1
{}

public interface IB
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class, IB?
    {
    }

    public void F2<T22>() where T22 : class?, IB?
    {
    }

    public void F3<T33>() where T33 : C1?, IB?
    {
    }

    public void F4<T44>() where T44 : C1, IB?
    {
    }
}

class D : IA
{
    public void F1<T111>() where T111 : class?, IB?
    {
    }

    public void F2<T222>() where T222 : class, IB?
    {
    }

    public void F3<T333>() where T333 : C1, IB?
    {
    }

    public void F4<T444>() where T444 : C1?, IB?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator1, symbolValidator: symbolValidator1);
            void symbolValidator1(ModuleSymbol m)
            {
                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.True(t11.IsNotNullableIfReferenceType);

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.False(t22.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                TypeParameterSymbol t33 = bf3.TypeParameters[0];
                Assert.False(t33.IsNotNullableIfReferenceType);

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                TypeParameterSymbol t44 = bf4.TypeParameters[0];
                Assert.True(t44.IsNotNullableIfReferenceType);
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17)
            );

            symbolValidator2(comp3.SourceModule);

            void symbolValidator2(ModuleSymbol m)
            {
                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.Null(t11.IsNotNullableIfReferenceType);

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.False(t22.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                TypeParameterSymbol t33 = bf3.TypeParameters[0];
                Assert.False(t33.IsNotNullableIfReferenceType);

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                TypeParameterSymbol t44 = bf4.TypeParameters[0];
                Assert.Null(t44.IsNotNullableIfReferenceType);
            }

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17)
            );

            symbolValidator1(comp5.SourceModule);

            var comp6 = CreateCompilation(new[] { source2 }, references: new[] { comp4.ToMetadataReference() });
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
            );

            symbolValidator2(comp6.SourceModule);
        }

        [Fact]
        public void Constraints_45()
        {
            var source1 =
@"
public interface IA
{
    void F2<T2>() where T2 : class?, IB;
    void F3<T3>() where T3 : C1?, IB;
}

public class C1
{}

public interface IB
{}
";
            var source2 =
@"
class B : IA
{
    public void F2<T22>() where T22 : class?, IB?
    {
    }

    public void F3<T33>() where T33 : C1?, IB?
    {
    }
}

class D : IA
{
    public void F2<T222>() where T222 : class?, IB
    {
    }

    public void F3<T333>() where T333 : C1?, IB
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(8, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator1, symbolValidator: symbolValidator1);
            void symbolValidator1(ModuleSymbol m)
            {
                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F2");
                TypeParameterSymbol t222 = bf2.TypeParameters[0];
                Assert.True(t222.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F3");
                TypeParameterSymbol t333 = bf3.TypeParameters[0];
                Assert.True(t333.IsNotNullableIfReferenceType);
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(8, 17)
            );

            symbolValidator2(comp3.SourceModule);

            void symbolValidator2(ModuleSymbol m)
            {
                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F2");
                TypeParameterSymbol t222 = bf2.TypeParameters[0];
                Assert.Null(t222.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F3");
                TypeParameterSymbol t333 = bf3.TypeParameters[0];
                Assert.Null(t333.IsNotNullableIfReferenceType);
            }

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
            );

            symbolValidator1(comp5.SourceModule);

            var comp6 = CreateCompilation(new[] { source2 }, references: new[] { comp4.ToMetadataReference() });
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
            );

            symbolValidator2(comp6.SourceModule);
        }

        [Fact]
        public void Constraints_46()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.True(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.True(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_47()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.Null(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.Null(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_48()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object?
    {
    }

    public static void F2<T2>(T2? t2) where T2 : System.Object?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F1<T1>(T1? t1) where T1 : object?
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "object?").WithArguments("object?").WithLocation(4, 50),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : System.Object?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31),
                // (8,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F2<T2>(T2? t2) where T2 : System.Object?
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "System.Object?").WithArguments("object?").WithLocation(8, 50)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1)", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2)", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.False(t2.IsReferenceType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_49()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7_3);
            var expected = new[]
            {
                // (4,44): error CS8370: Feature 'object generic type constraint' is not available in C# 7.3. Please use language version 8.0 or greater.
                //     public static void F1<T1>() where T1 : object
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "object").WithArguments("object generic type constraint", "8.0").WithLocation(4, 44),
                // (8,44): error CS8370: Feature 'object generic type constraint' is not available in C# 7.3. Please use language version 8.0 or greater.
                //     public static void F2<T2>() where T2 : System.Object
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "System.Object").WithArguments("object generic type constraint", "8.0").WithLocation(8, 44)
            };

            comp.VerifyDiagnostics(expected);

            {
                var m = comp.SourceModule;

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.Null(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.Null(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);

            comp.VerifyDiagnostics(expected
            .Concat(new[] {
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.3", "8.0").WithLocation(1, 1),
            }).ToArray()
            );

            {
                var m = comp.SourceModule;

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.True(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.True(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_50()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : System.Object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31)
            );
        }

        [Fact]
        public void Constraints_51()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : struct, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : struct, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : struct, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 58),
                // (4,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : struct, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : struct", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsValueType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : struct", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsValueType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_52()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : class, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,57): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 57),
                // (8,57): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : class, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 57)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : class", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsReferenceType);
            Assert.True(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_53()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class?, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : class?, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            Assert.False(((MethodSymbol)comp.SourceModule.GlobalNamespace.GetMember("B.F1")).TypeParameters[0].IsNotNullableIfReferenceType);

            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : class?, object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class?, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 58),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : class?, System.Object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31),
                // (8,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : class?, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsReferenceType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_54()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class?, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : class?, B
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0450: 'B': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class?, B
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "B").WithArguments("B").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_55()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.False(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);
                Assert.Empty(at1.GetAttributes());

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x)", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x)", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.False(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                Assert.Empty(tf1.GetAttributes());
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x)", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_56()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : TI;
}

class A : I<A>
{
    void I<A>.F1<TF1A>(TF1A x)
    {}
}

class B : I<A?>
{
    void I<A?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<A>.F1");
                Assert.Equal("I<A>.F1", af1.Name);
                Assert.Equal("I<A>.F1", af1.MetadataName);
                Assert.Equal("void A.I<A>.F1<TF1A>(TF1A x) where TF1A : A", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);
                Assert.Empty(at1.GetAttributes());

                Assert.Equal("void I<A>.F1<TF1>(TF1 x) where TF1 : A", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<A>.F1");
                Assert.Equal("I<A>.F1", bf1.Name);
                Assert.Equal("I<A>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<A?>.F1<TF1B>(TF1B x) where TF1B : A?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<A>.F1<TF1B>(TF1B x) where TF1B : A?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                Assert.Empty(tf1.GetAttributes());
                if (isSource)
                {
                    Assert.Equal("void I<A?>.F1<TF1>(TF1 x) where TF1 : A?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<A>.F1<TF1>(TF1 x) where TF1 : A", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_57()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : class?, TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : class?, System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : class?, System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x) where TF1B : class?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x) where TF1B : class?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x) where TF1 : class?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : class?, System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_58()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : B, object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,53): error CS0406: The class type constraint 'object' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : B, object
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "object").WithArguments("object").WithLocation(4, 53)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_59()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : B?, object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : B?, object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,54): error CS0406: The class type constraint 'object' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : B?, object
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "object").WithArguments("object").WithLocation(4, 54)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_60()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object, B
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0406: The class type constraint 'B' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : object, B
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "B").WithArguments("B").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_61()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object?, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F1<T1>(T1? t1) where T1 : object?, B
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "object?").WithArguments("object?").WithLocation(4, 50)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_62()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : B?, TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : B?, System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : B?, System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x) where TF1 : B?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : B?, System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_63()
        {
            var source =
@"
interface I<TI1, TI2> 
{
    void F1<TF1>(TF1 x) where TF1 : TI1, TI2;
}

class A : I<object, B?>
{
    void I<object, B?>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?, B?>
{
    void I<object?, B?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object,B>.F1");
                Assert.Equal("I<System.Object,B>.F1", af1.Name);
                Assert.Equal("I<System.Object,B>.F1", af1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void A.I<System.Object, B?>.F1<TF1A>(TF1A x) where TF1A : System.Object, B?", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void A.I<System.Object, B>.F1<TF1A>(TF1A x) where TF1A : System.Object, B?", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                if (isSource)
                {
                    Assert.Equal("void I<System.Object, B?>.F1<TF1>(TF1 x) where TF1 : System.Object, B?", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object, B>.F1<TF1>(TF1 x) where TF1 : System.Object, B", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object,B>.F1");
                Assert.Equal("I<System.Object,B>.F1", bf1.Name);
                Assert.Equal("I<System.Object,B>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?, B?>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object, B>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?, B?>.F1<TF1>(TF1 x) where TF1 : B?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object, B>.F1<TF1>(TF1 x) where TF1 : System.Object, B", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_64()
        {
            var source =
@"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F5<TF5>() where TF5 : I3;
    void F6<TF6>() where TF6 : I3?;
    void F7<TF7>() where TF7 : object, I3;
    void F8<TF8>() where TF8 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
    void F10<TF10>() where TF10 : object, I3?;
    void F11<TF11>() where TF11 : object, I3?;
    void F12<TF12>() where TF12 : object, I3?;
    void F13<TF13>() where TF13 : object, I3?;
}

public interface I3
{
}

class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F5<TF5A>() where TF5A : object, I3?
    {}
    public void F6<TF6A>() where TF6A : object, I3?
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F8<TF8A>() where TF8A : I3?
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
    public void F10<TF10A>() where TF10A : I3
    {}
    public void F11<TF11A>() where TF11A : I3?
    {}
    public void F12<TF12A>() where TF12A : object, I3
    {}
    public void F13<TF13A>() where TF13A : object, I3?
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,17): warning CS8633: Nullability in constraints for type parameter 'TF1A' of method 'A.F1<TF1A>()' doesn't match the constraints for type parameter 'TF1' of interface method 'I1.F1<TF1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<TF1A>() where TF1A : object
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("TF1A", "A.F1<TF1A>()", "TF1", "I1.F1<TF1>()").WithLocation(25, 17),
                // (27,17): warning CS8633: Nullability in constraints for type parameter 'TF2A' of method 'A.F2<TF2A>()' doesn't match the constraints for type parameter 'TF2' of interface method 'I1.F2<TF2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<TF2A>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("TF2A", "A.F2<TF2A>()", "TF2", "I1.F2<TF2>()").WithLocation(27, 17),
                // (35,17): warning CS8633: Nullability in constraints for type parameter 'TF6A' of method 'A.F6<TF6A>()' doesn't match the constraints for type parameter 'TF6' of interface method 'I1.F6<TF6>()'. Consider using an explicit interface implementation instead.
                //     public void F6<TF6A>() where TF6A : object, I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("TF6A", "A.F6<TF6A>()", "TF6", "I1.F6<TF6>()").WithLocation(35, 17),
                // (39,17): warning CS8633: Nullability in constraints for type parameter 'TF8A' of method 'A.F8<TF8A>()' doesn't match the constraints for type parameter 'TF8' of interface method 'I1.F8<TF8>()'. Consider using an explicit interface implementation instead.
                //     public void F8<TF8A>() where TF8A : I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("TF8A", "A.F8<TF8A>()", "TF8", "I1.F8<TF8>()").WithLocation(39, 17),
                // (45,17): warning CS8633: Nullability in constraints for type parameter 'TF11A' of method 'A.F11<TF11A>()' doesn't match the constraints for type parameter 'TF11' of interface method 'I1.F11<TF11>()'. Consider using an explicit interface implementation instead.
                //     public void F11<TF11A>() where TF11A : I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F11").WithArguments("TF11A", "A.F11<TF11A>()", "TF11", "I1.F11<TF11>()").WithLocation(45, 17)
            );
        }

        [Fact]
        public void Constraints_65()
        {
            var source =
@"
" + NonNullTypesOff() + @"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F5<TF5>() where TF5 : I3;
    void F7<TF7>() where TF7 : object, I3;
    void F8<TF8>() where TF8 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
}
" + NonNullTypesOn() + @"
public interface I3
{
}
" + NonNullTypesOn() + @"
class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F5<TF5A>() where TF5A : object, I3?
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F8<TF8A>() where TF8A : I3?
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29980: unexpected warning
            comp.VerifyDiagnostics(
                // (21,17): warning CS8633: Nullability in constraints for type parameter 'TF1A' of method 'A.F1<TF1A>()' doesn't match the constraints for type parameter 'TF1' of interface method 'I1.F1<TF1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<TF1A>() where TF1A : object
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("TF1A", "A.F1<TF1A>()", "TF1", "I1.F1<TF1>()").WithLocation(21, 17)
                );
        }

        [Fact]
        public void Constraints_66()
        {
            var source =
@"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F7<TF7>() where TF7 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
    void F10<TF10>() where TF10 : object, I3?;
    void F12<TF12>() where TF12 : object, I3?;
}

public interface I3
{
}

" + NonNullTypesOff() + @"
class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
    public void F10<TF10A>() where TF10A : I3
    {}
    public void F12<TF12A>() where TF12A : object, I3
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29980: unexpected warning
            comp.VerifyDiagnostics(
                // (23,17): warning CS8633: Nullability in constraints for type parameter 'TF2A' of method 'A.F2<TF2A>()' doesn't match the constraints for type parameter 'TF2' of interface method 'I1.F2<TF2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<TF2A>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("TF2A", "A.F2<TF2A>()", "TF2", "I1.F2<TF2>()").WithLocation(23, 17)
                );
        }

        [Fact]
        public void Constraints_67()
        {
            var source =
@"
class A
{
    public void F1<TF1>(object x1, TF1 y1, TF1 z1 ) where TF1 : object
    {
        y1.ToString();
        x1 = z1;
    }

    public void F2<TF2>(object x2, TF2 y2, TF2 z2 ) where TF2 : class
    {
        y2.ToString();
        x2 = z2;
    }

    public void F3<TF3>(object x3, TF3 y3, TF3 z3 ) where TF3 : class?
    {
        y3.ToString();
        x3 = z3;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         y3.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3").WithLocation(18, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = z3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "z3").WithLocation(19, 14)
                );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Local()
        {
            var source =
@"
#pragma warning disable CS0168
class B
{
    public static void F1<T1>()
    {
        T1? x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp.VerifyDiagnostics(
                // (7,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T1? x;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(7, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_01()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}

public interface IB : IA<ID<string?>> // 1
{}

public interface IC : IA<ID<string>?> // 2
{}

public interface IE : IA<ID<string>>
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string?>> x1; // 3
        IA<ID<string>?> y1; // 4
        IA<ID<string>> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}

    public void Test2(ID<string?> a2, ID<string> b2, ID<string>? c2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1<ID<string?>>(a2); // 7
        M1<ID<string?>>(b2); // 8
        M1<ID<string>?>(b2); // 9
        M1<ID<string>>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (24,12): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         IA<ID<string?>> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "ID<string?>").WithArguments("IA<TA>", "ID<string>", "TA", "ID<string?>").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         IA<ID<string>?> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "ID<string>?").WithArguments("IA<TA>", "ID<string>", "TA", "ID<string>?").WithLocation(25, 12),
                // (34,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(34, 9),
                // (36,9): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string>?").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string?>>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string?>>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string?>>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string?>>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(38, 9),
                // (38,25): warning CS8620: Nullability of reference types in argument of type 'ID<string>' doesn't match target type 'ID<string?>' for parameter 'x' in 'void B.M1<ID<string?>>(ID<string?> x)'.
                //         M1<ID<string?>>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "b2").WithArguments("ID<string>", "ID<string?>", "x", "void B.M1<ID<string?>>(ID<string?> x)").WithLocation(38, 25),
                // (39,9): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string>?>(b2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string>?>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string>?").WithLocation(39, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_02()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB : IA<string?> // 1
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1; // 2
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<string?>(a2); // 4
        M1<string?>(b2); // 5
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8634: The type 'string?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         IA<string?> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("IA<TA>", "TA", "string?").WithLocation(18, 12),
                // (27,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(27, 9),
                // (29,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(29, 9),
                // (30,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(b2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_03()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>?
{
}

public interface IC : IA<ID<string>?> 
{}

public interface IE : IA<ID<string>> 
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string>?> y1;
        IA<ID<string>> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>?
    {}

    public void Test2(ID<string> b2, ID<string>? c2)
    {
        M1(b2); 
        M1(c2);
        M1<ID<string>?>(c2);
        M1<ID<string>>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_04()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2); 
        M1<string?>(a2);
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_05()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}

public interface IB<TIB> : IA<TIB> where TIB : ID<string?> // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : ID<string>? // 2
{}

public interface IE<TIE> : IA<TIE> where TIE : ID<string>
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3> where TB1 : ID<string?> where TB2 : ID<string>? where TB3 : ID<string>
{
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> y1; // 4
        IA<TB3> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}

    public void Test2(TB1 a2, TB3 b2, TB2 c2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(c2); // 8
        M1<TB3>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (24,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(25, 12),
                // (34,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(34, 9),
                // (36,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(38, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_06()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : C
{}

public class C
{}

class B<TB1, TB2> where TB1 : C? where TB2 : C
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (21,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(21, 12),
                // (30,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(30, 9),
                // (32,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(32, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_07()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>?
{
}

public interface IC<TIC> : IA<TIC> where TIC : ID<string>?
{}

public interface IE<TIE> : IA<TIE> where TIE : ID<string>
{}

public interface ID<T>
{}

class B<TB2, TB3> where TB2 : ID<string>? where TB3 : ID<string>
{
    public void Test1()
    {
        IA<TB2> y1;
        IA<TB3> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>?
    {}

    public void Test2(TB3 b2, TB2 c2)
    {
        M1(b2); 
        M1(c2);
        M1<TB2>(c2);
        M1<TB3>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_08()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB<TIB> : IA<TIB> where TIB : C?
{}

public interface IC<TIC> : IA<TIC> where TIC : C
{}

public class C
{}

class B<TB1, TB2> where TB1 : C? where TB2 : C
{
    public void Test1()
    {
        IA<TB1> x1;
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2);
        M1(b2); 
        M1<TB1>(a2);
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_09()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : ID<string>
{
}
" + NonNullTypesOn() + @"
public interface IC : IA<ID<string>?> 
{}

public interface IE : IA<ID<string>> 
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string>?> y1;
        IA<ID<string>> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}
" + NonNullTypesOn() + @"
    public void Test2(ID<string> b2, ID<string>? c2)
    {
        M1(b2); 
        M1(c2);
        M1<ID<string>?>(c2);
        M1<ID<string>>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_10()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : class
{
}
" + NonNullTypesOn() + @"
public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2); 
        M1<string?>(a2);
        M1<string?>(b2);
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_11()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : ID<string?> // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : ID<string>? // 2
{}
" + NonNullTypesOff() + @"
public interface IE<TIE> : IA<TIE> where TIE : ID<string> // 3
{}
" + NonNullTypesOn() + @"
public interface ID<T>
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2, TB3> where TB1 : ID<string?> where TB2 : ID<string>? where TB3 : ID<string> {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 4
        IA<TB2> y1; // 5
        IA<TB3> z1; // 6
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2)
    {
        M1(a2); // 7
        M1(b2); // 8
        M1(c2); // 9
        M1<TB1>(a2); // 10
        M1<TB2>(c2); // 11
        M1<TB3>(b2); // 12
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (24,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(25, 12),
                // (26,12): warning CS8631: The type 'TB3' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         IA<TB3> z1; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB3").WithArguments("IA<TA>", "ID<string>", "TA", "TB3").WithLocation(26, 12),
                // (34,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(34, 9),
                // (35,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(35, 9),
                // (36,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(38, 9),
                // (39,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1<TB3>(b2); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB3>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(39, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_12()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : C // 2
{}
" + NonNullTypesOn() + @"
public class C
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : C? where TB2 : C {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (21,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(21, 12),
                // (22,12): warning CS8634: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB2").WithArguments("IA<TA>", "TA", "TB2").WithLocation(22, 12),
                // (30,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(30, 9),
                // (31,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(31, 9),
                // (32,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(32, 9),
                // (33,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(33, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_13()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB<TIB> : IA<TIB> where TIB : class? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : class
{}

class B<TB1, TB2> where TB1 : class? where TB2 : class
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(18, 12),
                // (27,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(27, 9),
                // (29,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(29, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_14()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB<TIB> : IA<TIB> where TIB : class?
{}

public interface IC<TIC> : IA<TIC> where TIC : class
{}

class B<TB1, TB2> where TB1 : class? where TB2 : class
{
    public void Test1()
    {
        IA<TB1> x1;
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2);
        M1(b2); 
        M1<TB1>(a2);
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_15()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : class? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : class // 2
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : class? where TB2 : class {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6 
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (18,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(18, 12),
                // (19,12): warning CS8634: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB2").WithArguments("IA<TA>", "TA", "TB2").WithLocation(19, 12),
                // (27,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(27, 9),
                // (28,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1(b2); // 6 
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(28, 9),
                // (29,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(29, 9),
                // (30,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_16()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}

public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF? // 2
{}

public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF?
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3, TB4> 
    where TB1 : IE?, ID<string?>, IF? 
    where TB2 : IE?, ID<string>?, IF? 
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> y1; // 4
        IA<TB3> z1;
        IA<TB4> u1;
    }

    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}

    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1(d2);
        M1<TB1>(a2); // 7
        M1<TB2>(c2); // 8
        M1<TB3>(b2);
        M1<TB4>(d2);
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (28,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(28, 12),
                // (29,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(29, 12),
                // (39,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(39, 9),
                // (41,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(41, 9),
                // (43,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(43, 9),
                // (44,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(44, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_17()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}
" + NonNullTypesOn() + @"
public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF?
{}

public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF?
{}

public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF?
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3, TB4> 
    where TB1 : IE?, ID<string?>, IF? 
    where TB2 : IE?, ID<string>?, IF? 
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
    public void Test1()
    {
        IA<TB1> x1; 
        IA<TB2> y1;
        IA<TB3> z1;
        IA<TB4> u1;
    }

" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2); 
        M1(b2); 
        M1(c2);
        M1(d2);
        M1<TB1>(a2); 
        M1<TB2>(c2);
        M1<TB3>(b2);
        M1<TB4>(d2);
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify();
        }

        [Fact]
        public void ConstraintsChecks_18()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}

" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF? // 1
{}

" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF? // 2
{}

" + NonNullTypesOff() + @"
public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF? // 3
{}
" + NonNullTypesOn() + @"
public interface ID<T>
{}

" + NonNullTypesOff() + @"
class B<TB1, TB2, TB3, TB4> 
    where TB1 : IE?, ID<string?>, IF? 
    where TB2 : IE?, ID<string>?, IF? 
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 4
        IA<TB2> y1; // 5
        IA<TB3> z1; // 6
        IA<TB4> u1; // 7
    }

" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}

" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2); // 8
        M1(b2); // 9
        M1(c2); // 10
        M1(d2); // 11
        M1<TB1>(a2); // 12
        M1<TB2>(c2); // 13
        M1<TB3>(b2); // 14
        M1<TB4>(d2); // 15
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (33,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(33, 12),
                // (34,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(34, 12),
                // (35,12): warning CS8631: The type 'TB3' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         IA<TB3> z1; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB3").WithArguments("IA<TA>", "ID<string>", "TA", "TB3").WithLocation(35, 12),
                // (36,12): warning CS8631: The type 'TB4' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         IA<TB4> u1; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB4").WithArguments("IA<TA>", "ID<string>", "TA", "TB4").WithLocation(36, 12),
                // (46,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(46, 9),
                // (47,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1(b2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(47, 9),
                // (48,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(48, 9),
                // (49,9): warning CS8631: The type 'TB4' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         M1(d2); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB4").WithLocation(49, 9),
                // (50,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(50, 9),
                // (51,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 13
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(51, 9),
                // (52,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1<TB3>(b2); // 14
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB3>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(52, 9),
                // (53,9): warning CS8631: The type 'TB4' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         M1<TB4>(d2); // 15
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB4>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB4").WithLocation(53, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_19()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class, IB, IC
{
}

class B<TB1> where TB1 : class?, IB?, IC? 
{
    public void Test1()
    {
        IA<TB1> x1; // 1
    }

    public void M1<TM1>(TM1 x) where TM1: class, IB, IC
    {}

    public void Test2(TB1 a2)
    {
        M1(a2); // 2
        M1<TB1>(a2); // 3
    }
}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (12,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IB", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IC", "TA", "TB1").WithLocation(12, 12),
                // (20,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(20, 9),
                // (21,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(21, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_20()
        {
            var source =
@"
class B<TB1> where TB1 : class, IB? 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_21()
        {
            var source =
@"
class B<TB1> where TB1 : class?, IB 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_22()
        {
            var source =
@"
class B<TB1> where TB1 : class, IB? {
" + NonNullTypesOff() + @"
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_23()
        {
            var source =
@"
class B<TB1> where TB1 : A?, IB, IC? 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public class A
{}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_24()
        {
            var source =
@"
class B<TB1> where TB1 : A?, IB, IC? {
" + NonNullTypesOff() + @"
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public class A
{}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_25()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}

public interface IB : IA<string?> // 1
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1; // 2
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: object
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<string?>(a2); // 4
        M1<string?>(b2); // 5
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8631: The type 'string?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         IA<string?> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("IA<TA>", "object", "TA", "string?").WithLocation(18, 12),
                // (27,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(27, 9),
                // (29,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1<string?>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(29, 9),
                // (30,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1<string?>(b2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_26()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : object
{
}
" + NonNullTypesOn() + @"
public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2); 
        M1<string?>(a2);
        M1<string?>(b2);
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        [WorkItem(30214, "https://github.com/dotnet/roslyn/issues/30214")]
        public void ConstraintsChecks_27()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : C // 2
{}

public class C
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : C? where TB2 : C {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            // https://github.com/dotnet/roslyn/issues/30214 The following warning is unexpected:
            // (22,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
            //         IA<TB2> z1; // 4
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (21,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(21, 12),
                // (22,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "object", "TA", "TB2").WithLocation(22, 12),
                // (30,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(30, 9),
                // (31,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(31, 9),
                // (32,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(32, 9),
                // (33,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(33, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_28()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}

public interface IB<TIB> : IA<TIB> // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : object
{}

class B<TB1, TB2> where TB2 : object
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: object
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(18, 12),
                // (27,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(27, 9),
                // (29,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(29, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_29()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : object // 2
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB2 : object {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6 
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (18,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(18, 12),
                // (19,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "object", "TA", "TB2").WithLocation(19, 12),
                // (27,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(27, 9),
                // (28,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1(b2); // 6 
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(28, 9),
                // (29,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(29, 9),
                // (30,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_30()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object, IB, IC
{
}

class B<TB1> where TB1 : IB?, IC? 
{
    public void Test1()
    {
        IA<TB1> x1; // 1
    }

    public void M1<TM1>(TM1 x) where TM1: object, IB, IC
    {}

    public void Test2(TB1 a2)
    {
        M1(a2); // 2
        M1<TB1>(a2); // 3
    }
}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IB", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IC", "TA", "TB1").WithLocation(12, 12),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(20, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(21, 9)
            );
        }

        // https://github.com/dotnet/roslyn/issues/29981: Should report CS8600 for `T1 t = (T1)NullableObject();`
        // and `T3 t = (T3)NullableObject();`. (See VisitConversion which skips reporting because the
        // `object?` has an Unboxing conversion. Should report warning on unconverted operand
        // when Unboxing.)
        [Fact]
        [WorkItem(29981, "https://github.com/dotnet/roslyn/issues/29981")]
        public void UnconstrainedTypeParameter_MayBeNonNullable()
        {
            var source =
@"class C1<T1>
{
    static object? NullableObject() => null;
    static T1 F1() => default; // warn: return type T1 may be non-null
    static T1 F2() => default(T1); // warn: return type T1 may be non-null
    static void F4()
    {
        T1 t1 = (T1)NullableObject(); // warn: T1 may be non-null
    }
}
class C2<T2> where T2 : class
{
    static object? NullableObject() => null;
    static T2 F1() => default; // warn: return type T2 may be non-null
    static T2 F2() => default(T2); // warn: return type T2 may be non-null
    static void F4()
    {
        T2 t2 = (T2)NullableObject(); // warn: T2 may be non-null
    }
}
class C3<T3> where T3 : new()
{
    static object? NullableObject() => null;
    static T3 F1() => default; // warn: return type T3 may be non-null
    static T3 F2() => default(T3); // warn: return type T3 may be non-null
    static T3 F3() => new T3();
    static void F4()
    {
        T3 t = (T3)NullableObject(); // warn: T3 may be non-null
    }
}
class C4<T4> where T4 : I
{
    static object? NullableObject() => null;
    static T4 F1() => default; // warn: return type T4 may be non-null
    static T4 F2() => default(T4); // warn: return type T4 may be non-null
    static void F4()
    {
        T4 t4 = (T4)NullableObject(); // warn: T4 may be non-null
    }
}
class C5<T5> where T5 : A
{
    static object? NullableObject() => null;
    static T5 F1() => default; // warn: return type T5 may be non-null
    static T5 F2() => default(T5); // warn: return type T5 may be non-null
    static void F4()
    {
        T5 t5 = (T5)NullableObject(); // warn: T5 may be non-null
    }
}
interface I
{
}
class A
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29981: missing warnings
            comp.VerifyDiagnostics(
                // (45,23): warning CS8603: Possible null reference return.
                //     static T5 F1() => default; // warn: return type T5 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(45, 23),
                // (35,23): warning CS8603: Possible null reference return.
                //     static T4 F1() => default; // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(35, 23),
                // (35,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T4 F1() => default; // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(35, 23),
                // (24,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T3 F1() => default; // warn: return type T3 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(24, 23),
                // (14,23): warning CS8603: Possible null reference return.
                //     static T2 F1() => default; // warn: return type T2 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(14, 23),
                // (4,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T1 F1() => default; // warn: return type T1 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(4, 23),
                // (46,23): warning CS8603: Possible null reference return.
                //     static T5 F2() => default(T5); // warn: return type T5 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T5)").WithLocation(46, 23),
                // (25,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T3 F2() => default(T3); // warn: return type T3 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T3)").WithLocation(25, 23),
                // (36,23): warning CS8603: Possible null reference return.
                //     static T4 F2() => default(T4); // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T4)").WithLocation(36, 23),
                // (36,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T4 F2() => default(T4); // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T4)").WithLocation(36, 23),
                // (5,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static T1 F2() => default(T1); // warn: return type T1 may be non-null
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T1)").WithLocation(5, 23),
                // (15,23): warning CS8603: Possible null reference return.
                //     static T2 F2() => default(T2); // warn: return type T2 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T2)").WithLocation(15, 23),
                // (49,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T5 t5 = (T5)NullableObject(); // warn: T5 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T5)NullableObject()").WithLocation(49, 17),
                // (49,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T5 t5 = (T5)NullableObject(); // warn: T5 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T5)NullableObject()").WithLocation(49, 17),
                // (18,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T2 t2 = (T2)NullableObject(); // warn: T2 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T2)NullableObject()").WithLocation(18, 17),
                // (18,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T2 t2 = (T2)NullableObject(); // warn: T2 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T2)NullableObject()").WithLocation(18, 17)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_MayBeNullable_01()
        {
            var source =
@"class C
{
    static void F(object o)
    {
    }
    static void F1<T1>(T1 t1)
    {
        F(t1);
        F((object)t1);
        t1.ToString();
    }
    static void F2<T2>(T2 t2) where T2 : struct
    {
        F(t2);
        F((object)t2);
        t2.ToString();
    }
    static void F3<T3>(T3 t3) where T3 : class
    {
        F(t3);
        F((object)t3);
        t3.ToString();
    }
    static void F4<T4>(T4 t4) where T4 : new()
    {
        F(t4);
        F((object)t4);
        t4.ToString();
    }
    static void F5<T5>(T5 t5) where T5 : I
    {
        F(t5);
        F((object)t5);
        t5.ToString();
    }
    static void F6<T6>(T6 t6) where T6 : A
    {
        F(t6);
        F((object)t6);
        t6.ToString();
    }
}
interface I
{
}
class A
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F(t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t1").WithArguments("o", "void C.F(object o)").WithLocation(8, 11),
                // (9,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t1").WithLocation(9, 11),
                // (9,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t1").WithArguments("o", "void C.F(object o)").WithLocation(9, 11),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(10, 9),
                // (26,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F(t4);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t4").WithArguments("o", "void C.F(object o)").WithLocation(26, 11),
                // (27,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t4);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t4").WithLocation(27, 11),
                // (27,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t4);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t4").WithArguments("o", "void C.F(object o)").WithLocation(27, 11),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         t4.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4").WithLocation(28, 9)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_MayBeNullable_02()
        {
            var source =
@"class C
{
    static void F1<T1>(T1 x1)
    {
        object? y1;
        y1 = (object?)x1;
        y1 = (object)x1; // warn: T1 may be null
    }
    static void F2<T2>(T2 x2) where T2 : class
    {
        object? y2;
        y2 = (object?)x2;
        y2 = (object)x2;
    }
    static void F3<T3>(T3 x3) where T3 : new()
    {
        object? y3;
        y3 = (object?)x3;
        y3 = (object)x3; // warn unless new() constraint implies non-nullable
        y3 = (object)new T3();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y1 = (object)x1; // warn: T1 may be null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x1").WithLocation(7, 14),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = (object)x3; // warn unless new() constraint implies non-nullable
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x3").WithLocation(19, 14)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_01()
        {
            var source =
@"class C
{
    static object? F01<T>(T t) => t;
    static object? F02<T>(T t) where T : class => t;
    static object? F03<T>(T t) where T : struct => t;
    static object? F04<T>(T t) where T : new() => t;
    static object? F05<T, U>(U u) where U : T => u;
    static object? F06<T, U>(U u) where U : class, T => u;
    static object? F07<T, U>(U u) where U : struct, T => u;
    static object? F08<T, U>(U u) where U : T, new() => u;
    static object? F09<T>(T t) => (object?)t;
    static object? F10<T>(T t) where T : class => (object?)t;
    static object? F11<T>(T t) where T : struct => (object?)t;
    static object? F12<T>(T t) where T : new() => (object?)t;
    static object? F13<T, U>(U u) where U : T => (object?)u;
    static object? F14<T, U>(U u) where U : class, T => (object?)u;
    static object? F15<T, U>(U u) where U : struct, T => (object?)u;
    static object? F16<T, U>(U u) where U : T, new() => (object?)u;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_02()
        {
            var source =
@"class C
{
    static object F01<T>(T t) => t;
    static object F02<T>(T t) where T : class => t;
    static object F03<T>(T t) where T : struct => t;
    static object F04<T>(T t) where T : new() => t;
    static object F05<T, U>(U u) where U : T => u;
    static object F06<T, U>(U u) where U : class, T => u;
    static object F07<T, U>(U u) where U : struct, T => u;
    static object F08<T, U>(U u) where U : T, new() => u;
    static object F09<T>(T t) => (object)t;
    static object F10<T>(T t) where T : class => (object)t;
    static object F11<T>(T t) where T : struct => (object)t;
    static object F12<T>(T t) where T : new() => (object)t;
    static object F13<T, U>(U u) where U : T => (object)u;
    static object F14<T, U>(U u) where U : class, T => (object)u;
    static object F15<T, U>(U u) where U : struct, T => (object)u;
    static object F16<T, U>(U u) where U : T, new() => (object)u;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,34): warning CS8603: Possible null reference return.
                //     static object F01<T>(T t) => t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "t").WithLocation(3, 34),
                // (6,50): warning CS8603: Possible null reference return.
                //     static object F04<T>(T t) where T : new() => t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "t").WithLocation(6, 50),
                // (7,49): warning CS8603: Possible null reference return.
                //     static object F05<T, U>(U u) where U : T => u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u").WithLocation(7, 49),
                // (10,56): warning CS8603: Possible null reference return.
                //     static object F08<T, U>(U u) where U : T, new() => u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u").WithLocation(10, 56),
                // (11,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F09<T>(T t) => (object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(11, 34),
                // (11,34): warning CS8603: Possible null reference return.
                //     static object F09<T>(T t) => (object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)t").WithLocation(11, 34),
                // (14,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F12<T>(T t) where T : new() => (object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(14, 50),
                // (14,50): warning CS8603: Possible null reference return.
                //     static object F12<T>(T t) where T : new() => (object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)t").WithLocation(14, 50),
                // (15,49): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F13<T, U>(U u) where U : T => (object)u;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(15, 49),
                // (15,49): warning CS8603: Possible null reference return.
                //     static object F13<T, U>(U u) where U : T => (object)u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)u").WithLocation(15, 49),
                // (18,56): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F16<T, U>(U u) where U : T, new() => (object)u;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(18, 56),
                // (18,56): warning CS8603: Possible null reference return.
                //     static object F16<T, U>(U u) where U : T, new() => (object)u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)u").WithLocation(18, 56));
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_03()
        {
            var source =
@"class C
{
    static T F01<T>(T t) => t;
    static T F02<T>(T t) where T : class => t;
    static T F03<T>(T t) where T : struct => t;
    static T F04<T>(T t) where T : new() => t;
    static T F05<T, U>(U u) where U : T => u;
    static T F06<T, U>(U u) where U : class, T => u;
    static T F07<T, U>(U u) where U : struct, T => u;
    static T F08<T, U>(U u) where U : T, new() => u;
    static T F09<T>(T t) => (T)t;
    static T F10<T>(T t) where T : class => (T)t;
    static T F11<T>(T t) where T : struct => (T)t;
    static T F12<T>(T t) where T : new() => (T)t;
    static T F13<T, U>(U u) where U : T => (T)u;
    static T F14<T, U>(U u) where U : class, T => (T)u;
    static T F15<T, U>(U u) where U : struct, T => (T)u;
    static T F16<T, U>(U u) where U : T, new() => (T)u;
    static U F17<T, U>(T t) where U : T => (U)t;
    static U F18<T, U>(T t) where U : class, T => (U)t;
    static U F19<T, U>(T t) where U : struct, T => (U)t;
    static U F20<T, U>(T t) where U : T, new() => (U)t;
    static U F21<T, U>(T t) => (U)(object)t;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29981: There should be a warning for F17

            comp.VerifyDiagnostics(
                // (20,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F18<T, U>(T t) where U : class, T => (U)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)t").WithLocation(20, 51),
                // (20,51): warning CS8603: Possible null reference return.
                //     static U F18<T, U>(T t) where U : class, T => (U)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)t").WithLocation(20, 51),
                // (23,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F21<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(23, 35)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Uninitialized()
        {
            var source =
@"
class C
{
    static void F1<T>()
    {
        T t;
        t.ToString(); // 1
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS0165: Use of unassigned local variable 't'
                //         t.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolation, "t").WithArguments("t").WithLocation(7, 9)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_OutVariable()
        {
            var source =
@"
class C
{
    static void F1<T>(out T t) => t = default; // 1
    static void F2<T>(out T t) => t = default(T); // 2
    static void F3<T>(T t1, out T t2) => t2 = t1;
    static void F4<T, U>(U u, out T t) where U : T => t = u;
    static void F5<T, U>(U u, out T t) where T : U => t = (T)u; // 3
    static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
}
";

            // https://github.com/dotnet/roslyn/issues/29981: there should be a warning for F5
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1<T>(out T t) => t = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(4, 39),
                // (5,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F2<T>(out T t) => t = default(T); // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(5, 39),
                // (9,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(9, 50)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_PatternMatching()
        {
            var source =
@"
class C
{
    static void F1<T>(object o, T tin)
    {
        if (o is T t1)
        {
            t1.ToString();
        }
        else
        {
            t1 = default; // 1
        }

        t1.ToString(); // 2

        if (!(o is T t2))
        {
            t2 = tin;
        }
        else
        {
            t2.ToString();
        }
        t2.ToString(); // 3

        if (!(o is T t3)) return;
        t3.ToString();
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             t1 = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(12, 18),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(15, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(25, 9)
            );
        }

        [Fact]
        [WorkItem(29983, "https://github.com/dotnet/roslyn/issues/29983")]
        public void UnconstrainedTypeParameter_TypeInferenceThroughCall()
        {
            var source =
@"
class C
{
    static T Copy<T>(T t) => t;
    static void CopyOut<T>(T t1, out T t2) => t2 = t1;
    static void CopyOutInherit<T1, T2>(T1 t1, out T2 t2) where T1 : T2 => t2 = t1;
    static void M<U>(U u)
    {
        var x1 = Copy(u);
        x1.ToString(); // 1

        CopyOut(u, out var x2);
        x2.ToString(); // 2

        CopyOut(u, out U x3);
        x3.ToString(); // 3

        if (u == null) throw null;

        var x4 = Copy(u);
        x4.ToString();

        CopyOut(u, out var x5);
        x5.ToString();

        CopyOut(u, out U x6);
        x6.ToString();

        CopyOutInherit(u, out var x7);
        x7.ToString();
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29983: Should not report warning for `x6.ToString()`.
            comp.VerifyDiagnostics(
                // (29,9): error CS0411: The type arguments for method 'C.CopyOutInherit<T1, T2>(T1, out T2)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         CopyOutInherit(u, out var x7);
                Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "CopyOutInherit").WithArguments("C.CopyOutInherit<T1, T2>(T1, out T2)").WithLocation(29, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(13, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         x3.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(16, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         x6.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x6").WithLocation(27, 9));
        }

        [Fact]
        [WorkItem(29993, "https://github.com/dotnet/roslyn/issues/29993")]
        public void TypeParameter_Return_01()
        {
            var source =
@"
class C
{
    static U F1<T, U>(T t) => (U)(object)t; // 1 and 2
    static U F2<T, U>(T t) where U : class => (U)(object)t; // 3, 4 and 5
    static U F3<T, U>(T t) where U : struct => (U)(object)t; // 5
    static U F4<T, U>(T t) where T : class => (U)(object)t;
    static U F5<T, U>(T t) where T : struct => (U)(object)t;
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29993: Errors are different than expected.
            comp.VerifyDiagnostics(
                // (4,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F1<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(4, 34),
                // (5,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(5, 50),
                // (5,47): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)(object)t").WithLocation(5, 47),
                // (5,47): warning CS8603: Possible null reference return.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)(object)t").WithLocation(5, 47),
                // (6,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F3<T, U>(T t) where U : struct => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(6, 51)
            );
        }

        [Fact]
        public void TrackUnconstrainedTypeParameter_LocalsAndParameters()
        {
            var source =
@"class C
{
    static void F0<T>()
    {
        default(T).ToString(); // warn 1
        default(T)?.ToString();
    }
    static void F1<T>()
    {
        T x1 = default; // warn 2
        x1.ToString(); // warn 3
        x1!.ToString();
        x1?.ToString();
        if (x1 != null) x1.ToString();
    }
    static void F2<T>(T x2, T[] a2)
    {
        x2.ToString(); // warn 4
        x2!.ToString();
        x2?.ToString();
        if (x2 != null) x2.ToString();
        T y2 = x2;
        y2.ToString();
        a2[0].ToString(); // warn 5
    }
    static void F3<T>() where T : new()
    {
        T x3 = new T();
        x3.ToString();
        x3!.ToString();
        var a3 = new[] { new T() };
        a3[0].ToString();
    }
    static T F4<T>(T x4)
    {
        T y4 = x4;
        return y4;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         default(T).ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T)").WithLocation(5, 9),
                // (10,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         T x1 = default; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(10, 16),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(11, 9),
                // (13,9): hidden CS8607: Expression is probably never null.
                //         x1?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(13, 9),
                // (14,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x1 != null) x1.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x1 != null").WithLocation(14, 13),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(18, 9),
                // (20,9): hidden CS8607: Expression is probably never null.
                //         x2?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(20, 9),
                // (21,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x2 != null) x2.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x2 != null").WithLocation(21, 13),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         a2[0].ToString(); // warn 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2[0]").WithLocation(24, 9));
        }

        [Fact]
        public void TrackUnconstrainedTypeParameter_ExplicitCast()
        {
            var source =
@"class C
{
    static void F(object o)
    {
    }
    static void F1<T1>(T1 t1)
    {
        F((object)t1);
        if (t1 != null) F((object)t1);
    }
    static void F2<T2>(T2 t2) where T2 : class
    {
        F((object)t2);
        if (t2 != null) F((object)t2);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t1").WithLocation(8, 11),
                // (8,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t1").WithArguments("o", "void C.F(object o)").WithLocation(8, 11),
                // (14,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t2 != null) F((object)t2);
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t2 != null").WithLocation(14, 13));
        }

        [Fact]
        public void NullableT_BaseAndInterfaces()
        {
            var source =
@"interface IA<T> { }
interface IB<T> : IA<T?> { }
interface IC<T> { }
class A<T> { }
class B<T> : A<(T, T?)> { }
class C<T, U, V> : A<T?>, IA<U>, IC<V> { }
class D<T, U, V> : A<T>, IA<U?>, IC<V> { }
class E<T, U, V> : A<T>, IA<U>, IC<V?> { }
class P
{
    static void F1(IB<object> o) { }
    static void F2(B<object> o) { }
    static void F3(C<object, object, object> o) { }
    static void F4(D<object, object, object> o) { }
    static void F5(E<object, object, object> o) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // interface IB<T> : IA<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 22),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T> : A<(T, T?)> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 20),
                // (6,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<T, U, V> : A<T?>, IA<U>, IC<V> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 22),
                // (7,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class D<T, U, V> : A<T>, IA<U?>, IC<V> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(7, 29),
                // (8,36): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class E<T, U, V> : A<T>, IA<U>, IC<V?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(8, 36)
                );
        }

        [Fact]
        public void NullableT_Constraints()
        {
            var source =
@"interface I<T, U> where U : T? { }
class A<T> { }
class B
{
    static void F<T, U>() where U : A<T?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // interface I<T, U> where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(1, 29),
                // (5,39): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F<T, U>() where U : A<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 39)
                );
        }

        [Fact]
        [WorkItem(29995, "https://github.com/dotnet/roslyn/issues/29995")]
        public void NullableT_Members()
        {
            var source =
@"using System;
#pragma warning disable 0067
#pragma warning disable 0169
#pragma warning disable 8618
delegate T? D<T>();
class A<T>
{
}
class B<T>
{
    const object c = default(T?[]);
    T? F;
    B(T? t) { }
    static void M<U>(T? t, U? u) { }
    static B<T?> P { get; set; }
    event EventHandler<T?> E;
    public static explicit operator A<T?>(B<T> t) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29995: Report error for `const object c = default(T?[]);`.
            comp.VerifyDiagnostics(
                // (5,10): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // delegate T? D<T>();
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 10),
                // (11,30): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     const object c = default(T?[]);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 30),
                // (12,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 5),
                // (13,7): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     B(T? t) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(13, 7),
                // (14,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void M<U>(T? t, U? u) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(14, 22),
                // (14,28): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void M<U>(T? t, U? u) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(14, 28),
                // (15,14): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static B<T?> P { get; set; }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(15, 14),
                // (16,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     event EventHandler<T?> E;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(16, 24),
                // (17,39): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static explicit operator A<T?>(B<T> t) => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 39)
                );
        }

        [Fact]
        public void NullableT_ReturnType()
        {
            var source =
@"interface I { }
class A { }
class B
{
    static T? F1<T>() => throw null; // error
    static T? F2<T>() where T : class => throw null;
    static T? F3<T>() where T : struct => throw null;
    static T? F4<T>() where T : new() => throw null; // error
    static T? F5<T>() where T : unmanaged => throw null;
    static T? F6<T>() where T : I => throw null; // error
    static T? F7<T>() where T : A => throw null;
}
class C
{
    static U?[] F1<T, U>() where U : T => throw null; // error
    static U?[] F2<T, U>() where T : class where U : T => throw null;
    static U?[] F3<T, U>() where T : struct where U : T => throw null;
    static U?[] F4<T, U>() where T : new() where U : T => throw null; // error
    static U?[] F5<T, U>() where T : unmanaged where U : T => throw null;
    static U?[] F6<T, U>() where T : I where U : T => throw null; // error
    static U?[] F7<T, U>() where T : A where U : T => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F2<T, U>() where T : class where U : T => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(16, 12),
                // (18,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F4<T, U>() where T : new() where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(18, 12),
                // (20,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F6<T, U>() where T : I where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(20, 12),
                // (15,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F1<T, U>() where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(15, 12),
                // (17,23): error CS0456: Type parameter 'T' has the 'struct' constraint so 'T' cannot be used as a constraint for 'U'
                //     static U?[] F3<T, U>() where T : struct where U : T => throw null;
                Diagnostic(ErrorCode.ERR_ConWithValCon, "U").WithArguments("U", "T").WithLocation(17, 23),
                // (19,23): error CS8379: Type parameter 'T' has the 'unmanaged' constraint so 'T' cannot be used as a constraint for 'U'
                //     static U?[] F5<T, U>() where T : unmanaged where U : T => throw null;
                Diagnostic(ErrorCode.ERR_ConWithUnmanagedCon, "U").WithArguments("U", "T").WithLocation(19, 23),
                // (8,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F4<T>() where T : new() => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 12),
                // (10,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F6<T>() where T : I => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 12),
                // (5,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F1<T>() => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 12));
        }

        [Fact]
        public void NullableT_Parameters()
        {
            var source =
@"interface I { }
abstract class A
{
    internal abstract void F1<T>(T? t); // error
    internal abstract void F2<T>(T? t) where T : class;
    internal abstract void F3<T>(T? t) where T : struct;
    internal abstract void F4<T>(T? t) where T : new(); // error
    internal abstract void F5<T>(T? t) where T : unmanaged;
    internal abstract void F6<T>(T? t) where T : I; // error
    internal abstract void F7<T>(T? t) where T : A;
}
class B : A
{
    internal override void F1<U>(U? u) { } // error
    internal override void F2<U>(U? u) { }
    internal override void F3<U>(U? u) { }
    internal override void F4<U>(U? u) { } // error
    internal override void F5<U>(U? u) { }
    internal override void F6<U>(U? u) { } // error
    internal override void F7<U>(U? u) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F1<T>(T? t); // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 34),
                // (7,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F4<T>(T? t) where T : new(); // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 34),
                // (9,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F6<T>(T? t) where T : I; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 34),
                // (14,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F1<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(14, 34),
                // (17,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F4<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(17, 34),
                // (19,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F6<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(19, 34));
        }

        [Fact]
        public void NullableT_ContainingType()
        {
            var source =
@"class A<T>
{
    internal interface I { }
    internal enum E { }
}
class C
{
    static void F1<T>(A<T?>.I  i) { }
    static void F2<T>(A<T?>.E[] e) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F2<T>(A<T?>.E[] e) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 25),
                // (8,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F1<T>(A<T?>.I  i) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 25)
                );
        }

        [Fact]
        public void NullableT_MethodBody()
        {
            var source =
@"#pragma warning disable 0168
class C<T>
{
    static void M<U>()
    {
        T? t;
        var u = typeof(U?);
        object? o = default(T?);
        o = new U?[0];
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? t;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9),
                // (7,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         var u = typeof(U?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(7, 24),
                // (8,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         object? o = default(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 29),
                // (9,17): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         o = new U?[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(9, 17)
                );
        }

        [Fact]
        public void NullableT_Lambda()
        {
            var source =
@"delegate void D<T>(T t);
class C
{
    static void F<T>(D<T> d) { }
    static void G<T>()
    {
        F((T? t) => { });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         F((T? t) => { });
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 12));
        }

        [Fact]
        public void NullableT_LocalFunction()
        {
            var source =
@"#pragma warning disable 8321
class C
{
    static void F1<T>()
    {
        T? L1() => throw null;
    }
    static void F2()
    {
        void L2<T>(T?[] t) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? L1() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9),
                // (10,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void L2<T>(T?[] t) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 20));
        }

        [Fact]
        [WorkItem(29996, "https://github.com/dotnet/roslyn/issues/29996")]
        public void NullableT_FromMetadata_BaseAndInterfaces()
        {
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor(bool[] b) cil managed { ret }
}
.class interface public abstract IA`1<T>
{
}
.class interface public abstract IB`1<T>
    implements class IA`1<!T>
{
  .interfaceimpl type class IA`1<!T>
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = ( 01 00 02 00 00 00 00 01 00 00 ) 
}
.class public A`1<T>
{
}
.class public B`1<T>
    extends class A`1<!T>
{
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = ( 01 00 02 00 00 00 00 01 00 00 ) 
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class C
{
    static void F(IB<object> b) { }
    static void G(B<object> b) { }
}";
            var comp = CreateCompilation(source1, new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/29996: Report errors for T? in metadata?
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29996, "https://github.com/dotnet/roslyn/issues/29996")]
        public void NullableT_FromMetadata_Methods()
        {
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}
.class interface public abstract I
{
}
.class public A
{
}
.class public C
{
  .method public static !!T F1<T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F2<class T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F3<valuetype .ctor ([mscorlib]System.ValueType) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F4<.ctor T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F5<(I) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F6<(A) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class P
{
    static void Main()
    {
        C.F1<int>(); // error
        C.F1<object>();
        C.F2<object>();
        C.F3<int>();
        C.F4<object>(); // error
        C.F5<I>(); // error
        C.F6<A>();
    }
}";
            var comp = CreateCompilation(source1, new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/29996: Report errors for T? in metadata?
            comp.VerifyDiagnostics();
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_01()
        {
            var source =
@"class A { }
class B<T> where T : T? { }
class C<T> where T : class, T? { }
class D<T> where T : struct, T? { }
class E<T> where T : A, T? { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,30): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                // class D<T> where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(4, 30),
                // (2,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class B<T> where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(2, 9),
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T> where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 22),
                // (3,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class C<T> where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(3, 9),
                // (5,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class E<T> where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(5, 9));
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_02()
        {
            var source =
@"class A<T, U>
    where U : T?
{
}
class B<T, U>
    where T : class
    where U : T?
{
}
class C<T, U>
    where T : U?
    where U : T?
{
}
class D<T, U>
    where T : class, U?
    where U : class, T?
{
}
class E<T, U>
    where T : class, U
    where U : T?
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 15),
                // (11,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where T : U?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(11, 15),
                // (12,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 15),
                // (10,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class C<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(10, 9),
                // (15,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class D<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(15, 9),
                // (20,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class E<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(20, 9));
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_03()
        {
            var source =
@"class A<T> where T : T, T? { }
class B<U> where U : U?, U { }
class C<V> where V : V?, V? { }
delegate void D1<T1, U1>()
    where U1 : T1, T1?;
delegate void D2<T2, U2>()
    where U2 : class, T2?, T2;
delegate void D3<T3, U3>()
    where T3 : class
    where U3 : T3, T3?;";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,25): error CS0405: Duplicate constraint 'T' for type parameter 'T'
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "T").WithLocation(1, 25),
                // (1,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(1, 25),
                // (1,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(1, 9),
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(2, 22),
                // (2,26): error CS0405: Duplicate constraint 'U' for type parameter 'U'
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "U").WithArguments("U", "U").WithLocation(2, 26),
                // (2,9): error CS0454: Circular constraint dependency involving 'U' and 'U'
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "U").WithArguments("U", "U").WithLocation(2, 9),
                // (3,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(3, 22),
                // (3,26): error CS0405: Duplicate constraint 'V' for type parameter 'V'
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "V?").WithArguments("V", "V").WithLocation(3, 26),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(3, 26),
                // (3,9): error CS0454: Circular constraint dependency involving 'V' and 'V'
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "V").WithArguments("V", "V").WithLocation(3, 9),
                // (5,20): error CS0405: Duplicate constraint 'T1' for type parameter 'U1'
                //     where U1 : T1, T1?;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T1?").WithArguments("T1", "U1").WithLocation(5, 20),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U1 : T1, T1?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(5, 20),
                // (7,23): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U2 : class, T2?, T2;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 23),
                // (7,28): error CS0405: Duplicate constraint 'T2' for type parameter 'U2'
                //     where U2 : class, T2?, T2;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T2").WithArguments("T2", "U2").WithLocation(7, 28),
                // (10,20): error CS0405: Duplicate constraint 'T3' for type parameter 'U3'
                //     where U3 : T3, T3?;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T3?").WithArguments("T3", "U3").WithLocation(10, 20));
        }

        [Fact]
        public void NullableTInConstraint_04()
        {
            var source =
@"class A { }
class B
{
    static void F1<T>() where T : T? { }
    static void F2<T>() where T : class, T? { }
    static void F3<T>() where T : struct, T? { }
    static void F4<T>() where T : A, T? { }
    static void F5<T, U>() where U : T? { }
    static void F6<T, U>() where T : class where U : T? { }
    static void F7<T, U>() where T : struct where U : T? { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F2<T>() where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(5, 20),
                // (6,43): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //     static void F3<T>() where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(6, 43),
                // (7,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F4<T>() where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(7, 20),
                // (8,38): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F5<T, U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 38),
                // (10,55): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //     static void F7<T, U>() where T : struct where U : T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(10, 55),
                // (4,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 35),
                // (4,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(4, 20));
        }

        [Fact]
        public void NullableTInConstraint_05()
        {
            var source =
@"#pragma warning disable 8321
class A { }
class B
{
    static void M()
    {
        void F1<T>() where T : T? { }
        void F2<T>() where T : class, T? { }
        void F3<T>() where T : struct, T? { }
        void F4<T>() where T : A, T? { }
        void F5<T, U>() where U : T? { }
        void F6<T, U>() where T : class where U : T? { }
        void F7<T, U>() where T : struct where U : T? { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 32),
                // (7,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(7, 17),
                // (8,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F2<T>() where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(8, 17),
                // (9,40): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //         void F3<T>() where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(9, 40),
                // (10,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F4<T>() where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(10, 17),
                // (11,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F5<T, U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 35),
                // (13,52): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //         void F7<T, U>() where T : struct where U : T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(13, 52));
        }

        [Fact]
        public void NullableTInConstraint_06()
        {
            var source =
@"#pragma warning disable 8321
class A<T> where T : class
{
    static void F1<U>() where U : T?
    {
    }
    static void F2()
    {
        void F3<U>() where U : T? { }
    }
}
class B
{
    static void F4<T>() where T : class
    {
        void F5<U>() where U : T? { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableTInConstraint_07()
        {
            var source =
@"interface I<T, U>
    where T : class
    where U : T
{
}
class A<T, U>
    where T : class
    where U : T?
{
}
class B1<T> : A<T, T>, I<T, T>
    where T : class
{
}
class B2<T> : A<T, T?>, I<T, T?>
    where T : class
{
} 
class B3<T> : A<T?, T>, I<T?, T>
    where T : class
{
}
class B4<T> : A<T?, T?>, I<T?, T?>
    where T : class
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Should report warnings that `T?`
            // does not satisfy `where T : class` constraint or `where U : T` constraint.
            comp.VerifyDiagnostics();
        }

        // `class C<T> where T : class, T?` from metadata.
        [Fact]
        public void NullableTInConstraint_08()
        {
            // https://github.com/dotnet/roslyn/issues/29997: `where T : class, T?` is not valid in C#,
            // so the class needs to be defined in IL. How and where should the custom
            // attribute be declared for the constraint type in the following?
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}
.custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 ) 
.class public C<class (!T) T>
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class Program
{
    static void Main()
    {
        object o;
        o = new C<object?>(); // 1
        o = new C<object>(); // 2
    }
}";
            var comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,19): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         o = new C<object?>(); // 1
                Diagnostic(ErrorCode.ERR_CircularConstraint, "object?").WithArguments("T", "T").WithLocation(6, 19),
                // (7,19): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         o = new C<object>(); // 2
                Diagnostic(ErrorCode.ERR_CircularConstraint, "object").WithArguments("T", "T").WithLocation(7, 19));
        }

        // `class C<T, U> where U : T?` from metadata.
        [Fact]
        public void NullableTInConstraint_09()
        {
            var source0 =
@"public class C<T, U>
    where T : class
    where U : T?
{
}";
            var source1 =
@"class Program
{
    static void Main()
    {
        object o;
        o = new C<object?, object?>(); // 1
        o = new C<object?, object>(); // 2
        o = new C<object, object?>(); // 3
        o = new C<object, object>(); // 4
    }
}";

            var comp = CreateCompilation(source0);

            comp.VerifyDiagnostics(
                // (3,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(3, 15),
                // (3,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     where U : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 16)
                );

            MetadataReference ref0 = comp.ToMetadataReference();

            comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp.EmitToImageReference();

            comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());

            var c = comp.GetTypeByMetadataName("C`2");
            Assert.IsAssignableFrom<PENamedTypeSymbol>(c);
            Assert.Equal("C<T, U> where T : class where U : T?", c.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            comp.VerifyDiagnostics(
                // (6,19): warning CS8634: The type 'object?' cannot be used as type parameter 'T' in the generic type or method 'C<T, U>'. Nullability of type argument 'object?' doesn't match 'class' constraint.
                //         o = new C<object?, object?>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "object?").WithArguments("C<T, U>", "T", "object?").WithLocation(6, 19),
                // (7,19): warning CS8634: The type 'object?' cannot be used as type parameter 'T' in the generic type or method 'C<T, U>'. Nullability of type argument 'object?' doesn't match 'class' constraint.
                //         o = new C<object?, object>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "object?").WithArguments("C<T, U>", "T", "object?").WithLocation(7, 19)
                );
        }

        [WorkItem(26294, "https://github.com/dotnet/roslyn/issues/26294")]
        [Fact]
        public void NullableTInConstraint_10()
        {
            var source =
@"interface I<T> { }
class C
{
    static void F1<T>() where T : class, I<T?> { }
    static void F2<T>() where T : I<dynamic?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,35): error CS1968: Constraint cannot be a dynamic type 'I<dynamic>'
                //     static void F2<T>() where T : I<dynamic?> { }
                Diagnostic(ErrorCode.ERR_ConstructedDynamicTypeAsBound, "I<dynamic?>").WithArguments("I<dynamic?>").WithLocation(5, 35));
        }

        [Fact]
        public void DuplicateConstraints()
        {
            var source =
@"interface I<T> where T : class { }
class C<T> where T : class
{
    static void F1<U>() where U : T, T { }
    static void F2<U>() where U : T, T? { }
    static void F3<U>() where U : T?, T { }
    static void F4<U>() where U : T?, T? { }
    static void F5<U>() where U : I<T>, I<T> { }
    static void F6<U>() where U : I<T>, I<T?> { }
    static void F7<U>() where U : I<T?>, I<T> { }
    static void F8<U>() where U : I<T?>, I<T?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,38): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F1<U>() where U : T, T { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T").WithArguments("T", "U").WithLocation(4, 38),
                // (5,38): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F2<U>() where U : T, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "U").WithLocation(5, 38),
                // (6,39): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F3<U>() where U : T?, T { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T").WithArguments("T", "U").WithLocation(6, 39),
                // (7,39): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F4<U>() where U : T?, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "U").WithLocation(7, 39),
                // (8,41): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F5<U>() where U : I<T>, I<T> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T>").WithArguments("I<T>", "U").WithLocation(8, 41),
                // (9,41): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F6<U>() where U : I<T>, I<T?> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T?>").WithArguments("I<T>", "U").WithLocation(9, 41),
                // (10,42): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F7<U>() where U : I<T?>, I<T> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T>").WithArguments("I<T>", "U").WithLocation(10, 42),
                // (11,42): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F8<U>() where U : I<T?>, I<T?> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T?>").WithArguments("I<T>", "U").WithLocation(11, 42));
        }

        [Fact]
        public void PartialClassConstraints()
        {
            var source =
@"class A<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}
partial class B<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}
partial class B<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void PartialClassConstraintMismatch()
        {
            var source =
@"class A { }
partial class B<T> where T : A { }
partial class B<T> where T : A? { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,15): error CS0265: Partial declarations of 'B<T>' have inconsistent constraints for type parameter 'T'
                // partial class B<T> where T : A { }
                Diagnostic(ErrorCode.ERR_PartialWrongConstraints, "B").WithArguments("B<T>", "T").WithLocation(2, 15));
        }

        [Fact]
        public void TypeUnification_01()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> { }
class C2<T, U> : I<T>, I<U?> { }
class C3<T, U> : I<T?>, I<U> { }
class C4<T, U> : I<T?>, I<U?> { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (4,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C3<T, U> : I<T?>, I<U> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 20),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 20),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26)
                );
        }

        [Fact]
        public void TypeUnification_02()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : struct { }
class C2<T, U> : I<T>, I<U?> where T : struct { }
class C3<T, U> : I<T?>, I<U> where T : struct { }
class C4<T, U> : I<T?>, I<U?> where T : struct { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27)
                );
        }

        [Fact]
        public void TypeUnification_03()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : class { }
class C2<T, U> : I<T>, I<U?> where T : class { }
class C3<T, U> : I<T?>, I<U> where T : class { }
class C4<T, U> : I<T?>, I<U?> where T : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27)
                );
        }

        [Fact]
        public void TypeUnification_04()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : struct where U : class { }
class C2<T, U> : I<T>, I<U?> where T : struct where U : class { }
class C3<T, U> : I<T?>, I<U> where T : struct where U : class { }
class C4<T, U> : I<T?>, I<U?> where T : struct where U : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Constraints are ignored when unifying types.
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7));
        }

        [Fact]
        public void TypeUnification_05()
        {
            var source =
@"interface I<T> where T : class { }
class C1<T, U> : I<T>, I<U> where T : class where U : class { }
class C2<T, U> : I<T>, I<U?> where T : class where U : class { }
class C3<T, U> : I<T?>, I<U> where T : class where U : class { }
class C4<T, U> : I<T?>, I<U?> where T : class where U : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7));
        }

        [Fact]
        public void AssignmentNullability()
        {
            var source =
@"class C
{
    static void F1(string? x1, string y1)
    {
        object? z1;
        (z1 = x1).ToString();
        (z1 = y1).ToString();
    }
    static void F2(string? x2, string y2)
    {
        object z2;
        (z2 = x2).ToString();
        (z2 = y2).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (z1 = x1).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1 = x1").WithLocation(6, 10),
                // (12,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (z2 = x2).ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(12, 15),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         (z2 = x2).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2 = x2").WithLocation(12, 10));
        }

        [WorkItem(27008, "https://github.com/dotnet/roslyn/issues/27008")]
        [Fact]
        public void OverriddenMethodNullableValueTypeParameter_01()
        {
            var source0 =
@"public abstract class A
{
    public abstract void F(int? i);
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var source =
@"class B : A
{
    public override void F(int? i) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void OverriddenMethodNullableValueTypeParameter_02()
        {
            var source0 =
@"public abstract class A<T> where T : struct
{
    public abstract void F(T? t);
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var source =
@"class B1<T> : A<T> where T : struct
{
    public override void F(T? t) { }
}
class B2 : A<int>
{
    public override void F(int? t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [WorkItem(27967, "https://github.com/dotnet/roslyn/issues/27967")]
        [Fact]
        public void UnannotatedTypeArgument_Interface()
        {
            var source0 =
@"public interface I<T>
{
}
public class B : I<object[]>
{
}
public class C : I<C>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void F(B x)
    {
        I<object[]?> a = x;
        I<object[]> b = x;
    }
    static void F(C y)
    {
        I<C?> a = y;
        I<C> b = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [WorkItem(27967, "https://github.com/dotnet/roslyn/issues/27967")]
        [Fact]
        public void UnannotatedTypeArgument_BaseType()
        {
            var source0 =
@"public class A<T>
{
}
public class B : A<object[]>
{
}
public class C : A<C>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void F(B x)
    {
        A<object[]?> a = x;
        A<object[]> b = x;
    }
    static void F(C y)
    {
        A<C?> a = y;
        A<C> b = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnannotatedTypeArgument_Interface_Lookup()
        {
            var source0 =
@"public interface I<T>
{
    void F(T t);
}
public interface I1 : I<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I2 : I<object>
{
}
class Program
{
    static void F(I1 i1, I2 i2, object x, object? y)
    {
        i1.F(x);
        i1.F(y);
        i2.F(x);
        i2.F(y); // warn
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,14): warning CS8604: Possible null reference argument for parameter 't' in 'void I<object>.F(object t)'.
                //         i2.F(y); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("t", "void I<object>.F(object t)").WithLocation(11, 14));
        }

        [Fact]
        public void UnannotatedTypeArgument_BaseType_Lookup()
        {
            var source0 =
@"public class A<T>
{
    public static void F(T t) { }
}
public class B1 : A<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B2 : A<object>
{
}
class Program
{
    static void F(object x, object? y)
    {
        B1.F(x);
        B1.F(y);
        B2.F(x);
        B2.F(y); // warn
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,14): warning CS8604: Possible null reference argument for parameter 't' in 'void A<object>.F(object t)'.
                //         B2.F(y); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("t", "void A<object>.F(object t)").WithLocation(11, 14));
        }

        [Fact]
        public void UnannotatedConstraint_01()
        {
            var source0 =
@"public class A1 { }
public class A2<T> { }
public class B1<T> where T : A1 { }
public class B2<T> where T : A2<object> { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void Main()
    {
        new B1<A1?>();
        new B1<A1>();
        new B2<A2<object?>>();
        new B2<A2<object>>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            var typeParameters = comp.GetMember<NamedTypeSymbol>("B1").TypeParameters;
            Assert.Equal("A1", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            typeParameters = comp.GetMember<NamedTypeSymbol>("B2").TypeParameters;
            Assert.Equal("A2<System.Object>", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
        }

        [Fact]
        public void UnannotatedConstraint_02()
        {
            var source0 =
@"
public class A1 { }
public class A2<T> { }
" + NonNullTypesOff() + @"
public class B1<T, U> where T : A1 where U : A1? { }
" + NonNullTypesOff() + @"
public class B2<T, U> where T : A2<object> where U : A2<object?> { }";
            var comp0 = CreateCompilation(new[] { source0 });
            comp0.VerifyDiagnostics(
                // (5,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class B1<T, U> where T : A1 where U : A1? { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 48),
                // (7,63): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class B2<T, U> where T : A2<object> where U : A2<object?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 63)
                );
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void Main()
    {
        new B1<A1, A1?>();
        new B1<A1?, A1>();
        new B2<A2<object>, A2<object?>>();
        new B2<A2<object?>, A2<object>>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (8,29): warning CS8631: The type 'A2<object>' cannot be used as type parameter 'U' in the generic type or method 'B2<T, U>'. Nullability of type argument 'A2<object>' doesn't match constraint type 'A2<object?>'.
                //         new B2<A2<object?>, A2<object>>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A2<object>").WithArguments("B2<T, U>", "A2<object?>", "U", "A2<object>").WithLocation(8, 29));
            var typeParameters = comp.GetMember<NamedTypeSymbol>("B1").TypeParameters;
            Assert.Equal("A1", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            Assert.Equal("A1?", typeParameters[1].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            typeParameters = comp.GetMember<NamedTypeSymbol>("B2").TypeParameters;
            Assert.Equal("A2<System.Object>", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            Assert.Equal("A2<System.Object?>", typeParameters[1].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
        }

        [Fact]
        public void UnannotatedConstraint_Override()
        {
            var source0 =
@"
public interface I<T> { }
public abstract class A<T> where T : class
{
" + NonNullTypesOff() + @"
    public abstract void F1<U>() where U : T, I<T>;
" + NonNullTypesOff() + @"
    public abstract void F2<U>() where U : T?, I<T?>;
" + NonNullTypesOn() + @"
    public abstract void F3<U>() where U : T, I<T>;
" + NonNullTypesOn() + @"
    public abstract void F4<U>() where U : T?, I<T?>;
}";
            var comp0 = CreateCompilation(new[] { source0 });
            comp0.VerifyDiagnostics(
                // (8,45): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 45),
                // (8,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 44),
                // (8,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 51),
                // (8,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 50),
                // (12,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F4<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 44),
                // (12,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F4<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 50)
                );

            var source =
@"
" + NonNullTypesOff() + @"
class B1 : A<string>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOff() + @"
class B2 : A<string?>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOn() + @"
class B3 : A<string>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOn() + @"
class B4 : A<string?>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { new CSharpCompilationReference(comp0) });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics(
                // (8,45): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 45),
                // (8,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 51)
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { new CSharpCompilationReference(comp0) });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            void verifyAllConstraintTypes()
            {
                string bangOrEmpty = comp0.Options.Nullable == true ? "!" : "";
                verifyConstraintTypes("B1.F1", "System.String", "I<System.String>");
                verifyConstraintTypes("B1.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B1.F3", "System.String" + bangOrEmpty, "I<System.String" + bangOrEmpty + ">!");
                verifyConstraintTypes("B1.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B2.F1", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B2.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B2.F3", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B2.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B3.F1", "System.String!", "I<System.String!>");
                verifyConstraintTypes("B3.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B3.F3", "System.String!", "I<System.String!>!");
                verifyConstraintTypes("B3.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B4.F1", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B4.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B4.F3", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B4.F4", "System.String?", "I<System.String?>!");
            }

            void verifyConstraintTypes(string methodName, params string[] expectedTypes)
            {
                var constraintTypes = comp.GetMember<MethodSymbol>(methodName).TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_LocalFunction_01()
        {
            var source = @"
class C
{
" + NonNullTypesOn() + @"
    void M1()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t;
            x!.ToString();
        }
    }
" + NonNullTypesOff() + @"
    void M2()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t; // warn 1
            x!.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (18,56): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 56),
                // (18,85): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 85),
                // (18,99): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 99),
                // (18,98): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(18, 98),
                // (20,13): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //             T? x = t; // warn 1
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(20, 13),
                // (20,14): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             T? x = t; // warn 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 14)
                );
            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>();

            verifyLocalFunction(localSyntaxes.ElementAt(0), "C.M1.local", new[] { "C!" });
            verifyLocalFunction(localSyntaxes.ElementAt(1), "C.M2.local", new[] { "C" });

            void verifyLocalFunction(LocalFunctionStatementSyntax localSyntax, string expectedName, string[] expectedConstraintTypes)
            {
                var localSymbol = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntax);
                var constraintTypes = localSymbol.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedConstraintTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_LocalFunction_02()
        {
            var source = @"
class C
{
    void M3()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t; // warn 2
            x!.ToString(); // warn 3
        }
    }
}";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (7,56): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 56),
                // (7,85): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 85),
                // (7,99): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 99),
                // (7,98): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 98),
                // (9,14): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             T? x = t; // warn 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 14),
                // (9,13): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //             T? x = t; // warn 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 13),
                // (10,14): warning CS8629: The suppression operator (!) should be used in code within a '#nullable' context.
                //             x!.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContext, "!").WithLocation(10, 14)
                );
            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>();

            verifyLocalFunction(localSyntaxes.ElementAt(0), "C.M3.local", new[] { "C" });

            void verifyLocalFunction(LocalFunctionStatementSyntax localSyntax, string expectedName, string[] expectedConstraintTypes)
            {
                var localSymbol = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntax);
                var constraintTypes = localSymbol.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedConstraintTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_Oblivious_01()
        {
            var source0 =
@"public interface I<T>
{
}
public class A<T> where T : I<T>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B1 : I<B1> { }
class B2 : I<B2?> { }
class C
{
    static void Main()
    {
        Type t;
        t = typeof(A<B1>);
        t = typeof(A<B2>); // 1
        t = typeof(A<B1?>); // 2
        t = typeof(A<B2?>);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (10,22): warning CS8631: The type 'B2' cannot be used as type parameter 'T' in the generic type or method 'A<T>'. Nullability of type argument 'B2' doesn't match constraint type 'I<B2>'.
                //         t = typeof(A<B2>); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "B2").WithArguments("A<T>", "I<B2>", "T", "B2").WithLocation(10, 22),
                // (11,22): warning CS8631: The type 'B1?' cannot be used as type parameter 'T' in the generic type or method 'A<T>'. Nullability of type argument 'B1?' doesn't match constraint type 'I<B1?>'.
                //         t = typeof(A<B1?>); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "B1?").WithArguments("A<T>", "I<B1?>", "T", "B1?").WithLocation(11, 22));

            var constraintTypes = comp.GetMember<NamedTypeSymbol>("A").TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
            Assert.Equal("I<T>", constraintTypes[0].ToTestDisplayString(true));
        }

        [Fact]
        public void Constraint_Oblivious_02()
        {
            var source0 =
@"public class A<T, U, V>
    where T : A<T, U, V>
    where V : U
{
    protected interface I { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B : A<B, object, object>
{
    static void F(I i)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Constraint_Oblivious_03()
        {
            var source0 =
@"public class A { }
public class B0<T> where T : A { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0169
#pragma warning disable 8618

class B1<T> where T : A? { }
class B2<T> where T : A { }
" + NonNullTypesOn() + @"
class B3<T> where T : A? { }
" + NonNullTypesOn() + @"
class B4<T> where T : A { }
" + NonNullTypesOff() + @"
class C
{
    B0<A?> F1; // 1
    B0<A> F2;
    B1<A?> F3; // 2
    B1<A> F4;
    B2<A?> F5; // 3
    B2<A> F6;
    B3<A?> F7; // 4
    B3<A> F8;
    B4<A?> F9; // 5 and 6
    B4<A> F10;
}
" + NonNullTypesOn() + @"
class D
{
    B0<A?> G1;
    B0<A> G2;
    B1<A?> G3;
    B1<A> G4;
    B2<A?> G5;
    B2<A> G6;
    B3<A?> G7;
    B3<A> G8;
    B4<A?> G9; // 7
    B4<A> G10;
}";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (4,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A? { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 24),
                // (21,8): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //     B4<A?> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A?").WithArguments("B4<T>", "A", "T", "A?").WithLocation(21, 8),
                // (15,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B1<A?> F3; // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 9),
                // (17,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B2<A?> F5; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 9),
                // (19,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B3<A?> F7; // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 9),
                // (21,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B4<A?> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 9),
                // (13,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B0<A?> F1; // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 9),
                // (35,8): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //     B4<A?> G9; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A?").WithArguments("B4<T>", "A", "T", "A?").WithLocation(35, 8)
                );
        }

        [Fact]
        public void Constraint_Oblivious_04()
        {
            var source0 =
@"public class A<T> { }
public class B0<T> where T : A<object> { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0169
#pragma warning disable 8618

class B1<T> where T : A<object?> { }
class B2<T> where T : A<object> { }
" + NonNullTypesOn() + @"
class B3<T> where T : A<object?> { }
" + NonNullTypesOn() + @"
class B4<T> where T : A<object> { }
" + NonNullTypesOff() + @"
class C
{
    B0<A<object?>> F1; // 1
    B0<A<object>> F2;
    B1<A<object?>> F3; // 2
    B1<A<object>> F4;
    B2<A<object?>> F5; // 3
    B2<A<object>> F6;
    B3<A<object?>> F7; // 4
    B3<A<object>> F8;
    B4<A<object?>> F9; // 5 and 6
    B4<A<object>> F10;
}
" + NonNullTypesOn() + @"
class D
{
    B0<A<object?>> G1;
    B0<A<object>> G2;
    B1<A<object?>> G3;
    B1<A<object>> G4; // 7
    B2<A<object?>> G5;
    B2<A<object>> G6;
    B3<A<object?>> G7;
    B3<A<object>> G8; // 8
    B4<A<object?>> G9; // 9
    B4<A<object>> G10;
}";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (4,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A<object?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 31),
                // (15,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B1<A<object?>> F3; // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 16),
                // (17,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B2<A<object?>> F5; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 16),
                // (19,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B3<A<object?>> F7; // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 16),
                // (21,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B4<A<object?>> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 16),
                // (13,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B0<A<object?>> F1; // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 16),
                // (30,8): warning CS8631: The type 'A<object>' cannot be used as type parameter 'T' in the generic type or method 'B1<T>'. Nullability of type argument 'A<object>' doesn't match constraint type 'A<object?>'.
                //     B1<A<object>> G4; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A<object>").WithArguments("B1<T>", "A<object?>", "T", "A<object>").WithLocation(30, 8),
                // (34,8): warning CS8631: The type 'A<object>' cannot be used as type parameter 'T' in the generic type or method 'B3<T>'. Nullability of type argument 'A<object>' doesn't match constraint type 'A<object?>'.
                //     B3<A<object>> G8; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A<object>").WithArguments("B3<T>", "A<object?>", "T", "A<object>").WithLocation(34, 8),
                // (35,8): warning CS8631: The type 'A<object?>' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A<object?>' doesn't match constraint type 'A<object>'.
                //     B4<A<object?>> G9; // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A<object?>").WithArguments("B4<T>", "A<object>", "T", "A<object?>").WithLocation(35, 8),
                // (21,8): warning CS8631: The type 'A<object?>' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A<object?>' doesn't match constraint type 'A<object>'.
                //     B4<A<object?>> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A<object?>").WithArguments("B4<T>", "A<object>", "T", "A<object?>").WithLocation(21, 8)
                );
        }

        [Fact]
        public void Constraint_TypeParameterConstraint()
        {
            var source0 =
@"public class A1<T, U>
    where T : class
    where U : class, T
{
}
public class A2<T, U>
    where T : class
    where U : class, T?
{
}";
            var comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"
class B1<T> where T : A1<T, T?> { } // 1
class B2<T> where T : A2<T?, T> { } // 2
" + NonNullTypesOn() + @"
class B3<T> where T : A1<T, T?> { }
" + NonNullTypesOn() + @"
class B4<T> where T : A2<T?, T> { }";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });

            comp.VerifyDiagnostics(
                // (2,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A1<T, T?> { } // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 30),
                // (2,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B1<T> where T : A1<T, T?> { } // 1
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 29),
                // (3,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2<T> where T : A2<T?, T> { } // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 27),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B2<T> where T : A2<T?, T> { } // 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(3, 26)
                );
        }

        // Boxing conversion.
        [Fact]
        public void Constraint_BoxingConversion()
        {
            var source0 =
@"public interface I<T> { }
public interface IIn<in T> { }
public interface IOut<out T> { }
public struct S0 : I<object> { }
public struct SIn0 : IIn<object> { }
public struct SOut0 : IOut<object> { }
public class A
{
    public static void F0<T>() where T : I<object> { }
    public static void FIn0<T>() where T : IIn<object> { }
    public static void FOut0<T>() where T : IOut<object> { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"struct S1 : I<object?> { }
struct S2 : I<object> { }
struct SIn1 : IIn<object?> { }
struct SIn2 : IIn<object> { }
struct SOut1 : IOut<object?> { }
struct SOut2 : IOut<object> { }
class B : A
{
    static void F1<T>() where T : I<object?> { }
    static void F2<T>() where T : I<object> { }
    static void FIn1<T>() where T : IIn<object?> { }
    static void FIn2<T>() where T : IIn<object> { }
    static void FOut1<T>() where T : IOut<object?> { }
    static void FOut2<T>() where T : IOut<object> { }
    static void F()
    {
        F0<S0>();
        F0<S1>();
        F0<S2>();
        F1<S0>();
        F1<S1>();
        F1<S2>(); // 1
        F2<S0>();
        F2<S1>(); // 2
        F2<S2>();
    }
    static void FIn()
    {
        FIn0<SIn0>();
        FIn0<SIn1>();
        FIn0<SIn2>();
        FIn1<SIn0>();
        FIn1<SIn1>();
        FIn1<SIn2>(); // 3
        FIn2<SIn0>();
        FIn2<SIn1>();
        FIn2<SIn2>();
    }
    static void FOut()
    {
        FOut0<SOut0>();
        FOut0<SOut1>();
        FOut0<SOut2>();
        FOut1<SOut0>();
        FOut1<SOut1>();
        FOut1<SOut2>();
        FOut2<SOut0>();
        FOut2<SOut1>(); // 4
        FOut2<SOut2>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (22,9): warning CS8627: The type 'S2' cannot be used as type parameter 'T' in the generic type or method 'B.F1<T>()'. Nullability of type argument 'S2' doesn't match constraint type 'I<object?>'.
                //         F1<S2>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1<S2>").WithArguments("B.F1<T>()", "I<object?>", "T", "S2").WithLocation(22, 9),
                // (24,9): warning CS8627: The type 'S1' cannot be used as type parameter 'T' in the generic type or method 'B.F2<T>()'. Nullability of type argument 'S1' doesn't match constraint type 'I<object>'.
                //         F2<S1>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F2<S1>").WithArguments("B.F2<T>()", "I<object>", "T", "S1").WithLocation(24, 9),
                // (34,9): warning CS8627: The type 'SIn2' cannot be used as type parameter 'T' in the generic type or method 'B.FIn1<T>()'. Nullability of type argument 'SIn2' doesn't match constraint type 'IIn<object?>'.
                //         FIn1<SIn2>(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FIn1<SIn2>").WithArguments("B.FIn1<T>()", "IIn<object?>", "T", "SIn2").WithLocation(34, 9),
                // (48,9): warning CS8627: The type 'SOut1' cannot be used as type parameter 'T' in the generic type or method 'B.FOut2<T>()'. Nullability of type argument 'SOut1' doesn't match constraint type 'IOut<object>'.
                //         FOut2<SOut1>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FOut2<SOut1>").WithArguments("B.FOut2<T>()", "IOut<object>", "T", "SOut1").WithLocation(48, 9));
        }

        [Fact]
        public void Constraint_ImplicitTypeParameterConversion()
        {
            var source0 =
@"public interface I<T> { }
public interface IIn<in T> { }
public interface IOut<out T> { }
public class A
{
    public static void F0<T>() where T : I<object> { }
    public static void FIn0<T>() where T : IIn<object> { }
    public static void FOut0<T>() where T : IOut<object> { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B : A
{
    static void F1<T>() where T : I<object?> { }
    static void F2<T>() where T : I<object> { }
    static void FIn1<T>() where T : IIn<object?> { }
    static void FIn2<T>() where T : IIn<object> { }
    static void FOut1<T>() where T : IOut<object?> { }
    static void FOut2<T>() where T : IOut<object> { }
    static void F<T, U>() where T : I<object?> where U : I<object>
    {
        F0<T>();
        F0<U>();
        F1<T>();
        F1<U>(); // 1
        F2<T>(); // 2
        F2<U>();
    }
    static void FIn<T, U>() where T : IIn<object?> where U : IIn<object>
    {
        FIn0<T>();
        FIn0<U>();
        FIn1<T>();
        FIn1<U>(); // 3
        FIn2<T>();
        FIn2<U>();
    }
    static void FOut<T, U>() where T : IOut<object?> where U : IOut<object>
    {
        FOut0<T>();
        FOut0<U>();
        FOut1<T>();
        FOut1<U>();
        FOut2<T>(); // 4
        FOut2<U>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (14,9): warning CS8627: The type 'U' cannot be used as type parameter 'T' in the generic type or method 'B.F1<T>()'. Nullability of type argument 'U' doesn't match constraint type 'I<object?>'.
                //         F1<U>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1<U>").WithArguments("B.F1<T>()", "I<object?>", "T", "U").WithLocation(14, 9),
                // (15,9): warning CS8627: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'B.F2<T>()'. Nullability of type argument 'T' doesn't match constraint type 'I<object>'.
                //         F2<T>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F2<T>").WithArguments("B.F2<T>()", "I<object>", "T", "T").WithLocation(15, 9),
                // (23,9): warning CS8627: The type 'U' cannot be used as type parameter 'T' in the generic type or method 'B.FIn1<T>()'. Nullability of type argument 'U' doesn't match constraint type 'IIn<object?>'.
                //         FIn1<U>(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FIn1<U>").WithArguments("B.FIn1<T>()", "IIn<object?>", "T", "U").WithLocation(23, 9),
                // (33,9): warning CS8627: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'B.FOut2<T>()'. Nullability of type argument 'T' doesn't match constraint type 'IOut<object>'.
                //         FOut2<T>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FOut2<T>").WithArguments("B.FOut2<T>()", "IOut<object>", "T", "T").WithLocation(33, 9));
        }

        [Fact]
        public void Constraint_MethodTypeInference()
        {
            var source0 =
@"public class A { }
public class B
{
    public static void F0<T>(T t) where T : A
    {
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C : B
{
    static void F1<T>(T t) where T : A
    {
    }
    static void G(A x, A? y)
    {
        F0(x);
        F1(x);
        F0(y);
        F1(y); // 1
        x = y;
        F0(x);
        F1(x); // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,9): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'C.F1<T>(T)'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //         F1(y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1").WithArguments("C.F1<T>(T)", "A", "T", "A?").WithLocation(11, 9),
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(12, 13),
                // (14,9): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'C.F1<T>(T)'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //         F1(x); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1").WithArguments("C.F1<T>(T)", "A", "T", "A?").WithLocation(14, 9));
        }

        [Fact]
        [WorkItem(29999, "https://github.com/dotnet/roslyn/issues/29999")]
        public void ThisAndBaseMemberInLambda()
        {
            var source =
@"delegate void D();
class A
{
    internal string? F;
}
class B : A
{
    void M()
    {
        D d;
        d = () =>
        {
            int n = this.F.Length; // 1
            this.F = string.Empty;
            n = this.F.Length;
        };
        d = () =>
        {
            int n = base.F.Length; // 2
            base.F = string.Empty;
            n = base.F.Length;
        };
    }
}";
            // https://github.com/dotnet/roslyn/issues/29999: Should not report warning for
            // dereference of `this.F` or `base.F` after assignment.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,21): warning CS8602: Possible dereference of a null reference.
                //             int n = this.F.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "this.F").WithLocation(13, 21),
                // (15,17): warning CS8602: Possible dereference of a null reference.
                //             n = this.F.Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "this.F").WithLocation(15, 17),
                // (19,21): warning CS8602: Possible dereference of a null reference.
                //             int n = base.F.Length; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "base.F").WithLocation(19, 21),
                // (21,17): warning CS8602: Possible dereference of a null reference.
                //             n = base.F.Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "base.F").WithLocation(21, 17));
        }

        [WorkItem(29049, "https://github.com/dotnet/roslyn/issues/29049")]
        [Fact]
        public void TypeSymbolWithAnnotations_GetHashCode()
        {
            var source =
@"interface I<T> { }
class A : I<A> { }
class B<T> where T : I<A?> { }
class Program
{
    static void Main()
    {
        new B<A>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            var diagnostics = comp.GetDiagnostics();
            diagnostics.Verify(
                // (8,15): warning CS8631: The type 'A' cannot be used as type parameter 'T' in the generic type or method 'B<T>'. Nullability of type argument 'A' doesn't match constraint type 'I<A?>'.
                //         new B<A>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A").WithArguments("B<T>", "I<A?>", "T", "A").WithLocation(8, 15));
            // Diagnostics must support GetHashCode() and Equals(), to allow removing
            // duplicates (see CommonCompiler.ReportErrors).
            foreach (var diagnostic in diagnostics)
            {
                diagnostic.GetHashCode();
                Assert.True(diagnostic.Equals(diagnostic));
            }
        }

        [WorkItem(29041, "https://github.com/dotnet/roslyn/issues/29041")]
        [WorkItem(29048, "https://github.com/dotnet/roslyn/issues/29048")]
        [WorkItem(30001, "https://github.com/dotnet/roslyn/issues/30001")]
        [Fact]
        public void ConstraintCyclesFromMetadata_01()
        {
            var source0 =
@"using System;
public class A0<T> where T : IEquatable<T> { }
public class A1<T> where T : class, IEquatable<T> { }

public class A3<T> where T : struct, IEquatable<T> { }
public class A4<T> where T : struct, IEquatable<T?> { }
public class A5<T> where T : IEquatable<string?> { }
public class A6<T> where T : IEquatable<int?> { }";
            var source =
@"class B
{
    static void Main()
    {
        new A0<string?>(); // 1
        new A0<string>();


        new A5<string?>(); // 4
        new A5<string>(); // 5
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });

            var expectedDiagnostics = new[]
            {
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22)
            };

            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesFalse());
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });

            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (5,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A0<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A0<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(5, 16),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22),
                // (9,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A5<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A5<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(9, 16)
                );
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember<NamedTypeSymbol>(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }

        [WorkItem(29041, "https://github.com/dotnet/roslyn/issues/29041")]
        [WorkItem(29048, "https://github.com/dotnet/roslyn/issues/29048")]
        [WorkItem(30003, "https://github.com/dotnet/roslyn/issues/30003")]
        [Fact]
        public void ConstraintCyclesFromMetadata_02()
        {
            var source0 =
@"using System;
public class A2<T> where T : class, IEquatable<T?> { }
";
            var source =
@"class B
{
    static void Main()
    {
        new A2<string?>(); // 2
        new A2<string>(); // 3
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics(
                // (2,48): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 48),
                // (2,49): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 49)
                );

            MetadataReference ref0 = comp0.ToMetadataReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report a nullability mismatch warning for A2<string>().
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesFalse());
            comp0.VerifyDiagnostics(
                // (2,48): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 48),
                // (2,49): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 49)
                );
            ref0 = comp0.ToMetadataReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report same warnings as other two cases.
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report a nullability mismatch warning for A2<string>().
            comp.VerifyDiagnostics(
                // (5,16): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A2<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("A2<T>", "T", "string?").WithLocation(5, 16),
                // (5,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A2<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A2<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(5, 16),
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember<NamedTypeSymbol>(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }

        [WorkItem(29186, "https://github.com/dotnet/roslyn/issues/29186")]
        [Fact]
        public void AttributeArgumentCycle_OtherAttribute()
        {
            var source =
@"using System;
class AAttribute : Attribute
{
    internal AAttribute(object o) { }
}
interface IA { }
interface IB<T> where T : IA { }
[A(typeof(IB<IA>))]
class C
{
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(29186, "https://github.com/dotnet/roslyn/issues/29186")]
        [Fact]
        public void AttributeArgumentCycle_NonNullTypes_01()
        {
            var source =
@"using System.Runtime.CompilerServices;
class A { }
class B<T> where T : A { }
[NonNullTypes(typeof(B<A>))]
class C
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesFalse());
            comp.VerifyDiagnostics(
                // (4,15): error CS1503: Argument 1: cannot convert from 'System.Type' to 'bool'
                // [NonNullTypes(typeof(B<A>))]
                Diagnostic(ErrorCode.ERR_BadArgType, "typeof(B<A>)").WithArguments("1", "System.Type", "bool").WithLocation(4, 15));
        }

        [WorkItem(29186, "https://github.com/dotnet/roslyn/issues/29186")]
        [Fact]
        public void AttributeArgumentCycle_NonNullTypes_02()
        {
            var source =
@"using System.Runtime.CompilerServices;
class A { }
class B<T> where T : A
{
    internal const bool True = true;
}
[NonNullTypes(B<A>.True)]
class C
{
}
[NonNullTypes(B<A?>.True)]
class D
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'Nullable' value: 'True' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("Nullable", "True", "7.3", "8.0").WithLocation(1, 1),
                // (7,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(B<A>.True)]
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(B<A>.True)").WithLocation(7, 2),
                // (11,18): error CS8370: Feature 'nullable reference types' is not available in C# 7.3. Please use language version 8.0 or greater.
                // [NonNullTypes(B<A?>.True)]
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7_3, "?").WithArguments("nullable reference types", "8.0").WithLocation(11, 18),
                // (11,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(B<A?>.True)]
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(B<A?>.True)").WithLocation(11, 2));

            var comp2 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
                // (7,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(B<A>.True)]
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(B<A>.True)").WithLocation(7, 2),
                // (11,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(B<A?>.True)]
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(B<A?>.True)").WithLocation(11, 2),
                // (11,15): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'B<T>'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                // [NonNullTypes(B<A?>.True)]
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "B<A?>").WithArguments("B<T>", "A", "T", "A?").WithLocation(11, 15));
        }

        [WorkItem(29186, "https://github.com/dotnet/roslyn/issues/29186")]
        [Fact]
        public void AttributeArgumentCycle_Nullable()
        {
            var source0 =
@"

namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Int32 { }
    public class Type { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
    public interface INullable<T> { }
    public struct Nullable<T> where T : INullable<object> { }
}
namespace System.Runtime.CompilerServices
{
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag = true) { }
    }
}";
            var source =
@"using System;
class AAttribute : Attribute
{
    internal AAttribute(object o) { }
}
struct S : INullable<object?> { }
[A(typeof(S?))]
class C
{
}";
            var comp = CreateEmptyCompilation(new[] { source0, source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,11): warning CS8631: The type 'S' cannot be used as type parameter 'T' in the generic type or method 'Nullable<T>'. Nullability of type argument 'S' doesn't match constraint type 'System.INullable<object>'.
                // [A(typeof(S?))]
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "S?").WithArguments("System.Nullable<T>", "System.INullable<object>", "T", "S").WithLocation(7, 11));
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_01()
        {
            var source =
@"


" + NonNullTypesOn() + @"
class A<T1, T2> where T1 : class where T2 : class
{
    T1 F;

" + NonNullTypesOff() + @"
    class B : A<T1, T2>
    {
" + NonNullTypesOn() + @"
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOff() + @"
    class C : A<C, C>
    {
" + NonNullTypesOn() + @"
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOff() + @"
    class D : A<T1, D>
    {
" + NonNullTypesOn() + @"
        void M4()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOff() + @"
    class E : A<T2, T2>
    {
" + NonNullTypesOn() + @"
        void M5()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T1, T2> where T1 : class where T2 : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (7,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(7, 8),
                // (15,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 17),
                // (21,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 13),
                // (30,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(30, 17),
                // (40,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(40, 17),
                // (50,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30177, "https://github.com/dotnet/roslyn/issues/30177")]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_02()
        {
            var source =
@"


" + NonNullTypesOff() + @"
class A<T1, T2> where T1 : class where T2 : class
{
" + NonNullTypesOn() + @"
    T1 F;

" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOn() + @"
    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOn() + @"
    class D : A<T1, D>
    {
        void M4()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOn() + @"
    class E : A<T2, T2>
    {
        void M5()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            // https://github.com/dotnet/roslyn/issues/30177 Unexpected warning CS8618: Non-nullable field 'F' is uninitialized.
            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T1, T2> where T1 : class where T2 : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (8,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(8, 8),
                // (30,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(30, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        public void GenericSubstitution_03()
        {
            var source =
NonNullTypesOff() + @"
class A<T> where T : class
{
    class B : A<T>
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_04()
        {
            var source =
NonNullTypesOn() + @"
class A<T> where T : class
{
    class B : A<T>
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_05()
        {
            var source =
@"


" + NonNullTypesOn() + @"
class A<T1, T2> where T1 : class where T2 : class
{
" + NonNullTypesOff() + @"
    T1 F;
" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

    class D : A<T1, D>
    {
        void M1()
        {
            F = null; // 4
        }
    }

    class E : A<T2, T2>
    {
        void M1()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (8,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(8, 8),
                // (14,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 17),
                // (27,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(27, 17),
                // (35,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(35, 17),
                // (43,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(43, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30177, "https://github.com/dotnet/roslyn/issues/30177")]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_06()
        {
            var source =
@"


" + NonNullTypesOff() + @"
class A<T1, T2> where T1 : class where T2 : class
{
    T1 F;

" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOn() + @"
    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOn() + @"
    class D : A<T1, D>
    {
        void M3()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOn() + @"
    class E : A<T2, T2>
    {
        void M3()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            // https://github.com/dotnet/roslyn/issues/30177 Unexpected warning CS8618: Non-nullable field 'F' is uninitialized.
            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T1, T2> where T1 : class where T2 : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (7,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(7, 8),
                // (29,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(29, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30171, "https://github.com/dotnet/roslyn/issues/30171")]
        public void NonNullTypesContext_01()
        {
            var source =
@"
using System.Runtime.CompilerServices;

class A
{
" + NonNullTypesOff() + @"
    B[] F1;

" + NonNullTypesOn() + @"
    C[] F2;
}

class B {}
class C {}
";
            var comp = CreateCompilation(new[] { source });


            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B[]", f1.Type.ToTestDisplayString(includeNonNullable: true));

            var f2 = comp.GetMember<FieldSymbol>("A.F2");
            Assert.Equal("C![]!", f2.Type.ToTestDisplayString(includeNonNullable: true));

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var arrays = tree.GetRoot().DescendantNodes().OfType<ArrayTypeSyntax>().ToArray();

            Assert.Equal(2, arrays.Length);

            Assert.Equal("B[]", model.GetTypeInfo(arrays[0]).Type.ToTestDisplayString(includeNonNullable: true));
            // https://github.com/dotnet/roslyn/issues/30171 Expected "C![]"
            Assert.Equal("C[]", model.GetTypeInfo(arrays[1]).Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        [WorkItem(30214, "https://github.com/dotnet/roslyn/issues/30214")]
        public void ObliviousTypeParameter_01()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UninitializedNonNullableField}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedField}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedFieldAssg}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVarAssg}
"
+
@"


" + NonNullTypesOff() + @"
class A<T1, T2, T3> where T2 : class where T3 : object
{
    T1 F1;
    T2 F2;
    T3 F3;
    B F4;

" + NonNullTypesOn() + @"
    void M1()
    {
        F1 = default;
        F2 = default;
        F3 = default;
        F4 = default;
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        T1 x2 = default;
        T2 y2 = default;
        T3 z2 = default;
    }

" + NonNullTypesOn() + @"
    void M3()
    {
        C.Test<T1>();
        C.Test<T2>();
        C.Test<T3>();
    }

" + NonNullTypesOn() + @"
    void M4()
    {
        D.Test(F1);
        D.Test(F2);
        D.Test(F3);
        D.Test(F4);
    }
}

class B {}

" + NonNullTypesOn() + @"
class C
{
    public static void Test<T>() where T : object
    {}
}

" + NonNullTypesOn() + @"
class D
{
    public static void Test<T>(T x) where T : object
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (20,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(20, 14),
                // (21,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F2 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(21, 14),
                // (22,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F3 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(22, 14),
                // (29,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         T1 x2 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(29, 17),
                // (30,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         T2 y2 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(30, 17),
                // (31,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         T3 z2 = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(31, 17),
                // (37,9): warning CS8631: The type 'T1' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T1' doesn't match constraint type 'object'.
                //         C.Test<T1>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T1>").WithArguments("C.Test<T>()", "object", "T", "T1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'T2' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T2' doesn't match constraint type 'object'.
                //         C.Test<T2>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T2>").WithArguments("C.Test<T>()", "object", "T", "T2").WithLocation(38, 9),
                // (39,9): warning CS8631: The type 'T3' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T3' doesn't match constraint type 'object'.
                //         C.Test<T3>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T3>").WithArguments("C.Test<T>()", "object", "T", "T3").WithLocation(39, 9)
                );
        }

        [Fact]
        [WorkItem(30220, "https://github.com/dotnet/roslyn/issues/30220")]
        public void ObliviousTypeParameter_02()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVar}
"
+
@"


" + NonNullTypesOn() + @"
class A<T1> where T1 : class
{
" + NonNullTypesOff() + @"
    class B<T2> where T2 : T1 
    {
    }

" + NonNullTypesOn() + @"
    void M1()
    {
        B<T1> a1;
        B<T1?> b1;
        A<T1>.B<T1> c1;
        A<T1>.B<T1?> d1;
        A<C>.B<C> e1;
        A<C>.B<C?> f1;
    }
}

class C {}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (20,17): warning CS8631: The type 'T1?' cannot be used as type parameter 'T2' in the generic type or method 'A<T1>.B<T2>'. Nullability of type argument 'T1?' doesn't match constraint type 'T1'.
                //         A<T1>.B<T1?> d1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "T1?").WithArguments("A<T1>.B<T2>", "T1", "T2", "T1?").WithLocation(20, 17),
                // (22,16): warning CS8631: The type 'C?' cannot be used as type parameter 'T2' in the generic type or method 'A<C>.B<T2>'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         A<C>.B<C?> f1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C?").WithArguments("A<C>.B<T2>", "C", "T2", "C?").WithLocation(22, 16)
                );
        }

        [Fact]
        public void NonNullTypes_27()
        {
            var source =
@"using System.Runtime.CompilerServices;

[module: NonNullTypes] // 1

[NonNullTypes] // 2
class A 
{
    [NonNullTypes] // 3
    string F1;

    [NonNullTypes] // 4
    string P1 {get; set;}

    [NonNullTypes] // 5
    void M1() {}

    [NonNullTypes] // 6
    event System.Action E1;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (3,10): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [module: NonNullTypes] // 1
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(3, 10),
                // (5,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes] // 2
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(5, 2),
                // (8,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes] // 3
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(8, 6),
                // (9,12): warning CS0169: The field 'A.F1' is never used
                //     string F1;
                Diagnostic(ErrorCode.WRN_UnreferencedField, "F1").WithArguments("A.F1").WithLocation(9, 12),
                // (11,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes] // 4
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(11, 6),
                // (14,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes] // 5
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(14, 6),
                // (17,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes] // 6
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes").WithLocation(17, 6),
                // (18,25): warning CS0067: The event 'A.E1' is never used
                //     event System.Action E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("A.E1").WithLocation(18, 25)
);
        }

        [Fact]
        public void NonNullTypes_28()
        {
            var source =
@"using System.Runtime.CompilerServices;

[module: NonNullTypes(false)] // 1

[NonNullTypes(false)] // 2
class A 
{
    [NonNullTypes(false)] // 3
    string F1;

    [NonNullTypes(false)] // 4
    string P1 {get; set;}

    [NonNullTypes(false)] // 5
    void M1() {}

    [NonNullTypes(false)] // 6
    event System.Action E1;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (3,10): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [module: NonNullTypes(false)] // 1
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(3, 10),
                // (5,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(false)] // 2
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(5, 2),
                // (8,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(false)] // 3
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(8, 6),
                // (9,12): warning CS0169: The field 'A.F1' is never used
                //     string F1;
                Diagnostic(ErrorCode.WRN_UnreferencedField, "F1").WithArguments("A.F1").WithLocation(9, 12),
                // (11,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(false)] // 4
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(11, 6),
                // (14,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(false)] // 5
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(14, 6),
                // (17,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(false)] // 6
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(false)").WithLocation(17, 6),
                // (18,25): warning CS0067: The event 'A.E1' is never used
                //     event System.Action E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("A.E1").WithLocation(18, 25)
);
        }

        [Fact]
        public void NonNullTypes_29()
        {
            var source =
@"using System.Runtime.CompilerServices;

[module: NonNullTypes(true)] // 1

[NonNullTypes(true)] // 2
class A 
{
    [NonNullTypes(true)] // 3
    string F1;

    [NonNullTypes(true)] // 4
    string P1 {get; set;}

    [NonNullTypes(true)] // 5
    void M1() {}

    [NonNullTypes(true)] // 6
    event System.Action E1;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (3,10): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [module: NonNullTypes(true)] // 1
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(3, 10),
                // (5,2): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                // [NonNullTypes(true)] // 2
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(5, 2),
                // (8,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(true)] // 3
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(8, 6),
                // (9,12): warning CS0169: The field 'A.F1' is never used
                //     string F1;
                Diagnostic(ErrorCode.WRN_UnreferencedField, "F1").WithArguments("A.F1").WithLocation(9, 12),
                // (11,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(true)] // 4
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(11, 6),
                // (14,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(true)] // 5
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(14, 6),
                // (17,6): error CS8636: Explicit application of 'System.Runtime.CompilerServices.NonNullTypesAttribute' is not allowed.
                //     [NonNullTypes(true)] // 6
                Diagnostic(ErrorCode.ERR_ExplicitNonNullTypesAttribute, "NonNullTypes(true)").WithLocation(17, 6),
                // (18,25): warning CS0067: The event 'A.E1' is never used
                //     event System.Action E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("A.E1").WithLocation(18, 25)
);
        }

        [WorkItem(23270, "https://github.com/dotnet/roslyn/issues/23270")]
        [Fact]
        public void NotNullAfterDereference_01()
        {
            var source =
@"class Program
{
    static void F(object? x)
    {
        x.ToString(); // 1
        object? y;
        y.ToString();
        y = null;
        y.ToString(); // 2
        x.ToString();
        y.ToString();
        x = y;
        if (y != null)
        {
            x.ToString();
        }
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 9),
                // (7,9): error CS0165: Use of unassigned local variable 'y'
                //         y.ToString();
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y").WithArguments("y").WithLocation(7, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9),
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (y != null)
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y != null").WithLocation(13, 13));
        }

        [Fact]
        public void NotNullAfterDereference_02()
        {
            var source =
@"class Program
{
    static void F<T>(T x)
    {
        x.ToString(); // 1
        T y;
        y.ToString();
        y = default;
        y.ToString(); // 2
        x.ToString();
        y.ToString();
        x = y;
        if (y != null)
        {
            x.ToString();
        }
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 9),
                // (7,9): error CS0165: Use of unassigned local variable 'y'
                //         y.ToString();
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y").WithArguments("y").WithLocation(7, 9),
                // (8,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(8, 13),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9),
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (y != null)
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y != null").WithLocation(13, 13));
        }

        [Fact]
        public void NotNullAfterDereference_03()
        {
            var source =
@"class C
{
    void F1(C x) { }
    static void G1(C? x)
    {
        x?.F1(x);
        x!.F1(x); // 1
        x.F1(x); // 2
        x.F1(x);
    }
    static void G2(C? y)
    {
        y?.F2(y);
        y!.F2(y); // 3
        y.F2(y); // 4, 5
        y.F2(y); // 6, 7
    }
}
static class E
{
    internal static void F2(this C x, C y) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,15): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.F1(C x)'.
                //         x!.F1(x); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "void C.F1(C x)").WithLocation(7, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         x.F1(x); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 9),
                // (14,15): warning CS8604: Possible null reference argument for parameter 'y' in 'void E.F2(C x, C y)'.
                //         y!.F2(y); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void E.F2(C x, C y)").WithLocation(14, 15),
                // (15,9): warning CS8604: Possible null reference argument for parameter 'x' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void E.F2(C x, C y)").WithLocation(15, 9),
                // (15,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void E.F2(C x, C y)").WithLocation(15, 14),
                // (16,9): warning CS8604: Possible null reference argument for parameter 'x' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 6, 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void E.F2(C x, C y)").WithLocation(16, 9),
                // (16,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 6, 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void E.F2(C x, C y)").WithLocation(16, 14));
        }

        [Fact]
        public void NotNullAfterDereference_04()
        {
            var source =
@"class Program
{
    static void F<T>(bool b, string? s)
    {
        int n;
        if (b)
        {
            n = s/*T:string?*/.Length; // 1
            n = s/*T:string!*/.Length;
            
        }
        n = b ? s/*T:string?*/.Length + // 2
            s/*T:string!*/.Length : 0;
        n = s/*T:string?*/.Length; // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 17),
                // (12,17): warning CS8602: Possible dereference of a null reference.
                //         n = b ? s/*T:string?*/.Length + // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 17),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         n = s/*T:string?*/.Length; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 13));
            comp.VerifyTypes();
        }

        [Fact]
        public void NotNullAfterDereference_05()
        {
            var source =
@"class Program
{
    static void F(string? s)
    {
        int n;
        try
        {
            n = s/*T:string?*/.Length; // 1
            try
            {
                n = s/*T:string!*/.Length;
            }
            finally
            {
                n = s/*T:string!*/.Length;
            }
        }
        catch (System.IO.IOException)
        {
            n = s/*T:string?*/.Length; // 2
        }
        catch
        {
            n = s/*T:string?*/.Length; // 3
        }
        finally
        {
            n = s/*T:string?*/.Length; // 4
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 17),
                // (20,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(20, 17),
                // (24,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(24, 17),
                // (28,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(28, 17));
            comp.VerifyTypes();
        }

        [Fact]
        public void NotNullAfterDereference_06()
        {
            var source =
@"class C
{
    object F = default!;
    static void G(C? c)
    {
        c.F = c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // One warning only, rather than one warning for dereference of c.F
            // and another warning for assignment c.F = c.
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.F = c;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(6, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Call()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? y;
    void F(object? o)
    {
    }
    static void G(C? x)
    {
        x.F(x = null); // 1
        x.F(x.y); // 2, 3
        x.F(x.y);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x.F(x.y).
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x.F(x = null); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.F(x.y); // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Array()
        {
            var source =
@"class Program
{
    static int F(object? o) => 0;
    static void G(object[]? x, object[] y)
    {
        object z;
        z = x[F(x = null)]; // 1
        z = x[x.Length]; // 2, 3
        z = x[x.Length];
        y[F(y = null)] = 1;
        y[y.Length] = 2; // 4, 5
        y[y.Length] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.Length] and y[y.Length].
            comp.VerifyDiagnostics(
                // (7,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[F(x = null)]; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 13),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.Length]; // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (10,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y[F(y = null)] = 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(10, 17),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.Length] = 2; // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Indexer()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? F;
    object this[object? o]
    {
        get { return 1; }
        set { }
    }
    static void G(C? x, C y)
    {
        object z;
        z = x[x = null]; // 1
        z = x[x.F]; // 2, 3
        z = x[x.F];
        y[y = null] = 1;
        y[y.F] = 2; // 4, 5
        y[y.F] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.F] and y[y.F].
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x = null]; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.F]; // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(14, 13),
                // (16,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y[y = null] = 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(16, 15),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.F] = 2; // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(17, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Field()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    object? F;
    static object? G(object? o) => o;
    static void M(C? x, C? y)
    {
        object? o;
        o = x.F; // 1
        o = x.F;
        y.F = G(y = null); // 2
        y.F = G(y.F); // 3, 4
        y.F = G(y.F);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.F = G(y.F).
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //         o = x.F; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 13),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y.F); // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Property()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    object? P { get; set; }
    static object? F(object? o) => o;
    static void M(C? x, C? y)
    {
        object? o;
        o = x.P; // 1
        o = x.P;
        y.P = F(y = null); // 2
        y.P = F(y.P); // 3, 4
        y.P = F(y.P);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.P = F(y.P).
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //         o = x.F; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 13),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y.F); // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Event()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
delegate void D();
class C
{
    event D E;
    D F;
    static D G(C? c) => throw null;
    static void M(C? x, C? y, C? z)
    {
        x.E(); // 1
        x.E();
        y.E += G(y = null); // 2
        y.E += y.F; // 3, 4
        y.E += y.F;
        y.E();
        z.E = null; // 5
        z.E();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.E += y.F.
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.E(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.E += G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y.E += y.F; // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(14, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         z.E = null; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(17, 9),
                // (17,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         z.E = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(17, 15),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         z.E();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z.E").WithLocation(18, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Dynamic()
        {
            var source =
@"class Program
{
    static void F(dynamic? d)
    {
        d.ToString(); // 1
        d.ToString();
    }
    static void G(dynamic? x, dynamic? y)
    {
        object z;
        z = x[x = null]; // 2
        z = x[x.F]; // 3, 4
        z = x[x.F];
        y[y = null] = 1;
        y[y.F] = 2; // 5, 6
        y[y.F] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.F] and y[y.F].
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         d.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d").WithLocation(5, 9),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x = null]; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.F]; // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y[y = null] = 1;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.F] = 2; // 5, 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(15, 9));
        }

        [WorkItem(30563, "https://github.com/dotnet/roslyn/issues/30563")]
        [Fact]
        public void NotNullAfterDereference_MethodGroup_01()
        {
            var source =
@"delegate void D();
class C
{
    void F1() { }
    static void F(C? x, C? y)
    {
        D d;
        d = x.F1; // warning
        d = y.F2; // ok
    }
}
static class E
{
    internal static void F2(this C? c) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30563: Should not report "CS8602: Possible dereference" for y.F2.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //         d = x.F1; // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //         d = y.F2; // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 13));
        }

        [WorkItem(30563, "https://github.com/dotnet/roslyn/issues/30563")]
        [Fact]
        public void NotNullAfterDereference_MethodGroup_02()
        {
            var source =
@"delegate void D1(int i);
delegate void D2();
class C
{
    void F(int i) { }
    static void F1(D1 d) { }
    static void F2(D2 d) { }
    static void G(C? x, C? y)
    {
        F1(x.F); // 1
        F1(x.F);
        F2(y.F); // 2
        F2(y.F); // 3
    }
}
static class E
{
    internal static void F(this C x) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30563: Should not report "CS8602: Possible dereference"
            // for F2(y.F). Should report "CS8604: Possible null reference argument" instead.
            comp.VerifyDiagnostics(
                // (10,12): warning CS8602: Possible dereference of a null reference.
                //         F1(x.F); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 12),
                // (12,12): warning CS8602: Possible dereference of a null reference.
                //         F2(y.F); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 12));
        }

        [WorkItem(30562, "https://github.com/dotnet/roslyn/issues/30562")]
        [Fact]
        public void NotNullAfterDereference_ForEach()
        {
            var source =
@"class Enumerable
{
    public System.Collections.IEnumerator GetEnumerator() => throw null;
}
class Program
{
    static void F1(object[]? x1, object[]? y1)
    {
        foreach (var x in x1) { } // 1
        foreach (var x in x1) { }
        foreach (var y in y1) { } // 2
        y1.GetEnumerator();
    }
    static void F2(Enumerable? x2, Enumerable? y2)
    {
        foreach (var x in x2) { } // 3
        foreach (var x in x2) { }
        y2.GetEnumerator(); // 4
        foreach (var y in y2) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30562: Should not report second warning in each case.
            comp.VerifyDiagnostics(
                // (9,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x1) { } // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x1) { }
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 27),
                // (11,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in y1) { } // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(11, 27),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y1.GetEnumerator();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(12, 9),
                // (16,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x2) { } // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(16, 27),
                // (17,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x2) { }
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(17, 27),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         y2.GetEnumerator(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(18, 9));
        }
        
        [Fact]
        public void SpecialAndWellKnownMemberLookup()
        {
            var source0 =
@"
namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Int32 { }
    public class Type { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }

    public struct Nullable<T>
    {
        public static implicit operator Nullable<T>(T x)
        {
            throw null;
        }
        public static explicit operator T(Nullable<T> x)
        {
            throw null;
        }
    }

    namespace Collections.Generic
    {
        public class EqualityComparer<T>
        {
            public static EqualityComparer<T> Default => throw null;
        }
    }
}
";
            var comp = CreateEmptyCompilation(new[] { source0 }, options: WithNonNullTypesTrue());

            var implicitOp = comp.GetSpecialTypeMember(SpecialMember.System_Nullable_T__op_Implicit_FromT);
            var explicitOp = comp.GetSpecialTypeMember(SpecialMember.System_Nullable_T__op_Explicit_ToT);
            var getDefault = comp.GetWellKnownTypeMember(WellKnownMember.System_Collections_Generic_EqualityComparer_T__get_Default);

            Assert.NotNull(implicitOp);
            Assert.NotNull(explicitOp);
            Assert.NotNull(getDefault);

            Assert.True(implicitOp.IsDefinition);
            Assert.True(explicitOp.IsDefinition);
            Assert.True(getDefault.IsDefinition);
        }

        [Fact]
        public void ExpressionTrees_ByRefDynamic()
        {
            string source = @"
using System;
using System.Linq.Expressions;
 
class Program
{
    static void Main()
    {
        Expression<Action<dynamic>> e = x => Goo(ref x);
    }
 
    static void Goo<T>(ref T x) { }
}
";
            CompileAndVerify(source, targetFramework: TargetFramework.StandardAndCSharp, options: WithNonNullTypesTrue());
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        public void TestErrorsImplementingGenericNestedInterfaces_Explicit()
        {
            var text = @"
using System.Collections.Generic;
class Outer<T>
{
    internal class Inner<U>
    {
        protected internal interface Interface<V, W>
        {
            T Property { set; }
            void Method<Z>(T a, U[] b, List<V> c, Dictionary<W, Z> d);
        }
        internal class Derived4
        {
            internal class Derived5 : Outer<T>.Inner<U>.Interface<U, T>
            {
                T Outer<T>.Inner<U>.Interface<U, T>.Property
                {
                    set { }
                }
                void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                {
                }
            }
            internal class Derived6 : Outer<T>.Inner<U>.Interface<U, T>
            {
                T Outer<T>.Inner<U>.Interface<U, T>.Property
                {
                    set { }
                }
                void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<T, K> D)
                {
                }
            }
        }
    }
}
";

            // https://github.com/dotnet/roslyn/issues/30677 - The following errors are unexpected:
            // (24,39): error CS0535: 'Outer<T>.Inner<U>.Derived4.Derived6' does not implement interface member 'Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], List<U>, Dictionary<T, Z>)'
            // (20,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
            // (30,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], List<U>, Dictionary<T, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
            CreateCompilation(text, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (14,39): error CS0535: 'Outer<T>.Inner<U>.Derived4.Derived5' does not implement interface member 'Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], List<U>, Dictionary<T, Z>)'
                //             internal class Derived5 : Outer<T>.Inner<U>.Interface<U, T>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "Outer<T>.Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5", "Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<T, Z>)").WithLocation(14, 39),
                // (20,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<K, T>)", "Outer<T>.Inner<U>.Interface<U, T>").WithLocation(20, 22),
                // (20,47): error CS0539: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)' in explicit interface declaration is not a member of interface
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                Diagnostic(ErrorCode.ERR_InterfaceMemberNotFound, "Method").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<K, T>)").WithLocation(20, 47),
                // (24,39): error CS0535: 'Outer<T>.Inner<U>.Derived4.Derived6' does not implement interface member 'Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], List<U>, Dictionary<T, Z>)'
                //             internal class Derived6 : Outer<T>.Inner<U>.Interface<U, T>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "Outer<T>.Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived6", "Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<T, Z>)").WithLocation(24, 39),
                // (30,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], List<U>, Dictionary<T, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<T, K> D)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<T, K>)", "Outer<T>.Inner<U>.Interface<U, T>").WithLocation(30, 22)
                );
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        public void TestErrorsImplementingGenericNestedInterfaces_Explicit_IncorrectPartialQualification()
        {
            var source = @"
using System.Collections.Generic;
class Outer<T>
{
    internal class Inner<U>
    {
        protected internal interface Interface<V, W>
        {
            T Property { set; }
            void Method<Z>(T a, U[] b, List<V> c, Dictionary<W, Z> d);
        }
        internal class Derived3 : Interface<long, string>
        {
            T Interface<long, string>.Property
            {
                set { }
            }
            void Inner<U>.Interface<long, string>.Method<K>(T a, U[] B, List<long> C, Dictionary<string, K> d)
            {
            }
        }
    }
}
";

            // https://github.com/dotnet/roslyn/issues/30677 - Expect no errors
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,35): error CS0535: 'Outer<T>.Inner<U>.Derived3' does not implement interface member 'Outer<T>.Inner<U>.Interface<long, string>.Method<Z>(T, U[], List<long>, Dictionary<string, Z>)'
                //         internal class Derived3 : Interface<long, string>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "Interface<long, string>").WithArguments("Outer<T>.Inner<U>.Derived3", "Outer<T>.Inner<U>.Interface<long, string>.Method<Z>(T, U[], System.Collections.Generic.List<long>, System.Collections.Generic.Dictionary<string, Z>)").WithLocation(12, 35),
                // (18,18): error CS0540: 'Outer<T>.Inner<U>.Derived3.Outer<T>.Inner<U>.Interface<long, string>.Method<K>(T, U[], List<long>, Dictionary<string, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<long, string>'
                //             void Inner<U>.Interface<long, string>.Method<K>(T a, U[] B, List<long> C, Dictionary<string, K> d)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<long, string>").WithArguments("Outer<T>.Inner<U>.Derived3.Outer<T>.Inner<U>.Interface<long, string>.Method<K>(T, U[], System.Collections.Generic.List<long>, System.Collections.Generic.Dictionary<string, K>)", "Outer<T>.Inner<U>.Interface<long, string>").WithLocation(18, 18)
                );
        }

        [Fact]
        public void WriteOfReadonlyStaticMemberOfAnotherInstantiation01()
        {
            var text =
@"public static class Goo<T>
{
    static Goo()
    {
        Goo<T>.Y = 3;
    }

    public static int Y { get; }
}";
            CreateCompilation(text, options: WithNonNullTypesTrue(TestOptions.ReleaseDll)).VerifyDiagnostics();
            CreateCompilation(text, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), parseOptions: TestOptions.Regular.WithStrictFeature()).VerifyDiagnostics();
        }

        [Fact]
        public void TestOverrideGenericMethodWithTypeParamDiffNameWithCustomModifiers()
        {
            var text = @"
namespace Metadata
{
    using System;
    public class GD : Outer<string>.Inner<ulong>
    {
        public override void Method<X>(string[] x, ulong[] y, X[] z) { Console.Write(""Hello {0}"", z.Length); }

        static void Main()
        {
            new GD().Method<byte>(null, null, new byte[] { 0, 127, 255 });
        }
    }
}
";
            var verifier = CompileAndVerify(
                text,
                new[] { TestReferences.SymbolsTests.CustomModifiers.Modifiers.dll },
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe),
                expectedOutput: @"Hello 3",
                expectedSignatures: new[]
                {
                    // The ILDASM output is following,and Roslyn handles it correctly. 
                    // Verifier tool gives different output due to the limitation of Reflection
                    // @".method public hidebysig virtual instance System.Void Method<X>(" +
                    // @"System.String modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) x," +
                    // @"UInt64 modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) y," +
                    // @"!!X modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) z) cil managed")
                    Signature("Metadata.GD", "Method",
                              @".method public hidebysig virtual instance System.Void Method<X>(" +
                              @"modopt(System.Runtime.CompilerServices.IsConst) System.String[] x, " +
                              @"modopt(System.Runtime.CompilerServices.IsConst) System.UInt64[] y, modopt(System.Runtime.CompilerServices.IsConst) X[] z) cil managed"),
                });
        }

        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/30747 Type load failed.")]
        [WorkItem(30747, "https://github.com/dotnet/roslyn/issues/30747")]
        public void MissingTypeKindBasisTypes()
        {
            var source1 = @"
public struct A {}

public enum B {}

public class C {}
public delegate void D();

public interface I1 {}
";
            var compilation1 = CreateEmptyCompilation(source1, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { MinCorlibRef });
            compilation1.VerifyEmitDiagnostics();

            Assert.Equal(TypeKind.Struct, compilation1.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation1.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation1.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation1.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation1.GetTypeByMetadataName("I1").TypeKind);

            var source2 = @"
interface I2
{
    I1 M(A a, B b, C c, D d); 
}
";

            var compilation2 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference(), MinCorlibRef });

            compilation2.VerifyEmitDiagnostics();
            CompileAndVerify(compilation2);

            Assert.Equal(TypeKind.Struct, compilation2.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation2.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation2.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation2.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation2.GetTypeByMetadataName("I1").TypeKind);

            var compilation3 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference(), MinCorlibRef });

            compilation3.VerifyEmitDiagnostics();
            CompileAndVerify(compilation3);

            Assert.Equal(TypeKind.Struct, compilation3.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation3.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation3.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation3.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation3.GetTypeByMetadataName("I1").TypeKind);

            var compilation4 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference() });

            compilation4.VerifyDiagnostics(
                // (4,10): error CS0012: The type 'ValueType' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "A").WithArguments("System.ValueType", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 10),
                // (4,15): error CS0012: The type 'Enum' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "B").WithArguments("System.Enum", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 15),
                // (4,25): error CS0012: The type 'MulticastDelegate' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("System.MulticastDelegate", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 25)
                );

            var a = compilation4.GetTypeByMetadataName("A");
            var b = compilation4.GetTypeByMetadataName("B");
            var c = compilation4.GetTypeByMetadataName("C");
            var d = compilation4.GetTypeByMetadataName("D");
            var i1 = compilation4.GetTypeByMetadataName("I1");
            Assert.Equal(TypeKind.Class, a.TypeKind);
            Assert.NotNull(a.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, b.TypeKind);
            Assert.NotNull(b.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, c.TypeKind);
            Assert.Null(c.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, d.TypeKind);
            Assert.NotNull(d.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Interface, i1.TypeKind);
            Assert.Null(i1.GetUseSiteDiagnostic());

            var compilation5 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference() });

            compilation5.VerifyEmitDiagnostics(
                // warning CS8021: No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.
                Diagnostic(ErrorCode.WRN_NoRuntimeMetadataVersion).WithLocation(1, 1)
                );
            CompileAndVerify(compilation5);

            Assert.Equal(TypeKind.Struct, compilation5.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation5.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation5.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation5.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation5.GetTypeByMetadataName("I1").TypeKind);

            var compilation6 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference(), MscorlibRef });

            compilation6.VerifyDiagnostics(
                // (4,10): error CS0012: The type 'ValueType' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "A").WithArguments("System.ValueType", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 10),
                // (4,15): error CS0012: The type 'Enum' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "B").WithArguments("System.Enum", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 15),
                // (4,25): error CS0012: The type 'MulticastDelegate' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d); 
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("System.MulticastDelegate", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 25)
                );

            a = compilation6.GetTypeByMetadataName("A");
            b = compilation6.GetTypeByMetadataName("B");
            c = compilation6.GetTypeByMetadataName("C");
            d = compilation6.GetTypeByMetadataName("D");
            i1 = compilation6.GetTypeByMetadataName("I1");
            Assert.Equal(TypeKind.Class, a.TypeKind);
            Assert.NotNull(a.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, b.TypeKind);
            Assert.NotNull(b.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, c.TypeKind);
            Assert.Null(c.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, d.TypeKind);
            Assert.NotNull(d.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Interface, i1.TypeKind);
            Assert.Null(i1.GetUseSiteDiagnostic());

            var compilation7 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference(), MscorlibRef });

            compilation7.VerifyEmitDiagnostics();
            CompileAndVerify(compilation7);

            Assert.Equal(TypeKind.Struct, compilation7.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation7.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation7.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation7.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation7.GetTypeByMetadataName("I1").TypeKind);
        }

        [Fact]
        public void AccessPropertyWithoutArguments()
        {
            var source1 =
@"Imports System
Imports System.Runtime.InteropServices
<Assembly: PrimaryInteropAssembly(0, 0)> 
<Assembly: Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E210"")> 
<ComImport()>
<Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E211"")>
Public Interface I
    Property Value(Optional index As Object = Nothing) As Object
End Interface";
            var ref1 = BasicCompilationUtils.CompileToMetadata(source1);

            var source2 =
@"class C : I
{
    public dynamic get_Value(object index = null) => ""Test"";
    public void set_Value(object index = null, object value = null) { }
}
class Test
{
    static void Main()
    {
        I x = new C();
        System.Console.WriteLine(x.Value.Length);
    }
}";
            var comp = CreateCompilation(source2, new[] { ref1.WithEmbedInteropTypes(true), CSharpRef }, options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            CompileAndVerify(comp, expectedOutput: "4");
        }
    }
}
