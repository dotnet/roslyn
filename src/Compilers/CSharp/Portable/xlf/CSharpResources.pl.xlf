<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">Nie można utworzyć konstruowanego typu ogólnego z innego konstruowanego typu ogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">Nie można utworzyć konstruowanego typu ogólnego z typu nieogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">„{0}”: zdarzenie abstrakcyjne nie może używać składni metody dostępu zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">Aby użyć elementu „@$” zamiast elementu „$@” w interpolowanym ciągu dosłownym, użyj wersji języka „{0}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">Nie można zastosować operatora „{0}” do elementu „default” i operandu typu „{1}”, ponieważ jest to parametr typu, który nie jest znany jako typ referencyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">Nie można użyć typu referencyjnego dopuszczającego wartość null podczas tworzenia obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">Nazwy elementów nie są dozwolone przy dopasowywaniu wzorca za pośrednictwem elementu „System.Runtime.CompilerServices.ITuple”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Użycie typu odwołania dopuszczającego wartość null „{0}?” w wyrażeniu „as” jest niedozwolone. Zamiast tego użyj bazowego typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Atrybut „{0}” nie jest prawidłowy w metodach dostępu zdarzenia. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">Właściwość implementowana automatycznie „{0}” nie może być zadeklarowana jako „readonly”, ponieważ ma metodę dostępu „set”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Automatycznie implementowana metoda dostępu „set” „{0}” nie może być zadeklarowana jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance definition for '{1}'</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera odpowiedniej publicznej definicji wystąpienia elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznej definicji wystąpienia elementu „{1}”. Czy planowano użyć instrukcji „foreach”, a nie „await foreach”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">Nie można użyć kolekcji typu dynamicznego w asynchronicznej instrukcji foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla parametru /nullable; należy użyć opcji „disable”, „enable”, „warnings” lub „annotations”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">Nie można użyć operatora typeof w przypadku typu referencyjnego dopuszczającego wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">Nieprawidłowy operand dla dopasowania wzorca; wymagana jest wartość, a znaleziono „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">Błąd składni wiersza polecenia: „{0}” nie jest prawidłową wartością dla opcji „{1}”. Wartość musi mieć postać „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">Element __arglist nie może mieć argumentu przekazywanego przez parametr „in” ani „out”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Parametr typu „{1}” ma ograniczenie „unmanaged”, dlatego elementu „{1}” nie można użyć jako ograniczenia dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}”. Użyj wersji języka „{2}” lub nowszej, aby dopasować typ otwarty za pomocą wzorca stałej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">Nazwa „{0}” nie jest zgodna z odpowiednim parametrem „Deconstruct” „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu „{0}”, ponieważ ma nieabstrakcyjną składową. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">Brak typu docelowego dla literału domyślnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">Domyślny literał „default” nie jest prawidłowy jako wzorzec. Użyj innego odpowiedniego literału (np. „0” lub „null”). Aby dopasować wszystko, użyj wzorca odrzucania „_”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">Wzorzec odrzucania nie jest dozwolony jako etykieta instrukcji case w instrukcji switch. Użyj instrukcji „case var _:” w przypadku wzorca odrzucania lub użyj instrukcji „case @_:” w przypadku stałej o nazwie „_”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">Element „{0}” jest jawnie zaimplementowany więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">Zduplikowany operator pomijania wartości null („!”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">Nie można określić modyfikatorów „readonly” dla obu metod dostępu właściwości lub indeksatora „{0}”. Zamiast tego dodaj modyfikator „readonly” do samej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">Instrukcja nie może rozpoczynać się od elementu „else”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">Jawne stosowanie elementu „System.Runtime.CompilerServices.NullableAttribute” jest niedozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">Podanego wyrażenia nie można użyć w instrukcji fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać przypisania łączącego wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wartości elementu ref struct ani typu ograniczonego „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora == ani != krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'„{0}”: zdarzenie extern nie może mieć inicjatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">Funkcja „{0}” jest obecnie w wersji zapoznawczej i jest *nieobsługiwana*. Aby używać funkcji w wersji zapoznawczej, skorzystaj z wersji języka w wersji zapoznawczej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">Funkcja „{0}” jest eksperymentalna i nieobsługiwana. Aby ją włączyć, użyj parametru „/features:{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 8.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 8.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">Zdarzenie-pole „{0}” nie może być zadeklarowane jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">Instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznej definicji wystąpienia elementu „{1}”. Czy planowano użyć instrukcji „await foreach”, a nie „foreach”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">Instrukcja goto nie może przechodzić do lokalizacji występującej przed deklaracją using w tym samym bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">Instrukcja goto nie może przechodzić do lokalizacji występującej po deklaracji using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">Operator pominięcia jest niedozwolony w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">W wywołaniu niejawnego indeksatora indeksu nie może być nazwy argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">W wywołaniu niejawnego indeksatora zakresu nie może być nazwy argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">Nie można używać argumentów z modyfikatorem „in” w wyrażeniach przydzielanych dynamicznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">Obiekt „{0}” nie może implementować elementu członkowskiego interfejsu „{1}” w ramach typu „{2}”, ponieważ zawiera on parametr __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">Błąd wewnętrzny w kompilatorze języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">Nieprawidłowa nazwa algorytmu wyznaczania wartości skrótu: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">Nieprawidłowa operacja tworzenia obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">Nie można określić modyfikatorów „readonly” jednocześnie dla właściwości lub indeksatora „{0}” i jego metody dostępu. Usuń jeden z nich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">Nieprawidłowy specyfikator rangi: oczekiwano „]”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Użycie typu odwołania dopuszczającego wartość null „{0}?” w wyrażeniu „is-type” jest niedozwolone. Zamiast tego użyj bazowego typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">Wyrażenie typu „{0}” nigdy nie zostanie dopasowane do podanego wzorca.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">Metoda „{0}” z blokiem iteratora musi być oznaczona jako „async”, aby zwrócić „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">Brak wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">Wiele plików konfiguracji analizatora nie może znajdować się w tym samym katalogu („{0}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">Nie można użyć atrybutu [EnumeratorCancellation] w wielu parametrach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">Ograniczenie „new()” nie może być używane z ograniczeniem „unmanaged”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">„{0}”: Typ użyty w asynchronicznej instrukcji using musi być jawnie konwertowalny na typ „System.IAsyncDisposable” lub musi implementować odpowiednią metodę „DisposeAsync”. Czy chodziło Ci o użycie instrukcji „using”, a nie „await using”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">„{0}”: typ użyty w instrukcji using musi umożliwiać niejawną konwersję na interfejs „System.IDisposable”. Czy chodziło Ci o instrukcję „await using”, a nie „using”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstraintMustBeFirst">
        <source>The 'notnull' constraint must come before any other constraints</source>
        <target state="translated">Ograniczenie „notnull” musi występować przed wszystkimi innymi ograniczeniami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">Oczekiwano opcji „enable”, „disable” lub „restore”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">Oczekiwano opcji „warnings” lub „annotations” albo końca dyrektywy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">Nieprawidłowa wartość „{0}”: „{1}” dla języka C# {2}. Użyj wersji języka „{3}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">Nullowalny parametr typumusi być typem wartości lub nienullowalnym typem referencyjnym. Rozważ dodanie elementu „class”, „struct” lub ograniczenia typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">Zmiennej out nie można zadeklarować jako lokalnej zmiennej ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">Metoda „{0}” określa ograniczenie „class” dla parametru typu „{1}”, lecz odpowiadający parametr typu „{2}” przesłoniętej lub jawnie zaimplementowanej metody „{3}” nie jest typem referencyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">Metoda „{0}” określa ograniczenie „struct” dla parametru typu „{1}”, lecz odpowiadający parametr typu „{2}” przesłoniętej lub jawnie zaimplementowanej metody „{3}” nie jest nienullowalnym typem wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReadOnlyDifference">
        <source>Both partial method declarations must be readonly or neither may be readonly</source>
        <target state="translated">Obie metody częściowe muszą być zadeklarowane jako readonly lub żadna nie może być zadeklarowana jako readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">Dopasowanie wzorca jest niedozwolone dla typów wskaźnika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">Treść metody iteratora asynchronicznego musi zawierać instrukcję „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">Treść metody iteratora asynchronicznego musi zawierać instrukcję „yield”. Rozważ usunięcie modyfikatora „async” z deklaracji metody lub dodanie instrukcji „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">Wzorzec podrzędny właściwości wymaga odwołania do właściwości lub pola, które należy dopasować, na przykład „{{ Name: {0} }}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu „{0}”, ponieważ zawiera ponowną abstrakcję składowej z interfejsu podstawowego. Rozważ ustawienie właściwości „Osadź typy międzyoperacyjne” na wartość false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'„{0}”: modyfikatora „readonly” można użyć dla metod dostępu tylko wtedy, gdy właściwość lub indeksator mają metody dostępu get i set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Nie można przypisać odwołania elementu „{1}” do elementu „{0}”, ponieważ element „{1}” ma węższy zakres wyjścia niż element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref local or parameter.</source>
        <target state="translated">Lewa strona przypisania odwołania musi być odwołaniem lokalnym lub parametrem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje specyfikatorów dostępu „protected”, „protected internal” i „private protected” dla składowej interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">Wzorzec dekonstrukcji z jednym elementem wymaga innej składni w celu ujednoznacznienia. Zaleca się dodanie desygnatora odrzucania „_” po nawiasie zamykającym „)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Statyczna funkcja lokalna nie może zawierać odwołania do elementu „this” lub „base”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">Statyczna funkcja lokalna nie może zawierać odwołania do elementu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Składowa statyczna „{0}” nie może być oznaczona jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern has already been handled by a previous arm of the switch expression.</source>
        <target state="translated">Wzorzec został już obsłużony przez poprzednie rozgałęzienie wyrażenia switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case has already been handled by a previous case.</source>
        <target state="translated">Etykieta case wyrażenia switch została już obsłużona przez poprzednią etykietę case.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">Nie znaleziono najlepszego typu dla wyrażenia switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">Wymagane są nawiasy wokół wyrażenia sterującego instrukcją switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">Nieoczekiwana sekwencja znaków „...”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">Nazwa „{0}” nie identyfikuje elementu krotki „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">Typy krotek używane jako operandy operatorów == lub != muszą mieć zgodne kardynalności. Ten operator zawiera natomiast typy krotek o kardynalności {0} z lewej strony i {1} z prawej strony.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">„{0}”: nie można jednocześnie określić klasy ograniczenia i ograniczenia „unmanaged”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintMustBeFirst">
        <source>The 'unmanaged' constraint must come before any other constraints</source>
        <target state="translated">Ograniczenie „unmanaged” musi występować przed wszystkimi innymi ograniczeniami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być nienullowalnym typem wartości (podobnie jak wszystkie pola na wszystkich poziomach zagnieżdżenia), aby można było używać go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">Nie można użyć zmiennej użycia bezpośrednio w sekcji instrukcji switch (rozważ użycie nawiasów klamrowych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">Składnia „var” dla wzorca nie może odwoływać się do typu, ale element „{0}” należy tutaj do zakresu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">Wyliczenia, klasy i struktury nie mogą być deklarowane w interfejsie mającym parametr typu „in” lub „out”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">Dopasowanie typu krotki „{0}” wymaga „{1}” wzorców podrzędnych, ale istnieje następująca liczba wzorców podrzędnych: „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Nazwa pliku „{0}” jest pusta, zawiera nieprawidłowe znaki, zawiera specyfikację dysku bez bezwzględnej ścieżki lub jest za długa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
-warn:&lt;n&gt;                     Set warning level (0-4) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
</source>
        <target state="translated">
                             Opcje kompilatora Visual C#

                        - PLIKI WYJŚCIOWE -
-out:&lt;plik&gt;                   Określ nazwę pliku wyjściowego (domyślnie: nazwa podstawowa 
                              pliku z klasą główną lub pierwszym plikiem)
-target:exe                   Kompiluj plik wykonywalny konsoli (domyślnie) (krótka 
                              wersja: -t:exe)
-target:winexe                Kompiluj plik wykonywalny systemu Windows (krótka wersja: 
                              -t:winexe)
-target:library               Kompiluj bibliotekę (krótka wersja: -t:library)
-target:module                Kompiluj moduł, który można dodać do innego 
                              zestawu (krótka wersja: -t:module)
-target:appcontainerexe       Kompiluj plik wykonywalny kontenera aplikacji (krótka wersja: 
                              -t:appcontainerexe)
-target:winmdobj              Kompiluj plik pośredni środowiska uruchomieniowego systemu Windows 
                              przeznaczony dla narzędzia WinMDExp (krótka wersja: -t:winmdobj)
-doc:&lt;plik&gt;                   Plik dokumentacji XML do wygenerowania
-refout:&lt;plik&gt;                Dane wyjściowe zestawu odwołania do wygenerowania
-platform:&lt;ciąg&gt;              Ogranicz platformy, na których można uruchamiać ten kod: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred lub 
                              anycpu. Wartość domyślna to anycpu.

                        - PLIKI WEJŚCIOWE -
-recurse:&lt;symbol wieloznaczny&gt; Uwzględnij wszystkie pliki zawarte w bieżącym katalogu i 
                               podkatalogach zgodnie ze specyfikacją określoną przy użyciu 
                               symboli wieloznacznych
-reference:&lt;alias&gt;=&lt;plik&gt;     Odwołuj się do metadanych z określonego pliku 
                              zestawu przy użyciu podanego aliasu (krótka wersja: -r)
-reference:&lt;lista_plików&gt;     Odwołuj się do metadanych z określonych 
                              plików zestawów (krótka wersja: -r)
-addmodule:&lt;lista plików&gt;     Połącz określone moduły z tym zestawem
-link:&lt;lista_plików&gt;          Osadź metadane z określonych plików 
                              zestawów międzyoperacyjnych (krótka wersja: -l)
-analyzer:&lt;lista_plików&gt;      Uruchom analizatory z tego zestawu
                              (krótka wersja: -a)
-additionalfile:&lt;lista_plików&gt; Dodatkowe pliki, które nie mają bezpośredniego wpływu na generowanie
                               kodu, ale mogą być używane przez analizatory w celu tworzenia
                               komunikatów o błędach lub ostrzeżeń.
-embed                        Osadź wszystkie pliki źródłowe w pliku PDB.
-embed:&lt;lista plików&gt;         Osadź określone pliki w pliku PDB

                        - ZASOBY -
-win32res:&lt;plik&gt;              Określ plik zasobu Win32 (res)
-win32icon:&lt;plik&gt;             Użyj tej ikony dla pliku wyjściowego
-win32manifest:&lt;plik&gt;         Określ plik manifestu środowiska Win32 (xml)
-nowin32manifest              Nie dołączaj domyślnego manifestu środowiska Win32
-resource:&lt;informacje_o_zasobie&gt; Osadź określony zasób (krótka wersja: -res)
-linkresource:&lt;informacje_o_zasobie&gt; Połącz określony zasób z tym zestawem 
                               (krótka wersja: -linkres), gdzie format informacji o zasobie 
                               to &lt;plik&gt;[,&lt;nazwa ciągu&gt;[,public|private]]

                        - GENEROWANIE KODU -
-debug[+|-]                   Emituj informacje o debugowaniu
-debug:{full|pdbonly|portable|embedded}
                              Określ typ debugowania (wartość domyślna to „full”, 
                              wartość „portable” to format międzyplatformowy,
                              a wartość „embedded” to format międzyplatformowy wbudowany w 
                              docelowym pliku DLL lub EXE)
-optimize[+|-]                Włącz optymalizacje (krótka wersja: -o)
-deterministic                Utwórz zestaw deterministyczny
                              (zawierający sygnaturę czasową i identyfikator GUID wersji modułu)
-refonly                      Utwórz zestaw odwołania zamiast głównych danych wyjściowych
-instrument:TestCoverage      Utwórz zestaw instrumentowany w celu gromadzenia
                              informacji o pokryciu
-sourcelink:&lt;plik&gt;            Informacje o linku źródłowym na potrzeby osadzenia w pliku PDB.

                        - BŁĘDY I OSTRZEŻENIA -
-warnaserror[+|-]             Zgłaszaj wszystkie ostrzeżenia jako błędy
-warnaserror[+|-]:&lt;lista_ostrzeżeń&gt; Zgłaszaj określone ostrzeżenia jako błędy
-warn:&lt;n&gt;                     Ustaw poziom ostrzeżeń (0–4) (krótka wersja: -w)
-nowarn:&lt;lista_ostrzeżeń&gt;     Wyłącz określone komunikaty ostrzeżeń
-ruleset:&lt;plik&gt;               Określ plik zestawu reguł wyłączający określone
                              funkcje diagnostyczne.
-errorlog:&lt;plik&gt;[,version=&lt;wersja_sarif&gt;]
                              Określ plik w celu rejestrowania wszystkich
                              danych diagnostycznych kompilatora i analizatora.
                              sarif_version:{1|2|2.1} Domyślne wartości 1. 2 i 2.1
                              oznaczają format SARIF w wersji 2.1.0.
-reportanalyzer               Zgłaszaj dodatkowe informacje analizatora, takie jak
                              czas wykonywania.
 
                        -JĘZYK -
-checked[+|-]                 Generuj operacje sprawdzenia przepełnienia
-unsafe[+|-]                  Zezwalaj na niebezpieczny kod
-define:&lt;lista symboli&gt;       Zdefiniuj symbole kompilacji warunkowej (krótka 
                              wersja: -d)
-langversion:?                Wyświetl dozwolone wartości dla wersji języka
-langversion:&lt;ciąg&gt;           Określ wersję języka, na przykład
                              „latest” (najnowsza wersja z uwzględnieniem wersji pomocniczych),
                              „default” (to samo co „latest”),
                              „latestmajor” (najnowsza wersja z pominięciem wersji pomocniczych),
                              „preview” (najnowsza wersja z uwzględnieniem funkcji w nieobsługiwanej wersji zapoznawczej),
                              lub konkretną wersję, taką jak „6” lub „7.1”
-nullable[+|-]                Określ, czy opcja kontekstu dopuszczającego wartość null jest włączona, czy wyłączona.
-nullable:{enable|disable|warnings|annotations}
                              Określ opcję kontekstu dopuszczającego wartość null: enable|disable|warnings|annotations.

                        - ZABEZPIECZENIA -
-delaysign[+|-]               Podpisz z opóźnieniem zestaw, używając tylko 
                              części publicznej klucza o silnej nazwie
-publicsign[+|-]              Podpisz publicznie zestaw, używając tylko
                              części publicznej klucza o silnej nazwie
-keyfile:&lt;plik&gt;               Określ plik klucza o silnej nazwie
-keycontainer:&lt;ciąg&gt;          Określ kontener klucza o silnej nazwie
-highentropyva[+|-]           Włącz losowe generowanie układu przestrzeni adresowej o wysokiej entropii

                        - RÓŻNE -
@&lt;plik&gt;                       Odczytaj plik odpowiedzi w celu uzyskania dodatkowych opcji
-help                         Wyświetl ten komunikat dotyczący użycia (krótka wersja: -?)
-nologo                       Pomiń komunikat kompilatora o prawach autorskich
-noconfig                     Nie dołączaj automatycznie pliku CSC.RSP
-parallel[+|-]                Kompilacja współbieżna
-version                      Wyświetl numer wersji kompilatora i zakończ

                        - ZAAWANSOWANE -
-baseaddress:&lt;adres&gt;          Adres podstawowy dla biblioteki do skompilowania
-checksumalgorithm:&lt;algorytm&gt; Określ algorytm do obliczania sumy kontrolnej
                              pliku źródłowego przechowywanej w pliku PDB.
                              Obsługiwane wartości: SHA1 lub SHA256 (domyślnie).
-codepage:&lt;n&gt;                 Określ stronę kodową do użycia podczas otwierania 
                              plików źródłowych
-utf8output                   Wyprowadź komunikaty kompilatora przy użyciu kodowania UTF-8
-main:&lt;typ&gt;                   Określ typ zawierający punkt wejścia 
                              (zignoruj wszystkie pozostałe możliwe punkty wejścia) (krótka 
                              wersja: -m)
-fullpaths                    Kompilator generuje w pełni kwalifikowane ścieżki
-filealign:&lt;n&gt;                Określ wyrównanie stosowane dla sekcji 
                              plików wyjściowych
-pathmap:&lt;K1&gt;=&lt;W1&gt;,&lt;K2&gt;=&lt;W2&gt;,... 
                              Określ mapowanie dla nazw ścieżek źródłowych wyprowadzanych przez 
                              kompilator.
-pdb:&lt;plik&gt;                   Określ nazwę pliku z informacjami o debugowaniu (domyślnie: 
                              nazwa pliku wyjściowego z rozszerzeniem pdb)
-errorendlocation             Wyprowadź wiersz i kolumnę lokalizacji końcowej dla 
                              każdego błędu
-preferreduilang              Określ nazwę preferowanego języka wyjściowego.
-nosdkpath                    Wyłącz przeszukiwanie domyślnej ścieżki zestawu SDK dla zestawów biblioteki standardowej.
-nostdlib[+|-]                Nie odwołuj się do biblioteki standardowej (mscorlib.dll)
-subsystemversion:&lt;ciąg&gt;      Określ wersję podsystemu tego zestawu
-lib:&lt;lista plików&gt;           Określ dodatkowe katalogi do przeszukania pod kątem 
                              odwołań
-errorreport:&lt;ciąg&gt;           Określ, w jaki sposób obsługiwać wewnętrzne błędy kompilatora: 
                              prompt, send, queue lub none. Wartość domyślna to 
                              queue.
-appconfig:&lt;plik&gt;             Określ plik konfiguracji aplikacji 
                              zawierający ustawienia powiązania zestawu
-moduleassemblyname:&lt;ciąg&gt;    Nazwa zestawu, którego częścią 
                              ma być ten moduł
-modulename:&lt;ciąg&gt;            Określ nazwę modułu źródłowego
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">domyślna implementacja interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">możliwy do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">alternatywne interpolowane ciągi dosłowne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">asynchroniczna instrukcja using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">przypisanie łączące</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">ogólne ograniczenia typów delegowania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">ogólne ograniczenia typów wyliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">deklaracje zmiennych wyrażeń w inicjatorach elementów członkowskich i zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">rozszerzalna instrukcja fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">operator indeksowania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">indeksowanie możliwych do przenoszenia buforów fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">parametry odrzucania wyrażenia lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">zasłanianie nazw w funkcjach zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">Element stackalloc w wyrażeniach zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">ogólne ograniczenie typu notnull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">typy referencyjne dopuszczające wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">przestarzałe w metodzie dostępu właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">akcja warning: enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">operator zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">składowe tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">wzorce rekursywne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">wyrażenie warunkowe ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">zmienne pętli for odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">zmienna iteracji foreach odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">ponowne przypisanie odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">inicjator stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">statyczne funkcje lokalne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;wyrażenie przełącznika&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">równość krotki</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">parametry typu bez ograniczeń w operatorze łączenia wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">niezarządzane typy konstruowane</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">ogólne niezarządzane ograniczenia typów</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">deklaracje using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">ograniczenia dla przesłonięć i jawnych metod implementacji interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;wyrażenie throw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(Lokalizacja symbolu związanego z poprzednim błędem)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(Lokalizacja symbolu związanego z poprzednim ostrzeżeniem)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> Nie można dołączyć nieprawidłowo sformułowanego pliku XML „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> Nie można wstawić części lub całości dołączonego kodu XML </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Tag Include jest nieprawidłowy </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> Dla następującego tagu Include nie znaleziono żadnych zgodnych elementów </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">Brak atrybutu pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">Brak atrybutu ścieżki</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;globalna przestrzeń nazw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">ogólne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">metody anonimowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">moduł jako specyfikator elementu docelowego atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">kwalifikator aliasu przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">bufory o ustalonym rozmiarze</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">klasy statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">struktury tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">typy częściowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">funkcja async</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">włącz typ wartości logicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">grupa metod</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">metoda anonimowa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">wyrażenie lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">kolekcja</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">modyfikatory dostępu we właściwościach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">iteratory</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">operator domyślny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">domyślny literał</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">prywatny chroniony</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">typy dopuszczające wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">dopasowanie wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">metoda dostępu właściwości treści wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">konstruktor i destruktor treści wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">wyrażenie throw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">niejawnie typizowana tablica</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">niejawnie typizowana zmienna lokalna</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">typy anonimowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">automatycznie zaimplementowane właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">automatycznie implementowane właściwości tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">inicjator obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">inicjator kolekcji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">wyrażenie zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">metoda rozszerzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">metoda częściowa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">typ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">przestrzeń nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">pole</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">element</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">zmienna</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">etykieta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">zdarzenie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">alias użycia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">konstruktor</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">zmienna iteracji foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">zmienna ustalona</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">zmienna użycia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">kontrawariantny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">kontrawariantnie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">kowariantny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">kowariantnie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">niezmiennie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">dynamiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">argument nazwany</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">parametr opcjonalny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">filtr wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">typ wariancji</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">Element SyntaxTree nie jest częścią kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">Element SyntaxTree nie jest częścią kompilacji, więc nie można go usunąć</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">Nazwa „_” odwołuje się do stałej, a nie do wzorca odrzucania. Użyj elementu „var _”, aby odrzucić wartość, lub użyj elementu „@_”, aby odwołać się do stałej za pomocą tej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">Nie używaj elementu „_” dla stałej case.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Konwertowanie literału o wartości null lub możliwej wartości null na nienullowalny typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Konwertowanie literału o wartości null lub możliwej wartości null na nienullowalny typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="needs-review-translation">Możliwa wartość null nie może być przekazywana do elementu docelowego oznaczonego atrybutem [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="needs-review-translation">Możliwa wartość null nie może być przekazywana do elementu docelowego oznaczonego atrybutem [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">Element „{0}” występuje już na liście interfejsów dla typu „{1}” z inną obsługą wartości null typów referencyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">Interfejs występuje już na liście interfejsów z inną obsługą wartości null typów referencyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Dane wyrażenie jest zawsze zgodne z podaną stałą.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Dane wyrażenie jest zawsze zgodne z podaną stałą.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie nigdy nie jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie nigdy nie jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">Wywołanie składowej innej niż tylko do odczytu „{0}” ze składowej zadeklarowanej jako „readonly” może spowodować niejawne utworzenie kopii elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">Wywołanie składowej innej niż tylko do odczytu ze składowej zadeklarowanej jako „readonly” może spowodować niejawne utworzenie kopii.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">Nazwa „_” odwołuje się do typu „{0}”, a nie do wzorca odrzucania. Użyj elementu „@_” aby odwołać się do typu, lub użyj elementu „var _”, aby odrzucić wartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">Nie używaj elementu „_” w celu odwoływania się do typu w wyrażeniu „is” z typem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana tylko w kodzie z kontekstem adnotacji „#nullable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana w kodzie tylko w ramach kontekstu adnotacji „#nullable”. Wygenerowany automatycznie kod wymaga jawnej dyrektywy „#nullable” w źródle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana w kodzie tylko w ramach kontekstu adnotacji „#nullable”. Wygenerowany automatycznie kod wymaga jawnej dyrektywy „#nullable” w źródle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana tylko w kodzie z kontekstem adnotacji „#nullable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Nie można przekonwertować literału o wartości null na nienullowalny typ referencyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Nie można przekonwertować literału o wartości null na nienullowalny typ referencyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">Możliwy argument odwołania o wartości null dla parametru „{0}” w „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">Możliwy argument odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">Możliwe przypisanie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">Możliwe przypisanie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">Inicjator obiektu lub kolekcji niejawnie wyłuskuje składową o możliwej wartości null „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">Inicjator obiektu lub kolekcji niejawnie wyłuskuje składową o możliwej wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Wyłuskanie odwołania, które może mieć wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Wyłuskanie odwołania, które może mieć wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">Możliwe zwrócenie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">Możliwe zwrócenie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu typu „{0}” nie można użyć dla parametru „{2}” typu „{1}” w elemencie „{3}” z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu typu „{0}” nie można użyć jako danych wyjściowych typu „{1}” dla parametru „{2}” w elemencie „{3}” z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu nie można użyć jako danych wyjściowych dla parametru z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu nie można użyć dla parametru z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w wartości typu „{0}” jest niezgodna z typem docelowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w wartości jest niezgodna z typem docelowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Obsługa wartości null w ograniczeniach dla parametru typu „{0}” metody „{1}” jest niezgodna z ograniczeniami parametru typu „{2}” metody interfejsu „{3}”. Rozważ użycie jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">Obsługa wartości null w ograniczeniach dla parametru typu jest niezgodna z ograniczeniami parametru typu w niejawnie implementowanej metodzie interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">Deklaracje metod częściowych elementu „{0}” mają niespójne opcje dopuszczania wartości null w ograniczeniach parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">Deklaracje metod częściowych mają niespójne opcje dopuszczania wartości null w ograniczeniach dla parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w jawnym specyfikatorze interfejsu jest niezgodna z interfejsem implementowanym przez typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w jawnym specyfikatorze interfejsu jest niezgodna z interfejsem implementowanym przez typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Obsługa wartości null dla typów referencyjnych w interfejsie implementowanym przez typ podstawowy jest niezgodna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Typ nie implementuje składowej interfejsu. Obsługa wartości null dla typów referencyjnych w interfejsie implementowanym przez typ podstawowy jest niezgodna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” elementu „{1}” jest niezgodna z delegatem docelowym „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z delegatem docelowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” „{1}” jest niezgodna z niejawnie implementowaną składową „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym elementu „{0}” jest niezgodna z delegatem docelowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym elementu jest niezgodna z delegatem docelowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z implementowaną składową „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym „{0}” jest niezgodna z niejawnie implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z implementowaną składową „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie „{0}” jest niezgodna z niejawnie implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{3}” jest niezgodna z typem ograniczenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z typem ograniczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">Nie można użyć typu „{2}” jako parametru typu „{1}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{2}” jest niezgodna z ograniczeniem „notnull”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z ograniczeniem „notnull”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">Nie można użyć typu „{2}” jako parametru typu „{1}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{2}” jest niezgodna z ograniczeniem „class”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z ograniczeniem „class”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Typ wartości dopuszczający wartość null może być równy null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Typ wartości dopuszczający wartość null może być równy null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' may not have a null value when exiting with '{1}'.</source>
        <target state="new">Parameter '{0}' may not have a null value when exiting with '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter may not have a null value when exiting in some condition.</source>
        <target state="new">Parameter may not have a null value when exiting in some condition.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="new">A method marked [DoesNotReturn] should not return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="new">A method marked [DoesNotReturn] should not return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości jego typu danych wejściowych (nie jest kompletne).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive).</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null (nie jest kompletne).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości jego typu danych wejściowych (nie jest kompletne).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">Zgłoszona wartość może być równa null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">Zgłoszona wartość może być równa null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została zignorowana, ponieważ po drugiej stronie operatora == lub != krotki określono inną nazwę lub nie określono żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Nazwa elementu krotki została zignorowana, ponieważ po drugiej stronie operatora == lub != krotki określono inną nazwę lub nie określono żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co parametr typu z metody zewnętrznej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">Parametr typu ma ten sam typ co parametr typu z metody zewnętrznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Konwersja unboxing wartości, która może być wartością null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Konwersja unboxing wartości, która może być wartością null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Atrybut EnumeratorCancellationAttribute zastosowany dla parametru „{0}” nie będzie miał żadnego efektu. Atrybut jest uwzględniany tylko dla parametru typu CancellationToken w asynchronicznej metodzie iteratora zwracającej interfejs IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Atrybut EnumeratorCancellationAttribute nie będzie miał żadnego efektu. Atrybut jest uwzględniany tylko dla parametru typu CancellationToken w asynchronicznej metodzie iteratora zwracającej interfejs IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Iterator asynchroniczny „{0}” ma co najmniej jeden parametr typu „CancellationToken”, ale żaden z nich nie ma atrybutu „EnumeratorCancellation” i dlatego zostanie wykorzystany parametr tokenu anulowania z wygenerowanego elementu „IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Element członkowski iteratora asynchronicznego ma co najmniej jeden parametr typu „CancellationToken”, ale żaden z nich nie ma atrybutu „EnumeratorCancellation” i dlatego zostanie wykorzystany parametr tokenu anulowania z wygenerowanego elementu „IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' is uninitialized. Consider declaring the {0} as nullable.</source>
        <target state="translated">Nienullowalny element {0} „{1}” jest niezainicjowany. Rozważ zadeklarowanie elementu {0} jako nullowalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field is uninitialized. Consider declaring as nullable.</source>
        <target state="translated">Nienullowalne pole jest niezainicjowane. Rozważ zadeklarowanie go jako nullowalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">Znaków „{0}” nie można użyć w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">Użyto nieprawidłowej składni w komentarzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">Znaleziono nieprawidłowy znak wewnątrz odwołania do jednostki.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">Oczekiwano ciągu „&gt;” lub „/&gt;” zamykającego tag „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">Oczekiwano identyfikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Nieprawidłowy znak Unicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">Białe znaki są niedozwolone w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">Znaku „&lt;” nie można użyć w wartości atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">Brak znaku równości między atrybutem i wartością atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">Odwołanie do niezdefiniowanej jednostki „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">Oczekiwano literału ciągu, lecz nie znaleziono otwierającego znaku cudzysłowu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">Brak zamykającego znaku cudzysłowu dla literału ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">Nie można używać znaków cudzysłowu spoza zestawu znaków ASCII wokół literałów ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">Tag końcowy jest nieoczekiwany w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">Tag końcowy „{0}” nie jest zgodny z tagiem początkowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">Oczekiwano tagu końcowego dla elementu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">Brak wymaganego białego znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">Nieoczekiwany znak w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">Ciąg literału „]]&gt;” jest niedozwolony w zawartości elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Zduplikowany atrybut „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">Nie można znaleźć pliku metadanych „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">Odwołania do metadanych nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">Nie można otworzyć pliku metadanych „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w nieprzywoływanym zestawie. Musisz dodać odwołanie do zestawu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w module, który nie został dodany. Musisz dodać moduł „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">Nie można zapisać do pliku wyjściowego „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">W programie zdefiniowano więcej niż jeden punkt wejścia. Skompiluj z opcją /main, aby określić typ zawierający punkt wejścia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do argumentów operacji typu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">Dzielenie przez wartość stałą wynoszącą zero</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">Do wyrażenia typu „{0}” nie można zastosować indeksowania przy użyciu konstrukcji [].</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">Wewnątrz konstrukcji [] występuje niewłaściwa liczba indeksów. Oczekiwana liczba: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do argumentu operacji typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefault">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do operandu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">W przypadku statycznej właściwości, statycznej metody lub statycznego inicjatora pola użycie słowa kluczowego „this” jest nieprawidłowe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">W bieżącym kontekście słowo kluczowe „this” jest niedostępne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'Element „{0}” ma nieprawidłową sygnaturę i nie może być punktem wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">Metoda ma nieprawidłową sygnaturę i nie może być punktem wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">Nie można niejawnie przekonwertować typu „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">Nie można przekonwertować typu „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">Nie można przekonwertować wartości stałej „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">Operator „{0}” jest niejednoznaczny dla operandów typu „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands 'default' and 'default'</source>
        <target state="translated">Operator „{0}” jest niejednoznaczny dla operandów „default” i „default”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">Dla argumentu operacji typu „{0}” operator „{1}” jest niejednoznaczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">W parametrze wyjściowym nie może występować atrybut wejściowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">Nie można przekonwertować wartości null na „{0}”, ponieważ jest to nienullowalny typ wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">Nie można przekonwertować typu „{0}” na „{1}” za pomocą konwersji odwołania, konwersji pakującej, konwersji rozpakowującej, konwersji opakowującej ani konwersji na typ zerowy</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">Wystąpił nieoczekiwany błąd podczas zapisywania informacji debugowania — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż metoda „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż metoda „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">Niespójność dostępności: typ pola „{1}” jest mniej dostępny niż pole „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">Niespójność dostępności: typ właściwości „{1}” jest mniej dostępny niż właściwość „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany indeksatora „{1}” jest mniej dostępny niż indeksator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż indeksator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż operator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż operator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">Niespójność dostępności: klasa bazowa „{1}” jest mniej dostępna niż klasa „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">Niespójność dostępności: interfejs podstawowy „{1}” jest mniej dostępny niż interfejs „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': dla właściwości zdarzenia muszą istnieć metody dostępu Add i Remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'„{0}”: typ zdarzenia musi być zgodny z typem delegowanym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">Zdarzenie „{0}” nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">Zdarzenie nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'„{0}”: zdarzenie wystąpienia w interfejsie nie może mieć inicjatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">Zdarzenie „{0}” może występować tylko po lewej stronie symboli += lub -= (z wyjątkiem sytuacji, w której używane jest z wnętrza typu „{1}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">Jawna implementacja interfejsu zdarzenia musi używać składni metody dostępu zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'„{0}”: nie można przesłonić. Element „{1}” nie jest zdarzeniem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">Metoda dostępu add lub remove musi mieć treść</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'„{0}”: nie może istnieć inicjator zdarzenia abstrakcyjnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">Nazwa zestawu „{0}” jest zarezerwowana i nie można jej użyć jako odwołania w sesji interaktywnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">Nazwa typu wyliczeniowego „{0}” jest zarezerwowana i nie można jej użyć</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">Operatora „as” należy używać z typem referencyjnym lub typem nullowalnym („{0}” jest typem nienullowalnym)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">Sufiks „l” z łatwością można pomylić z cyfrą „1” — w celu zachowania jednoznaczności użyj sufiksu „L”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">Sufiks „l” można łatwo pomylić z cyfrą „1”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">Zdarzenie „{0}” może pojawić się tylko po lewej stronie wyrażenia += lub -=.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">Ograniczenia są niedozwolone w deklaracjach innych niż ogólne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">Deklaracja parametru typu musi być identyfikatorem, a nie typem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">Typ „{1}” już rezerwuje składową o nazwie „{0}” z tymi samymi typami parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">Nazwa parametru „{0}” jest duplikatem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">Przestrzeń nazw „{0}” już zawiera definicję dla „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">Typ „{0}” już zawiera definicję dla „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">Nazwa „{0}” nie istnieje w bieżącym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">Nazwa „{0}” nie istnieje w bieżącym kontekście (brak odwołania do zestawu „{1}”?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'Element „{0}” to niejednoznaczne odwołanie między elementem „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">Dyrektywa using dla elementu „{0}” już wystąpiła w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">Dyrektywa using występowała wcześniej w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">Modyfikator „{0}” jest nieprawidłowy dla tego elementu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">Więcej niż jeden modyfikator ochrony</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'Element „{0}” ukrywa odziedziczoną składową „{1}”. Użyj słowa kluczowego new, jeśli ukrycie jest zamierzone.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">Składowa ukrywa dziedziczoną składową; brak słowa kluczowego new</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base class. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">Zmienna została zadeklarowana przy użyciu tej samej nazwy co zmienna w klasie bazowej. Jednak nie użyto słowa kluczowego new. To ostrzeżenie informuje o konieczności użycia słowa kluczowego new. Zmienna została zadeklarowana tak, jakby użyto słowa kluczowego new w deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">Składowa „{0}” nie ukrywa składowej z możliwością dostępu. Słowo kluczowe new nie jest wymagane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">Składowa nie ukrywa dziedziczonej składowej; słowo kluczowe new nie jest wymagane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">Obliczanie wartości stałej dla elementu „{0}” obejmuje definicję cykliczną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">Typ „{1}” już definiuje składową o nazwie „{0}” z tymi samymi typami parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member '{0}' cannot be marked as override, virtual, or abstract</source>
        <target state="translated">Statycznej składowej „{0}” nie można oznaczyć specyfikatorem override, virtual ani abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">Dla składowej „{0}” ze specyfikatorem override nie można określić specyfikatora new ani virtual</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'Element „{0}” ukrywa odziedziczoną składową „{1}”. Aby przesłonić tę implementację bieżącą składową, dodaj słowo kluczowe override. W przeciwnym razie dodaj słowo kluczowe new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">Składowa ukrywa dziedziczoną składową; brak słowa kluczowego override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'„{0}”: nie znaleziono odpowiedniej metody do przesłonięcia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields or methods</source>
        <target state="translated">Przestrzeń nazw nie może bezpośrednio zawierać składowych, takich jak pola lub metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'Element „{0}” nie zawiera definicji „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'Element „{0}” to element {1}, ale jest używany jak element {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'Element „{0}” to element „{1}”, który jest nieprawidłowy w podanym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">Dla niestatycznego pola, metody lub właściwości „{0}” wymagane jest odwołanie do obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">Wystąpiło niejednoznaczne wywołanie między następującymi dwiema metodami lub właściwościami: „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'Element „{0}” jest niedostępny z powodu swojego poziomu ochrony.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">Żadne z przeciążeń dla elementu „{0}” nie pasuje do delegata „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">Wymagany jest obiekt, który można przekonwertować na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">Ponieważ element „{0}” zwraca wartość typu void, po słowie kluczowym nie może występować wyrażenie obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">Lokalna zmienna lub funkcja o nazwie „{0}” została już zdefiniowana w tym zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">Lewa strona przypisania musi być zmienną, właściwością lub indeksatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'„{0}”: konstruktor statyczny nie może mieć parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">Wyrażenie przypisane do elementu „{0}” musi być stałą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'Typ elementu „{0}” to „{1}”. Pole stałe typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">Element lokalny lub parametr o nazwie „{0}” nie może zostać zadeklarowany w tym zakresie, ponieważ ta nazwa jest już użyta w otaczającym zakresie lokalnym do zdefiniowania elementu lokalnego lub parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">Dyrektywa „using namespace” może być stosowana tylko do przestrzeni nazw. Element „{0}” to typ, a nie przestrzeń nazw. Zamiast tego rozważ użycie dyrektywy „using static”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">Dyrektywa „using static” może być stosowana tylko do typów. Element „{0}” to przestrzeń nazw, a nie typ. Zamiast tego rozważ użycie dyrektywy „using namespace”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">Za pomocą dyrektywy „using static” nie można deklarować aliasu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">Brak pętli otaczającej, w której ma nastąpić przerwanie lub kontynuowanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">Etykieta „{0}” jest duplikatem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">Typ „{0}” nie ma zdefiniowanego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract class or interface '{0}'</source>
        <target state="translated">Nie można utworzyć wystąpienia klasy lub interfejsu abstrakcyjnego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">Pole stałej wymaga podania wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base class dependency involving '{0}' and '{1}'</source>
        <target state="translated">Cykliczna zależność klasy bazowej obejmująca element „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">W delegacie „{0}” brak prawidłowego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">Oczekiwano nazwy metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">Oczekiwano wartości stałej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">Wyrażenie switch lub etykieta case musi być wartością logiczną, znakiem, ciągiem, liczbą całkowitą, wyliczeniem lub odpowiadającym typem dopuszczającym wartość null w języku C# 6 i wcześniejszych wersjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">Oczekiwano wartości typu całkowitoliczbowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">Instrukcja switch zawiera wiele etykiet case o wartości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">Instrukcja goto case jest prawidłowa tylko wewnątrz instrukcji switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">W tym kontekście nie można użyć właściwości lub indeksatora „{0}”, ponieważ brakuje dla niej metody dostępu Get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">Przechwycony lub zgłoszony typ musi pochodzić od klasy System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">Instrukcja throw bez żadnych argumentów jest niedozwolona poza klauzulą catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">Sterowanie nie może opuścić treści klauzuli finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">Etykieta „{0}” zasłania inną etykietę o takiej samej nazwie w zawartym zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">Brak etykiety „{0}” w zakresie instrukcji goto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki tego typu lub jego nadtypu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „true”, rozważ usunięcie tego filtru</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „true”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'„{0}”: nie wszystkie ścieżki w kodzie zwracają wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">Wykryto nieosiągalny kod</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">Wykryto nieosiągalny kod</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">Nie można przejść z jednej etykiety instrukcji case („{0}”) do innej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">Brak odwołania do tej etykiety</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">Brak odwołania do tej etykiety</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Użyto nieprzypisanej zmiennej lokalnej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">Zmienna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">Zmienna jest zadeklarowana, ale nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">Pole „{0}” nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">Pole nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThis">
        <source>Field '{0}' must be fully assigned before control is returned to the caller</source>
        <target state="translated">Pole „{0}” musi być całkowicie przypisane przed zwróceniem sterowania do elementu wywołującego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">Nie można określić typu wyrażenia warunkowego, ponieważ elementy „{0}” i „{1}” są wzajemnie niejawnie konwertowane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">Nie można określić typu wyrażenia warunkowego, ponieważ nie istnieje niejawna konwersja między elementem „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">Klasa bazowa jest wymagana dla odwołania „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">Użycie słowa kluczowego „base” jest nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">Nie można uzyskać dostępu do składowej „{0}” przy użyciu odwołania do wystąpienia. Należy użyć nazwy typu jako kwalifikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">Wartość parametru ze specyfikatorem out „{0}” musi być przypisana zanim sterowanie wyjdzie z bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">Nieprawidłowy specyfikator rangi: oczekiwano „,” lub „]”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny ani deklarować treści</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny ani zawierać inicjatora konstruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny i abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">Parametr „{0}” konstruktora atrybutu jest typu „{1}”, który nie jest prawidłowym typem parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">Argument atrybutu musi być wyrażeniem stałej, wyrażeniem TypeOf lub wyrażeniem tworzenia tablicy typu parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">Parametr „{0}” konstruktora atrybutu jest opcjonalny, ale nie została podana wartość domyślna parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">Podane wyrażenie jest zawsze określonego typu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'Podane wyrażenie wyrażenia „is” zawsze ma podany typ</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">Podane wyrażenie nigdy nie jest określonego typu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'Podane wyrażenie wyrażenia „is” nigdy nie ma podanego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'„{0}” to nie jest typ referencyjny wymagany przez instrukcję lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">Użycie wartości null jest nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">Użycie domyślnego literału nie jest prawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThis">
        <source>The 'this' object cannot be used before all of its fields are assigned to</source>
        <target state="translated">Obiekt „this” nie może być używany przed przypisaniem wszystkich jego pól</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">Konstrukcja __arglist jest prawidłowa tylko wewnątrz metody argumentu zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">Do wskaźnika należy zastosować operator * lub -&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">Wskaźnik musi być indeksowany tylko przez jedną wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Użycie elementu „{0}” jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania, ponieważ to jest pole klasy marshal-by-reference</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">Użycie pola klasy marshal-by-reference jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Nie można przypisać wartości do statycznego pola tylko do odczytu (jest to możliwe tylko w konstruktorze statycznym lub w inicjatorze zmiennej).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Statycznego pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze statycznym)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Nie można przypisać wartości do właściwości lub indeksatora „{0}” – jest on tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">Jako instrukcji można używać tylko wyrażeń przypisania, wywołania, zwiększenia, zmniejszenia, oczekiwania oraz utworzenia nowego obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">Instrukcja foreach wymaga, aby typ zwracany „{0}” dla elementu „{1}” miał odpowiednią metodę publiczną „MoveNext” i właściwość publiczną „Current”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">Dozwolonych jest tylko 65534 elementów lokalnych, włącznie z wygenerowanymi przez kompilator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Nie można wywołać abstrakcyjnej składowej bazowej: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A property or indexer may not be passed as an out or ref parameter</source>
        <target state="translated">Nie można przekazać właściwości lub indeksatora jako parametru „out” lub „ref”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">Nie można przyjąć adresu, pobrać rozmiaru lub zadeklarować wskaźnika typu zarządzanego („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">Typ zmiennej lokalnej zadeklarowanej w instrukcji fixed musi być typem wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">Inicjator musi zostać udostępniony w deklaracji instrukcji fixed lub using</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">Nie można pobrać adresu podanego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">Wewnątrz inicjatora instrukcji fixed można pobrać jedynie adres nieustalonego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">Nie można użyć instrukcji fixed do pobrania adresu już ustalonego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">Wskaźniki i bufory o ustalonym rozmiarze mogą zostać użyte tylko w kontekście słowa kluczowego „unsafe”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">Typ zwracany operatora True lub False musi być typem logicznym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">Operator „{0}” wymaga zdefiniowanego zgodnego operatora „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">Aby istniała możliwość zastosowania zdefiniowanego przez użytkownika operatora logicznego („{0}”) jako operatora „short circuit”, musi on mieć taki sam typ zwracany i typy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">Aby element „{0}” można było zastosować jako operator „short circuit”, jego typ deklarujący „{1}” musi definiować operatory true i false</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">Zmienna „{0}” jest przypisana, lecz jej wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">Zmienna jest przypisana, ale jej wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">Operacja przepełnia się w czasie kompilowania w trybie sprawdzonym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">Nie można przekonwertować wartości stałej „{0}” na „{1}” (w celu przesłonięcia należy użyć składni instrukcji „unchecked”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">Metoda z atrybutem vararg nie może być ogólna, znajdować się w typie ogólnym ani mieć parametru params</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeArray">
        <source>The params parameter must be a single dimensional array</source>
        <target state="translated">Parametr params musi być tablicą jednowymiarową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">Wyrażenie __arglist może się pojawić tylko wewnątrz wywołania lub nowego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">Niebezpieczny kod może się pojawić tylko w przypadku kompilowania przy użyciu opcji /unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">Niejednoznaczność pomiędzy „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">W instrukcji foreach wymagany jest typ i identyfikator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">Parametr params musi być ostatnim parametrem na liście parametrów formalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">Element „{0}” nie ma wstępnie zdefiniowanego rozmiaru, dlatego operatora sizeof można użyć tylko w kontekście słowa kluczowego unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">Typ lub przestrzeń nazw „{0}” nie występuje w przestrzeni nazw „{1}” (czy nie brakuje odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">Inicjator pola nie może odwoływać się do niestatycznego pola, metody lub właściwości „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'Elementu „{0}” nie można zapieczętować, ponieważ nie jest przesłonięciem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'„{0}”: nie można przesłonić odziedziczonej składowej „{1}”, ponieważ jest ona zapieczętowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">Rozpatrywana operacja jest niezdefiniowana we wskaźnikach void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jest to metoda przesłonięcia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">W typach wskaźnika nie można używać operatorów „is” ani „as”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">Destruktory i metoda object.Finalize nie mogą być bezpośrednio wywoływane. Rozważ wywołanie metody IDisposable.Dispose, jeżeli jest dostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Nie można znaleźć nazwy typu lub przestrzeni nazw „{0}” (brak dyrektywy using lub odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">Nie można użyć ujemnego rozmiaru w przypadku słowa kluczowego stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">Nie można utworzyć tablicy z ujemnym rozmiarem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">Nie przesłaniaj metody object.Finalize. Zamiast tego udostępnij destruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base class Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">Nie wywołuj bezpośrednio metody Finalize klasy bazowej. Metoda jest wywoływana automatycznie z destruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">Indeksowanie tablicy z ujemnym indeksem (indeksy tablicy zawsze rozpoczynają się od zera)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">Indeksowanie tablicy z ujemnym indeksem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie lewej strony na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań; lewa strona wymaga rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie prawej strony na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań; prawa strona wymaga rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">Prawa strona przypisania instrukcji fixed nie może być wyrażeniem rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">Słowo kluczowe stackalloc nie może być używane w bloku catch lub finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">Parametr __arglist musi być ostatnim parametrem formalnej listy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">Brak częściowego modyfikatora w deklaracji typu „{0}”. Istnieje inna częściowa deklaracja tego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all structs, or all interfaces</source>
        <target state="translated">Wszystkie częściowe deklaracje elementu „{0}” muszą być klasami, strukturami lub interfejsami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">Modyfikatory dostępu częściowych deklaracji elementu „{0}” powodują konflikt</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” nie mogą określać różnych klas bazowych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu w takiej samej kolejności</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” mają niezgodne ograniczenia parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">Nie można niejawnie przekonwertować typu „{0}” na „{1}”. Istnieje konwersja jawna (czy nie brakuje rzutu?).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'struct', 'interface', or 'void'</source>
        <target state="translated">Modyfikator „partial” może się pojawić tylko bezpośrednio przed typem „class”, „struct”, „interface” lub „void”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base class dependency.</source>
        <target state="translated">Importowany typ „{0}” jest nieprawidłowy. Zawiera on cykliczną zależność klasy bazowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Użycie nieprzypisanego parametru ze specyfikatorem out „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">Rozmiaru tablicy nie można określić w deklaracji zmiennej (spróbuj przeprowadzić inicjowanie przy użyciu wyrażenia „new”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Get jest niedostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Set jest niedostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">Modyfikator dostępności dla metody dostępu „{0}” musi być bardziej restrykcyjny niż właściwość lub indeksator „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">Nie można określić modyfikatorów dostępności dla obu metod dostępu właściwości lub indeksatora „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'„{0}”: modyfikatorów dostępności można używać tylko wtedy, gdy właściwość lub indeksator mają metody dostępu Get i Set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie jest publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'Element „{0}” nie implementuje wzorca „{1}”. Elementy „{2}” i „{3}” są wzajemnie niejednoznaczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">Typ nie zawiera implementacji wzorca kolekcji; składowe są niejednoznaczne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is either static or not public.</source>
        <target state="translated">'Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” jest statyczny lub nie jest publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible_Title">
        <source>Type does not implement the collection pattern; member is either static or not public</source>
        <target state="translated">Typ nie zawiera implementacji wzorca kolekcji; składowa jest statyczna lub niepubliczna</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” ma nieprawidłową sygnaturę.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">Typ nie zawiera implementacji wzorca kolekcji; składowa ma niewłaściwą sygnaturę</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale klucz publiczny zestawu wyjściowego („{1}”) nie jest zgodny z kluczem określonym przez atrybut InternalsVisibleTo w zestawie udzielającym dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale silna nazwa stanu podpisywania zestawu wyjściowego nie jest zgodna z nazwą określoną przez atrybut w zestawie udzielającym dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">Nie ma zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury „{0}”. Aby określić kolejność, wszystkie pola wystąpienia muszą znajdować się w tej samej deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">Brak zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">Typu „{0}” nie można zadeklarować jako const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">Nie można utworzyć wystąpienia typu zmiennej „{0}”, ponieważ nie ma ograniczenia new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">Użycie ogólnego elementu {1} „{0}” wymaga argumentów typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">Typu „{0}” nie można użyć jako argumentu typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Elementu {1} „{0}” nie można używać z argumentami typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Nieogólnego elementu {1} „{0}” nie można używać z argumentami typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'Element „{2}” musi być typem nieabstrakcyjnym z publicznym konstruktorem bez parametrów, aby można go było użyć jako parametru „{1}” w typie ogólnym lub metodzie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak niejawnej konwersji odwołania z typu „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”. Typy zerowalne nie mogą spełniać żadnych ograniczeń interfejsów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej lub konwersji parametru typu z „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej z „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">Nazwa parametru „{0}” powoduje konflikt z nazwą parametru generowaną automatycznie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">Nie można odnaleźć nazwy typu lub przestrzeni nazw „{0}” w globalnej przestrzeni nazw (czy nie brakuje odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last constraint specified</source>
        <target state="translated">Ograniczenie new() musi być ostatnim określonym ograniczeniem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'„{0}”: punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">Punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">Nie można przekonwertować wartości null na parametr typu „{0}”, ponieważ może on być nienullowalnym typem wartości. Zamiast tego rozważ użycie elementu „default({0}!)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCantBeGeneric">
        <source>Cannot apply attribute class '{0}' because it is generic</source>
        <target state="translated">Nie można zastosować klasy atrybutów „{0}”, ponieważ jest ona typu ogólnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">Zduplikowane ograniczenie „{0}” dla parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">Ograniczenie typu klasy „{0}” musi występować przed wszystkimi innymi ograniczeniami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'„{1} {0}” ma nieprawidłowy zwracany typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">Niezgodność odwołań między metodą „{0}” a delegatem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">Klauzula ograniczenia została już określona dla parametru typu „{0}”. Wszystkie ograniczenia dla parametru typu muszą być określone w jednej klauzuli where.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">Nie można wywnioskować argumentów typu dla metody „{0}” na podstawie użytkowania. Spróbuj jawnie określić argumenty typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'„{0}”: parametr, zmienna lokalna lub funkcja lokalna nie może mieć tej samej nazwy co parametr typu metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">Parametru typu „{0}” nie można użyć z operatorem „as”, ponieważ nie ma ograniczenia typu klasy ani ograniczenia „class”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">Pole „{0}” jest przypisane, lecz jego wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">Pole jest przypisane, ale jego wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w indeksatorze, który nie jest jawną deklaracją składowej interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'„{0}”: argument atrybutu nie może używać parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'„{0}”: nie można udostępnić argumentów podczas tworzenia wystąpienia typu zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract class cannot be sealed or static</source>
        <target state="translated">'„{0}”: klasa abstrakcyjna nie może być zapieczętowana ani statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">Niejednoznaczne odwołanie w atrybucie cref: „{0}”. Przyjęto element „{1}”, lecz inne elementy przeciążające także są zgodne, w tym „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">Niejednoznaczne odwołanie w atrybucie cref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'„{0}”: odwołanie do pola nietrwałego nie będzie traktowane jako nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">Odwołanie do pola nietrwałego nie będzie traktowane jak nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">Pole nietrwałe nie powinno być zwykle używane jako wartość ref ani out, ponieważ nie będzie traktowane jak pole nietrwałe. Istnieją wyjątki od tej reguły, takie jak wywołanie blokowanego interfejsu API.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">Ponieważ element „{1}” ma atrybut ComImport, element „{0}” musi być zewnętrzny lub abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'„{0}”: klasa o atrybucie ComImport nie może określać klasy bazowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Ograniczenia parametrów typu „{0}” metody „{1}” muszą być zgodne z ograniczeniami parametrów typu „{2}” metody interfejsu „{3}”. Rozważ użycie jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">Nazwy elementów krotki w podpisie metody „{0}” muszą być zgodne z nazwami elementów krotki metody interfejsu „{1}” (w tym w zwracanym typie).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">Nazwa typu „{0}” nie istnieje w typie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Nie można przekonwertować grupy metod „{0}” na typ niedelegowany „{1}”. Czy zamierzasz wywołać metodę?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">Alias zewnętrzny „{0}” nie został określony w opcji /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">Nie można użyć aliasu „{0}” ze znakami „::”, ponieważ alias odwołuje się do typu. Użyj znaku „.”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">Nie znaleziono aliasu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">Typ „{1}” istnieje zarówno w elemencie „{0}”, jak i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z typem „{3}” w elemencie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyta przestrzeń nazw zdefiniowana w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">Przestrzeń nazw powoduje konflikt z zaimportowanym typem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">Typ powoduje konflikt z zaimportowanym typem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowaną przestrzenią nazw „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">Typ powoduje konflikt z zaimportowaną przestrzenią nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z przestrzenią nazw „{3}” w elemencie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">Deklaracja aliasu zewnętrznego musi poprzedzać wszystkie inne elementy zdefiniowane w przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">Definiowanie aliasu o nazwie „global” jest niezalecane, ponieważ łańcuch „global::” zawsze odwołuje się do globalnej przestrzeni nazw, a nie do aliasu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">Nie zaleca się definiowania aliasu o nazwie „global”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a class cannot be both static and sealed</source>
        <target state="translated">'„{0}”: klasa nie może być jednocześnie statyczna i zapieczętowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'„{0}”: właściwości abstrakcyjne nie mogą mieć prywatnych metod dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">Błąd składni; oczekiwano wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">Nie można zmodyfikować wyniku konwersji rozpakowującej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Instrukcja foreach nie może działać względem elementu „{0}”. Czy element „{0}” miał być wywołany?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">Typ zwracany przez operator ++ lub -- musi odpowiadać typowi parametru lub pochodzić od typu parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundMustBeFirst">
        <source>The 'class' or 'struct' constraint must come before any other constraints</source>
        <target state="translated">Ograniczenie „class” lub „struct” musi występować przed wszystkimi innymi ograniczeniami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'„{0}”: nie można jednocześnie określić klasy ograniczenia i ograniczenia „class” lub „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">Ograniczenie „new()” nie może być używane z ograniczeniem „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być typem referencyjnym, aby można było używać go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być nienullowalnym typem wartości, aby można było użyć go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">Cykliczna zależność ograniczenia obejmująca elementy „{0}” i „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">Parametr typu „{0}” dziedziczy powodujące konflikt ograniczenia „{1}” i „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Parametr typu „{1}” ma ograniczenie „struct”, dlatego elementu „{1}” nie można użyć jako ograniczenia dla „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">Niejednoznaczne zdefiniowane przez użytkownika konwersje „{0}” i „{1}” podczas konwertowania z „{2}” na „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">Wynikiem wyrażenia jest zawsze element „null” typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">Wynikiem wyrażenia jest zawsze wartość „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">Nie można zwrócić elementu „this” przez referencję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it is has 'in' parameters.</source>
        <target state="translated">Nie można użyć konstruktora atrybutu „{0}”, ponieważ ma parametry „in”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">Ograniczenia dla przesłoniętych i jawnych metod implementacji interfejsu są dziedziczone z metody podstawowej, dlatego nie mogą być określone bezpośrednio, chyba że są to ograniczenia „class” lub „struct”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">Dziedziczone składowe „{0}” i „{1}” mają tę samą sygnaturę w typie „{2}”, dlatego nie mogą być przesłaniane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">Obliczenie wyrażenia ze stałą dziesiętną nie powiodło się</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">Porównanie z wartością null typu „{0}” zawsze daje wartość „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">Porównanie z wartością null typu struktury zawsze zwraca wartość „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora. Czy zamierzane było zadeklarowanie destruktora?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">To ostrzeżenie występuje w przypadku utworzenia klasy przy użyciu metody, której sygnatura to publiczny wirtualny element void Finalize.

Jeśli taka klasa zostanie użyta jako klasa bazowa i klasa pochodna definiuje destruktor, ten destruktor przesłoni metodę Finalize klasy bazowej, a nie element Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'Element „{0}” nie powinien mieć parametru params, ponieważ nie ma go element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">Wartości „goto case” nie można jawnie przekonwertować na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">Nie można niejawnie przekonwertować wartości „goto case” na typ przełącznika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Metoda „{0}” nie może implementować metody dostępu interfejsu „{1}” dla typu „{2}”. Użyj jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">Jawna implementacja interfejsu „{0}” jest zgodna z więcej niż jedną składową interfejsu. Wybór interfejsu do użycia zależy od implementacji. Rozważ użycie zamiast niej implementacji niejawnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">Implementacja interfejsu jawnego jest zgodna z więcej niż jedną składową interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'W elemencie „{0}” nie może wystąpić deklaracja treści, ponieważ jest on oznaczony jako abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'Element „{0}” musi zadeklarować treść, ponieważ nie jest oznaczony jako abstrakcyjny, zewnętrzny ani częściowy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny i zapieczętowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">Abstrakcyjny element {0} „{1}” nie może być oznaczona jako wirtualny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">Stałej „{0}” nie można oznaczyć jako statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest funkcją</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'„{0}”: nie można przesłonić odziedziczonej składowej „{1}”, ponieważ nie została ona oznaczona przy użyciu słowa kluczowego „virtual”, „abstract” ani „override”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'„{0}”: nie można zmienić modyfikatorów dostępu podczas przesłaniania elementu „{1}” dziedziczoną składową „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'„{0}”: nie można zmienić nazw elementów krotki w przypadku przesłaniania dziedziczonej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'„{0}”: typem zwracanym musi być „{2}”, aby być zgodnym z przesłoniętą składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'„{0}”: pochodzenie od zapieczętowanego typu „{1}” jest niemożliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract class '{1}'</source>
        <target state="translated">'Element „{0}” jest abstrakcyjny, ale jest zawarty w nieabstrakcyjnej klasie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'„{0}”: konstruktor statyczny nie może zawierać jawnego wywołania konstruktora „this” lub „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'„{0}”: modyfikatory dostępu są niedozwolone dla konstruktorów statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">Konstruktor „{0}” nie może wywołać sam siebie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">Konstruktor „{0}” nie może wywołać się za pośrednictwem innego konstruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">Element „{0}” nie ma klasy bazowej i nie może wywołać konstruktora bazowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” jest zadeklarowany w wielu przywoływanych zestawach: „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'„{0}”: struktury nie mogą wywoływać konstruktorów klasy bazowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Składowa „{0}” typu „{1}” powoduje wystąpienie cyklu w układzie struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">Interfejsy nie mogą zawierać pól wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">Interfejsy nie mogą zawierać konstruktorów wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">Typ „{0}” na liście interfejsów nie jest interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'Interfejs „{0}” już wyszczególniono na liście interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'Element „{0}” znajduje się już na liście interfejsów w typie „{2}” z różnymi nazwami elementów krotki jako „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">Dziedziczony interfejs „{1}” jest przyczyną wystąpienia cyklu w hierarchii interfejsów „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'Element „{0}” ukrywa dziedziczoną, abstrakcyjną składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'Element „{0}” nie implementuje odziedziczonej abstrakcyjnej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">Klasa System.Object nie może mieć klasy bazowej ani implementować interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'Element „{0}” w jawnej deklaracji interfejsu nie jest interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">W jawnej deklaracji interfejsu nie znaleziono elementu „{0}” wśród składowych interfejsu, które można implementować</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'„{0}”: typ zawierający nie implementuje interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, struct or interface</source>
        <target state="translated">'„{0}”: jawna deklaracja interfejsu może występować tylko w klasie, strukturze lub interfejsie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'„{0}”: nazwy składowych nie mogą być takie same jak nazwa zawierającego je typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'„{0}”: wartość, która wystąpiła w module wyliczającym, jest zbyt duża, aby można było ją stosować przy użyciu typu tego modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest właściwością</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu get, którą można przesłonić</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu set, którą można przesłonić</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'„{0}”: właściwość ani indeksator nie mogą być typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'„{0}”: właściwość lub indeksator musi mieć co najmniej jedna metodę dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed class '{1}'</source>
        <target state="translated">'„{0}” to nowa wirtualna składowa klasy zapieczętowanej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'Element „{0}” dodaje metodę dostępu, której nie znaleziono w składowej interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">W jawnej implementacji interfejsu „{0}” brakuje metody dostępu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'„{0}”: zdefiniowane przez użytkownika konwersje na lub z interfejsu nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base class are not allowed</source>
        <target state="translated">'„{0}”: zdefiniowane przez użytkownika konwersje na lub z klasy bazowej nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived class are not allowed</source>
        <target state="translated">'„{0}”: zdefiniowane przez użytkownika konwersje na lub z klasy pochodnej nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type</source>
        <target state="translated">Zdefiniowany przez użytkownika operator nie może pobrać obiektu typu otaczającego i dokonać konwersji na obiekt typu otaczającego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">Zdefiniowana przez użytkownika konwersja musi dokonywać konwersji na typ otaczający lub z niego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">Zduplikowana konwersja zdefiniowana przez użytkownika w typie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">Operator zdefiniowany przez użytkownika „{0}” musi być zadeklarowany ze specyfikatorami static i public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">Typ parametru dla operatora ++ lub -- musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">Parametr operatora jednoargumentowego musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">Jeden z parametrów operatora binarnego musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int</source>
        <target state="translated">Pierwszy argument operacji przeciążonego operatora przesunięcia musi mieć taki sam typ co typ zawierający, a typ drugiego argumentu operacji musi być typem int</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructsCantContainDefaultConstructor">
        <source>Structs cannot contain explicit parameterless constructors</source>
        <target state="translated">Struktury nie mogą zawierać jawnych konstruktorów bez parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">Wyliczenia nie mogą zawierać jawnych konstruktorów bez parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'„{0}” nie może przesłonić „{1}”, ponieważ nie jest to obsługiwane przez język</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'Element „{0}” nie jest obsługiwany przez język.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'„{0}”: nie można jawnie wywołać operatora lub metody dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'„{0}”: nie można odwołać się do typu przy użyciu wyrażenia. Spróbuj użyć „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitializerInStruct">
        <source>'{0}': cannot have instance property or field initializers in structs</source>
        <target state="translated">'„{0}”: nie można umieścić inicjatorów właściwości lub pola wystąpienia w strukturach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of class</source>
        <target state="translated">Nazwa destruktora musi być zgodna z nazwą klasy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">Tylko typy klasy mogą zawierać destruktory</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">Przestrzeń nazw „{1}” zawiera definicję powodującą konflikt z aliasem „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">Alias „{0}” jest w konflikcie z definicją {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, or explicit interface implementation</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jest to konstruktor, destruktor, operator lub jawna implementacja interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jego typem zwracanym nie jest void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Zduplikowany atrybut „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">Zduplikowany atrybut „{0}” w elemencie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w składowych interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">Zdefiniowane przez użytkownika operatory nie mogą zwracać wartości void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'„{0}”: zdefiniowane przez użytkownika konwersje na lub z typu dynamicznego nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">Nieprawidłowa wartość argumentu dla atrybutu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">Parametr jest nieprawidłowy dla określonego niezarządzanego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">Należy podać parametr atrybutu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">Należy podać parametr atrybutu „{0}” lub „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Niezarządzany typ „{0}” jest nieprawidłowy dla pól.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Niezarządzany typ „{0}” jest prawidłowy tylko dla pól.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">W tej deklaracji typu atrybut „{0}” jest nieprawidłowy. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">Wartość stałej zmiennoprzecinkowej jest spoza zakresu typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">Atrybut Guid musi być określony z atrybutem ComImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">Nieprawidłowa wartość nazwanego argumentu atrybutu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">Dla metody oznaczonej przy użyciu słów kluczowych „static” i „extern” musi zostać określony atrybut DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">Nie można zaktualizować elementu „{0}”. Brak atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic type.</source>
        <target state="translated">Atrybut DllImport nie może być zastosowany do metody, która jest ogólna lub zawarta w typie ogólnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">Pole ani właściwość nie może mieć typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">Pole lub automatycznie implementowana właściwość nie może być typu „{0}”, chyba że jest to składowa struktury ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">W tablicy nie mogą występować elementy typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'Element „{0}” jest przestarzały</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Typ lub składowa jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'„{0}” to nie jest klasa atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'„{0}” nie jest prawidłowym argumentem nazwanego atrybutu. Argumentami nazwanego atrybutu muszą być pola, które nie są tylko do odczytu i nie są statyczne ani stałe, lub właściwości do odczytu/zapisu, które są publiczne, ale nie statyczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'Element „{0}” jest przestarzały: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Typ lub składowa jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'Element „{0}” jest przestarzały: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">Indeksowanie nie może być typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'„{0}”: wirtualne ani abstrakcyjne składowe nie mogą być prywatne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">Wyrażenia inicjatora tablicy mogą być używane tylko w celu przypisania wartości do typów tablicowych. Zamiast tego spróbuj użyć wyrażenia „new”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">Inicjatora tablicy można użyć tylko w inicjatorze zmiennej lub pola. Zamiast tego spróbuj użyć wyrażenia „new”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">„{0}”: pola wystąpienia w ramach typów oznaczonych elementem StructLayout(LayoutKind.Explicit) muszą mieć atrybut FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">Metoda, operator lub metoda dostępu „{0}” jest oznaczona jako zewnętrzna i nie ma atrybutów. Rozważ dodanie atrybutu DllImport w celu określenia implementacji zewnętrznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">Metoda, operator lub metoda dostępu są oznaczone jako zewnętrzne i nie zawierają atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed class</source>
        <target state="translated">'„{0}”: w klasie zapieczętowanej została zadeklarowana nowa chroniona składowa</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed class</source>
        <target state="translated">W klasie zapieczętowanej zadeklarowano nową chronioną składową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Warunkowa składowa „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">Parametry „ref” i „out” są nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">Argument atrybutu „{0}” musi być prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Atrybut FieldOffset można umieścić tylko w składowych o typie oznaczonym przy użyciu atrybutu StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">Atrybut FieldOffset jest niedozwolony w polach typu static lub const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w klasach pochodzących od klasy System.Attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'„{0}” zduplikowany nazwany argument atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'„{0}” nie może pochodzić od klasy specjalnej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">Dla typu zawierającego indeksator nie można określić atrybutu DefaultMember.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'Element „{0}” jest typem obsługiwanym przez język.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">Do pola „{0}” nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">Do pola nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">Niewłaściwy deklarator tablicy. Aby zadeklarować tablicę zarządzaną, przed identyfikatorem zmiennej umieść specyfikator rangi tablicy. Aby zadeklarować pole buforu o ustalonym rozmiarze, przed typem pola użyj słowa kluczowego „fixed”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">Porównanie ze stałą całkowitoliczbową jest bezcelowe. Stała jest poza zakresem typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">Porównanie ze stałą całkowitoliczbową jest bezcelowe; stała jest poza zakresem typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">Nie można zastosować klasy atrybutów „{0}”, ponieważ jest ona abstrakcyjna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'„{0}” nie jest prawidłowym argumentem nazwanego atrybutu, ponieważ nie jest to prawidłowy typ parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">Brak wymaganej przez kompilator składowej „{0}.{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'„{0}” to nie jest prawidłowa lokalizacja atrybutu tej deklaracji. Prawidłowe lokalizacje atrybutu tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">Nieprawidłowa lokalizacja atrybutu tej deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'„{0}” nie jest rozpoznawaną lokalizacją atrybutu. Prawidłowe lokalizacje atrybutu dla tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">Nie jest to rozpoznawana lokalizacja atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'Element „{0}” przesłania metodę Object.Equals(object o), lecz nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">Typ przesłania metodę Object.Equals(object o), ale nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">Typ definiuje operator == lub !=, ale nie przesłania metody Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">Typ definiuje operator == lub !=, ale nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">Nie można określić atrybutu Out dla parametru ref bez określania także atrybutu wejściowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'Element „{0}” nie może definiować przeciążonego elementu {1}, który różni się tylko modyfikatorami parametru „{2}” i „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">Nie można niejawnie przekonwertować literału typu double na typ „{1}”. W celu utworzenia literału tego typu należy użyć sufiksu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">Przypisanie w wyrażeniu warunkowym jest zawsze stałe. Czy zamiast operatora = miał zostać użyty operator == ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">Przypisanie w wyrażeniu warunkowym jest zawsze stałe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'„{0}”: nowa chroniona składowa zadeklarowana w strukturze</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">Istnieją dwa indeksatory o różnych nazwach. Dla każdego indeksatora w określonym typie należy użyć atrybutu IndexerName o takiej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">W klasie z atrybutem ComImport nie może występować konstruktor zdefiniowany przez użytkownika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">Typ pola nie może być typem void</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">Składowa „{0}” przesłania przestarzałą składową „{1}”. Dodaj atrybut Obsolete do składowej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">Składowa przesłania przestarzałą składową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">W języku C# nie można użyć elementu System.Void. Aby uzyskać obiekt typu void, użyj elementu typeof(void).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArray">
        <source>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">Nie używaj atrybutu „System.ParamArrayAttribute”. Zamiast niego użyj słowa kluczowego „params”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">Operator LUB działający na bitach został użyty względem argumentu ze znakiem. Rozważ możliwość wcześniejszego rzutowania na mniejszy typ bez znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">Użyto operatora bitowego OR w argumencie operacji z rozszerzonym znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">Kompilator niejawnie poszerzył zmienną i rozszerzył jej znak, a następnie użył wartości wynikowej w operacji bitowej OR. Może to powodować nieoczekiwane działanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'„{0}”: pole nietrwałe nie może być typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'„{0}”: pole nie może być jednocześnie nietrwałe i tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">Modyfikator „abstract” w polach jest nieprawidłowy. Spróbuj zamiast niego użyć właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'„{0}” nie może implementować „{1}”, ponieważ nie jest to obsługiwane przez język</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'Jawna implementacja metody „{0}” nie może implementować elementu „{1}”, ponieważ jest to metoda dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'Interfejs „{0}” z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">Interfejs z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Warunkowa składowa „{0}” nie może mieć parametru wyjściowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Metoda dostępu „{0}” nie może implementować składowej interfejsu „{1}” dla typu „{2}”. Należy użyć implementacji interfejsu jawnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">Kwalifikator aliasu przestrzeni nazw „::” jest zawsze rozpoznawany jako typ lub przestrzeń nazw, dlatego jest tutaj niedozwolony. Zamiast niego rozważ możliwość użycia kwalifikatora „.”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">Nie może pochodzić od „{0}”, ponieważ jest to parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">Zduplikowany parametr typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co parametr typu zewnętrznego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">Parametr typu ma tę samą nazwę co parametr typu zewnętrznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co zawierający typ lub metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'Element „{0}” nie może implementować jednocześnie elementu „{1}” i „{2}”, ponieważ mogą się one łączyć przy niektórych podstawieniach parametrów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericDerivingFromAttribute">
        <source>A generic type cannot derive from '{0}' because it is an attribute class</source>
        <target state="translated">Typ ogólny nie może pochodzić od „{0}”, ponieważ jest klasą atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">Element „{1}” nie definiuje parametru typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'„{0}” to nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">Ograniczenie nie może być specjalną klasą „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">Niespójność dostępności: typ ograniczony „{1}” jest mniej dostępny niż „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">Nie można wyszukać składowej w elemencie „{0}”, ponieważ to jest parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">Nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'„{0}”: nie można zadeklarować składowych wystąpienia w klasie statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'„{1}”: nie można utworzyć na podstawie klasy statycznej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">Klasy statyczne nie mogą mieć konstruktorów wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">Klasy statyczne nie mogą zawierać destruktorów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">Nie można utworzyć wystąpienia klasy statycznej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">Klasa statyczna „{0}” nie może pochodzić od typu „{1}”. Klasy statyczne muszą pochodzić od obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'„{0}”: klasy statyczne nie mogą implementować interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructInterfaceImpl">
        <source>'{0}': ref structs cannot implement interfaces</source>
        <target state="translated">'„{0}”: Struktury ref nie mogą implementować interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'„{0}”: klasy statyczne nie mogą zawierać operatorów zdefiniowanych przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">Nie można przekonwertować na typ statyczny „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'„{0}”: klas statycznych nie można używać jako ograniczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'„{0}”: typów statycznych nie można używać jako argumentów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'„{0}”: elementy tablicy nie mogą być typu statycznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'„{0}”: nie można zadeklarować indeksatorów w klasie statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'„{0}”: typów statycznych nie można użyć jako parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'„{0}”: typów statycznych nie można użyć jako typów w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">Nie można zadeklarować zmiennej typu statycznego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">Instrukcja throw bez argumentów jest niedozwolona w klauzuli finally zagnieżdżonej w najbliższej otaczającej klauzuli catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'„{0}” nie jest prawidłowym specyfikatorem formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">Prawdopodobnie niepoprawne przypisanie do elementu lokalnego „{0}”, który jest argumentem instrukcji using lub lock. Wywołanie metody Dispose lub odblokowanie nastąpi dla oryginalnej wartości elementu lokalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">Możliwe niepoprawne przypisanie do zmiennej lokalnej będącej argumentem instrukcji using lub lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w tym zestawie, ale zdefiniowano dla niego funkcję przesyłania typu dalej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">Nie można przesłać typu „{0}”, ponieważ jest to zagnieżdżony typ „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">Funkcja przesyłania dalej dla typu „{0}” w zestawie „{1}” powoduje wystąpienie cyklu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">Opcję /moduleassemblyname można określić tylko w przypadku kompilowania elementu docelowego typu „module”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">Określono nieprawidłowy typ jako argument dla atrybutu TypeForwardedTo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is static.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować składowej interfejsu, ponieważ jest statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować składowej interfejsu, ponieważ jest niepubliczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ brak pasującego zwracanego typu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'„{0}” zduplikowany atrybut TypeForwardedToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">Treść zapytania musi kończyć się klauzulą „select” lub „group”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „on”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „by”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">Nieprawidłowy deklarator składowej typu anonimowego. Składowe typu anonimowego muszą być deklarowane przy użyciu przypisania składowej, nazwy prostej lub dostępu do składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">Nieprawidłowy deklarator inicjującej składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Niespójne użycie parametrów lambda. Wszystkie typy parametrów muszą być albo jawne, albo niejawne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInvalidModifier">
        <source>A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers</source>
        <target state="translated">Metoda częściowa nie może mieć modyfikatorów dostępu ani modyfikatorów virtual, abstract, override, new, sealed lub extern.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyInPartialClass">
        <source>A partial method must be declared within a partial class, partial struct, or partial interface</source>
        <target state="translated">Metoda częściowa musi być zadeklarowana w częściowej klasie, strukturze lub interfejsie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodCannotHaveOutParameters">
        <source>A partial method cannot have out parameters</source>
        <target state="translated">Metoda częściowa nie może mieć parametrów wyjściowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodNotExplicit">
        <source>A partial method may not explicitly implement an interface method</source>
        <target state="translated">Metoda częściowa nie może jawnie implementować metody interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">Obie deklaracje metody częściowej muszą być metodami rozszerzenia albo żadna z nich nie może być metodą rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">Metoda częściowa nie może mieć wielu deklaracji definiujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">Metoda częściowa nie może mieć wielu deklaracji implementujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamsDifference">
        <source>Both partial method declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">Obie częściowe deklaracje metody muszą używać parametru params lub żadna nie może go używać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">Nie znaleziono deklaracji definiującej na potrzeby implementowania częściowej metody „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentTupleNames">
        <source>Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">Obydwie częściowe deklaracje metody, „{0}” i „{1}”, muszą korzystać z tych samych nazw elementów krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Deklaracje metod częściowych elementu „{0}” mają niespójne ograniczenia dla parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">Nie można utworzyć delegata z metody „{0}”, ponieważ jest to metoda częściowa bez deklaracji implementującej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodStaticDifference">
        <source>Both partial method declarations must be static or neither may be static</source>
        <target state="translated">Obie deklaracje metody częściowej muszą być statyczne albo żadna z nich nie może być statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodUnsafeDifference">
        <source>Both partial method declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">Obie deklaracje metody częściowej muszą być niezabezpieczone albo żadna z nich nie może być niezabezpieczona.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">W drzewach wyrażeń nie można używać metod częściowych zawierających tylko deklarację definiującą ani usuniętych metod warunkowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustReturnVoid">
        <source>Partial methods must have a void return type</source>
        <target state="translated">Metody częściowe muszą zwracać typ void.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">Przestarzała składowa „{0}” przesłania nieprzestarzałą składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">Przestarzała składowa przesłania nieprzestarzałą składową</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">W pełni kwalifikowana nazwa elementu „{0}” jest za długa dla informacji debugowania. Skompiluj bez opcji „/debug”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">W pełni kwalifikowana nazwa jest za długa dla informacji debugowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">Nie można przypisać elementu {0} do zmiennej o typie określonym niejawnie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">Zmienne o typie określonym niejawnie muszą być inicjowane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">Zmienne o typie określonym niejawnie nie mogą mieć wiele deklaratorów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">Nie można zainicjować zmiennej o typie określonym niejawnie za pomocą inicjatora tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">Zmienne lokalne o typie określonym niejawnie nie mogą być ustalone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">Zmienne o typie określonym niejawnie nie mogą być stałymi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">Konstruktor „{0}” jest oznaczony jako zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">Konstruktor jest oznaczony jako zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">Kontekstowe słowo kluczowe „var” może występować tylko w deklaracji zmiennej lokalnej lub kodzie skryptu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">Nie odnaleziono najlepszego typu dla tablicy o typie określonym niejawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">Nie można przypisać elementu {0} do właściwości typu anonimowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora przypisania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">Typ anonimowy nie może mieć wielu właściwości o tej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">Wyrażenia lambda z treścią instrukcji nie można skonwertować na drzewo wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">Nie można skonwertować wyrażenia lambda na drzewo wyrażenia, którego argument typu „{0}” nie jest typem delegowanym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">W wyrażeniu stałym nie można użyć typu anonimowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">Pierwszy argument operacji operatora „is” lub „as” nie może być wyrażeniem lambda, metodą anonimową ani grupą metod.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">Pierwszy operand operatora „as” nie może być literałem krotki bez typu naturalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać inicjatora tablicy wielowymiarowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">Brak argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">Typu elementu „{0}” nie można wywnioskować, ponieważ jego inicjator bezpośrednio lub pośrednio przywołuje definicję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoProperty">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller.</source>
        <target state="translated">Automatycznie implementowana właściwość „{0}” musi być całkowicie przypisana przed zwróceniem sterowania do elementu wywołującego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem. Deklaracja zmiennej lokalnej powoduje ukrycie pola „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać operatora łączącego z literałem domyślnym lub o wartości null po lewej stronie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Oczekiwano identyfikatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">Oczekiwano średnika (;)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">Błąd składni, oczekiwano elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">Zduplikowany modyfikator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">Metoda dostępu do właściwości jest już zdefiniowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">Oczekiwano typu byte, sbyte, short, ushort, int, uint, long lub ulong.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">Nierozpoznana sekwencja ucieczki</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">W stałej występuje symbol przejścia do następnego wiersza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">Pusty literał znakowy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">Za wiele znaków w literale znakowym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">Oczekiwano metody dostępu get lub set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">Oczekiwano typu object, string lub class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">Oczekiwano argumentu atrybutu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Klauzule catch nie mogą następować po ogólnej klauzuli catch instrukcji try.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">Oczekiwano słowa kluczowego „this” lub „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">Oczekiwano operatora jednoargumentowego z możliwością przeciążenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">Oczekiwano operatora binarnego z możliwością przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">Za duża wartość stałej całkowitej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">Oczekiwano definicji typu lub przestrzeni nazw albo znacznika końca pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">Oczekiwano definicji składowej, instrukcji albo znacznika końca pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">Osadzona instrukcja nie może być instrukcją deklaracji ani instrukcją etykiety.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">Oczekiwano dyrektywy preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">Oczekiwano znaku )</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">Oczekiwano dyrektywy #endif.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">Nieoczekiwana dyrektywa preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#błąd: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">Dyrektywa #warning</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">Oczekiwano typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">Nie można zdefiniować/usunąć definicji symboli preprocesora po pierwszym tokenie w pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">Nie można użyć dyrektywy #r po pierwszym tokenie w pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">Napotkano znacznik końca pliku. Oczekiwano znaków "*/".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">Napotkano znacznik konfliktu scalania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">Nie używaj opcji refout, gdy używana jest opcja refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">Nie można skompilować modułów sieciowych, gdy używana jest opcja /refout lub /refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">Oczekiwano operatora z możliwością przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">Oczekiwano dyrektywy #endregion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">Niezakończony literał ciągu znaków</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">Dyrektywy preprocesora muszą wystąpić w wierszu jako pierwsze znaki inne niż spacja.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">Oczekiwano identyfikatora; „{1}” jest słowem kluczowym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">Oczekiwano znaku { lub ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">W instrukcjach deklaracji „for”, „using”, „fixed”, „or” nie można użyć większej liczby typów niż jeden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">Oczekiwano metody dostępu Add lub Remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Nieoczekiwany znak „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">Nieoczekiwany token „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'„{0}”: klasy statyczne nie mogą zawierać chronionych składowych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki. Wszystkie wywołane elementy niebędące wyjątkami zostaną opakowane w elemencie System.Runtime.CompilerServices.RuntimeWrappedException.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">To ostrzeżenie występuje, gdy blok catch() nie ma określonego typu wyjątku po bloku catch (System.Exception e). Ostrzeżenie zawiera zalecenie, aby blok catch() nie przechwytywało żadnych wyjątków.

Blok catch() po bloku catch (System.Exception e) może przechwytywać wyjątki niezgodne ze specyfikacją CLS, jeśli element RuntimeCompatibilityAttribute ma ustawioną wartość false w pliku AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Jeśli ten atrybut nie ma jawnie ustawionej wartości false, wszystkie zgłaszane wyjątki niezgodne ze specyfikacją CLS są opakowywane jako wyjątki przez blok catch (System.Exception e).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">Argument operatora zwiększania lub zmniejszania musi być zmienną, właściwością lub indeksatorem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Element „{0}” nie zawiera definicji „{1}” i nie odnaleziono dostępnej metody rozszerzenia „{1}”, która przyjmuje pierwszy argument typu „{0}” (czy nie brakuje dyrektywy using lub odwołania do zestawu?).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'Element „{0}” nie zawiera definicji elementu „{1}” i nie można znaleźć metody rozszerzenia „{1}” przyjmującej pierwszy argument typu „{0}” (brak dyrektywy using dla elementu „{2}”?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">Metoda „{0}” zawiera modyfikator parametru „this”, który nie znajduje się w pierwszym parametrze</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated">Modyfikator parametru „{0}” nie może być używany z elementem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">Pierwszy parametr metody rozszerzenia nie może być parametrem typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">Tablicy parametrów nie można używać z modyfikatorem „this” w metodzie rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">Metoda rozszerzenia musi być statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">Metoda rozszerzenia musi być zdefiniowana w nieogólnej klasie statycznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">Parametr może mieć tylko jeden modyfikator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">Metody rozszerzenia muszą być zdefiniowane w statycznych klasach najwyższego poziomu. „{0}” to klasa zagnieżdżona</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">Nie można zdefiniować nowej metody rozszerzenia, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania do System.Core.dll?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">Nie używaj „System.Runtime.CompilerServices.ExtensionAttribute”. Zamiast niego użyj słowa kluczowego „this”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">Nie używaj „System.Runtime.CompilerServices.DynamicAttribute”. Zamiast niego użyj słowa kluczowego „dynamic”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">Wywołanie konstruktora musi być przydzielane dynamicznie, ale jest to niemożliwe, ponieważ jest częścią inicjatora konstruktora. Rozważ możliwość rzutowania argumentów dynamicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">Metody rozszerzenia „{0}” zdefiniowanej dla typu wartości „{1}” nie można użyć do tworzenia delegatów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">Żadne przeładowanie metody „{0}” nie pobiera następującej liczby argumentów: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">Argument „{0}”: nie można przekonwertować z „{1}” na „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">Nie można otworzyć pliku źródłowego „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">Nie można połączyć plików zasobów podczas kompilowania modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">Identyfikator zasobu „{0}” został już użyty w tym zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">Nazwa pliku każdego połączonego zasobu i modułu musi być unikatowa. Nazwę pliku „{0}” określono więcej niż raz w tym zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">Przywoływany plik „{0}” nie jest zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">Wartość ref lub out musi być zmienną umożliwiającą przypisanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">W metodzie statycznej słowo kluczowe „base” jest niedostępne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">W bieżącym kontekście słowo kluczowe „base” jest niedostępne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">Oczekiwano znaku }</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">Oczekiwano znaku {</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'Oczekiwano słowa kluczowego „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">Nieprawidłowe wyrażenie preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, struct, or interface member declaration</source>
        <target state="translated">Nieprawidłowy token „{0}” w deklaracji składowej klasy, struktury lub interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">Metoda musi mieć typ zwracany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">Nieprawidłowy typ podstawowy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">Pusty blok „switch”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">Pusty blok „switch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">Oczekiwano instrukcji „catch” lub „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">W wyrażeniu występuje nieprawidłowe określenie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires (), [], or {} after type</source>
        <target state="translated">Wyrażenie new wymaga znaków (), [] lub {} po typie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">Elementów definiowanych w przestrzeni nazw nie można jawnie deklarować jako prywatnych, chronionych, chronionych wewnętrznych lub prywatnych chronionych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">Oczekiwano znaku ; lub = (w deklaracji nie można określić argumentów konstruktora).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">Klauzula „using” musi występować przed wszystkimi innymi elementami zdefiniowanymi w przestrzeni nazw poza deklaracjami aliasów zewnętrznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">Przeciążony operator binarny „{0}” przyjmuje dwa parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">Przeciążony operator jednoargumentowy „{0}” przyjmuje jeden parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">Nieprawidłowy typ parametru (void)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">Alias użycia „{0}” pojawił się poprzednio w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">Nie można uzyskać dostępu do składowej chronionej „{0}” za pośrednictwem kwalifikatora typu „{1}”. Wymagany jest kwalifikator typu „{2}” (lub typu pochodzącego od tego typu).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'Nie można dodać elementu „{0}” do tego zestawu, ponieważ jest to już zestaw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metody dostępu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metodę dostępu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">W tym kontekście nie można użyć słowa kluczowego „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">Dla indeksatora trzeba zdefiniować co najmniej jeden parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">Specyfikator typu tablicy — [] — musi wystąpić przed nazwą parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">Nieprawidłowa deklaracja; zamiast niej użyj konstrukcji „{0} operator &lt;typ_docelowy&gt; (...”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Nie można znaleźć elementu „{0}” określonego dla metody Main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, struct, or interface</source>
        <target state="translated">Element „{0}” określony dla metody Main musi być nieogólną klasą, strukturą lub interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">Element „{0}” nie ma odpowiedniej statycznej metody „Main”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">Nie można użyć elementu „{0}” dla metody Main, ponieważ jest on zaimportowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">Dla wyjść bez źródła trzeba określić opcję /out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">Określono opcje powodujące konflikt: plik zasobów Win32; manifest Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">Określono opcje powodujące konflikt: plik zasobów Win32; ikona Win32.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas odczytywania zasobu „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">Błąd zapisu w pliku dokumentacji XML: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">Komentarz XML ma nieprawidłowo sformułowany kod XML — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">Komentarz XML ma nieprawidłowo sformułowany kod XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag param dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag param</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag param dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag param, ale nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Komentarz XML elementu „{1}” ma tag paramref dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag paramref, ale nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">Parametr „{0}” nie ma zgodnego tagu param w komentarzu XML elementu „{1}” (lecz inne parametry mają)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">Parametr nie ma zgodnego tagu param w komentarzu XML (ale inne parametry mają ten tag)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">Komentarz XML ma atrybut cref „{0}”, którego nie można rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">Komentarz XML zawiera atrybut cref, którego nie można rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">W wyrażeniu stackalloc po nazwie typu wymagane jest użycie specyfikatora [].</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">Nie określono numeru wiersza dla dyrektywy #line lub określony numer jest nieprawidłowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano nazwy pliku w cudzysłowie, jednowierszowego komentarza lub końca wiersza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">Oczekiwano nazwy pliku w cudzysłowach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">Dyrektywa #r jest dozwolona tylko w skryptach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'</source>
        <target state="translated">Instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznej definicji wystąpienia elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">Nieprawidłowy typ parametru {0} w atrybucie cref komentarza XML: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy typ parametru w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Błąd odczytu zasobów Win32 — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">Komentarz XML zawiera składniowo niepoprawny atrybut cref „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">Komentarz XML zawiera składniowo niepoprawny atrybut cref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">Modyfikator składowej „{0}” musi wystąpić przed definicją typu i nazwy składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">Do utworzenia tablicy wymagane jest określenie rozmiaru tablicy lub inicjatora tablicy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Komentarz XML nie został umieszczony w prawidłowym elemencie języka</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Komentarz XML nie został umieszczony w prawidłowym elemencie języka</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">Nie można dołączyć fragmentu XML „{1}” pliku „{0}” — {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">Nie można dołączyć fragmentu XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">Nieprawidłowy element include w kodzie XML — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">Nieprawidłowy element include w kodzie XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">Brak komentarza XML dla widocznego publicznie typu lub składowej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">Brak komentarza XML dla widocznego publicznie typu lub składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">Określono opcję kompilatora /doc, ale co najmniej jedna konstrukcja nie ma komentarzy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Nieprawidłowo sformułowany kod XML znajduje się w pliku komentarzy — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Nieprawidłowo sformułowany kod XML w pliku komentarzy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">Delegat „{0}” nie przyjmuje argumentów {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">Użycie średnika po bloku metody lub metody dostępu jest nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>Method or delegate cannot return type '{0}'</source>
        <target state="translated">Metoda ani delegat nie może zwracać typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">Kompilacja anulowana przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">Nie można przywołać zmiennej typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">Nie można przypisać wartości do elementu „{0}” ponieważ jest on tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">Atrybut RequiredAttribute jest niedozwolony dla typów C#</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">Nie można używać modyfikatorów w deklaracjach metod dostępu do zdarzeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">Parametr params nie może zostać zadeklarowany jako {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">Nie można zmodyfikować zwracanej wartości „{0}”, ponieważ nie jest to zmienna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">Nie można znaleźć zarządzanej klasy otoki coclass „{0}” interfejsu „{1}” (brak odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'; use either '@{0}' or '{0}Attribute'</source>
        <target state="translated">'„{0}” jest niejednoznaczne między „{1}” i „{2}”; użyj „@{0}” lub „{0}Attribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">Argumentu „{0}” nie można przekazać ze słowem kluczowym „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">Opcja „{0}” przesłania atrybut „{1}” podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">Opcja przesłania atrybut podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">To ostrzeżenie występuje, jeśli atrybut zestawu AssemblyKeyFileAttribute lub AssemblyKeyNameAttribute w źródle powoduje konflikt z opcją wiersza polecenia /keyfile lub /keycontainer albo z nazwą pliku klucza lub kontenerem określonymi we właściwościach projektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla /langversion. Użyj opcji „/langversion:?”, aby wyświetlić listę obsługiwanych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">Nie można utworzyć delegata z „{0}”, ponieważ on albo metoda, którą przesłania, ma atrybut „Conditional”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">Nie można utworzyć pliku tymczasowego — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">Argument „{0}” musi być przekazywany ze słowem kluczowym „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">Nie można używać instrukcji yield wewnątrz metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">Nie można zwrócić wartości z iteratora. Użyj instrukcji yield return, aby zwrócić wartość, lub yield break, aby zakończyć iterację.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">Iteratory nie mogą mieć parametrów ref, in ani out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">Treść „{0}” nie może być blokiem iteratora, ponieważ „{1}” nie jest typem interfejsu iteratora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">Nie można użyć instrukcji yield w treści klauzuli finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">Nie można użyć instrukcji yield z wartością w treści bloku try z klauzulą catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">Oczekiwano wyrażenia po instrukcji yield return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Nie można użyć parametru ref, out ani in „{0}” wewnątrz metody anonimowej, wyrażenia lambda, wyrażenia zapytania lub funkcji lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalInnerUnsafe">
        <source>Unsafe code may not appear in iterators</source>
        <target state="translated">Niebezpieczny kod nie może występować w iteratorach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">Nie można użyć instrukcji yield z wartością w treści klauzuli catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">Kontrolka nie może opuścić tekstu metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Nierozpoznana dyrektywa #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Nierozpoznana dyrektywa #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">Oczekiwano elementu „disable” lub „restore”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">Oczekiwano elementu „disable” lub „restore” po ostrzeżeniu #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">Nie można przywrócić ostrzeżenia „CS{0}”, ponieważ zostało wyłączone globalnie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">Nie można przywrócić ostrzeżenia, ponieważ zostało globalnie wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">Element „__arglist” jest niedozwolony w liście parametrów iteratorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have unsafe parameters or yield types</source>
        <target state="translated">Iteratory nie mogą mieć niebezpiecznych parametrów ani typów przekazywania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">Sygnatura „{0}” zarządzanej klasy otoki coclass dla interfejsu „{1}” nie jest prawidłową sygnaturą nazwy klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Instrukcja foreach nie może używać zmiennych typu „{0}”, ponieważ implementuje wiele utworzeń wystąpienia elementu „{1}”. Spróbuj rzutowania na konkretne utworzenie wystąpienia interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">Pole buforu o ustalonym rozmiarze musi mieć specyfikator rozmiaru tablicy po nazwie pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">Pola buforu o ustalonym rozmiarze mogą być tylko składowymi struktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">Nie dla wszystkich ścieżek w kodzie jest zwracana wartość w {0} typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Funkcja „{0}” nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Funkcja nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">Słowo kluczowe, identyfikator lub ciąg oczekiwany po specyfikatorze kalki: @.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Składowych pola tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor of the class in which the field is defined or a variable initializer))</source>
        <target state="translated">Nie można przypisać do pola tylko do odczytu (poza konstruktorem klasy, w której pole jest zdefiniowane lub jest inicjatorem zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">Nie można modyfikować składowych pola tylko do odczytu „{0}” (z wyjątkiem składowych w konstruktorze lub inicjatorze zmiennych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">Nie można użyć elementu {0} „{1}” jako wartości ref ani out, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">Składowe elementu {0} „{1}” nie mogą być używane jako wartość ref ani out, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' because it is a readonly variable</source>
        <target state="translated">Nie można przypisać do elementu {0} „{1}”, ponieważ jest to zmienna tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' because it is a readonly variable</source>
        <target state="translated">Nie można przypisać do składowej {0} „{1}”, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">Nie można zwrócić elementu {0} „{1}” przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">Składowe elementu {0} „{1}” nie mogą być zwracane przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Polom statycznego pola tylko do odczytu „{0}” nie można przypisać wartości (z wyjątkiem pól w konstruktorze statycznym lub inicjatorze zmiennych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Pól pola statycznego tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze statycznym)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">Nie można zmodyfikować składowych „{0}”, ponieważ jest to „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Nie można użyć pól elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">Nie można przypisać wartości do elementu „{0}”, ponieważ jest to „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}. Patrz także błąd CS{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">Ostrzeżenie przesłania błąd</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">Kompilator emituje to ostrzeżenie w przypadku przesłonięcia błędu z ostrzeżeniem. Aby uzyskać informacje dotyczące tego problemu, wyszukaj podany kod błędu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">Nie można przekonwertować elementu {0} na typ „{1}”, ponieważ nie jest to typ delegowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">Nie można przekonwertować elementu {0} na typ „{1}”, ponieważ typy parametrów nie pasują do typów parametru delegowanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">Nie można przekonwertować bloku „{0}” na zamierzony typ delegowany, ponieważ niektóre typy zwracane występujące w bloku nie umożliwiają niejawnej konwersji na zwracany typ delegowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than 'Task&lt;{0}&gt;'</source>
        <target state="translated">Ponieważ jest to metoda asynchroniczna, zwracane wyrażenie musi być typu „{0}”, a nie „Task&lt;{0}&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">Nie można przekonwertować elementu async {0} na typ delegowany „{1}”. Element async {0} może zwrócić wartość void, Task lub Task&lt;T&gt;, a żadne z tych typów nie mogą być przekonwertowane na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">Typ buforu o ustalonym rozmiarze musi być jednym z następujących typów: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float lub double.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">Bufor o ustalonym rozmiarze o długości {0} i typie „{1}” jest za duży</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">Bufory o ustalonym rozmiarze muszą mieć długość większą niż zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">Nie można użyć buforów o ustalonym rozmiarze zawartych w wyrażeniach unfixed. Spróbuj użyć instrukcji fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Atrybut „{0}” nie jest prawidłowy w metodach dostępu do właściwości lub zdarzeń. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">Określono nieprawidłową ścieżkę wyszukiwania „{0}” w elemencie „{1}” — „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">Określono nieprawidłową ścieżkę wyszukiwania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">Element „__arglist” jest nieprawidłowy w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">Element params jest nieprawidłowy w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">Deklaracja przestrzeni nazw nie może mieć modyfikatorów ani atrybutów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla opcji /platform; wymagana wartość to anycpu, x86, Itanium, arm, arm64 lub x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.</source>
        <target state="translated">Anonimowe metody, wyrażenia lambda i wyrażenia zapytania wewnątrz struktur nie mogą uzyskiwać dostępu do składowych wystąpień elementu „this”. Rozważ możliwość skopiowania elementu „this” do zmiennej lokalnej poza metodą anonimową, wyrażeniem lambda lub wyrażeniem zapytania i użycie zamiast niego elementu lokalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.</source>
        <target state="translated">„{0}”: typ użyty w instrukcji using musi umożliwiać niejawną konwersję na interfejs „System.IDisposable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">Parametr „{0}” musi być deklarowany za pomocą słowa kluczowego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">Parametr {0} nie powinien być deklarowany za pomocą słowa kluczowego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">Parametr {0} jest deklarowany jako typ „{1}{2}”, a powinien być „{3}{4}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowy alias zewnętrzny dla opcji „/reference”; wartość „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">Nieprawidłowa opcja aliasu odwołania: „{0}=” — brak nazwy pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">Nie można ponownie zdefiniować globalnego aliasu zewnętrznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">Odwołanie do typu „{0}” określa, że jest zdefiniowane w tym zestawie, lecz nie jest zdefiniowane w module źródłowym ani w żadnym z dodanych modułów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">Odwołanie do typu „{0}” określa, że jest zdefiniowane w elemencie „{1}”, lecz nie można go znaleźć</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” jest zdefiniowany w wielu zestawach aliasu globalnego. Zostanie użyta definicja z elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">Wstępnie zdefiniowany typ występuje w wielu zestawach w aliasie globalnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">Ten błąd występuje w przypadku odnalezienia wstępnie zdefiniowanego typu, takiego jak System.Int32, w dwóch zestawach. Może się tak dziać, gdy utworzono odwołanie do elementu mscorlib lub biblioteki System.Runtime.dll w dwóch różnych miejscach, na przykład podczas próby uruchomienia dwóch wersji programu .NET Framework obok siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">Adresu elementu lokalnego „{0}” lub jego składowych nie można pobrać i użyć wewnątrz metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">Nie można przekonwertować bloku metody anonimowej bez listy parametrów na typ delegowany „{0}”, ponieważ ma on jeden lub kilka parametrów out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w przypadku metod lub klas atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Dostęp do składowej elementu „{0}” może spowodować wystąpienie wyjątku czasu wykonywania, ponieważ to jest pole w klasie marshal-by-reference</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">Dostęp do składowej pola w klasie marshal-by-reference może spowodować wystąpienie wyjątku czasu wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">To ostrzeżenie występuje, gdy w przypadku próby wywołania metody, właściwości lub indeksatora w składowej klasy pochodnej elementu MarshalByRefObject składowa jest typem wartości. Obiekty dziedziczące po elemencie MarshalByRefObject zwykle powinny być kierowane przez referencję w domenie aplikacji. Jeśli kod spróbuje bezpośrednio uzyskać dostęp do składowej typu wartości takiego obiektu w domenie aplikacji, wystąpi wyjątek czasu wykonywania. Aby rozwiązać problem podany w ostrzeżeniu, skopiuj składową do zmiennej lokalnej i wywołaj metodę w tej zmiennej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">'„{0}” to nie jest prawidłowy numer ostrzeżenia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">Nieprawidłowy numer ostrzeżenia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">Numer przekazany do dyrektywy preprocesora ostrzeżenia #pragma nie jest prawidłowym numerem ostrzeżenia. Upewnij się, że numer reprezentuje ostrzeżenie, a nie błąd.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora. Nazwa pliku jest za długa lub nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">Nieprawidłowa składnia sumy kontrolnej #pragma checksum; powinna być następująca: #pragma checksum "nazwa_pliku" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">Nieprawidłowa składnia sumy kontrolnej #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza po dyrektywie #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">Podano różne sumy kontrolne dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">Podano różne wartości sumy kontrolnej #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">To ostrzeżenie oznacza, że nie określono poprawnie atrybutu, takiego jak InternalsVisibleToAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">Zostało zaimportowanych wiele zestawów o równoważnej tożsamości: „{0}” i „{1}”. Usuń jedno ze zduplikowanych odwołań.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">Zestaw o tej samej prostej nazwie „{0}” został już zaimportowany. Spróbuj usunąć jedno z odwołań (np. „{1}”) lub podpisz je, aby umożliwić działanie obok siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">Zestaw „{0}” z tożsamością „{1}” używa elementu „{2}”, który ma wyższą wersję niż przywoływany zestaw „{3}” z tożsamością „{4}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">Do buforów o ustalonym rozmiarze można uzyskać dostęp tylko przez elementy lokalne lub pola</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag typeparam dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag typeparam</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparam dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparam, ale nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML elementu „{1}” ma tag typeparamref dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparamref, ale nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">Parametr typu „{0}” nie ma zgodnego tagu typeparam w komentarzu XML elementu „{1}” (lecz inne parametry typu mają)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">Parametr typu nie ma zgodnego tagu typeparam w komentarzu XML (ale inne parametry mają ten tag)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'„{0}”: typ musi być „{2}”, aby być zgodnym z przesłoniętą składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">Nie używaj atrybutu „System.Runtime.CompilerServices.FixedBuffer”. Zamiast niego użyj modyfikatora pola „fixed”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">Wykonano przypisanie do tej samej zmiennej. Czy chcesz przypisać coś innego?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">Ustawiono przypisanie do tej samej zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">Wykonano porównanie z tą samą zmienną. Czy chcesz porównać coś innego?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">Wykonano porównanie z tą samą zmienną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas otwierania pliku zasobów Win32 „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">Wyrażenie zawsze spowoduje wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość elementu „{0}” to null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">Wyrażenie będzie zawsze powodować wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość typu to null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">Klasa „{0}” nie może zawierać wielu klas bazowych: „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">Przed interfejsami musi występować klasa bazowa „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">Komentarz XML zawiera atrybut cref „{0}” przywołujący parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">Komentarz XML zawiera atrybut cref przywołujący parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Deklaracje InternalsVisibleTo nie mogą mieć określonej wersji, kultury, tokena klucza publicznego ani architektury procesora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Zestawy podpisane silnymi nazwami muszą określać klucz publiczny w swoich deklaracjach InternalsVisibleTo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">Nie można powiązać obiektu delegowanego z elementem „{0}”, ponieważ jest to składowa typu „System.Nullable&lt;T&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'Element „{0}” nie zawiera konstruktora przyjmującego następującą liczbę argumentów: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">Atrybuty zestawu i modułu muszą występować przed wszystkimi innymi elementami zdefiniowanymi w pliku poza klauzulami using i deklaracjami aliasów zewnętrznych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">Oczekiwano wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">Nieprawidłowa wersja „{0}” dla opcji /subsystemversion. Wymagana jest 6.02 lub nowsza dla ARM lub AppContainerExe oraz wersja 4.00 lub nowsza w pozostałych przypadkach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">Osadzona metoda międzyoperacyjna „{0}” zawiera treść.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be in the range 0-4</source>
        <target state="translated">Poziom ostrzeżeń musi być wartością z zakresu od 0 do 4</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla opcji /debug; wymagana wartość to „portable”, „embedded”, „full” lub „pdbonly”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">Nieprawidłowa opcja „{0}”; widoczność zasobu musi mieć wartość „public” lub „private”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">Typ argumentu atrybutu DefaultParameterValue musi być zgodny z typem parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">Argumentu typu „{0}” nie można stosować do atrybutu DefaultParameterValue</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">Zduplikowana inicjacja składowej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">Nie można zainicjować składowej „{0}”. To nie jest pole ani właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">Statycznego pola lub właściwości „{0}” nie można przypisać w inicjatorze obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Do składowych pola tylko do odczytu „{0}” typu „{1}” nie można przypisać inicjatora obiektu, ponieważ jest ono typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Składowych właściwości „{0}” typu „{1}” nie można przypisać za pomocą inicjatora obiektu, ponieważ jest on typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">Nie można użyć niezabezpieczonego typu „{0}” do tworzenia obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">Inicjator elementu nie może być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">Najlepiej dopasowana metoda przeciążona elementu „{0}” zawiera niewłaściwą sygnaturę dla elementu inicjatora. Możliwa do zainicjowania metoda Add musi być dostępną metodą wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">Nie można zainicjować typu „{0}” za pomocą inicjatora kolekcji, ponieważ nie implementuje on interfejsu „System.Collections.IEnumerable”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas odczytywania pliku manifestu Win32 „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'„{0}” nie zawiera definicji dla „{1}”, a najlepsze przeciążenie metody rozszerzenia „{2}” wymaga odbiorcy typu „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">Zmienna zakresu „{0}” jest już zadeklarowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">Zmienna zakresu „{0}” powoduje konflikt z poprzednią deklaracją zmiennej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">Nie można przypisać elementu „{0}” do zmiennej zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Rozważ jawne określenie typu zmiennej zakresu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Być może brakuje odwołania do biblioteki „System.Core.dll” lub użycia dyrektywy dla przestrzeni nazw „System.Linq”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Nazwa „{0}” jest poza zakresem lewej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Nazwa „{0}” jest poza zakresem prawej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">Nie można przekazać zmiennej zakresu „{0}” jako parametru ze specyfikatorem out lub ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">Znaleziono wiele implementacji wzorca zapytania dla typu źródłowego „{0}”. Niejednoznaczne wywołanie elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Typ jednego z wyrażeń w klauzuli {0} jest nieprawidłowy. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Typ wyrażenia w klauzuli {0} jest niepoprawny. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">Wyrażenie typu „{0}” jest niedozwolone w kolejnej klauzuli from w wyrażeniu zapytania z typem źródłowym „{1}”. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać niebezpiecznej operacji wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać wyrażenia metody anonimowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">Nie można przekonwertować wyrażenia metody anonimowej na drzewo wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Nie można wykonać przypisania do zmiennej zakresu „{0}” — można ją tylko odczytać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">Zmienna zakresu „{0}” nie może mieć takiej samej nazwy jak parametr typu metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">Nie można używać kontekstowego słowa kluczowego „var” w deklaracji zmiennej zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">Niektóre argumenty najlepiej dopasowanej przeciążonej metody Add „{0}”dla inicjatora kolekcji są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać parametrów ref, in ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać metody z argumentami zmiennych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać grupy metod</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">Nie można użyć najlepiej dopasowanej przeciążonej metody Match „{0}” dla elementu inicjatora kolekcji. Metody „Add” inicjatora kolekcji nie mogą mieć parametrów ref ani out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">Składowej „{0}”, której nie można wywoływać, nie można używać jak metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">Składowa „{0}” implementuje składową interfejsu „{1}” w typie „{2}”. W czasie wykonywania składowa interfejsu jest zgodna z wieloma metodami. Od implementacji zależy, która metoda zostanie wywołana.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">Składowa implementuje składową za pomocą wielu dopasowań w czasie wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">To ostrzeżenie może zostać wygenerowane, gdy dwie metody interfejsu różnią się tylko oznaczeniem określonego parametru specyfikatorem ref lub out. Aby zapobiec występowaniu tego ostrzeżenia, zmień kod, ponieważ nie można jednoznacznie określić ani zagwarantować, która metoda zostanie wywołana w czasie wykonywania.

Język C# rozróżnia specyfikatory out i ref, jednak dla środowiska CLR są one takie same. Wybiera ono dowolny z nich podczas określania, która metoda zawiera implementację interfejsu.

Musisz umożliwić kompilatorowi rozróżnienie metod. Możesz na przykład nadać im różne nazwy lub określić dla jednej z nich dodatkowy parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">Składowa „{1}” przesłania element „{0}”. W czasie wykonywania jest możliwych wiele różnych przesłonięć. Od implementacji zależy, która metoda zostanie wywołana.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">Składowa przesłania podstawową składową za pomocą wielu możliwych przesłonięć w czasie wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">Nie można zastosować wyrażeń inicjatora obiektu i kolekcji do wyrażenia tworzenia delegata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'Element „{0}” jest typu „{1}”. W deklaracji stałej należy określić typ sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, typ wyliczeniowy lub typ odwołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">Nie można znaleźć pliku źródłowego „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">Plik źródłowy „{0}” jest określony wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">Plik źródłowy został określony wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">Brak specyfikacji pliku dla opcji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">Błąd składni wiersza polecenia: brak elementu „{0}” dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Nierozpoznana opcja: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">Nie określono plików źródłowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">Nie określono plików źródłowych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">Oczekiwano skryptu (plik CSX), ale go nie określono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">Błąd podczas otwierania pliku odpowiedzi „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">Nie można otworzyć „{0}” do zapisu — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">Nieprawidłowy numer podstawowy obrazu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'Plik „{0}” jest plikiem binarnym, a nie plikiem tekstowym</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">Strona kodowa „{0}” jest nieprawidłowa lub niezainstalowana</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">Algorytm „{0}” nie jest obsługiwany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">W czasie kompilowania modułu lub biblioteki nie można określić opcji /main</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">Nieprawidłowy typ elementu docelowego dla opcji /target: musisz podać typ „exe”, „winexe”, „library” lub „module”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">Nieprawidłowe wyrównanie sekcji pliku „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa wyjścia: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">Nieprawidłowy format informacji debugowania: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'Składnia „id#” nie jest już używana. Zamiast niej użyj składni „$id”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">Nie można utworzyć krótkiej nazwy pliku „{0}”, jeśli już istnieje długa nazwa pliku, której krótka wersja jest taka sama</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">Opcja /reference, która deklaruje alias zewnętrzny, może mieć tylko jedną nazwę pliku. Aby określić wiele aliasów lub nazw plików, użyj wielu opcji /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">Błąd składni wiersza polecenia: brak elementu „:&lt;liczba&gt;” dla opcji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">Opcja /pdb wymaga również użycia opcji /debug </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać wywołania modelu COM z pominiętym parametrem ref przy argumentach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">Błąd składni wiersza polecenia: nieprawidłowy format identyfikatora GUID „{0}” dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">Błąd składni wiersza polecenia: brak identyfikatora Guid dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">Typ argumentu „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">Typ argumentu nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">Zwracany typ „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">Typ zwracany nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">Typ elementu „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">Typ nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">Typ zmiennej publicznej, chronionej zmiennej lub chronionej zmiennej wewnętrznej musi być zgodny ze specyfikacją CLS (Common Language Specification).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">Identyfikator „{0}” różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">Identyfikator różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda „{0}” różniąca się tylko specyfikacją ref lub out parametru lub rangą tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda różniąca się tylko parametrem ref lub out albo rangą tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda „{0}” różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">Ten błąd występuje, gdy przeciążona metoda korzysta z tablicy nieregularnej i jedyną różnicą między sygnaturami metod jest typ elementu tablicy. Aby uniknąć tego błędu, rozważ użycie tablicy regularnej zamiast tablicy nieregularnej, użyj dodatkowego parametru w celu odróżnienia wywołania funkcji, zmień nazwy przeciążonych metod lub usuń atrybut CLSCompliantAttribute, jeśli zgodność ze specyfikacją CLS nie jest wymagana.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">Identyfikator „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">Identyfikator nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'„{0}”: typ podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">Typ podstawowy nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">Typ podstawowy został oznaczony jako element, który nie musi być zgodny ze specyfikacją CLS (Common Language Specification), w zestawie oznaczonym jako zgodny ze specyfikacją CLS. Usuń atrybut określający, że zestaw jest zgodny ze specyfikacją CLS, lub usuń atrybut określający, że typ nie jest zgodny ze specyfikacją CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'„{0}”: interfejsy zgodne ze specyfikacją CLS muszą mieć tylko składowe zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">Interfejsy zgodne ze specyfikacją CLS muszą mieć tylko składowe zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'„{0}”: tylko składowe zgodne ze specyfikacją CLS mogą być abstrakcyjne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">Tylko składowe zgodne ze specyfikacją CLS mogą być abstrakcyjne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Nie można oznaczyć typu lub składowej jako zgodnej ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'Element „{0}” nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">Typ nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ jest to składowa typu „{1}” niezgodnego ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">Nie można oznaczyć typu jako zgodnego ze specyfikacją CLS, ponieważ jest to składowa typu niezgodnego ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane dla elementu „{0}”, ponieważ nie jest on widoczny spoza tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane, ponieważ nie jest on widoczny spoza tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'Element „{0}” nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Typ lub składowa nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do parametrów. Zamiast tego spróbuj umieścić go w metodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do zwracanych typów. Zamiast tego spróbuj umieścić go w metodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do typów zwracanych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">Typ ograniczenia „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">Typ ograniczenia nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">Pole zgodne ze specyfikacją CLS „{0}” nie może mieć specyfikatora volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">Pole zgodne ze specyfikacją CLS nie może być nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'Element „{0}” nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">Typ nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">Operator „await” wymaga, aby typ {0} miał odpowiednią metodę „GetAwaiter”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">Nie można zdefiniować oczekiwania na „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">Operator „await” wymaga, aby zwracany typ „{0}” metody „{1}.GetAwaiter()” miał odpowiednie składowe „IsCompleted”, „OnCompleted” i „GetResult” oraz implementował interfejs „INotifyCompletion” lub „ICriticalNotifyCompletion”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">Operator „await” wymaga, aby typ {0} miał przypisaną odpowiednią metodę „GetAwaiter”. Czy brakuje dyrektywy using dla elementu „System”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">Nie można zdefiniować oczekiwania na „void”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'Operatora „await” nie można użyć jako identyfikatora w metodzie asynchronicznej ani wyrażeniu lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'„{0}” nie implementuje „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">Ponieważ „{0}” to metoda asynchroniczna zwracająca typ „Task”, po słowie kluczowym return nie może następować wyrażenie obiektu. Czy zamierzony zwracany typ to „Task&lt;T&gt;”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">Typ zwracany metody asynchronicznej musi być elementem void, Task lub Task&lt;T&gt;, typem podobnym do zadania albo elementem IAsyncEnumerable&lt;T&gt; lub IAsyncEnumerator&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">Nie można zwrócić wyrażenia typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">Element „__arglist” jest niedozwolony na liście parametrów metod asynchronicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>'await' cannot be used in an expression containing the type '{0}'</source>
        <target state="translated">'Operatora „await” nie można użyć w wyrażeniu zawierającym typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have unsafe parameters or return types</source>
        <target state="translated">Metody asynchroniczne nie mogą zawierać niezabezpieczonych parametrów ani zwracanych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">Metody asynchroniczne nie mogą zawierać parametrów ref, in ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">Operatora „await” można używać tylko wtedy, gdy zawierająca go metoda lub wyrażenie lambda zostaną oznaczone modyfikatorem „async”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">Operatora „await” można używać tylko w elemencie asynchronicznym {0}. Rozważ oznaczenie elementu {0} za pomocą modyfikatora „async”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">Operatora „await” można używać tylko w metodzie asynchronicznej. Rozważ oznaczenie tej metody za pomocą modyfikatora „async” i zmianę jej typu zwracanego na „Task&lt;{0}&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">Operatora „await” można używać tylko wewnątrz metody asynchronicznej. Rozważ możliwość oznaczenia tej metody za pomocą modyfikatora „async” i zmiany zwracanego przez nią typu na „Task”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania w treści klauzuli „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania wewnątrz klauzuli „catch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania w wyrażeniu filtru klauzuli „catch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">Nie można zdefiniować oczekiwania w treści instrukcji „lock”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">Operatora „await” nie można użyć w inicjalizatorze statycznej zmiennej skryptu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">Nie można zdefiniować oczekiwania w kontekście słowa kluczowego „unsafe”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">Modyfikatora „async” można używać tylko w metodach mających treść.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefLocal">
        <source>Parameters or locals of type '{0}' cannot be declared in async methods or lambda expressions.</source>
        <target state="translated">Parametrów ani elementów lokalnych typu „{0}” nie można deklarować w metodach asynchronicznych ani wyrażeniach lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefIterator">
        <source>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.</source>
        <target state="translated">Instrukcja foreach nie może działać na modułach wyliczających typu „{0}” w metodach asynchronicznych lub iteratora, ponieważ element „{0}” jest strukturą ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">Atrybutu zabezpieczeń „{0}” nie można zastosować dla metody asynchronicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">Metody asynchroniczne są niedozwolone w interfejsach, klasach lub strukturach z atrybutem „SecurityCritical” lub „SecuritySafeCritical”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">Operatora „await” można użyć tylko w wyrażeniu zapytania w pierwszym wyrażeniu kolekcji początkowej klauzuli „from” albo w wyrażeniu kolekcji klauzuli „join”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">W tej metodzie asynchronicznej brakuje operatorów „await”, dlatego będzie wykonywana synchronicznie. Rozważ możliwość użycia operatora „await” w celu zdefiniowania oczekiwania na nieblokujące wywołania interfejsów API albo wyrażenia „await Task.Run(...)” w celu przeniesienia wykonywania zadań intensywnie angażujących procesor do wątku w tle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">Metoda asynchroniczna nie zawiera operatorów „await” i zostanie uruchomiona synchronicznie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">Ponieważ to wywołanie nie jest oczekiwane, wykonywanie bieżącej metody będzie kontynuowane bez oczekiwania na ukończenie wywołania. Rozważ możliwość zastosowania operatora „await” do wyniku wywołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">To wywołanie nie jest oczekiwane, dlatego wykonywanie bieżącej metody będzie kontynuowane do czasu ukończenia wywołania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">Bieżąca metoda wywołuje metodę asynchroniczną, która zwraca zadanie lub wynik Task&lt;TResult&gt; i która nie stosuje operatora await do wyniku. Wywołanie metody asynchronicznej rozpoczyna zadanie asynchroniczne. Jednak ze względu na niezastosowanie operatora await działanie programu będzie kontynuowane bez oczekiwania na zakończenie zadania. W większości przypadków jest to nieoczekiwane zachowanie. Przeważnie inne aspekty metody wywołującej zależą do wyników wywołania lub przynajmniej działanie wywołanej metody powinno zakończyć się przed powrotem z metody zawierającej wywołanie.

Równie ważnym problemem jest to, co dzieje się z wyjątkami zgłoszonymi przez wywołaną metodę asynchroniczną. Wyjątek zgłoszony w ramach metody zwracającej zadanie lub wynik Task&lt;TResult&gt; jest przechowywany w zwróconym zadaniu. Jeśli nie wykonasz operacji await dla zadania ani jawnie nie wyszukasz wyjątków, wyjątek zostanie utracony. Jeśli wykonasz operację await dla zadania, wyjątek zostanie ponownie zgłoszony.

Najlepsze rozwiązanie to wykonywanie operacji await dla zadania za każdym razem.

Pominięcie ostrzeżenia należy wziąć pod uwagę tylko w sytuacji, gdy na pewno nie chcesz czekać na zakończenie wywołania asynchronicznego oraz gdy wywołana metoda nie zgłosi żadnych wyjątków. W tym przypadku można pominąć ostrzeżenie, przydzielając wynik zadania wywołania do zmiennej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'Atrybutu „MethodImplOptions.Synchronized” nie można stosować do metody asynchronicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerLineNumberAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerFilePathAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerMemberNameAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerLineNumberAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerFilePathAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerMemberNameAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerLineNumberAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerLineNumberAttribute nie odniesie żadnego skutku, ponieważ dotyczy on składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Atrybut CallerFilePathAttribute zastosowany do parametru „{0}” nie będzie mieć efektu, ponieważ jest stosowany do składowej używanej w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Atrybut CallerFilePathAttribute nie będzie mieć efektu, ponieważ jest stosowany do składowej używanej w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku, ponieważ dotyczy on składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">Program nie zawiera statycznej metody „Main” odpowiedniej jako punkt wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">Oczekiwano inicjatora tablicy o długości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">Oczekiwano zagnieżdżonego inicjatora tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">Nieprawidłowy modyfikator wariancji. Jako wariant można określić tylko parametry typu interface i delegate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">Nieoczekiwane użycie nazwy z aliasem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">Nieoczekiwane użycie nazwy ogólnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">Nieoczekiwane użycie niepowiązanej nazwy ogólnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">Wyrażenia i instrukcje mogą znajdować się tylko w treści metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">Dostęp do tablicy nie może mieć specyfikatora argumentu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">Ta funkcja językowa („{0}”) nie jest jeszcze zaimplementowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">Wartości domyślne w tym kontekście są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">Błąd podczas otwierania pliku ikony {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">Błąd podczas otwierania pliku manifestu Win32 {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Błąd kompilacji zasobów Win32 — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">Parametry opcjonalne muszą występować po wszystkich parametrach wymaganych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">Nie można dziedziczyć interfejsu „{0}” z określonymi typami parametrów, ponieważ spowoduje to, że metoda „{1}” będzie zawierać przeciążenia, które będą się różnić tylko parametrami ref i out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu i modyfikatory wariancji w takiej samej kolejności</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">Nieprawidłowa wariancja: parametr typu „{1}” musi być elementem {3} prawidłowym dla elementu „{0}”. Element „{1}” to „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'„{0}”: nie może pochodzić od typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'„{0}”: nie może implementować interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">Ograniczenie nie może być typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">Ograniczenie nie może być typu dynamicznego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można odnaleźć przynajmniej jednego typu wymaganego do skompilowania wyrażenia dynamicznego. Czy nie brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">Długość nazwy „{0}” przekracza maksymalną długość dozwoloną w metadanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">Atrybuty w tym kontekście są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'Alias zewnętrzny w tym kontekście jest nieprawidłowy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">Użycie elementu „{0}” do testowania zgodności z elementem „{1}” jest w zasadzie identyczne z testowaniem zgodności z elementem „{2}” i powiedzie się dla wszystkich wartości innych niż null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">Testowanie zgodności z typem „dynamic” za pomocą operatora „is” jest zasadniczo identyczne z testowaniem zgodności z typem „Object”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">Nie można użyć instrukcji „yield” w kodzie skryptu najwyższego poziomu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">Nie można zadeklarować przestrzeni nazw w kodzie skryptu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">Atrybuty zestawów i modułów nie są dozwolone w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">Delegat „{0}” nie ma metody wywołania lub ma metodę wywołania z typem zwracanym lub typami parametrów, które nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global script code; ignoring '{0}' entry point.</source>
        <target state="translated">Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia „{0}” został zignorowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global script code; ignoring entry point</source>
        <target state="translated">Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia został zignorowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">Drugi operand operatora „is” lub „as” nie może być typem statycznym „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zdarzenia „{1}” jest mniej dostępny niż zdarzenie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">Specyfikacje argumentów nazwanych muszą występować po wszystkich stałych argumentach, które zostały określone. Użyj wersji języka {0} lub nowszej, aby zezwalać na argumenty nazwane inne niż końcowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">Specyfikacje argumentu nazwanego muszą występować po wszystkich stałych argumentach, które zostały określone w dynamicznym wywołaniu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Najlepsza metoda przeładowania dla elementu „{0}” nie ma parametru o nazwie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Delegat „{0}” nie ma parametru o nazwie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">Nazwanego argumentu „{0}” nie można wprowadzać wiele razy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">Nazwany argument „{0}” określa parametr, dla którego argument pozycyjny został już wskazany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">Nazwany argument „{0}” jest używany poza pozycją, ale następuje po nim nienazwany argument</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">Nie można określić wartości domyślnej parametru w połączeniu z klasami DefaultParameterAttribute lub OptionalAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">Wartość domyślna parametru „{0}” musi być stałą czasu kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">Parametr ref lub out nie może mieć wartości domyślnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">Nie można określić wartości domyślnej dla parametru „this”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter array</source>
        <target state="translated">Nie można określić wartości domyślnej dla tablicy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">Wartości typu „{0}” nie można użyć jako domyślnego parametru, ponieważ nie ma standardowych konwersji do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">Wartości typu „{0}” nie można użyć jako domyślnego parametru dla parametru dopuszczającego wartość null „{1}”, ponieważ typ „{0}” nie jest typem prostym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'Typ elementu „{0}” to „{1}”. Wartość domyślnego parametru typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Domyślna wartość określona dla parametru „{0}” nie odniesie żadnego skutku, ponieważ jest zastosowana dla składowej używanej w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie określonej wartości domyślnej nie odniesie żadnego skutku, ponieważ dotyczy ona składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z pliku „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z kontenera „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">Operator typeof nie może zostać użyty dla typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operacji dynamicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">Asynchronicznych wyrażeń lambda nie można konwertować na drzewa wyrażeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można zdefiniować klasy ani składowej korzystającej z typu „dynamic”, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">Nie można przekazać wartości null dla nazwy przyjaznego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">W pliku klucza „{0}” brakuje klucza prywatnego potrzebnego do podpisania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">Określono publiczne podpisywanie, które wymaga klucza publicznego, lecz nie podano klucza publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">Publiczne podpisywanie nie jest obsługiwane w przypadku modułów sieciowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">Określony ciąg wersji jest niezgodny z wymaganym formatem — główna[.pomocnicza[.kompilacja[.poprawka]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">Określony ciąg wersji zawiera znaki wieloznaczne, które nie są zgodne z determinizmem. Usuń znaki wieloznaczne z ciągu wersji lub wyłącz determinizm dla tej kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">Określony ciąg wersji nie jest zgodny z wymaganym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka (bez znaków wieloznacznych).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">Pliki wykonywalne nie mogą być zestawami satelity, element Culture powinien zawsze być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'</source>
        <target state="translated">Nie podano argumentu odpowiadającego wymaganemu parametrowi formalnemu „{0}” elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">Przełącznik wiersza polecenia „{0}” nie został jeszcze wdrożony i został zignorowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">Przełącznik wiersza polecenia nie jest jeszcze zaimplementowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">Wyemitowanie modułu „{0}” nie powiodło się: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Ustalonego, lokalnego elementu „{0}” nie można używać w metodzie anonimowej, wyrażeniu lambda ani wyrażeniu zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać specyfikacji argumentu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać połączenia lub wywołania, które używa argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać właściwości indeksowanej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">Właściwość indeksowana „{0}” ma nieopcjonalne argumenty, które muszą być określone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">Właściwość indeksowana „{0}” musi mieć wszystkie argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">Wystąpienia typu „{0}” nie można użyć wewnątrz funkcji zagnieżdżonej, wyrażenia zapytania, bloku iteratora ani metody asynchronicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">Pierwszy argument atrybutu zabezpieczeń musi być prawidłową wartością SecurityAction</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">Atrybut zabezpieczeń „{0}” ma nieprawidłową wartość SecurityAction „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla typu lub metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutu PrincipalPermission</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">Nie można rozpoznać ścieżki pliku „{0}” określonej dla argumentu nazwanego „{1}” atrybutu PermissionSet</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">Błąd podczas odczytu pliku „{0}” określonego przez argument nazwany „{1}” atrybutu PermissionSet: „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można odnaleźć nazwy typu „{0}” w globalnej przestrzeni nazw. Ten typ został przesłany dalej do zestawu „{1}”. Rozważ możliwość dodania odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można odnaleźć nazwy typu „{0}” w przestrzeni nazw „{1}”. Ten typ został przesłany dalej do zestawu „{2}”. Rozważ możliwość dodania odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można znaleźć nazwy typu „{0}”. Ten typ został przekazany do zestawu „{1}”. Rozważ dodanie odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">Zestawy „{0}” i „{1}” odwołują się do tych samych metadanych, ale tylko jeden z nich jest odwołaniem połączonym (określonym za pomocą opcji /link); rozważ usunięcie jednego z odwołań.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorInInteractive">
        <source>Yield statements may not appear at the top level in interactive code.</source>
        <target state="translated">Instrukcje yield nie mogą pojawiać się na najwyższym poziomie kodu interaktywnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">Atrybut zabezpieczeń „{0}” jest nieprawidłowy w tym typie deklaracji. Atrybuty zabezpieczeń są prawidłowe tylko dla deklaracji zestawu, typu i metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">Nie można użyć wyrażenia typu „{0}” jako argumentu do operacji przydzielanej dynamicznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">Nie można użyć wyrażenia lambda jako argumentu do operacji przydzielanej dynamicznie bez uprzedniego rzutowania go na delegata lub typ drzewa wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">Nie można użyć grupy metod jako argumentu do operacji przydzielanej dynamicznie. Czy zamierzane było wywołanie metody?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Wywołanie metody „{0}” musi być przydzielane dynamicznie, lecz to nie jest możliwe, ponieważ jest ona częścią wyrażenia dostępu bazowego. Rozważ rzutowanie argumentów dynamicznych lub wyeliminowanie dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">Wyrażenia zapytań w odniesieniu do typu źródła „dynamic” lub z sekwencją złączenia typu „dynamic” nie są dozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Dostęp indeksatora musi być przydzielany dynamicznie, ale jest to niemożliwe, ponieważ jest częścią wyrażenia dostępu bazowego. Rozważ możliwość rzutowania argumentów dynamicznych lub wykluczenia dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">Dynamicznie przydzielane wywołanie metody „{0}” może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">Dynamicznie przydzielane wywołanie może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">„{0}” nie ma odpowiedniej metody o nazwie „{1}”, ale wygląda na to, że ma metodę rozszerzenia o tej nazwie. Metody rozszerzenia nie mogą być przydzielane dynamicznie. Rozważ rzutowanie dynamicznych argumentów lub wywołanie metody rozszerzenia bez składni metody rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerFilePathAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerFilePathAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Zastosowanie elementu CallerFilePathAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">Wyrażenie musi umożliwiać niejawną konwersję na typ Boolean lub jego typ „{0}” musi definiować operator „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'Element „{0}” nie może implementować elementu „{1}”, ponieważ „{2}” to zdarzenie środowiska wykonawczego systemu Windows, a „{3}” to zwykłe zdarzenie środowiska .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">Wywołaj metodę Call System.IDisposable.Dispose() dla alokowanego wystąpienia elementu {0}, zanim wszystkie odwołania do niego znajdą się poza zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">Wywołaj metodę System.IDisposable.Dispose() dla alokowanego wystąpienia zanim wszystkie odwołania do niego znajdą się poza zakresem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">Alokowane wystąpienie elementu {0} nie jest usuwane we wszystkich ścieżkach wyjątku. Wywołaj metodę System.IDisposable.Dispose(), zanim wszystkie odwołania do niego znajdą się poza zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">Nie usunięto alokowanego wystąpienia ze wszystkich ścieżek wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">Obiektu „{0}” nie można usunąć więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">Nie można usunąć obiektu więcej niż raz</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}”. Użyj zamiast tego odpowiedniego interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Typu „{0}” nie można osadzić, ponieważ to jest typ zagnieżdżony. Rozważ ustawienie właściwości „Osadź typy międzyoperacyjne” na wartość false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Typ „{0}” nie może być osadzony, ponieważ ma on argument ogólny. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">Osadzona struktura międzyoperacyjna „{0}” może zawierać tylko publiczne pola wystąpień.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Zdarzenia środowiska wykonawczego systemu Windows nie można przekazać jako parametru ze specyfikatorem out lub ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">Interfejs źródłowy „{0}” nie zawiera metody „{1}” wymaganej do osadzenia zdarzenia „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">Interfejs „{0}” zawiera nieprawidłowy interfejs źródłowy wymagany do osadzenia zdarzenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}”, ponieważ brakuje w nim wymaganego atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}” znajdującego się jednocześnie w zestawach „{1}” i „{2}”. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Osadzenie typu międzyoperacyjnego „{0}” z zestawu „{1}” powoduje konflikt nazw w bieżącym zestawie. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego „{0}” z powodu pośredniego odwołania do tego zestawu utworzonego przez zestaw „{1}”. Rozważ zmianę właściwości „Osadź typy międzyoperacyjne” w jednym z zestawów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego z powodu pośredniego odwołania do tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">Dodano odwołanie do zestawu przy użyciu opcji /link (ustawienie wartości True dla właściwości Osadź typy międzyoperacyjne). Nakazuje to kompilatorowi osadzenie informacji o typie międzyoperacyjnym z tego zestawu. Jednak kompilator nie może osadzić informacji o typie międzyoperacyjnym z tego zestawu, ponieważ inny przywoływany zestaw odwołuje się do tego zestawu przy użyciu opcji /reference (ustawienie wartości False dla właściwości Osadź typy międzyoperacyjne).

Aby osadzić informacje o typie międzyoperacyjnym dla obu zestawów, użyj opcji /link dla odwołań do każdego zestawu (ustaw wartość True dla właściwości Osadź typy międzyoperacyjne).

Aby usunąć ostrzeżenie, możesz zamiast tego użyć opcji /reference (ustaw wartość False dla właściwości Osadź typy międzyoperacyjne). W takiej sytuacji informacje o typie międzyoperacyjnym udostępnia podstawowy zestaw międzyoperacyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">Typ „{0}” z zestawu „{1}” nie może być używany między granicami zestawów, ponieważ ma argument typu ogólnego, który jest osadzonym typem międzyoperacyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">Nie można znaleźć typu międzyoperacyjnego zgodnego z osadzonym typem międzyoperacyjnym „{0}”. Czy brakuje odwołania do zestawu?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefReturnUnsupported">
        <source>By-reference return type 'ref {0}' is not supported.</source>
        <target state="translated">Typ zwracany przez referencję „ref {0}” nie jest obsługiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">Nazwa modułu „{0}” przechowywana w elemencie „{1}” musi być zgodna z nazwą jego pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa modułu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">Nieprawidłowa wartość „{0}”: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">Ścieżka AppConfigPath musi być bezwzględna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Atrybut „{0}” z modułu „{1}” zostanie zignorowany na korzyść wystąpienia w źródle</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Atrybut zostanie zignorowany na rzecz wystąpienia w źródle</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">Atrybut „{0}” podany w pliku źródłowym jest w konflikcie z opcją „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">Ustalony bufor może mieć tylko jeden wymiar.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">Przywoływany zestaw „{0}” nie ma silnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">Przywoływany zestaw nie ma silnej nazwy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">W atrybucie AssemblySignatureKeyAttribute określono nieprawidłowy klucz publiczny sygnatury.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Typ przesłany „{0}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” przesłanym do zestawu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">Przywoływany zestaw „{0}” ma inne ustawienie kultury — „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">Przywoływany zestaw ma inne ustawienie kultury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">Zestaw agnostyczny nie może mieć modułu specyficznego dla procesora „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">Zestaw i moduł „{0}” nie mogą wskazywać różnych procesorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">Celem przywołanego zestawu „{0}” jest inny procesor.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">Celem przywołanego zestawu jest inny procesor</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">Wystąpił błąd kryptograficzny w czasie tworzenia mieszań.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">Brak odwołania do modułu netmodule „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">Moduł „{0}” jest już zdefiniowany w tym zestawie. Nazwa pliku każdego modułu musi być unikatowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">Nie można odczytać pliku konfiguracyjnego „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">Nie można kontynuować, ponieważ edycja zawiera odwołanie do typu osadzonego: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">Dostęp do składowej „{0}” dodanej podczas bieżącej sesji debugowania można uzyskać tylko w deklarowanym zestawie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">Nie można równocześnie określić opcji kompilacji „{0}” i „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">Połączone metadane modułu netmodule muszą określać pełny obraz PE: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred można używać tylko z /t:exe, /t:winexe i /t:appcontainerexe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;lista ścieżek&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;tekst&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">operator propagowania wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">metoda z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">właściwość z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">indeksator z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">inicjator właściwości automatycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;przestrzeń nazw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">zmienne lokalne i wartości zwracane byref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">odwołania tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">struktury ref</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">Kompilacja (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">Węzeł składni znajduje się poza drzewem składni</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Lokalizacja musi być określona, aby zapewnić minimalną kwalifikację typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Klasa SyntaxTreeSemanticModel musi być dostępna, aby zapewnić minimalną kwalifikację typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">Nie można odwołać się do kompilacji typu „{0}” z kompilacji {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">Drzewo składni już istnieje</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">Przesłanie może zawierać tylko kod skryptu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">Przesłanie może mieć co najwyżej jedno drzewo składni.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">drzewo musi zawierać węzeł główny z elementem SyntaxKind.CompilationUnit</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">Argument typu nie może mieć wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">Nieprawidłowa liczba argumentów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">Nazwa {0} powoduje konflikt nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">Kombinacja opcji elementu LookupOptions jest nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">Element items: nie może być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier lub Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier do utworzenia tokenów identyfikatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów znakowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów liczbowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">Tej metody można użyć tylko do tworzenia tokenów — element {0} nie jest rodzajem tokenu.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">Ogólny parametr jest definicją, a oczekiwano odwołania {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">Wywołano metodę GetDeclarationName dla węzła deklaracji, który może zawierać wiele deklaratorów zmiennych.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeNotPartOfCompilation">
        <source>tree not part of compilation</source>
        <target state="translated">drzewo nie jest częścią kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">Pozycja nie znajduje się w drzewie składni o pełnym zasięgu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">Nazwa języka „{0}” jest nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">Nazwa języka jest nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">Dostęp do składowej z użyciem przezroczystego identyfikatora dla pola „{0}” typu „{1}” nie powiódł się. Czy odpytywane dane implementują wzorzec zapytania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">Parametr ma wiele różnych domyślnych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">Pole ma wiele unikatowych wartości stałych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">To nie symbol języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">Niepotrzebna dyrektywa using.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">Nieużywany alias zewnętrzny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">Elementy nie mogą mieć wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">zmienna środowiskowa LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">opcja /LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH opcja</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">katalog nie istnieje</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">ścieżka jest za długa lub nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">Nie znaleziono wartości elementu RuntimeMetadataVersion. Nie znaleziono żadnego zestawu zawierającego element System.Object ani nie określono wartości elementu RuntimeMetadataVersion za pomocą opcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">Nie odnaleziono wartości elementu RuntimeMetadataVersion</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">Oczekiwano elementu SemanticModel {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">wyrażenie lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 1. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 2. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 3. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 4. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 5. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 6. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsUnimplemented">
        <source>Feature '{0}' is not implemented in this compiler.</source>
        <target state="translated">Funkcja „{0}” nie jest zaimplementowana w tym kompilatorze.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'„eksperymentalna”</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">Pozycja musi znajdować się w zasięgu drzewa składni.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">Drzewo składni do przeanalizowania nie może należeć do drzewa składni bieżącej kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">Tworzenie łańcuchów spekulacyjnego modelu semantycznego nie jest obsługiwane. Należy utworzyć model spekulacyjny z nadrzędnego modelu niespekulacyjnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Kompilator Microsoft (R) Visual C#</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} w wersji {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Obsługiwane wersje językowe:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'„{0}”: klasa o atrybucie ComImport nie może określać inicjatorów pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">Lokalna nazwa „{0}” jest za długa dla pliku PDB. Rozważ skrócenie jej lub skompilowanie bez opcji /debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">Nazwa lokalna jest za długa dla pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">Funkcja anonimowa przekonwertowana na delegata zwracającego typ void nie może zwracać wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">Asynchroniczne wyrażenie lambda przekonwertowane na delegata zwracającego typ „Task” nie może zwracać wartości. Czy zamierzony zwracany typ to „Task&lt;T&gt;”?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">Wystąpienia analizatora {0} nie można utworzyć z elementu {1}: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">Nie można utworzyć wystąpienia analizatora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">Zestaw {0} nie zawiera żadnych analizatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">Zestaw nie zawiera analizatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">Nie można załadować zestawu analizatora {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">Nie można załadować zestawu analizatora</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">Niektóre typy zestawu analizatora {0} zostaną pominięte z powodu wyjątku ReflectionTypeLoadException: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">Błąd podczas odczytywania pliku zestawu reguł {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">Błąd podczas odczytywania informacji dotyczących debugowania elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">Operacja spowodowała przepełnienie stosu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">Oczekiwano identyfikatora lub literału liczbowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">Oczekiwano identyfikatora lub literału liczbowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties can have initializers.</source>
        <target state="translated">Tylko właściwości zaimplementowane automatycznie mogą mieć inicjatory.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">Właściwości zaimplementowane automatycznie w interfejsach muszą mieć metody dostępu get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">Automatycznie implementowane właściwości muszą przesłaniać wszystkie metody dostępu przesłanianej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">Struktury bez jawnych konstruktorów nie mogą zawierać składowych z inicjatorami.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">Nie można wyemitować informacji debugowania dla tekstu źródłowego bez kodowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">Treści bloku i treści wyrażenia nie mogą być jednocześnie udostępnione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">Kontrolka nie może wykraczać poza przełącznik z końcowej etykiety case („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">Argumenty typu nie są dozwolone w operatorze nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać operatora propagowania wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać inicjatora słownika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">Metoda Add rozszerzenia nie jest obsługiwana w przypadku inicjatora kolekcji w operatorze lambda wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">operator nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">inicjator słownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">Brak zamykającego znaku ograniczającego „}” dla interpolowanego wyrażenia rozpoczynającego się od znaku „{”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">W ciągu interpolowanym nie można użyć jednowierszowego komentarza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">Wyrażenie jest zbyt długie lub zbyt złożone do skompilowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">Wyrażenie nie ma nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">Podwyrażenie nie może być używane w argumencie operatora „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">Nazwa kwalifikowana za pomocą aliasu nie jest wyrażeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">Parametry typu nie są dozwolone w grupie metod jako argument operatora „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">Oczekiwano elementu SearchCriteria.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">Ciągi kultury zestawu nie mogą zawierać osadzonych znaków NUL.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">ciągi interpolowane</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">Instrukcja await w blokach catch i finally</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">literały binarne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">separatory cyfr</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">funkcje lokalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">W przypadku znaku „{0}” należy zastosować ucieczkę (przez wpisanie dwóch takich znaków) w ciągu interpolowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">W przypadku znaku „{0}” ucieczkę można zastosować tylko przez wpisanie dwóch znaków „{0}{0}” w ciągu interpolowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">Specyfikator formatu nie może kończyć się białym znakiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">Pusty specyfikator formatu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">Wystąpił błąd w przywoływanym zestawie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">Oczekiwano wyrażenia lub instrukcji deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">Grupy metod rozszerzeń nie są dozwolone jako argument elementu „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">Wartość wyrównania {0} jest większa niż {1} i może powodować powstanie ciągu w dużym formacie.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">Nieużywany alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">Niepotrzebna dyrektywa using</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">Pomiń ładowanie typów w zestawie analizatora zakończonych niepowodzeniem z powodu wyjątku ReflectionTypeLoadException</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">Wartość wyrównania może powodować powstanie ciągu w dużym formacie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">Długość stałej typu String w wyniku łączenia przekracza wartość System.Int32.MaxValue. Spróbuj podzielić ciąg na wiele stałych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">Krotka musi zawierać co najmniej dwa elementy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">Punkt wejściowy debugowania musi być definicją metody zadeklarowanej w bieżącej kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">element #load jest dozwolony tylko w skryptach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">Nie można używać elementu #load po pierwszym tokenie w pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">Nie można znaleźć pliku.</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">Element SyntaxTree jest wynikiem dyrektywy #load i nie można go bezpośrednio usunąć ani zastąpić.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">Odwołania do plików źródłowych nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">Opcja pathmap jest nieprawidłowo sformatowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">Nieprawidłowy literał liczby rzeczywistej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">Właściwości zaimplementowane automatycznie nie mogą zwracać wartości przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">Właściwości zwracające wartość przez referencję muszą mieć metodę dostępu get</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">Właściwości zwracające wartość przez referencję nie mogą mieć metod dostępu set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">Element „{0}” musi odpowiadać zwracanej przez referencję przesłoniętej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">Wartości zwracane przez referencję mogą być używane tylko w metodach zwracających wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">Wartości zwracanych przez wartość można użyć tylko w metodach zwracających wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">Zwracane wyrażenie musi być typu „{0}”, ponieważ ta metoda zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ nie ma pasującej wartości zwracanej przez referencję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">Treść elementu „{0}” nie może być blokiem iteratora, ponieważ element „{0}” zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">Wyrażeń lambda, które zwracają wartość przez referencję, nie można przekonwertować na drzewa wyrażeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać wywołania metody, właściwości ani indeksatora, który zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">Nie można użyć wyrażenia w tym kontekście, ponieważ może ono nie zostać przekazane lub zwrócone przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić elementu „{0}” przez referencję, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić przez referencję składowej elementu „{0}”, ponieważ została ona zainicjowana przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">Elementu „{0}” nie można zwrócić przez referencję, ponieważ jest tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">Nie można zwrócić zmiennej zakresu „{0}” przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">Nie można zwrócić elementu „{0}” przez referencję, ponieważ to jest element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal2Cause">
        <source>Cannot return fields of '{0}' by reference because it is a '{1}'</source>
        <target state="translated">Nie można zwrócić pól elementu „{0}” przez referencję, ponieważ to jest element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">Nie można zwrócić pola tylko do odczytu przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">Statycznego pola tylko do odczytu nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Składowych pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Pól statycznego pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref or out parameter</source>
        <target state="translated">Nie można zwrócić parametru „{0}” przez referencję, ponieważ to nie jest parametr ref ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">Nie można zwrócić składowej parametru „{0}” przez referencję, ponieważ to nie jest parametr ref ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Nie można zwrócić zmiennej lokalnej „{0}” przez referencję, ponieważ to nie jest zmienna lokalna ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Nie można zwrócić składowej zmiennej lokalnej „{0}” przez referencję, ponieważ to nie jest zmienna lokalna ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">Składowe struktury nie mogą zwracać obiektu „this” ani innych składowych wystąpienia przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">Nie można używać wyrażenia w tym kontekście, ponieważ pośrednio może ujawniać zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeLocal">
        <source>Cannot use local '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Nie można używać lokalnego elementu „{0}” w tym kontekście, ponieważ może uwidaczniać przywoływane zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Nie można używać wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Nie można używać składowej wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Ta kombinacja argumentów dla elementu „{0}” jest niedozwolona, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Gałęzie operatora warunkowego ref nie mogą przywoływać zmiennych z niezgodnymi zakresami deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">Nie można używać wyniku wyrażenia stackalloc typu „{0}” w tym kontekście, ponieważ może zostać ujawniony poza metodą zawierającą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">Nie można zainicjować zmiennej dostępnej przez wartość za pomocą odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">Nie można zainicjować zmiennej dostępnej przez odwołanie za pomocą wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">Wyrażenie musi być typu „{0}”, ponieważ jest przypisywane przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">Deklaracja zmiennej dostępnej przez odwołanie musi mieć inicjator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Nie można użyć zmiennej lokalnej typu ref „{0}” wewnątrz metody anonimowej, wyrażenia lambda ani wyrażenia zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorLocalType">
        <source>Iterators cannot have by-reference locals</source>
        <target state="translated">Iteratory nie mogą mieć zmiennych lokalnych dostępnych przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLocalType">
        <source>Async methods cannot have by-reference locals</source>
        <target state="translated">Metody asynchroniczne nie mogą mieć zmiennych lokalnych dostępnych przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>'await' cannot be used in an expression containing a call to '{0}' because it returns by reference</source>
        <target state="translated">'Elementu „await” nie można użyć w wyrażeniu zawierającym wywołanie elementu „{0}”, ponieważ zwraca ono wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'Element „await” nie może być używany w wyrażeniu zawierającym operator warunkowy ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">Obie wartości operatora warunkowego muszą być wartościami ref lub żadna z nich nie może być wartością ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">Wyrażenie musi być typu „{0}”, aby było zgodne z alternatywną wartością ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać odwołania do funkcji lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">Nie można przekazać argumentu z dynamicznym typem do parametru params „{0}” lokalnej funkcji „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">Drzewo składni powinno zostać utworzone na podstawie przesłanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">Całkowita długość ciągów użytkownika używanych przez program przekracza dozwolony limit. Spróbuj ograniczyć użycie literałów ciągów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}' in a pattern; use the underlying type '{1}' instead.</source>
        <target state="translated">Użycie typu dopuszczającego wartość null „{0}” jest niedozwolone we wzorcu. Użyj zamiast tego bazowego typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">Wystąpił błąd podczas zapisywania pliku wyjściowego: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">Nazwy elementów krotek muszą być unikatowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">Nazwa elementu krotki „{0}“ jest dozwolona tylko na pozycji {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">Nazwa elementu krotki „{0}“ nie jest dozwolona na żadnej pozycji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">Nie znaleziono składowej „{0}” dla typu „{1}” z zestawu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">krotki</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">Nie znaleziono odpowiedniego wystąpienia „Deconstruct” lub metody rozszerzenia dla typu „{0}” z {1} parametrami wyjściowymi i typem zwracanym void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">Przypisanie dekonstrukcji wymaga wyrażenia o typie podanym po prawej stronie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">Wyrażenie switch musi być wartością; znaleziono element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">Atrybut „{0}” jest ignorowany w przypadku określenia podpisywania publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">Atrybut jest ignorowany w przypadku określenia podpisywania publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">Opcja „{0}” musi być ścieżką bezwzględną.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">Nie można przekonwertować krotki z {0} elementami na typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">deklaracja zmiennej wyjściowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">Odwołanie do zmiennej wyjściowej z niejawnym typem „{0}” jest niedozwolone na tej samej liście argumentów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">Nie można wywnioskować typu zmiennej wyjściowej z niejawnym typem „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">Nie można wnioskować typu wprowadzonej niejawnie zmiennej dekonstrukcji „{0}“.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">Nie można wywnioskować typu odrzucenia o typie określonym niejawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">Nie można dekonstruować krotki „{0}” elementów do „{1}” zmiennych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">Nie można dekonstruować obiektów dynamicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">Dekonstrukcja musi zawierać co najmniej dwie zmienne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została zignorowana, ponieważ typ elementu docelowego „{1}” określa inną nazwę lub nie określa żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">Nazwa elementu krotki została zignorowana, ponieważ element docelowy przypisania określa inną nazwę lub nie określa żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” musi być strukturą.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'Atrybutu „new” nie można użyć z typem krotki. Użyj wyrażenia literału krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">Forma „var (...)” dekonstrukcji nie zezwala na specyficzny typ wartości „var”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można zdefiniować klasy lub składowej, która wykorzystuje krotki, ponieważ nie można znaleźć wymaganego typu kompilatora „{0}”. Czy brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">Nie można odwołać się do atrybutu „System.Runtime.CompilerServices.TupleElementNamesAttribute” jawnie. Użyj składni krotek, aby zdefiniować nazwy krotek.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać deklaracji zmiennej argumentu wyjściowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać odrzucenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora zgodnego z wzorcem „is”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać literału krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać konwersji krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">Przełącznik /sourcelink jest obsługiwany tylko w przypadku emitowania pliku PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">Przełącznik /embed jest obsługiwany tylko w przypadku emitowania pliku PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">Nieprawidłowy rodzaj instrumentacji: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">Składnia „var (...)“ jako wartość lvalue jest zastrzeżona.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">Oczekiwano symbolu { lub ; lub =&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">Wyrażenie throw jest niedozwolone w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixedDeconstructionUnsupported">
        <source>A deconstruction cannot mix declarations and expressions on the left-hand-side.</source>
        <target state="translated">Dekonstrukcja nie może mieszać deklaracji i wyrażeń po lewej stronie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">Deklaracja jest niedozwolona w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Pętla foreach musi deklarować swoje zmienne iteracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">Nazwy elementów krotek nie są dozwolone po lewej stronie dekonstrukcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">Aby rzutować wartość ujemną, musisz ją ująć w nawias.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia throw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa zestawu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">Aby typ „{0}” mógł zostać użyty jako element AsyncMethodBuilder dla typu „{1}”, jego właściwość zadania powinna zwracać typ „{1}” zamiast typu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesInLocalFuncDecl">
        <source>Attributes are not allowed on local function parameters or type parameters</source>
        <target state="translated">Atrybuty nie są dozwolone w przypadku lokalnych parametrów funkcji lub parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">Moduł „{0}” w zestawie „{1}” przekazuje typ „{2}” do wielu zestawów: „{3}” i „{4}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">Używanie typu „dynamic” we wzorcu nie jest dozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">Podany tryb dokumentacji jest nieobsługiwany lub nieprawidłowy: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">Podany rodzaj kodu źródłowego jest nieobsługiwany lub nieprawidłowy: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">Podana wersja języka jest nieobsługiwana lub nieprawidłowa: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.1. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.2. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">Określona wersja „{0}” języka nie może mieć zer wiodących</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">Nie można przypisać wyrażenia typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'Element „{0}” jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">Typ jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">Wersja kompilatora: „{0}”. Wersja języka: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">asynchroniczna funkcja main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została wywnioskowana. Użyj wersji języka {1} lub nowszej, aby uzyskać dostęp do elementu według jego wywnioskowanej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">Spójna kolekcja nie może zawierać wartości typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">Punkt wejścia zwracający wartości void lub int nie może być asynchroniczny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}” w języku C# {2}. Użyj języka w wersji {3} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">Funkcja lokalna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">Funkcja lokalna jest zadeklarowana, ale nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>'{0}' is a local function and must therefore always have a body.</source>
        <target state="translated">'„{0}” jest funkcją lokalną i w związku z tym musi zawsze mieć treść.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">Nie można odczytać informacji debugowania metody „{0}” (token 0x{1:X8}) z zestawu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} nie jest prawidłowym wyrażeniem konwersji języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">Nie można przekazać argumentu o typie dynamicznym do ogólnej funkcji lokalnej „{0}” z argumentami typu wywnioskowanego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">wiodący separator cyfr</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">Nie używaj elementu „{0}”. Jest on zarezerwowany do użycia przez kompilator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">Nazwa typu „{0}” jest zarezerwowana do użycia przez kompilator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">Pierwszy parametr metody rozszerzenia „in”, „{0}”, musi być konkretnym typem wartości (nieogólnym).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">Wystąpienia pól struktur tylko do odczytu muszą być tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">Automatycznie implementowane właściwości wystąpienia w strukturach tylko do odczytu muszą być tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">Zdarzenia podobne do pól nie są dozwolone w strukturach tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">metody rozszerzenia ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">Konwersja wyrażenia stackalloc typu „{0}” na typ „{1}” nie jest możliwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">Pierwszy parametr metody rozszerzenia „ref” „{0}” musi być typem wartości lub typem ogólnym ograniczonym do struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">W parametrze wejściowym nie może występować atrybut wyjściowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} nie jest prawidłową złożoną operacją przypisania w języku C#</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”, rozważ usunięcie klauzuli catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”, rozważ usunięcie bloku try-catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">Element __arglist nie może mieć argumentu typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">Wyrażenie warunkowe nie może być używane bezpośrednio w interpolacji ciągu, ponieważ znak „:” kończy interpolację. Umieść wyrażenie warunkowe w nawiasie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">Nie używaj atrybutu „System.Runtime.CompilerServices.FixedBuffer” względem właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.3. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">Atrybuty docelowe dla pól w ramach właściwości automatycznych nie są obsługiwane w języku w wersji {0}. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">Atrybuty docelowe dla pól w ramach właściwości automatycznych nie są obsługiwane w tej wersji języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">strumienie asynchroniczne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">„{0}”: Typ użyty w asynchronicznej instrukcji using musi być jawnie konwertowalny na typ „System.IAsyncDisposable” lub musi implementować odpowiednią metodę „DisposeAsync”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">Asynchroniczna instrukcja foreach wymaga, aby zwracany typ „{0}” elementu „{1}” miał odpowiednią metodę publiczną „MoveNextAsync” i właściwość publiczną „Current”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może używać zmiennych typu „{0}”, ponieważ implementuje wiele utworzeń wystąpienia elementu „{1}”. Spróbuj rzutowania na konkretne utworzenie wystąpienia interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Interfaces cannot contain conversion, equality, or inequality operators</source>
        <target state="translated">Interfejsy nie mogą zawierać operatorów konwersji, równości ani nierówności</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje domyślnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">Element „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”, ponieważ docelowe środowisko uruchomieniowe nie obsługuje domyślnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationModifier">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">Modyfikator „{0}” nie jest prawidłowy dla tego elementu w języku C# {1}. Użyj wersji języka „{2}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może jawnie implementować składowej niepublicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">Składowa interfejsu „{0}” nie ma najbardziej specyficznej implementacji. Ani implementacja „{1}”, ani „{2}” nie jest najbardziej specyficzna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">Element „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”, ponieważ funkcja „{3}” nie jest dostępna w języku C# {4}. Użyj wersji języka „{5}” lub nowszej.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>