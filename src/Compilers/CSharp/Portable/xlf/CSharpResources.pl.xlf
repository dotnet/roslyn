<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CallingConventionTypeIsInvalid">
        <source>Cannot use '{0}' as a calling convention modifier.</source>
        <target state="translated">Nie można użyć elementu „{0}” jako modyfikatora konwencji wywoływania.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallingConventionTypesRequireUnmanaged">
        <source>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</source>
        <target state="translated">Przekazywanie elementu „{0}” jest nieprawidłowe, chyba że element „{1}” ma wartość „SignatureCallingConvention.Unmanaged".</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">Nie można utworzyć konstruowanego typu ogólnego z innego konstruowanego typu ogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">Nie można utworzyć konstruowanego typu ogólnego z typu nieogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractConversionNotInvolvingContainedType">
        <source>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</source>
        <target state="translated">Konwersja zdefiniowana przez użytkownika w interfejsie musi być skonwertowana na lub z parametru typu w przypadku typu otaczającego ograniczonego do typu otaczającego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">„{0}”: zdarzenie abstrakcyjne nie może używać składni metody dostępu zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInIterator">
        <source>The '&amp;' operator cannot be used on parameters or local variables in iterator methods.</source>
        <target state="translated">Operatora „&amp;” nie można używać dla parametrów ani zmiennych lokalnych w metodach iteratora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfMethodGroupInExpressionTree">
        <source>'&amp;' on method groups cannot be used in expression trees</source>
        <target state="translated">Znak „&amp;” dla grup metod nie może być używany w drzewach wyrażeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfToNonFunctionPointer">
        <source>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</source>
        <target state="translated">Nie można przekonwertować grupy &amp;metod „{0}” na typ wskaźnikowy elementu innego niż funkcja „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AllowsClauseMustBeLast">
        <source>The 'allows' constraint clause must be the last constraint specified</source>
        <target state="translated">Klauzula ograniczenia „allows” musi być ostatnim określonym ograniczeniem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">Aby użyć elementu „@$” zamiast elementu „$@” w interpolowanym ciągu dosłownym, użyj wersji języka „{0}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</source>
        <target state="translated">Operator „{0}” jest niejednoznaczny dla operandów „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">Nie można zastosować operatora „{0}” do elementu „default” i operandu typu „{1}”, ponieważ jest to parametr typu, który nie jest znany jako typ referencyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver">
        <source>Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.</source>
        <target state="translated">Identyfikator '{0}' jest niejednoznaczny między typem '{1}' i parametrem '{2}' w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">Nie można użyć typu referencyjnego dopuszczającego wartość null podczas tworzenia obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseRefLike">
        <source>Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Nie można użyć parametru '{0}', który ma typ przypominający odwołanie wewnątrz metody anonimowej, wyrażenia lambda, wyrażenia zapytania lub funkcji lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterCaptured">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member</source>
        <target state="translated">Metody anonimowe, wyrażenia lambda, wyrażenia zapytań i funkcje lokalne wewnątrz struktury nie mogą uzyskać dostępu do głównego parametru konstruktora używanego również wewnątrz członka wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterInMember">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter</source>
        <target state="translated">Metody anonimowe, wyrażenia lambda, wyrażenia zapytań i funkcje lokalne wewnątrz członka instancji struktury nie mają dostępu do głównego parametru konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">Nazwy elementów nie są dozwolone przy dopasowywaniu wzorca za pośrednictwem elementu „System.Runtime.CompilerServices.ITuple”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Użycie typu odwołania dopuszczającego wartość null „{0}?” w wyrażeniu „as” jest niedozwolone. Zamiast tego użyj bazowego typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Podstawowy parametr konstruktora typu tylko do odczytu nie może być przypisany (z wyjątkiem setera inicjującego typu lub inicjalizatora zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Elementy podstawowego parametru konstruktora '{0}' typu tylko do odczytu nie mogą być modyfikowane (z wyjątkiem inicjującego settera typu lub inicjalizatora zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</source>
        <target state="translated">Właściwość lub indeksator „{0}” tylko do inicjowania można przypisać tylko w inicjatorze obiektu, w elemencie „this” lub „base” w konstruktorze wyrażenia albo w metodzie dostępu „init”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">Typ „{0}” nie może być używany w tym kontekście, ponieważ nie może być reprezentowany w metadanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrTypeArgCannotBeTypeVar">
        <source>'{0}': an attribute type argument cannot use type parameters</source>
        <target state="translated">"{0}": argument typu atrybut nie może używać parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Atrybut „{0}” nie jest prawidłowy w metodach dostępu zdarzenia. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesRequireParenthesizedLambdaExpression">
        <source>Attributes on lambda expressions require a parenthesized parameter list.</source>
        <target state="translated">Atrybuty w wyrażeniach lambda wymagają listy parametrów ujętych w nawiasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">Właściwość implementowana automatycznie „{0}” nie może być zadeklarowana jako „readonly”, ponieważ ma metodę dostępu „set”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Automatycznie implementowana metoda dostępu „set” „{0}” nie może być zadeklarowana jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera odpowiedniego publicznego wystąpienia lub definicji rozszerzenia dla elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznego wystąpienia lub definicji rozszerzenia dla elementu „{1}”. Czy planowano użyć instrukcji „foreach”, a nie „await foreach”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Jeden z parametrów operatora binarnego musi być typem otaczającym lub jest parametrem typu ograniczonym do niego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractEqualityOperatorSignature">
        <source>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</source>
        <target state="translated">Jeden z parametrów operatora równości lub nierówności zadeklarowanego w interfejsie „{0}” musi być parametrem typu w przypadku „{0}” ograniczonego do „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecRetType">
        <source>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</source>
        <target state="translated">Zwracany typ dla operatora ++ lub -- musi być zgodny z typem parametru lub być pochodną od typu parametru, bądź musi być parametrem typu typu zawierającego ograniczonego do niego, chyba że typ parametru jest innym parametrem typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Typ parametru operatora ++ lub -- musi być typem zawierającym lub jest on parametrem typu ograniczonym do niego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</source>
        <target state="translated">Pierwszy operand przeciążonego operatora przesunięcia musi mieć ten sam typ co typ zawierający lub jego parametr typu musi być do niego ograniczony</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractStaticMemberAccess">
        <source>A static virtual or abstract interface member can be accessed only on a type parameter.</source>
        <target state="translated">Dostęp do statycznej składowej interfejsu abstrakcyjnego można uzyskać tylko w przypadku parametru typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Parametr operatora jednoargumentowego musi być typem zawierającym lub jest on parametrem typu ograniczonym do niego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAllowByRefLikeEnumerator">
        <source>foreach statement cannot operate on enumerators of type '{0}' because it is a type parameter that allows ref struct and it is not known at compile time to implement IDisposable.</source>
        <target state="translated">Instrukcja foreach nie może działać na modułach wyliczeniowych typu „{0}”, ponieważ jest to parametr typu, który umożliwia strukturę ref i nie jest znany w czasie kompilacji w celu zaimplementowania interfejsu IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRefLangVersion">
        <source>Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.</source>
        <target state="translated">Argument {0} nie może być przekazywany ze słowem kluczowym „ref” w wersji językowej {1}. Aby przekazać argumenty „ref” do parametrów „in”, uaktualnij do wersji językowej {2} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryReadOnlySpanConcatenation">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</source>
        <target state="translated">Nie można zastosować operatora „{0}” do argumentów operacji typu „{1}” i „{2}”, które nie są reprezentacjami bajtów UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
        <source>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerArgumentExpressionAttribute można zastosować tylko do parametrów z wartościami domyślnymi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCaseInSwitchArm">
        <source>A switch expression arm does not begin with a 'case' keyword.</source>
        <target state="translated">Ramię wyrażenia przełączające nie rozpoczyna się od słowa kluczowego „case”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">Nie można użyć kolekcji typu dynamicznego w asynchronicznej instrukcji foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFieldTypeInRecord">
        <source>The type '{0}' may not be used for a field of a record.</source>
        <target state="translated">Typ „{0}” nie może być używany dla pola rekordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerArgCount">
        <source>Function pointer '{0}' does not take {1} arguments</source>
        <target state="translated">Wskaźnik funkcji „{0}” nie przyjmuje argumentów {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerParamModifier">
        <source>'{0}' cannot be used as a modifier on a function pointer parameter.</source>
        <target state="translated">Elementu „{0}” nie można użyć jako modyfikatora w parametrze wskaźnika funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInheritanceFromRecord">
        <source>Only records may inherit from records.</source>
        <target state="translated">Tylko rekordy mogą dziedziczyć po rekordach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInitAccessor">
        <source>The 'init' accessor is not valid on static members</source>
        <target state="translated">Metoda dostępu „init” jest nieprawidłowa w składowych statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonVirtualInterfaceMemberAccessOnAllowsRefLike">
        <source>A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.</source>
        <target state="translated">Nie można uzyskać dostępu do niewirtualnej składowej interfejsu wystąpienia dla parametru typu, który zezwala na strukturę ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla parametru /nullable; należy użyć opcji „disable”, „enable”, „warnings” lub „annotations”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableReferenceTypeInUsingAlias">
        <source>Using alias cannot be a nullable reference type.</source>
        <target state="translated">Używanie aliasu nie może być typem referencyjnym dopuszczającym wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">Nie można użyć operatora typeof w przypadku typu referencyjnego dopuszczającego wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefaultOrNew">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do operandu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">Nieprawidłowy operand dla dopasowania wzorca; wymagana jest wartość, a znaleziono „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordBase">
        <source>Records may only inherit from object or another record</source>
        <target state="translated">Rekordy mogą dziedziczyć tylko po obiekcie lub innym rekordzie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordMemberForPositionalParameter">
        <source>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</source>
        <target state="translated">Składowa rekordu "{0}" musi być możliwą do odczytu właściwością wystąpienia typu "{1}", aby dopasować parametr pozycyjny "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefParameter">
        <source>Parameters of type '{0}' cannot be declared in async methods or async lambda expressions.</source>
        <target state="translated">Parametry typu „{0}” nie mogą być deklarowane w metodach asynchronicznych ani asynchronicznych wyrażeniach lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefInUsingAlias">
        <source>Using alias cannot be a 'ref' type.</source>
        <target state="translated">Używanie aliasu nie może być typem „ref”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticAfterUnsafe">
        <source>'static' modifier must precede 'unsafe' modifier.</source>
        <target state="translated">Modyfikator „statyczny” musi poprzedzać modyfikator „niebezpieczny”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">Błąd składni wiersza polecenia: „{0}” nie jest prawidłową wartością dla opcji „{1}”. Wartość musi mieć postać „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnsafeInUsingDirective">
        <source>Only a 'using static' or 'using alias' can be 'unsafe'.</source>
        <target state="translated">Tylko element „użycie statyczne” lub „użycie aliasu” może być „niebezpieczne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingStaticType">
        <source>'{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.</source>
        <target state="translated">Typ „{0}” jest nieprawidłowy dla „using static”. Można używać tylko klasy, struktury, interfejsu, wyliczenia, delegata lub przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInUnsafe">
        <source>Cannot use 'yield return' in an 'unsafe' block</source>
        <target state="translated">Nie można użyć instrukcji „yield return” w bloku „unsafe”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BuilderAttributeDisallowed">
        <source>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</source>
        <target state="translated">Atrybut AsyncMethodBuilder jest niedozwolony w metodach anonimowych bez jawnego zwracanego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToMember">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on this member.</source>
        <target state="translated">Nie można użyć atrybutu "OverloadResolutionPriorityAttribute" w tej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToOverride">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.</source>
        <target state="translated">Nie można użyć atrybutu „OverloadResolutionPriorityAttribute” w zastępującej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeConvertedToUtf8">
        <source>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</source>
        <target state="translated">Nie można przekonwertować ciągu wejściowego na równoważną reprezentację bajtową UTF-8. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'Nie można ustawić elementu „{0}” jako dopuszczającego wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotClone">
        <source>The receiver type '{0}' is not a valid record type and is not a struct type.</source>
        <target state="translated">Typ odbiorcy "{0}" nie jest prawidłowym typem rekordu i nie jest typem struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertAddressOfToDelegate">
        <source>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</source>
        <target state="translated">Nie można przekonwertować &amp;grupy metod „{0}” na typ delegata „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDynamicInvokeOnExpression">
        <source>Cannot perform a dynamic invocation on an expression with type '{0}'.</source>
        <target state="translated">Nie można wykonać wywołania dynamicznego na wyrażeniu o typie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferDelegateType">
        <source>The delegate type could not be inferred.</source>
        <target state="translated">Nie można wywnioskować typu delegowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotMatchOnINumberBase">
        <source>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specifc numeric type.</source>
        <target state="translated">Nie można użyć stałej liczbowej lub wzorca relacyjnego w „{0}”, ponieważ dziedziczy on lub rozszerza element "INumberBase&lt;T&gt;". Rozważ użycie wzorca typu w celu zawężenia do określonego typu liczbowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
        <source>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</source>
        <target state="translated">Konwencji wywoływania „managed” nie można łączyć z niezarządzanymi specyfikatorami konwencji wywoływania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseFunctionPointerAsFixedLocal">
        <source>The type of a local declared in a fixed statement cannot be a function pointer type.</source>
        <target state="translated">Typ zmiennej lokalnej zadeklarowanej w instrukcji fixed nie może być typem wskaźnikowym funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
        <source>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Nie można użyć elementu „{0}” jako typu {1} w metodzie z atrybutem „UnmanagedCallersOnly”.</target>
        <note>1 is the localized word for 'parameter' or 'return'. UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_CannotUseReducedExtensionMethodInAddressOf">
        <source>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</source>
        <target state="translated">Nie można użyć metody rozszerzenia z odbiornikiem jako elementem docelowym operatora „&amp;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseRefInUnmanagedCallersOnly">
        <source>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Nie można użyć elementów „ref”, „in” ani „out” w sygnaturze metody z atrybutem „UnmanagedCallersOnly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
        <source>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</source>
        <target state="translated">Argumenty atrybutu InterpolatedStringHandlerArgumentAttribute nie mogą odwoływać się do parametru, na podstawie którego jest używany atrybut.</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_CantChangeInitOnlyOnOverride">
        <source>'{0}' must match by init-only of overridden member '{1}'</source>
        <target state="translated">Element „{0}” musi odpowiadać zmiennymi tylko do inicjowania przesłoniętej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturnType">
        <source>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</source>
        <target state="translated">Nie można przekonwertować {0} na typ "{1}", ponieważ zwracany typ jest niezgodny ze zwracanym typem delegowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">Element __arglist nie może mieć argumentu przekazywanego przez parametr „in” ani „out”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
        <source>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</source>
        <target state="translated">Ten konstruktor musi dodać element „SetsRequiredMembers”, ponieważ tworzy łańcuch z konstruktorem mającym ten atrybut.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOperatorNeedsMatch">
        <source>The operator '{0}' requires a matching non-checked version of the operator to also be defined</source>
        <target state="translated">Operator „{0}” wymaga, aby była zdefiniowana również pasująca niesprawdzona wersja operatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassIsCombinedWithRefStruct">
        <source>Cannot allow ref structs for a type parameter known from other constraints to be a class</source>
        <target state="translated">Nie można zezwolić strukturom ref dla parametru typu znanego z innych ograniczeń na bycie klasą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloneDisallowedInRecord">
        <source>Members named 'Clone' are disallowed in records.</source>
        <target state="translated">Składowe o nazwie „Clone” są niedozwolone w rekordach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotStatic">
        <source>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</source>
        <target state="translated">Atrybut "{0}" nie implementuje statycznej składowej interfejsu "{1}". Atrybut "{2}" nie może zaimplementować składowej interfejsu, ponieważ nie jest ona statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidMethodName">
        <source>The CollectionBuilderAttribute method name is invalid.</source>
        <target state="translated">Nazwa metody CollectionBuilderAttribute jest nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidType">
        <source>The CollectionBuilderAttribute builder type must be a non-generic class or struct.</source>
        <target state="translated">Typ konstruktora CollectionBuilderAttribute musi być klasą lub strukturą nie generycznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeMethodNotFound">
        <source>Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan&lt;{1}&gt;' and return type '{2}'.</source>
        <target state="translated">Nie można odnaleźć dostępnej metody „{0}” z oczekiwanym podpisem: metoda statyczna z pojedynczym parametrem typu „ReadOnlySpan&lt;{1}&gt;” i zwracanym typem „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderNoElementType">
        <source>'{0}' has a CollectionBuilderAttribute but no element type.</source>
        <target state="translated">Element „{0}” ma atrybut CollectionBuilderAttribute, ale nie ma typu elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionEscape">
        <source>A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</source>
        <target state="translated">Nie można użyć wyrażenia kolekcji typu „{0}” w tym kontekście, ponieważ może ono być uwidocznione poza bieżącym zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionImmutableArray">
        <source>This version of '{0}' cannot be used with collection expressions.</source>
        <target state="translated">Tej wersji elementu „{0}” nie można używać z wyrażeniami kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingAdd">
        <source>Collection expression type '{0}' must have an instance or extension method 'Add' that can be called with a single argument.</source>
        <target state="translated">Typ wyrażenia kolekcji „{0}” musi mieć wystąpienie lub metodę rozszerzenia „Dodaj”, którą można wywołać z pojedynczym argumentem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingConstructor">
        <source>Collection expression type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Typ wyrażenia kolekcji musi mieć odpowiedni konstruktor, który można wywołać bez argumentów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionNoTargetType">
        <source>There is no target type for the collection expression.</source>
        <target state="translated">Brak typu docelowego dla wyrażenia kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetNoElementType">
        <source>Collection expression target '{0}' has no element type.</source>
        <target state="translated">Wyrażenie kolekcji docelowej „{0}” nie ma typu elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetTypeNotConstructible">
        <source>Cannot initialize type '{0}' with a collection expression because the type is not constructible.</source>
        <target state="translated">Nie można zainicjować typu „{0}” z wyrażeniem kolekcji, ponieważ nie można go skonstruować.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitializerInfiniteChainOfAddCalls">
        <source>Collection initializer results in an infinite chain of instantiations of collection '{0}'.</source>
        <target state="new">Collection initializer results in an infinite chain of instantiations of collection '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Parametr typu „{1}” ma ograniczenie „unmanaged”, dlatego elementu „{1}” nie można użyć jako ograniczenia dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="translated">Funkcja lokalna „{0}” musi być oznaczona jako „static”, aby można było używać atrybutu warunkowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}”. Użyj wersji języka „{2}” lub nowszej, aby dopasować typ otwarty za pomocą wzorca stałej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantValueOfTypeExpected">
        <source>A constant value of type '{0}' is expected</source>
        <target state="translated">Oczekiwano stałej wartości typu '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorMustInvokeBaseCopyConstructor">
        <source>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</source>
        <target state="translated">Konstruktor kopiujący w rekordzie musi wywoływać konstruktor kopiujący elementu podstawowego lub bezparametrowy konstruktor obiektu, jeśli rekord dziedziczy z obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorWrongAccessibility">
        <source>A copy constructor '{0}' must be public or protected because the record is not sealed.</source>
        <target state="translated">Konstruktor kopiujący „{0}” musi być publiczny lub chroniony, ponieważ rekord nie jest zapieczętowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">Nazwa „{0}” nie jest zgodna z odpowiednim parametrem „Deconstruct” „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructVariableCannotBeByRef">
        <source>A deconstruction variable cannot be declared as a ref local</source>
        <target state="translated">Nie można zadeklarować zmiennej dekonstrukcji jako lokalnej wartości ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultConstraintOverrideOnly">
        <source>The 'default' constraint is valid on override and explicit interface implementation methods only.</source>
        <target state="translated">Ograniczenie „default” jest prawidłowe tylko w przypadku ograniczenia dla przesłoniętych i jawnych metod implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu „{0}”, ponieważ ma nieabstrakcyjną składową. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">Brak typu docelowego dla literału domyślnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">Domyślny literał „default” nie jest prawidłowy jako wzorzec. Użyj innego odpowiedniego literału (np. „0” lub „null”). Aby dopasować wszystko, użyj wzorca odrzucania „_”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeneathPatternCombinator">
        <source>A variable may not be declared within a 'not' or 'or' pattern.</source>
        <target state="translated">Nie można deklarować zmiennej we wzorcu „not” ani „or”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">Wzorzec odrzucania nie jest dozwolony jako etykieta instrukcji case w instrukcji switch. Użyj instrukcji „case var _:” w przypadku wzorca odrzucania lub użyj instrukcji „case @_:” w przypadku stałej o nazwie „_”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseEqualityContract">
        <source>'{0}' does not override expected property from '{1}'.</source>
        <target state="translated">Element „{0}” nie przesłania oczekiwanej właściwości z elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseMethod">
        <source>'{0}' does not override expected method from '{1}'.</source>
        <target state="translated">Element „{0}” nie przesłania oczekiwanej metody z elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideMethodFromObject">
        <source>'{0}' does not override expected method from 'object'.</source>
        <target state="translated">Element „{0}” nie przesłania oczekiwanej metody z elementu „object”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupReturnTypeMod">
        <source>A return type can only have one '{0}' modifier.</source>
        <target state="translated">Typ zwracany może mieć tylko jeden modyfikator „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">Element „{0}” jest jawnie zaimplementowany więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterceptor">
        <source>The indicated call is intercepted multiple times.</source>
        <target state="translated">Wskazane wywołanie jest przechwytywane wiele razy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithDifferencesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</source>
        <target state="translated">Element „{0}” znajduje się już na liście interfejsów typu „{2}” jako „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">Zduplikowany operator pomijania wartości null („!”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">Nie można określić modyfikatorów „readonly” dla obu metod dostępu właściwości lub indeksatora „{0}”. Zamiast tego dodaj modyfikator „readonly” do samej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicDispatchToParamsCollection">
        <source>'{0}' is applicable only with expanded form of non-array params collection which is not supported during dynamic dispatch.</source>
        <target state="translated">Element „{0}” ma zastosowanie tylko w przypadku rozszerzonej formy kolekcji parametrów niebędących tablicami, która nie jest obsługiwana podczas wysyłania dynamicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">Instrukcja nie może rozpoczynać się od elementu „else”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EntryPointCannotBeUnmanagedCallersOnly">
        <source>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Punkty wejścia aplikacji nie mogą mieć atrybutu „UnmanagedCallersOnly”.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_EqualityContractRequiresGetter">
        <source>Record equality contract property '{0}' must have a get accessor.</source>
        <target state="translated">Właściwość kontraktu równości rekordu „{0}” musi mieć metodę dostępu get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeVariable">
        <source>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Nie można używać zmiennej „{0}” w tym kontekście, ponieważ może uwidaczniać odwoływane zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInterpolatedString">
        <source>Expected interpolated string</source>
        <target state="translated">Oczekiwany ciąg interpolowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplementationOfOperatorsMustBeStatic">
        <source>Explicit implementation of a user-defined operator '{0}' must be declared static</source>
        <target state="translated">Jawna implementacja operatora zdefiniowanego przez użytkownika „{0}” musi być zadeklarowana jako statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">Jawne stosowanie elementu „System.Runtime.CompilerServices.NullableAttribute” jest niedozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArrayOrCollection">
        <source>Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">Nie używaj atrybutu „System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute”. Zamiast niego użyj słowa kluczowego „params”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMismatchInitOnly">
        <source>Accessors '{0}' and '{1}' should both be init-only or neither</source>
        <target state="translated">Tylko do inicjowania powinny być obie metody dostępu „{0}” i „{1}” albo żadna z nich</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitRequiredMember">
        <source>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</source>
        <target state="translated">Nie używaj elementu „System.Runtime.CompilerServices.RequiredMemberAttribute”. Zamiast tego użyj słowa kluczowego „required” w wymaganych polach i właściwościach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitScopedRef">
        <source>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</source>
        <target state="translated">Nie używaj atrybutu "System.Runtime.CompilerServices.ScopedRefAttribute". Zamiast tego użyj słowa kluczowego „scoped”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">Podanego wyrażenia nie można użyć w instrukcji fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać przypisania łączącego wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wartości elementu ref struct ani typu ograniczonego „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
        <source>An expression tree may not contain an access of static virtual or abstract interface member</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać dostępu do statycznej składowej abstrakcyjnej lub wirtualnej w interfejsie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsCollectionExpression">
        <source>An expression tree may not contain a collection expression.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać wyrażenia kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia „od końca indeksu” („^”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInlineArrayOperation">
        <source>An expression tree may not contain an inline array access or conversion</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać dostępu do tablicy śródwierszowej ani konwersji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
        <source>An expression tree may not contain an interpolated string handler conversion.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać konwersji procedury obsługi ciągu interpolowanego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternImplicitIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać dostępu do indeksatora z wzorcem System.Index lub System.Range</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia zakresu („..”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora == ani != krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsUtf8StringLiterals">
        <source>An expression tree may not contain UTF-8 string conversion or literal.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać konwersji ciągu UTF-8 ani literału.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsWithExpression">
        <source>An expression tree may not contain a with-expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia with.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">„{0}”: zdarzenie extern nie może mieć inicjatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">Funkcja „{0}” jest obecnie w wersji zapoznawczej i jest *nieobsługiwana*. Aby używać funkcji w wersji zapoznawczej, skorzystaj z wersji języka w wersji zapoznawczej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">Funkcja „{0}” jest eksperymentalna i nieobsługiwana. Aby ją włączyć, użyj parametru „/features:{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion10">
        <source>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja "{0}" nie jest dostępna w języku C# 10.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion11">
        <source>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 11.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion12">
        <source>Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 12.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion13">
        <source>Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w wersji języka C# 13.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 8.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 8.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion9">
        <source>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 9.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">Zdarzenie-pole „{0}” nie może być zadeklarowane jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileLocalDuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}' in this file.</source>
        <target state="translated">Przestrzeń nazw „{1}” już zawiera definicję dla „{0}” w tym pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FilePathCannotBeConvertedToUtf8">
        <source>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</source>
        <target state="translated">Nie można użyć typu pliku lokalnego „{0}”, ponieważ zawierającej ścieżki pliku nie można przekonwertować na równoważną reprezentację bajtów UTF-8. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedAndNormalNamespace">
        <source>Source file can not contain both file-scoped and normal namespace declarations.</source>
        <target state="translated">Plik źródłowy nie może zawierać deklaracji przestrzeni nazw z określonym zakresem plików ani deklaracji zwykłych przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedNamespaceNotBeforeAllMembers">
        <source>File-scoped namespace must precede all other members in a file.</source>
        <target state="translated">Przestrzeń nazw z określonym zakresem plików musi poprzedzać wszystkie inne składowe w pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeBase">
        <source>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</source>
        <target state="translated">Typ pliku lokalnego „{0}” nie może być używany jako typ podstawowy typu innego niż plik lokalny „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeDisallowedInSignature">
        <source>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</source>
        <target state="translated">Nie można użyć typu pliku lokalnego „{0}” w sygnaturze elementu składowego w typie innym niż plik lokalny „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNameDisallowed">
        <source>Types and aliases cannot be named 'file'.</source>
        <target state="translated">Typy i aliasy nie mogą mieć nazwy „file”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNested">
        <source>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</source>
        <target state="translated">Typ pliku lokalnego „{0}” musi być zdefiniowany w typie najwyższego poziomu; „{0}” jest typem zagnieżdżonym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNoExplicitAccessibility">
        <source>File-local type '{0}' cannot use accessibility modifiers.</source>
        <target state="translated">Typ pliku lokalnego „{0}” nie może używać modyfikatorów ułatwień dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNonUniquePath">
        <source>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</source>
        <target state="translated">Typ pliku lokalnego „{0}” musi być zadeklarowany w pliku z unikatową ścieżką. Ścieżka „{1}” jest używana w wielu plikach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedFieldMustNotBeRef">
        <source>A fixed field must not be a ref field.</source>
        <target state="translated">Pole stałe nie może być polem referencyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">Instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznego wystąpienia lub definicji rozszerzenia dla elementu „{1}”. Czy planowano użyć instrukcji „await foreach”, a nie „foreach”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrMethMustBeStatic">
        <source>Cannot create a function pointer for '{0}' because it is not a static method</source>
        <target state="translated">Nie można utworzyć wskaźnika funkcji dla elementu „{0}”, ponieważ nie jest to metoda statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrRefMismatch">
        <source>Ref mismatch between '{0}' and function pointer '{1}'</source>
        <target state="translated">Niezgodność odwołań między metodą „{0}” a wskaźnikiem funkcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointerTypesInAttributeNotSupported">
        <source>Using a function pointer type in this context is not supported.</source>
        <target state="translated">Używanie typu wskaźnika funkcji w tym kontekście nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointersCannotBeCalledWithNamedArguments">
        <source>A function pointer cannot be called with named arguments.</source>
        <target state="translated">Nie można wywołać wskaźnika funkcji przy użyciu argumentów nazwanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
        <source>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</source>
        <target state="translated">Interfejs „{0}” nie może być używany jako argument typu. Składowa statyczna „{1}” nie ma najbardziej specyficznej implementacji w interfejsie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingInNamespace">
        <source>A global using directive cannot be used in a namespace declaration.</source>
        <target state="translated">Nie można użyć globalnych używających dyrektywy w deklaracji przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingOutOfOrder">
        <source>A global using directive must precede all non-global using directives.</source>
        <target state="translated">Globalne używające dyrektywy muszą poprzedzać wszystkie nieglobalne używające dyrektywy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingStaticFileType">
        <source>File-local type '{0}' cannot be used in a 'global using static' directive.</source>
        <target state="translated">Nie można użyć typu pliku lokalnego „{0}” w dyrektywie „global using static”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">Instrukcja goto nie może przechodzić do lokalizacji występującej przed deklaracją using w tym samym bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">Instrukcja goto nie może przechodzić do lokalizacji występującej po deklaracji using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HiddenPositionalMember">
        <source>The positional member '{0}' found corresponding to this parameter is hidden.</source>
        <target state="translated">Odnaleziony członek pozycyjny „{0}” odpowiadający temu parametrowi jest ukryty.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAtSequence">
        <source>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</source>
        <target state="translated">Sekwencja znaków „@” jest niedozwolona. Ciąg lub identyfikator dosłownego ciągu może zawierać tylko jeden znak „@”, a nieprzetworzony ciąg nie może zawierać żadnego znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">Operator pominięcia jest niedozwolony w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitConversionOperatorCantBeChecked">
        <source>An 'implicit' user-defined conversion operator cannot be declared checked</source>
        <target state="translated">Nie można zadeklarować zaznaczonego operatora konwersji zdefiniowanego przez użytkownika „implicit”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może jawnie implementować niedostępnej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">W wywołaniu niejawnego indeksatora indeksu nie może być nazwy argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationIllegalTargetType">
        <source>The type '{0}' may not be used as the target type of new()</source>
        <target state="translated">Typu „{0}” nie można używać jako typu docelowego wyrażenia new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNoTargetType">
        <source>There is no target type for '{0}'</source>
        <target state="translated">Brak typu docelowego dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNotValid">
        <source>Use of new() is not valid in this context</source>
        <target state="translated">Użycie wyrażenia new() jest nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">W wywołaniu niejawnego indeksatora zakresu nie może być nazwy argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedDefaultParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have a default value.</source>
        <target state="translated">Niejawnie typizowany parametr wyrażenia lambda „{0}” nie może mieć wartości domyślnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">Nie można używać argumentów z modyfikatorem „in” w wyrażeniach przydzielanych dynamicznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritingFromRecordWithSealedToString">
        <source>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</source>
        <target state="translated">Dziedziczenie z rekordu z zapieczętowanym obiektem "Object.ToString" nie jest obsługiwane w języku C# {0}. Użyj wersji języka "{1}" lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitCannotBeReadonly">
        <source>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</source>
        <target state="translated">Metody dostępu „init” nie można oznaczyć jako „tylko do odczytu”. Zamiast tego oznacz jako tylko do odczytu element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayAttributeOnRecord">
        <source>Attribute 'System.Runtime.CompilerServices.InlineArray' cannot be applied to a record struct.</source>
        <target state="translated">Atrybut „System.Runtime.CompilerServices.InlineArray” nie może być zastosowany do struktury rekordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayBadIndex">
        <source>Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.</source>
        <target state="translated">Dostęp do elementów typu tablicy śródwierszowej można uzyskiwać tylko z pojedynczym argumentem, który można niejawnie przekonwertować na wartości „int”, „System.Index” lub „System.Range”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToReadOnlySpanNotSupported">
        <source>Cannot convert expression to '{0}' because it may not be passed or returned by reference</source>
        <target state="translated">Nie można przekonwertować wyrażenia na „{0}”, ponieważ może ono nie zostać przekazane lub zwrócone przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToSpanNotSupported">
        <source>Cannot convert expression to '{0}' because it is not an assignable variable</source>
        <target state="translated">Nie można przekonwertować wyrażenia na „{0}”, ponieważ nie jest to zmienna możliwa do przypisania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayForEachNotSupported">
        <source>foreach statement on an inline array of type '{0}' is not supported</source>
        <target state="translated">instrukcja foreach w tablicy wbudowanej typu „{0}” nie jest obsługiwana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayIndexOutOfRange">
        <source>Index is outside the bounds of the inline array</source>
        <target state="translated">Indeks znajduje się poza granicami tablicy śródwierszowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayUnsupportedElementFieldModifier">
        <source>Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.</source>
        <target state="translated">Pole elementu tablicy wbudowanej nie może być zadeklarowane jako wymagane, tylko do odczytu, nietrwałe ani jako bufor o stałym rozmiarze.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstancePropertyInitializerInInterface">
        <source>Instance properties in interfaces cannot have initializers.</source>
        <target state="translated">Właściwości wystąpienia w interfejsach nie mogą mieć inicjatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptableMethodMustBeOrdinary">
        <source>Cannot intercept '{0}' because it is not an invocation of an ordinary member method.</source>
        <target state="translated">Nie można przechwycić „{0}”, ponieważ nie jest to wywołanie zwykłej metody składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorArityNotCompatible">
        <source>Method '{0}' must be non-generic or have arity {1} to match '{2}'.</source>
        <target state="translated">Metoda „{0}” musi być niegeneryczna lub mieć liczbę argumentów{1}, aby pasować do „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotBeGeneric">
        <source>Method '{0}' must be non-generic to match '{1}'.</source>
        <target state="translated">Metoda „{0}” nie może być ogólna, aby była zgodna z elementem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotInterceptNameof">
        <source>A nameof operator cannot be intercepted.</source>
        <target state="translated">Nie można przechwycić operatora nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotUseUnmanagedCallersOnly">
        <source>An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.</source>
        <target state="translated">Nie można oznaczyć interceptora atrybutem „UnmanagedCallersOnlyAttribute”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCharacterOutOfRange">
        <source>The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.</source>
        <target state="translated">Podany wiersz ma długość składającą się z „{0}” znaków, czyli mniej niż podana liczba znaków „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorContainingTypeCannotBeGeneric">
        <source>Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</source>
        <target state="translated">Metoda „{0}” nie może być używana jako metoda interceptora, ponieważ jej typ zawierający ma parametry typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorFilePathCannotBeNull">
        <source>Interceptor cannot have a 'null' file path.</source>
        <target state="translated">Interceptor nie może mieć ścieżki pliku o wartości „null”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorGlobalNamespace">
        <source>An interceptor cannot be declared in the global namespace.</source>
        <target state="translated">Nie można zadeklarować interceptora w globalnej przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineCharacterMustBePositive">
        <source>Line and character numbers provided to InterceptsLocationAttribute must be positive.</source>
        <target state="translated">Liczba wierszy i znaków przekazana do atrybutu InterceptsLocationAttribute musi być dodatnia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineOutOfRange">
        <source>The given file has '{0}' lines, which is fewer than the provided line number '{1}'.</source>
        <target state="translated">Podany plik zawiera następującą liczbę wierszy: „{0}”, czyli mniej niż podana liczba wierszy „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMethodMustBeOrdinary">
        <source>An interceptor method must be an ordinary member method.</source>
        <target state="translated">Metoda interceptora musi być zwykłą metodą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustHaveMatchingThisParameter">
        <source>Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.</source>
        <target state="translated">Interceptor musi mieć parametr „this” zgodny z parametrem „{0}” w „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustNotHaveThisParameter">
        <source>Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.</source>
        <target state="translated">Interceptor nie może mieć parametru „this”, ponieważ „{0}” nie ma parametru „this”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustReferToStartOfTokenPosition">
        <source>The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?</source>
        <target state="translated">Podana liczba wierszy i znaków nie odwołuje się do początku tokenu „{0}”. Czy chodziło Ci o użycie wiersza „{1}” i znaku „{2}”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNameNotInvoked">
        <source>Possible method name '{0}' cannot be intercepted because it is not being invoked.</source>
        <target state="translated">Nie można przechwycić możliwej nazwy metody „{0}”, ponieważ nie jest ona wywoływana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNonUniquePath">
        <source>Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.</source>
        <target state="translated">Nie można przechwycić wywołania w pliku ze ścieżką „{0}”, ponieważ wiele plików w kompilacji ma tę ścieżkę.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNotAccessible">
        <source>Cannot intercept call with '{0}' because it is not accessible within '{1}'.</source>
        <target state="translated">Nie można przechwycić wywołania z „{0}”, ponieważ nie jest ono dostępne w obrębie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilation">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'.</source>
        <target state="translated">Nie można przechwycić: kompilacja nie zawiera pliku ze ścieżką „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithCandidate">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?</source>
        <target state="translated">Nie można przechwycić: kompilacja nie zawiera pliku ze ścieżką „{0}”. Czy chodziło o użycie ścieżki „{1}”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithUnmappedCandidate">
        <source>Cannot intercept: Path '{0}' is unmapped. Expected mapped path '{1}'.</source>
        <target state="translated">Nie można przechwycić: Ścieżka „{0}” jest niezmapowana. Oczekiwano zmapowanej ścieżki „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPositionBadToken">
        <source>The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.</source>
        <target state="translated">Podana liczba wierszy i znaków nie odwołuje się do nazwy metody możliwej do przechwycenia, ale do tokenu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorScopedMismatch">
        <source>Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.</source>
        <target state="translated">Nie można przechwycić wywołania do „{0}” za pomocą „{1}” z powodu różnicy w modyfikatorach „scoped” lub atrybutach „[UnscopedRef]”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorSignatureMismatch">
        <source>Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.</source>
        <target state="translated">Nie można przechwycić metody „{0}” za pomocą interceptora „{1}” , ponieważ podpisy nie są zgodne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorsFeatureNotEnabled">
        <source>The 'interceptors' feature is not enabled in this namespace. Add '{0}' to your project.</source>
        <target state="needs-review-translation">Funkcja eksperymentalna „interceptorów” nie jest włączona w tej przestrzeni nazw. Dodaj „{0}” do swojego projektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidFormat">
        <source>The data argument to InterceptsLocationAttribute is not in the correct format.</source>
        <target state="translated">Argument danych atrybutu InterceptsLocationAttribute ma niepoprawny format.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidPosition">
        <source>The data argument to InterceptsLocationAttribute refers to an invalid position in file '{0}'.</source>
        <target state="translated">Argument danych atrybutu InterceptsLocationAttribute odwołuje się do nieprawidłowej pozycji w pliku „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDuplicateFile">
        <source>Cannot intercept a call in file '{0}' because it is duplicated elsewhere in the compilation.</source>
        <target state="translated">Nie można przechwycić wywołania w pliku „{0}”, ponieważ jest ono zduplikowane w innym miejscu w kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationFileNotFound">
        <source>Cannot intercept a call in file '{0}' because a matching file was not found in the compilation.</source>
        <target state="translated">Nie można przechwycić wywołania w pliku „{0}”, ponieważ w kompilacji nie znaleziono zgodnego pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationUnsupportedVersion">
        <source>Version '{0}' of the interceptors format is not supported. The latest supported version is '1'.</source>
        <target state="translated">Wersja „{0}” formatu interceptorów nie jest obsługiwana. Najnowsza obsługiwana wersja to „1”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
        <source>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Metoda "UnmanagedCallersOnly" "{0}" nie może implementować składowej interfejsu "{1}" w typie "{2}"</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">Obiekt „{0}” nie może implementować elementu członkowskiego interfejsu „{1}” w ramach typu „{2}”, ponieważ zawiera on parametr __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">Błąd wewnętrzny w kompilatorze języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
        <source>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</source>
        <target state="translated">Atrybut InterpolatedStringHandlerArgumentAttribute zastosowany do parametru "{0}" jest źle sformułowany i nie można go zinterpretować. Utwórz ręcznie wystąpienie "{1}".</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
        <source>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</source>
        <target state="translated">Parametr „{0}” jest argumentem konwersji interpolowanej procedury obsługi ciągów dla parametru „{1}”, ale odpowiedni argument jest określony po wyrażeniu ciągu interpolowanego. Zmień kolejność argumentów, aby przenieść „{0}” przed „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
        <source>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</source>
        <target state="translated">Parametr „{0}” nie został jawnie podany, ale jest używany jako argument konwersji interpolowanej procedury obsługi ciągów dla parametru „{1}”. Określ wartość „{0}” przed „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
        <source>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</source>
        <target state="translated">W konstrukcji procedury obsługi ciągów interpolowanych nie można używać dynamicznych składowych. Ręcznie utwórz wystąpienie elementu "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnInconsistent">
        <source>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</source>
        <target state="translated">Metoda obsługi ciągu interpolowanego „{0}” ma niespójny zwracany typ. Oczekiwano zwrócenia elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnMalformed">
        <source>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</source>
        <target state="translated">Metoda procedury obsługi ciągu interpolowanego "{0}" ma nieprawidłową postać. Nie zwraca ona wartości "void" lub "bool".</target>
        <note>void and bool are keywords</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
        <source>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</source>
        <target state="translated">W inicjatorach składowych indeksatora nie można używać konwersji procedury obsługi ciągów interpolowanych odwołujących się do indeksowanego wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExperimentalDiagID">
        <source>The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</source>
        <target state="translated">Argument diagnosticId atrybutu „Experimental” musi być prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFuncPointerReturnTypeModifier">
        <source>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</source>
        <target state="translated">Element „{0}” nie jest prawidłowym modyfikatorem zwracanego typu wskaźnikowego funkcji. Prawidłowe modyfikatory to „ref” i „ref readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFunctionPointerCallingConvention">
        <source>'{0}' is not a valid calling convention specifier for a function pointer.</source>
        <target state="translated">Element „{0}” nie jest prawidłowym specyfikatorem konwencji wywoływania dla wskaźnika funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">Nieprawidłowa nazwa algorytmu wyznaczania wartości skrótu: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayFields">
        <source>Inline array struct must declare one and only one instance field.</source>
        <target state="translated">Struktura tablicy śródwierszowej musi deklarować jedno i tylko jedno pole wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLayout">
        <source>Inline array struct must not have explicit layout.</source>
        <target state="translated">Struktura tablicy śródwierszowej nie może mieć układu jawnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLength">
        <source>Inline array length must be greater than 0.</source>
        <target state="translated">Długość tablicy śródwierszowej musi być większa niż 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not a valid parameter name from '{1}'.</source>
        <target state="translated">„{0}” nie jest prawidłową nazwą parametru z elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierForLanguageVersion">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">Modyfikator „{0}” nie jest prawidłowy dla tego elementu w języku C# {1}. Użyj wersji języka „{2}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameInSubpattern">
        <source>Identifier or a simple member access expected.</source>
        <target state="translated">Oczekiwano dostępu do identyfikatora lub prostej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">Nieprawidłowa operacja tworzenia obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPrimaryConstructorParameterReference">
        <source>Cannot use primary constructor parameter '{0}' in this context.</source>
        <target state="translated">W tym kontekście nie można użyć podstawowego parametru konstruktora '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">Nie można określić modyfikatorów „readonly” jednocześnie dla właściwości lub indeksatora „{0}” i jego metody dostępu. Usuń jeden z nich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">Nieprawidłowy specyfikator rangi: oczekiwano „]”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUnmanagedCallersOnlyCallConv">
        <source>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</source>
        <target state="translated">Element „{0}” nie jest prawidłowym specyfikatorem konwencji wywoływania dla atrybutu „UnmanagedCallersOnly”.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InvalidWithReceiverType">
        <source>The receiver of a `with` expression must have a non-void type.</source>
        <target state="translated">Odbiorca wyrażenia „with” musi mieć typ inny niż void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Użycie typu odwołania dopuszczającego wartość null „{0}?” w wyrażeniu „is-type” jest niedozwolone. Zamiast tego użyj bazowego typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">Wyrażenie typu „{0}” nigdy nie zostanie dopasowane do podanego wzorca.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">Metoda „{0}” z blokiem iteratora musi być oznaczona jako „async”, aby zwrócić „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaExplicitReturnTypeVar">
        <source>The contextual keyword 'var' cannot be used as an explicit lambda return type</source>
        <target state="translated">Kontekstowego słowa kluczowego „var” nie można użyć jako jawnego zwracanego typu lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaWithAttributesToExpressionTree">
        <source>A lambda expression with attributes cannot be converted to an expression tree</source>
        <target state="translated">Nie można przekonwertować wyrażenia lambda z atrybutami na drzewo wyrażeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">Element „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”, ponieważ funkcja „{3}” nie jest dostępna w języku C# {4}. Użyj wersji języka „{5}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContainsDifferentWhitespace">
        <source>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</source>
        <target state="translated">Wiersz zawiera inny biały znak niż wiersz zamykający literału nieprzetworzonego ciągu: „{0}” a „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineDoesNotStartWithSameWhitespace">
        <source>Line does not start with the same whitespace as the closing line of the raw string literal.</source>
        <target state="translated">Wiersz nie rozpoczyna się od tego samego odstępu co wiersz zamykający literału nieprzetworzonego ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveEndLessThanStart">
        <source>The #line directive end position must be greater than or equal to the start position</source>
        <target state="translated">Pozycja końcowa dyrektywy #line musi być większa lub równa pozycji początkowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveInvalidValue">
        <source>The #line directive value is missing or out of range</source>
        <target state="translated">Brak wartości dyrektywy #line lub jest ona poza zakresem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveRequiresSpace">
        <source>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</source>
        <target state="translated">Dyrektywa zakresu #line wymaga spacji przed pierwszym nawiasem, przed przesunięciem znaku i przed nazwą pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ListPatternRequiresLength">
        <source>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</source>
        <target state="translated">Wzorce listy nie mogą być używane dla wartości typu „{0}”. Nie znaleziono odpowiedniej właściwości „Długość” ani „Liczba”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethFuncPtrMismatch">
        <source>No overload for '{0}' matches function pointer '{1}'</source>
        <target state="translated">Żadne z przeciążeń dla elementu „{0}” nie pasuje do wskaźnika funkcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedRecord">
        <source>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</source>
        <target state="translated">Nieoczekiwane słowo kluczowe „record”. Czy chodziło o „record struct” lub „record class”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedSlicePattern">
        <source>Slice patterns may only be used once and directly inside a list pattern.</source>
        <target state="translated">Wzorce wycinków mogą być używane tylko raz i bezpośrednio wewnątrz wzorca listy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedUnchecked">
        <source>Unexpected keyword 'unchecked'</source>
        <target state="translated">Nieoczekiwane słowo kluczowe „unchecked”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddressOf">
        <source>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</source>
        <target state="translated">Nie można przekonwertować grupy metod na wskaźnik funkcji (może brakuje znaku „&amp;”?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">Brak wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
        <source>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Inicjator modułu nie może mieć atrybutu „UnmanagedCallersOnly”.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
        <source>Module initializer method '{0}' must not be generic and must not be contained in a generic type</source>
        <target state="translated">Metoda inicjatora modułu „{0}” nie może być ogólna i nie może być zawarta w typie ogólnym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
        <source>Module initializer method '{0}' must be accessible at the module level</source>
        <target state="translated">Metoda inicjatora modułu „{0}” musi być dostępna na poziomie modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeOrdinary">
        <source>A module initializer must be an ordinary member method</source>
        <target state="translated">Inicjator modułu musi być zwykłą metodą składową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
        <source>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</source>
        <target state="translated">Metoda inicjatora modułu „{0}” musi być statyczna, nie wirtualna, nie może mieć parametrów i musi zwracać typ „void”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">Wiele plików konfiguracji analizatora nie może znajdować się w tym samym katalogu („{0}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">Nie można użyć atrybutu [EnumeratorCancellation] w wielu parametrach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleFileScopedNamespace">
        <source>Source file can only contain one file-scoped namespace declaration.</source>
        <target state="translated">Plik źródłowy może zawierać tylko jedną deklarację przestrzeni nazw z określonym zakresem plików.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleRecordParameterLists">
        <source>Only a single partial type declaration may have a parameter list</source>
        <target state="translated">Tylko pojedyncza deklaracja typu częściowego może mieć listę parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForInlineArray">
        <source>An inline array access may not have a named argument specifier</source>
        <target state="translated">Dostęp do tablicy śródwierszowej nie może mieć specyfikatora argumentu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">Ograniczenie „new()” nie może być używane z ograniczeniem „unmanaged”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintCannotHaveRequiredMembers">
        <source>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</source>
        <target state="translated">„{2}” nie może spełnić ograniczenia „new()” dla parametru „{1}” w typie ogólnym lub metodzie „{0}”, ponieważ „{2}” ma wymagane elementy członkowskie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
        <source>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</source>
        <target state="translated">Nowe wiersze wewnątrz ciągu interpolowanego nie będącego ciągiem dosłownym nie są obsługiwane w {0} języka C#. Użyj wersji językowej {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">„{0}”: typ użyty w asynchronicznej instrukcji using musi implementować typ „System.IAsyncDisposable” lub odpowiednią metodę „DisposeAsync”. Czy chodzi Ci o instrukcję „using” zamiast „await using”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">„{0}”: typ użyty w instrukcji using musi implementować typ „System.IDisposable”. Czy chodzi Ci o instrukcję „await using” zamiast „using”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerArgumentExpressionParam">
        <source>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Nie można zastosować atrybutu CallerArgumentExpressionAttribute, ponieważ nie ma standardowych konwersji z typu "{0}" na typ "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCopyConstructorInBaseType">
        <source>No accessible copy constructor found in base type '{0}'.</source>
        <target state="translated">W typie podstawowym „{0}” nie znaleziono dostępnego konstruktora kopiującego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDelegateConstraint">
        <source>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</source>
        <target state="translated">Słowo kluczowe „delegat” nie może być używane jako ograniczenie. Czy chodziło Ci o „System.Delegate”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEnumConstraint">
        <source>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</source>
        <target state="translated">Słowo kluczowe „enum” nie może być używane jako ograniczenie. Czy chodziło Ci o „struct, System.Enum”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvTargetTypedConditional">
        <source>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</source>
        <target state="translated">Wyrażenie warunkowe nie jest prawidłowe w wersji językowej {0} ponieważ nie znaleziono typu wspólnego między "{1}" i "{2}". Aby użyć konwersji z typem docelowym, uaktualnij do wersji językowej {3} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnUsing">
        <source>Modifiers cannot be placed on using declarations</source>
        <target state="translated">Modyfikatorów nie można umieszczać przy użyciu deklaracji usług</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="translated">Nie można było określić katalogu wyjściowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPrivateAPIInRecord">
        <source>Record member '{0}' must be private.</source>
        <target state="translated">Składowa rekordu „{0}” musi być prywatna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonProtectedAPIInRecord">
        <source>Record member '{0}' must be protected.</source>
        <target state="translated">Składowa rekordu „{0}” musi być chroniona.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicAPIInRecord">
        <source>Record member '{0}' must be public.</source>
        <target state="translated">Składowa rekordu „{0}” musi być publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicParameterlessStructConstructor">
        <source>The parameterless struct constructor must be 'public'.</source>
        <target state="translated">Konstruktor struktury bez parametrów musi mieć wartość „public”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughCloseBracesForRawString">
        <source>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</source>
        <target state="translated">Interpolacja musi kończyć się taką samą liczbą zamykających nawiasów klamrowych jak liczba znaków „$” które rozpoczynają literał nieprzetworzonego ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughQuotesForRawString">
        <source>Not enough quotes for raw string literal.</source>
        <target state="translated">Za mało cudzysłowów dla literału nieprzetworzonego ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not an instance method, the receiver cannot be an interpolated string handler argument.</source>
        <target state="translated">"{0}" nie jest metodą wystąpienia, a odbiorca nie może być argumentem procedury obsługi ciągu interpolowanego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableAPIInRecord">
        <source>'{0}' must allow overriding because the containing record is not sealed.</source>
        <target state="translated">Element „{0}” musi zezwalać na przesłanianie, ponieważ zawierający go rekord nie jest zapieczętowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotRefStructConstraintNotSatisfied">
        <source>The type '{2}' may not be a ref struct or a type parameter allowing ref structs in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” nie może być strukturą ref ani parametrem typu zezwalającym na struktury ref, aby użyć go jako parametru „{1}” w typie ogólnym lub metodzie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullInvalidInterpolatedStringHandlerArgumentName">
        <source>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</source>
        <target state="translated">Wartość null nie jest prawidłową nazwą parametru. Aby uzyskać dostęp do odbiorcy metody wystąpienia, użyj pustego ciągu jako nazwy parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">Oczekiwano opcji „enable”, „disable” lub „restore”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">Oczekiwano opcji „warnings” lub „annotations” albo końca dyrektywy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">Nieprawidłowa wartość „{0}”: „{1}” dla języka C# {2}. Użyj wersji języka „{3}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">Parametr typu przyjmującego wartość null musi być znany jako typ wartości lub typ odwołania niedopuszczający wartości null, chyba że zostanie użyta wersja języka „{0}” lub nowsza. Rozważ zmianę wersji języka lub dodanie ograniczenia „class”, „struct” lub „type”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedTypeArgument">
        <source>Omitting the type argument is not allowed in the current context</source>
        <target state="translated">Pominięcie argumentu typu jest niedozwolone w bieżącym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantBeChecked">
        <source>User-defined operator '{0}' cannot be declared checked</source>
        <target state="translated">Nie można zadeklarować operatora „{0}” zdefiniowanego przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefReadonlyParam">
        <source>A ref readonly parameter cannot have the Out attribute.</source>
        <target state="translated">Parametr ref readonly nie może mieć atrybutu Out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">Zmiennej out nie można zadeklarować jako lokalnej zmiennej ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideDefaultConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</source>
        <target state="translated">Metoda „{0}” określa ograniczenie „default” dla parametru typu „{1}”, lecz odpowiadający parametr typu „{2}” przesłoniętej lub jawnie zaimplementowanej metody „{3}” jest ograniczony do typu odwołania lub typu wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideMustHaveRequired">
        <source>'{0}' must be required because it overrides required member '{1}'</source>
        <target state="translated">„{0}” musi być wymagana, ponieważ przesłania wymaganą składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">Metoda „{0}” określa ograniczenie „class” dla parametru typu „{1}”, lecz odpowiadający parametr typu „{2}” przesłoniętej lub jawnie zaimplementowanej metody „{3}” nie jest typem referencyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">Metoda „{0}” określa ograniczenie „struct” dla parametru typu „{1}”, lecz odpowiadający parametr typu „{2}” przesłoniętej lub jawnie zaimplementowanej metody „{3}” nie jest nienullowalnym typem wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNullCheckingNotSupported">
        <source>The 'parameter null-checking' feature is not supported.</source>
        <target state="translated">Funkcja „sprawdzanie wartości null parametru” nie jest obsługiwana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionConstructorDoesntInitializeRequiredMember">
        <source>Constructor '{0}' leaves required member '{1}' uninitialized.</source>
        <target state="translated">Konstruktor „{0}” pozostawia wymaganą składową "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExpressionTree">
        <source>An expression tree may not contain an expanded form of non-array params collection parameter.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać rozszerzonej formy parametru kolekcji params innego niż tablica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExtensionAddMethod">
        <source>'{0}' does not contain a definition for a suitable instance 'Add' method</source>
        <target state="translated">Element „{0}” nie zawiera definicji odpowiedniej metody „Dodaj” wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionInfiniteChainOfConstructorCalls">
        <source>Creation of params collection '{0}' results in an infinite chain of invocation of constructor '{1}'.</source>
        <target state="translated">Utworzenie kolekcji parametrów „{0}” powoduje nieskończony łańcuch wywołania konstruktora „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionMissingConstructor">
        <source>Non-array params collection type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Typ kolekcji niebędący tablicą parametrów musi mieć odpowiedni konstruktor, który można wywołać bez argumentów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMemberCannotBeLessVisibleThanDeclaringMember">
        <source>Method '{0}' cannot be less visible than the member with params collection '{1}'.</source>
        <target state="translated">Metoda „{0}” nie może być mniej widoczna niż składowa z kolekcją parametrów „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeCollection">
        <source>The params parameter must have a valid collection type</source>
        <target state="translated">Parametr params musi mieć prawidłowy typ kolekcji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberAccessibilityDifference">
        <source>Both partial member declarations must have identical accessibility modifiers.</source>
        <target state="translated">Obie częściowe deklaracje elementów członkowskich muszą mieć identyczne modyfikatory dostępności.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberCannotBeAbstract">
        <source>A partial member cannot have the 'abstract' modifier</source>
        <target state="translated">Częściowy element członkowski nie może mieć modyfikatora „abstract”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberInconsistentTupleNames">
        <source>Both partial member declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">Obie deklaracje częściowych elementów członkowskich, „{0}” i „{1}”, muszą korzystać z tych samych nazw elementów krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberOnlyInPartialClass">
        <source>A partial member must be declared within a partial type</source>
        <target state="translated">Częściowy element członkowski musi być zadeklarowany w ramach częściowego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberParamsDifference">
        <source>Both partial member declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">Obie częściowe deklaracje elementów członkowskich muszą używać parametru params lub żadna z nich nie może używać parametru params</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberReadOnlyDifference">
        <source>Both partial member declarations must be readonly or neither may be readonly</source>
        <target state="translated">Obie deklaracje częściowych elementów członkowskich muszą być tylko do odczytu lub żadna z nich nie może być tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberExtendedModDifference">
        <source>Both partial member declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</source>
        <target state="translated">Obie deklaracje częściowych elementów członkowskich muszą mieć identyczne kombinacje modyfikatorów „virtual”, „override”, „sealed” i „new”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberRefReturnDifference">
        <source>Partial member declarations must have matching ref return values.</source>
        <target state="translated">Deklaracje częściowych elementów członkowskich muszą mieć pasujące wartości zwracane ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberUnsafeDifference">
        <source>Both partial member declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">Obie częściowe deklaracje elementów członkowskich muszą być niebezpieczne lub żadna z nich nie może być niebezpieczna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReturnTypeDifference">
        <source>Both partial method declarations must have the same return type.</source>
        <target state="translated">Obie częściowe deklaracje metod muszą mieć taki sam zwracany typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
        <source>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</source>
        <target state="translated">Metoda częściowa „{0}” musi mieć część implementacji, ponieważ ma modyfikatory dostępności.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithExtendedModMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</source>
        <target state="translated">Metoda częściowa „{0}” musi mieć modyfikatory dostępności, ponieważ ma modyfikator „virtual”, „override”, „sealed”, „new” lub „extern”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</source>
        <target state="translated">Metoda częściowa „{0}” musi mieć modyfikatory dostępności, ponieważ ma typ zwracany inny niż void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithOutParamMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</source>
        <target state="translated">Metoda częściowa „{0}” musi mieć modyfikatory dostępności, ponieważ ma parametry „out”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateDefinition">
        <source>A partial property may not have multiple defining declarations, and cannot be an auto-property.</source>
        <target state="translated">Właściwość częściowa nie może mieć wielu deklaracji definiujących i nie może być właściwością automatyczną.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateImplementation">
        <source>A partial property may not have multiple implementing declarations</source>
        <target state="translated">Właściwość częściowa nie może mieć wielu deklaracji implementujących</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateInitializer">
        <source>A partial property cannot have an initializer on both the definition and implementation.</source>
        <target state="new">A partial property cannot have an initializer on both the definition and implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyInitMismatch">
        <source>Property accessor '{0}' must be '{1}' to match the definition part</source>
        <target state="translated">Metoda dostępu właściwości „{0}” musi mieć wartość „{1}”, aby dopasować część definicji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingAccessor">
        <source>Property accessor '{0}' must be implemented because it is declared on the definition part</source>
        <target state="translated">Właściwość accessor „{0}” musi zostać zaimplementowana, ponieważ jest zadeklarowana w części definicji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingDefinition">
        <source>Partial property '{0}' must have a definition part.</source>
        <target state="translated">Właściwość częściowa „{0}” musi mieć część definicji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingImplementation">
        <source>Partial property '{0}' must have an implementation part.</source>
        <target state="translated">Właściwość częściowa „{0}” musi mieć część implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyRequiredDifference">
        <source>Both partial property declarations must be required or neither may be required</source>
        <target state="translated">Obie deklaracje właściwości częściowych muszą być wymagane lub żadna z nich nie może być wymagana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyTypeDifference">
        <source>Both partial property declarations must have the same type.</source>
        <target state="translated">Obie deklaracje właściwości częściowych muszą mieć ten sam typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyUnexpectedAccessor">
        <source>Property accessor '{0}' does not implement any accessor declared on the definition part</source>
        <target state="translated">Właściwość accessor „{0}” nie implementuje żadnego accessora zadeklarowanego w części definiującej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternSpanCharCannotBeStringNull">
        <source>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</source>
        <target state="translated">Stała ciągu „null” nie jest obsługiwana jako wzorzec dla „{0}”. Zamiast tego użyj pustego ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">Dopasowanie wzorca jest niedozwolone dla typów wskaźnika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">Treść metody iteratora asynchronicznego musi zawierać instrukcję „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">Treść metody iteratora asynchronicznego musi zawierać instrukcję „yield”. Rozważ usunięcie modyfikatora „async” z deklaracji metody lub dodanie instrukcji „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">Wzorzec podrzędny właściwości wymaga odwołania do właściwości lub pola, które należy dopasować, na przykład „{{ Name: {0} }}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringDelimiterOnOwnLine">
        <source>Raw string literal delimiter must be on its own line.</source>
        <target state="translated">Ogranicznik literału ciągu nieprzetworzonego musi znajdować się w osobnym wierszu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringInVerbatimInterpolatedStrings">
        <source>Multi-line raw string literals are only allowed in verbatim interpolated strings.</source>
        <target state="translated">Wielowierszowe literały nieprzetworzonych ciągów są dozwolone tylko w interpolowanych ciągach dosłownych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringMustContainContent">
        <source>Multi-line raw string literals must contain at least one line of content.</source>
        <target state="translated">Wielowierszowe literały nieprzetworzonych ciągów muszą zawierać co najmniej jeden wiersz zawartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringNotInDirectives">
        <source>Raw string literals are not allowed in preprocessor directives.</source>
        <target state="translated">Literały nieprzetworzonego ciągu są niedozwolone w dyrektywach preprocesora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu „{0}”, ponieważ zawiera ponowną abstrakcję składowej z interfejsu podstawowego. Rozważ ustawienie właściwości „Osadź typy międzyoperacyjne” na wartość false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">„{0}”: modyfikatora „readonly” można użyć dla metod dostępu tylko wtedy, gdy właściwość lub indeksator mają metody dostępu get i set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordAmbigCtor">
        <source>The primary constructor conflicts with the synthesized copy constructor.</source>
        <target state="translated">Konstruktor podstawowy powoduje konflikt z konstruktorem syntetyzowanej kopii.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordStructConstructorCallsDefaultConstructor">
        <source>A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</source>
        <target state="translated">Konstruktor zadeklarowany w „strukturze rekordów” z listą parametrów musi mieć inicjator „this”, który wywołuje konstruktor podstawowy lub jawnie zadeklarowany konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Nie można przypisać odwołania elementu „{1}” do elementu „{0}”, ponieważ element „{1}” ma węższy zakres wyjścia niż element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignReturnOnly">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">Nie można przypisać odwołania „{1}” do „{0}”, ponieważ „{1}” może jedynie opuścić bieżącą metodę za pomocą instrukcji return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignValEscapeWider">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">Nie można przypisać wartości ref „{1}” do „{0}”, ponieważ „{1}” ma szerszy zakres ucieczki wartości niż „{0}”, umożliwiając przypisanie za pośrednictwem „{0}” wartości z węższymi zakresami ucieczki niż „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldCannotReferToRefStruct">
        <source>A ref field cannot refer to a ref struct.</source>
        <target state="translated">Pole referencyjne nie może odwoływać się do struktury referencyjnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldInNonRefStruct">
        <source>A ref field can only be declared in a ref struct.</source>
        <target state="translated">Pole referencyjne można zadeklarować tylko w strukturze referencyjnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalAcrossAwait">
        <source>A 'ref' local cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Nie można zachować elementu lokalnego „ref” w granicach „await” lub „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref variable.</source>
        <target state="translated">Lewa strona przypisania referencyjnego musi być zmienną referencyjną.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadOnlyWrongOrdering">
        <source>'readonly' modifier must be specified after 'ref'.</source>
        <target state="translated">Modyfikator „readonly” musi być określony po znaku „ref”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Podstawowy parametr konstruktora typu tylko do odczytu nie może być użyty jako wartość ref lub out (z wyjątkiem inicjującego settera typu lub inicjalizatora zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Składowych podstawowego parametru konstruktora '{0}' typu tylko do odczytu nie można używać jako wartości ref ani out (z wyjątkiem inicjującego settera typu lub inicjalizatora zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter">
        <source>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Nie można zwrócić parametru przez odwołanie „{0}” za pomocą parametru ref; można go zwrócić tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter2">
        <source>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Nie można zwrócić przez odwołanie składowej parametru „{0}” za pomocą parametru ref; może on być zwracany tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnPrimaryConstructorParameter">
        <source>Cannot return primary constructor parameter '{0}' by reference.</source>
        <target state="translated">Nie można zwrócić podstawowego parametru konstruktora '{0}' przez odwołanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be returned by writable reference</source>
        <target state="translated">Podstawowy parametr konstruktora typu tylko do odczytu nie może być zwracany przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference</source>
        <target state="translated">Składowe podstawowego parametru konstruktora '{0}' typu tylko do odczytu nie mogą być zwracane przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter">
        <source>Cannot return a parameter by reference '{0}' because it is scoped to the current method</source>
        <target state="translated">Nie można zwrócić parametru przez odwołanie „{0}”, ponieważ jest on ograniczony do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</source>
        <target state="translated">Nie można zwrócić przez odwołanie składowej parametru „{0}”, ponieważ jest on ograniczony do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningPropertiesCannotBeRequired">
        <source>Ref returning properties cannot be required.</source>
        <target state="translated">Odwołanie zwracające właściwości nie może być wymagane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructConstraintAlreadySpecified">
        <source>'ref struct' is already specified.</source>
        <target state="translated">„Struktura ref” jest już określona.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' for ref struct '{2}'.</source>
        <target state="translated">Element „{0}” nie może zaimplementować składowej interfejsu „{1}” dla struktury ref „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RelationalPatternWithNaN">
        <source>Relational patterns may not be used for a floating-point NaN.</source>
        <target state="translated">Wzorców relacyjnych nie można używać na potrzeby zmiennoprzecinkowej wartości NaN.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeHidden">
        <source>Required member '{0}' cannot be hidden by '{1}'.</source>
        <target state="translated">Wymagana składowa „{0}” nie może być ukrywana przez „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
        <source>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</source>
        <target state="translated">Wymagana składowa „{0}” nie może być mniej widoczna lub mieć metody ustawiającej mniej widocznej niż typ zawierający „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSet">
        <source>Required member '{0}' must be set in the object initializer or attribute constructor.</source>
        <target state="translated">Wymagana składowa „{0}” musi być ustawiona w konstruktorze inicjatora obiektów lub atrybutów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSettable">
        <source>Required member '{0}' must be settable.</source>
        <target state="translated">Wymagana składowa „{0}” musi być konfigurowalna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersBaseTypeInvalid">
        <source>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</source>
        <target state="translated">Lista wymaganych składowych dla typu podstawowego „{0}” jest źle sformułowana i nie można jej zinterpretować. Aby użyć tego konstruktora, zastosuj atrybut „SetsRequiredMembers”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersInvalid">
        <source>The required members list for '{0}' is malformed and cannot be interpreted.</source>
        <target state="translated">Lista wymaganych składowych dla „{0}” jest źle sformułowana i nie można jej zinterpretować.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersMustBeAssignedValue">
        <source>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</source>
        <target state="translated">Wymagana składowa „{0}” musi mieć przypisaną wartość, nie może używać zagnieżdżonej składowej ani inicjatora kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNameDisallowed">
        <source>Types and aliases cannot be named 'required'.</source>
        <target state="translated">Typy i aliasy nie mogą mieć nazwy „required”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportByRefLikeGenerics">
        <source>Target runtime doesn't support by-ref-like generics.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje typów ogólnych by-ref-like.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
        <source>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">„{0}”: docelowe środowisko uruchomieniowe nie obsługuje typów kowariantnych w przesłonięciach. Typem musi być „{2}”, aby zachować zgodność z przesłoniętą składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
        <source>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">„{0}”: docelowe środowisko uruchomieniowe nie obsługuje kowariantnych typów zwracanych w przesłonięciach. Typem zwracanym musi być „{2}”, aby zachować zgodność z przesłoniętą składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportInlineArrayTypes">
        <source>Target runtime doesn't support inline array types.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje typów tablic śródwierszowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje specyfikatorów dostępu „protected”, „protected internal” i „private protected” dla składowej interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportRefFields">
        <source>Target runtime doesn't support ref fields.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje pól referencyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
        <source>Target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje statycznych składowych abstrakcyjnych w interfejsach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">Atrybut "{0}" nie może implementować składowej interfejsu "{1}" w typie "{2}", ponieważ docelowe środowisko uruchomieniowe nie obsługuje statycznych składowych abstrakcyjnych w interfejsach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
        <source>The target runtime doesn't support extensible or runtime-environment default calling conventions.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje rozszerzalnych ani domyślnych dla środowiska uruchomieniowego konwencji wywoływania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedDiscard">
        <source>The 'scoped' modifier cannot be used with discard.</source>
        <target state="translated">Modyfikator „scoped” nie może być używany z odrzuceniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Modyfikator „scoped” parametru „{0}” nie jest zgodny z przesłoniętą lub zaimplementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfPartial">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match partial definition.</source>
        <target state="translated">Modyfikator „scoped” parametru „{0}” nie jest zgodny z częściową definicją.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Modyfikator „scoped” 'parametru „{0}” nie jest zgodny z 'elementem docelowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedRefAndRefStructOnly">
        <source>The 'scoped' modifier can be used for refs and ref struct values only.</source>
        <target state="translated">Modyfikator „scoped" może być używany tylko w przypadku odwołań i wartości struktury referencyjnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedTypeNameDisallowed">
        <source>Types and aliases cannot be named 'scoped'.</source>
        <target state="translated">Typy i aliasy nie mogą mieć nazwy „scoped”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
        <source>Required members are not allowed on the top level of a script or submission.</source>
        <target state="translated">Wymagane składowe są niedozwolone na najwyższym poziomie skryptu lub żądania przesłania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedAPIInRecord">
        <source>'{0}' cannot be sealed because containing record is not sealed.</source>
        <target state="translated">Element „{0}” nie może być zapieczętowany, ponieważ zawierający go rekord nie jest zapieczętowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignatureMismatchInRecord">
        <source>Record member '{0}' must return '{1}'.</source>
        <target state="translated">Składowa rekordu „{0}” musi zwracać wartość „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramDisallowsMainType">
        <source>Cannot specify /main if there is a compilation unit with top-level statements.</source>
        <target state="translated">Nie można określić opcji /main, jeśli istnieje jednostka kompilacji z instrukcjami najwyższego poziomu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramIsEmpty">
        <source>At least one top-level statement must be non-empty.</source>
        <target state="translated">Co najmniej jedna instrukcja najwyższego poziomu nie może być pusta.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
        <source>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</source>
        <target state="translated">W tym kontekście nie można użyć zmiennej lokalnej ani funkcji lokalnej „{0}” zadeklarowanej w instrukcji najwyższego poziomu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
        <source>Only one compilation unit can have top-level statements.</source>
        <target state="translated">Tylko jedna jednostka kompilacji może mieć instrukcje najwyższego poziomu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramNotAnExecutable">
        <source>Program using top-level statements must be an executable.</source>
        <target state="translated">Program korzystający z instrukcji najwyższego poziomu musi być plikiem wykonywalnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">Wzorzec dekonstrukcji z jednym elementem wymaga innej składni w celu ujednoznacznienia. Zaleca się dodanie desygnatora odrzucania „_” po nawiasie zamykającym „)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpreadMissingMember">
        <source>Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">Operator rozłożenia „..” nie może operować na zmiennych typu „{0}”, ponieważ „{0}” nie zawiera publicznego wystąpienia lub definicji rozszerzenia dla elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAPIInRecord">
        <source>Record member '{0}' may not be static.</source>
        <target state="translated">Składowa rekordu „{0}” nie może być statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureThis">
        <source>A static anonymous function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Statyczna funkcja anonimowa nie może zawierać odwołania do elementu „this” lub „base”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureVariable">
        <source>A static anonymous function cannot contain a reference to '{0}'.</source>
        <target state="translated">Statyczna funkcja anonimowa nie może zawierać odwołania do elementu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Statyczna funkcja lokalna nie może zawierać odwołania do elementu „this” lub „base”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">Statyczna funkcja lokalna nie może zawierać odwołania do elementu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Składowa statyczna „{0}” nie może być oznaczona jako „readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">określono argument stdin „-”, ale dane wejściowe nie zostały przekierowane ze standardowego strumienia wejściowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StringMustStartWithQuoteCharacter">
        <source>String must start with quote character: "</source>
        <target state="translated">Ciąg musi rozpoczynać się znakiem cudzysłowu: "</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructHasInitializersAndNoDeclaredConstructor">
        <source>A 'struct' with field initializers must include an explicitly declared constructor.</source>
        <target state="translated">Element „struct” z inicjatorami pól musi zawierać jawnie zadeklarowanego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCyclePrimaryConstructorParameter">
        <source>Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Podstawowy parametr konstruktora struktury '{0}' typu '{1}' powoduje cykl w układzie struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</source>
        <target state="translated">Wzorzec jest nieosiągalny. Został on już obsłużony przez poprzednie odgałęzienie wyrażenia switch albo nie można go dopasować.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</source>
        <target state="translated">Przypadek switch jest nieosiągalny. Został on już obsłużony przez poprzednią instrukcję case albo nie można go dopasować.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">Nie znaleziono najlepszego typu dla wyrażenia switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">Wymagane są nawiasy wokół wyrażenia sterującego instrukcją switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SymbolDefinedInAssembly">
        <source>'{0}' is defined in assembly '{1}'.</source>
        <target state="translated">„{0}” jest zdefiniowany w zestawie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCloseBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</source>
        <target state="translated">Interpolowany literał nieprzetworzonego ciągu nie zaczyna się od wystarczającej liczby znaków „$”, aby zezwolić na następującą liczbę kolejnych zamykających nawiasów klamrowych jako zawartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyOpenBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</source>
        <target state="translated">Interpolowany literał nieprzetworzonego ciągu nie zaczyna się od wystarczającej liczby znaków „$”, aby zezwolić na następującą liczbę kolejnych otwierających nawiasów klamrowych jako zawartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyQuotesForRawString">
        <source>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</source>
        <target state="translated">Nieprzetworzony literał ciągu nie rozpoczyna się od wystarczającej liczby znaków cudzysłowu, aby umożliwić używanie tak wielu kolejnych znaków cudzysłowu jako zawartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TopLevelStatementAfterNamespaceOrType">
        <source>Top-level statements must precede namespace and type declarations.</source>
        <target state="translated">Instrukcje najwyższego poziomu muszą poprzedzać deklaracje przestrzeni nazw i typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">Nieoczekiwana sekwencja znaków „...”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">Nazwa „{0}” nie identyfikuje elementu krotki „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">Typy krotek używane jako operandy operatorów == lub != muszą mieć zgodne kardynalności. Ten operator zawiera natomiast typy krotek o kardynalności {0} z lewej strony i {1} z prawej strony.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConstraintsMustBeUniqueAndFirst">
        <source>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</source>
        <target state="translated">Ograniczeń „class”, „struct”, „unmanaged”, „notnull” i „default” nie można łączyć ani duplikować i należy je najpierw określić na liście ograniczeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeIsNotAnInterpolatedStringHandlerType">
        <source>'{0}' is not an interpolated string handler type.</source>
        <target state="translated">„{0}” nie jest interpolowanym typem obsługi ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMustBePublic">
        <source>Type '{0}' must be public to be used as a calling convention.</source>
        <target state="translated">Typ „{0}” musi być publiczny, aby można go było używać jako konwencji wywoływania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Automatycznie implementowana właściwość „{0}” musi być w pełni przypisana, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie do wersji językowej „{1}”, aby automatycznie ustawić domyślną właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Pole „{0}” musi być w pełni przypisane, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie pola do wersji językowej „{1}”, aby automatycznie ustawić domyślne pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedParameterList">
        <source>Unexpected parameter list.</source>
        <target state="translated">Nieoczekiwana lista parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</source>
        <target state="translated">Element „{0}” ma atrybut „UnmanagedCallersOnly” i nie można go wywołać bezpośrednio. Uzyskaj wskaźnik funkcji do tej metody.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</source>
        <target state="translated">Element „{0}” ma atrybut „UnmanagedCallersOnly” i nie można go przekonwertować na typ delegowany. Uzyskaj wskaźnik funkcji do tej metody.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedRefSafetyRulesAttributeVersion">
        <source>'{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.</source>
        <target state="translated">Element '{0}' jest zdefiniowany w module z nierozpoznaną wersją RefSafetyRulesAttribute, oczekiwano „11”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeInterfaceImplementation">
        <source>UnscopedRefAttribute cannot be applied to an interface implementation because implemented member '{0}' doesn't have this attribute.</source>
        <target state="translated">Nie można zastosować atrybutu UnscopedRefAttribute do implementacji interfejsu, ponieważ zaimplementowana składowa „{0}” nie ma tego atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedMemberTarget">
        <source>UnscopedRefAttribute can only be applied to struct or virtual interface instance methods and properties, and cannot be applied to constructors or init-only members.</source>
        <target state="translated">Atrybut UnscopedRefAttribute można stosować tylko do metod i właściwości wystąpienia interfejsu wirtualnego lub struktury i nie można go stosować do konstruktorów ani składowych tylko do inicjowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedTarget">
        <source>UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.</source>
        <target state="translated">Nie można zastosować atrybutu UnscopedRefAttribute do tego elementu, ponieważ jest on domyślnie nieobjęty zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedScoped">
        <source>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</source>
        <target state="translated">Nie można zastosować atrybutu UnscopedRefAttribute do parametrów, które mają modyfikator „scoped”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCompilerFeature">
        <source>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</source>
        <target state="translated">„{0}” wymaga funkcji kompilatora „{1}”, która nie jest obsługiwana przez tę wersję kompilatora języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRef">
        <source>Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member</source>
        <target state="translated">Nie można użyć ref, out lub w podstawowym parametrze konstruktora '{0}' wewnątrz elementu członkowskiego wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefAny">
        <source>Cannot use primary constructor parameter of type '{0}' inside an instance member</source>
        <target state="translated">Nie można użyć podstawowego parametru konstruktora typu „{0}” wewnątrz składowej wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefLike">
        <source>Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member</source>
        <target state="translated">Nie można użyć podstawowego parametru konstruktora '{0}', który ma typ przypominający odwołanie wewnątrz składowej wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForListPattern">
        <source>List patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Wzorców list nie można używać na potrzeby wartości typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForSlicePattern">
        <source>Slice patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Wzorców wycinków nie można używać na potrzeby wartości typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedRawString">
        <source>Unterminated raw string literal.</source>
        <target state="translated">Niezakończony literał ciągu znaków.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola „{0}”. Rozważ zaktualizowanie pola do wersji językowej „{1}”, aby automatycznie ustawić domyślne pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”. Rozważ zaktualizowanie do wersji językowej „{1}”, aby automatycznie ustawić domyślną właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Nie można użyć obiektu „this” przed przypisaniem wszystkich jego pól. Rozważ zaktualizowanie nieprzypisanych pól do wersji językowej „{0}”, aby automatycznie ustawić domyślne pola niezaznaczone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongArityAsyncReturn">
        <source>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</source>
        <target state="translated">Oczekiwano zwracanego typu podobnego do zadania ogólnego, ale typ "{0}" znaleziony w atrybucie "AsyncMethodBuilder" był nieodpowiedni. Musi to być niepowiązany typ ogólny jednego argumentu, a zawarty w nim typ (jeśli występuje), nie może być ogólny.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing">
        <source>The using directive for '{0}' appeared previously as global using</source>
        <target state="translated">Dyrektywa użycia w przypadku "{0}" pojawiła się wcześniej jako użycie globalne</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing_Title">
        <source>The using directive appeared previously as global using</source>
        <target state="translated">Dyrektywa użycia pojawiła się wcześniej jako użycie globalne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ArrayAccess">
        <source>array access</source>
        <target state="translated">dostęp do macierzy</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AsyncMethodBuilderOverride">
        <source>async method builder override</source>
        <target state="translated">zastąpienie konstruktora metodą asynchroniczną</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAllowsRefStructConstraint">
        <source>allows ref struct constraint</source>
        <target state="translated">zezwala na ograniczenie ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoDefaultStructs">
        <source>auto default struct fields</source>
        <target state="translated">pola automatycznej struktury domyślnej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCheckedUserDefinedOperators">
        <source>checked user-defined operators</source>
        <target state="translated">zaznaczone operatory zdefiniowane przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressions">
        <source>collection expressions</source>
        <target state="translated">wyrażenia kolekcji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCovariantReturnsForOverrides">
        <source>covariant returns</source>
        <target state="translated">zwroty kowariantne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDiscards">
        <source>discards</source>
        <target state="translated">odrzucenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDisposalPattern">
        <source>pattern-based disposal</source>
        <target state="translated">likwidacja oparta na wzorcu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPropertyPatterns">
        <source>extended property patterns</source>
        <target state="translated">wzorce właściwości rozszerzonych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFieldKeyword">
        <source>field keyword</source>
        <target state="translated">słowo kluczowe pola</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileScopedNamespace">
        <source>file-scoped namespace</source>
        <target state="translated">przestrzeń nazw z określonym zakresem plików</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileTypes">
        <source>file types</source>
        <target state="translated">typy plików</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenericAttributes">
        <source>generic attributes</source>
        <target state="translated">atrybuty ogólne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalUsing">
        <source>global using directive</source>
        <target state="translated">globalne przy użyciu dyrektywy</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitIndexerInitializer">
        <source>implicit indexer initializer</source>
        <target state="translated">niejawny inicjator indeksatora</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitObjectCreation">
        <source>target-typed object creation</source>
        <target state="translated">tworzenie obiektu z typem docelowym</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImprovedInterpolatedStrings">
        <source>interpolated string handlers</source>
        <target state="translated">procedury obsługi ciągów interpolowanych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInferredDelegateType">
        <source>inferred delegate type</source>
        <target state="translated">Typ delegowania wywnioskowanego</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInlineArrays">
        <source>inline arrays</source>
        <target state="translated">tablice śródwierszowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInstanceMemberInNameof">
        <source>instance member in 'nameof'</source>
        <target state="translated">składowa wystąpienia w elemencie „nameof”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaAttributes">
        <source>lambda attributes</source>
        <target state="translated">atrybuty lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaOptionalParameters">
        <source>lambda optional parameters</source>
        <target state="translated">opcjonalne parametry wyrażenia lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaParamsArray">
        <source>lambda params array</source>
        <target state="translated">tablica parametrów lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaReturnType">
        <source>lambda return type</source>
        <target state="translated">zwracany typ lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureListPattern">
        <source>list pattern</source>
        <target state="translated">wzorzec listy</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLockObject">
        <source>Lock object</source>
        <target state="translated">Zablokuj obiekt</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNewLinesInInterpolations">
        <source>newlines in interpolations</source>
        <target state="translated">nowe wiersze w interpolacjach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParameterlessStructConstructors">
        <source>parameterless struct constructors</source>
        <target state="translated">Konstruktory struktury bez parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParamsCollections">
        <source>params collections</source>
        <target state="translated">kolekcje params</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePositionalFieldsInRecords">
        <source>positional fields in records</source>
        <target state="translated">pola pozycyjne w rekordach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrimaryConstructors">
        <source>primary constructors</source>
        <target state="translated">konstruktory podstawowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRawStringLiterals">
        <source>raw string literals</source>
        <target state="translated">literały nieprzetworzonego ciągu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecordStructs">
        <source>record structs</source>
        <target state="translated">struktury rekordów</target>
        <note>'record structs' is not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFields">
        <source>ref fields</source>
        <target state="translated">pola referencyjne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReadonlyParameters">
        <source>ref readonly parameters</source>
        <target state="translated">parametry tylko do odczytu ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructInterfaces">
        <source>ref struct interfaces</source>
        <target state="translated">interfejsy struktury ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefUnsafeInIteratorAsync">
        <source>ref and unsafe in async and iterator methods</source>
        <target state="translated">„ref” i „unsafe” w metodach asynchronicznych i iteracyjnych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelaxedShiftOperator">
        <source>relaxed shift operator</source>
        <target state="translated">operator swobodnej zmiany</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRequiredMembers">
        <source>required members</source>
        <target state="translated">wymagane składowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSealedToStringInRecord">
        <source>sealed ToString in record</source>
        <target state="translated">zapieczętowany obiekt ToString w rekordzie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStringEscapeCharacter">
        <source>string escape character</source>
        <target state="translated">ciąg — znak ucieczki</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStructFieldInitializers">
        <source>struct field initializers</source>
        <target state="translated">inicjatory pola struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnsignedRightShift">
        <source>unsigned right shift</source>
        <target state="translated">niepodpisane przesunięcie w prawo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUtf8StringLiterals">
        <source>UTF-8 string literals</source>
        <target state="translated">Literały ciągu UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingTypeAlias">
        <source>using type alias</source>
        <target state="translated">przy użyciu aliasu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnAnonymousTypes">
        <source>with on anonymous types</source>
        <target state="translated">przy użyciu typów anonimowych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAbstractMembersInInterfaces">
        <source>static abstract members in interfaces</source>
        <target state="translated">statyczne abstrakcyjne składowe w interfejsach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnStructs">
        <source>with on structs</source>
        <target state="translated">przy użyciu struktur</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSpanCharConstantPattern">
        <source>pattern matching ReadOnly/Span&lt;char&gt; on constant string</source>
        <target state="translated">dopasowanie wzorca ReadOnly/Span&lt;char&gt; w ciągu stałym</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Missing">
        <source>&lt;missing&gt;</source>
        <target state="translated">&lt;missing&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverloadResolutionPriority">
        <source>overload resolution priority</source>
        <target state="translated">priorytet rozwiązywania przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PointerElementAccess">
        <source>pointer element access</source>
        <target state="translated">dostęp do elementu wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ARRAY">
        <source>array</source>
        <target state="translated">tablica</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_DYNAMIC">
        <source>dynamic</source>
        <target state="translated">dynamiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FUNCTION_POINTER">
        <source>function pointer</source>
        <target state="translated">wskaźnik funkcji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_POINTER">
        <source>pointer</source>
        <target state="translated">wskaźnik</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_IdentifierConflictWithContextualKeyword_Title">
        <source>Identifier is a contextual keyword, with a specific meaning, in a later language version.</source>
        <target state="translated">Identyfikator jest kontekstowym słowem kluczowym o określonym znaczeniu w późniejszej wersji językowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas">
        <source>Compiling requires binding the lambda expression at least {0} times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">Kompilowanie wymaga powiązania wyrażenia lambda co najmniej {0} razy. Rozważ zadeklarowanie wyrażenia lambda z jawnymi typami parametrów lub jeśli zawarte wywołanie metody jest ogólne, rozważ użycie jawnych argumentów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas_Title">
        <source>Compiling requires binding the lambda expression many times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">Kompilowanie wymaga powiązania wyrażenia lambda wiele razy. Rozważ zadeklarowanie wyrażenia lambda z jawnymi typami parametrów lub jeśli zawarte wywołanie metody jest ogólne, rozważ użycie jawnych argumentów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISpreadOperationIsNotCSharpSpread">
        <source>{0} is not a valid C# spread operation</source>
        <target state="translated">{0} nie jest prawidłową operacją rozłożenia w języku C#</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">Operator „&amp;” nie powinien być używany w parametrach ani zmiennych lokalnych w metodach asynchronicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync_Title">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">Operator „&amp;” nie powinien być używany w parametrach ani zmiennych lokalnych w metodach asynchronicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">Zestaw „{0}” zawierający typ „{1}” odwołuje się do platformy .NET Framework, co nie jest obsługiwane.</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">Załadowany zestaw odwołuje się do platformy .NET Framework, co nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler">
        <source>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="translated">Zestaw analizatora „{0}” odwołuje się do wersji „{1}” kompilatora, która jest nowsza niż obecnie uruchomiona wersja „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler_Title">
        <source>The analyzer assembly references a newer version of the compiler than the currently running version.</source>
        <target state="translated">Zestaw analizatora odwołuje się do nowszej wersji kompilatora niż obecnie uruchomiona wersja.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn">
        <source>Argument {0} should be passed with the 'in' keyword</source>
        <target state="translated">Argument {0} powinien być przekazywany za pomocą słowa kluczowego „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn_Title">
        <source>Argument should be passed with the 'in' keyword</source>
        <target state="translated">Argument powinien być przekazywany za pomocą słowa kluczowego „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn">
        <source>Argument {0} should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">Argument {0} powinien być przekazywany za pomocą słowa kluczowego „ref” lub „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn_Title">
        <source>Argument should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">Argument powinien być przekazywany za pomocą słowa kluczowego „ref” lub „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">Typ „{0}” nie może być używany w tym kontekście, ponieważ nie może być reprezentowany w metadanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed_Title">
        <source>Type cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">Typ nie może być używany w tym kontekście, ponieważ nie może być reprezentowany w metadanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef">
        <source>The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Modyfikator „ref” dla argumentu {0} odpowiadającego parametrowi „in” jest równoważny parametrowi „in”. Zamiast tego rozważ użycie parametru „in”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef_Title">
        <source>The 'ref' modifier for an argument corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Modyfikator „ref” dla argumentu odpowiadającego parametrowi „in” jest równoważny parametrowi „in”. Zamiast tego rozważ użycie parametru „in”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">Należy określić parametr atrybutu „SizeConst”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired_Title">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">Należy określić parametr atrybutu „SizeConst”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing">
        <source>This combination of arguments to '{0}' may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Ta kombinacja argumentów „{0}” może uwidaczniać zmienne przywoływane przez parametr „{1}” poza zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing_Title">
        <source>This combination of arguments may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">Ta kombinacja argumentów może uwidaczniać zmienne przywoływane przez parametr poza zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</source>
        <target state="translated">Atrybut CallerArgumentExpressionAttribute zastosowany do parametru "{0}" nie odniesie żadnego skutku. Zastosowano go z nieprawidłową nazwą parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
        <source>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</source>
        <target state="translated">Atrybut CallerArgumentExpressionAttribute zastosowano z nieprawidłową nazwą parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</source>
        <target state="translated">Atrybut CallerArgumentExpressionAttribute zastosowany do parametru „{0}” nie będzie działać, ponieważ jego odwołanie jest samodzielne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
        <source>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</source>
        <target state="translated">Zastosowany atrybut CallerArgumentExpressionAttribute do parametru nie odniesie żadnego skutku, ponieważ odwołuje się sam do siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie atrybutu CallerArgumentExpressionAttribute do parametru "{0}" nie odniesie żadnego skutku, ponieważ dotyczy składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie atrybutu CallerArgumentExpressionAttribute nie odniesie żadnego skutku, ponieważ dotyczy on składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Atrybut CallerArgumentExpressionAttribute zastosowany do parametru „{0}” nie będzie działać. Jest on zastępowany przez atrybut CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerFilePathAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Zastosowany atrybut CallerArgumentExpressionAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on zastępowany przez atrybut CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Atrybut CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on zastąpiony przez atrybut CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</source>
        <target state="translated">Zastosowany atrybut CallerArgumentExpressionAttribute do parametru "{0}" nie odniesie żadnego skutku. Jest on zastępowany przez atrybut CallerMemberNameAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</source>
        <target state="translated">Atrybut CallerMemberNameAttribute nie odniesie żadnego skutku; ponieważ jest on zastąpiony przez atrybut CallerFilePathAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Parametr „{0}” jest przechwytywany w stanie otaczającego typu, a jego wartość jest również używana do inicjowania pola, właściwości lub zdarzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Parametr jest przechwytywany w stanie otaczającego typu, a jego wartość jest również używana do inicjowania pola, właściwości lub zdarzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Parametr '{0}' jest przechwytywane do stanu otaczającego typu, a jego wartość jest również przekazywana do konstruktora podstawowego. Wartość może zostać również przechwycona przez klasę bazową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Parametr zostaje przechwycony do stanu otaczającego typu, a jego wartość jest również przekazywana do konstruktora podstawowego. Wartość może być również przechwycona przez klasę bazową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">Wyrażenie kolekcji typu „{0}” może spowodować nieoczekiwane alokacje sterty. Rozważ jawne utworzenie tablicy, a następnie przekonwertowanie na „{0}”, aby jawnie utworzyć alokację.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">Wyrażenie kolekcji może spowodować nieoczekiwane alokacje sterty. Rozważ jawne utworzenie tablicy, a następnie przekonwertowanie na typ końcowy, aby jawnie utworzyć alokację.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">Wyrażenie kolekcji typu „{0}” może spowodować nieoczekiwane alokacje sterty z powodu użycia „.”. Rozważ jawne utworzenie tablicy, a następnie przekonwertowanie na „{0}”, aby jawnie utworzyć alokację.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations due to use of '..' spreads. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">Wyrażenie kolekcji może spowodować nieoczekiwane alokacje sterty z powodu użycia spreadów „.”. Rozważ jawne utworzenie tablicy, a następnie przekonwertowanie na typ końcowy, aby jawnie utworzyć alokację.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow">
        <source>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Operacja może się przepełnić w środowisku uruchomieniowym „{0}” (użyj składni „niezaznaczone”, aby zastąpić)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow_Title">
        <source>The operation may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Operacja może się przepełnić w środowisku uruchomieniowym (użyj składni „niezaznaczone”, aby zastąpić)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Wartość typu „System.Threading.Lock” przekonwertowana na inny typ użyje prawdopodobnie niezamierzonego blokowania opartego na monitorze w instrukcji „zablokuj”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock_Title">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Wartość typu „System.Threading.Lock” przekonwertowana na inny typ użyje prawdopodobnie niezamierzonego blokowania opartego na monitorze w instrukcji „zablokuj”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers">
        <source>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</source>
        <target state="translated">Porównanie wskaźników funkcji może zwrócić nieoczekiwany wynik, ponieważ wskaźniki do tej samej funkcji mogą być różne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers_Title">
        <source>Do not compare function pointer values</source>
        <target state="translated">Nie porównuj wartości wskaźników funkcji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference">
        <source>Analyzer reference '{0}' specified multiple times</source>
        <target state="translated">Odwołanie analizatora „{0}” określono wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference_Title">
        <source>Analyzer reference specified multiple times</source>
        <target state="translated">Odwołanie do analizatora określono wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall">
        <source>Use of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Użycie wyniku „{0}” w tym kontekście może uwidocznić zmienne przywoływane przez parametr „{1}” poza zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2">
        <source>Use of member of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Nie można używać składowej wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2_Title">
        <source>Use of member of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">Nie można używać składowej wyniku elementu w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall_Title">
        <source>Use of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">Użycie wyniku w tym kontekście może uwidaczniać zmienne przywoływane przez parametr poza zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</source>
        <target state="translated">Nie można używać wyniku wyrażenia stackalloc typu „{0}” w tym kontekście, ponieważ może zostać ujawniony poza metodą zawierającą</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc_Title">
        <source>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</source>
        <target state="translated">Wynik wyrażenia stackalloc tego typu w tym kontekście może być uwidoczniony poza metodą zawierającą</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable">
        <source>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Nie można używać zmiennej „{0}” w tym kontekście, ponieważ może uwidaczniać odwoływane zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable_Title">
        <source>Use of variable in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Nie można używać zmiennej w tym kontekście, ponieważ może uwidaczniać odwoływane zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous">
        <source>In language version {0}, the 'field' keyword binds to a synthesized backing field for the property. To avoid generating a synthesized backing field, and to refer to the existing member, use 'this.field' or '@field' instead.</source>
        <target state="new">In language version {0}, the 'field' keyword binds to a synthesized backing field for the property. To avoid generating a synthesized backing field, and to refer to the existing member, use 'this.field' or '@field' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous_Title">
        <source>The 'field' keyword binds to a synthesized backing field for the property.</source>
        <target state="new">The 'field' keyword binds to a synthesized backing field for the property.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">Operator konwersji tablicy wbudowanej nie będzie używany do konwersji z wyrażenia typu deklarującego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed_Title">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">Operator konwersji tablicy wbudowanej nie będzie używany do konwersji z wyrażenia typu deklarującego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">Indeksator tablicy wbudowanej nie będzie używany na potrzeby wyrażenia dostępu do elementów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed_Title">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">Indeksator tablicy wbudowanej nie będzie używany na potrzeby wyrażenia dostępu do elementów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">Funkcja języka „Tablice wbudowane” nie jest obsługiwana w przypadku typu tablicy wbudowanej, który jest nieprawidłowy jako argument typu lub ma typ elementu, który jest nieprawidłowy jako argument typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage_Title">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">Funkcja języka „Tablice wbudowane” nie jest obsługiwana w przypadku typu tablicy wbudowanej, który jest nieprawidłowy jako argument typu lub ma typ elementu, który jest nieprawidłowy jako argument typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Metoda „Slice” tablicy wbudowanej nie będzie używana dla wyrażenia dostępu do elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed_Title">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Metoda „Slice” tablicy wbudowanej nie będzie używana dla wyrażenia dostępu do elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru „{0}” nie pasuje do odpowiadającego mu parametru „{1}” w ukrytej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in hidden member.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru nie pasuje do odpowiedniego parametru w ukrytym elemencie członkowskim.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch">
        <source>Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.</source>
        <target state="translated">Przechwytywanie wywołania do „{0}” za pomocą interceptora „{1}”, ale sygnatury nie są zgodne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch_Title">
        <source>Signatures of interceptable and interceptor methods do not match.</source>
        <target state="translated">Podpisy metody możliwej do przechwycenia i metody interceptora nie są zgodne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">Argument InterpolatedStringHandlerArgument nie odniesie żadnego skutku po zastosowaniu do parametrów lambda i zostanie zignorowany w lokacji wywołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">Argument InterpolatedStringHandlerArgument nie odniesie żadnego skutku po zastosowaniu do parametrów lambda i zostanie zignorowany w lokacji wywołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName">
        <source>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Nazwa typu „{0}” zawiera tylko małe litery ascii. Takie nazwy mogą zostać zarezerwowane dla języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName_Title">
        <source>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Nazwa typu zawiera tylko małe litery ascii. Takie nazwy mogą zostać zarezerwowane dla języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</source>
        <target state="translated">Przyjmuje adres, pobiera rozmiar lub deklaruje wskaźnik do typu zarządzanego („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr_Title">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type</source>
        <target state="translated">Przyjmuje adres, pobiera rozmiar lub deklaruje wskaźnik do typu zarządzanego</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel">
        <source>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Konwertowanie grupy metod „{0}” na typ inny niż delegowany „{1}”. Czy zamierzasz wywołać metodę?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel_Title">
        <source>Converting method group to non-delegate type</source>
        <target state="translated">Konwertowanie grupy metod na typ inny niż delegowany</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Gałęzie operatora warunkowego ref nie mogą przywoływać zmiennych z niezgodnymi zakresami deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary_Title">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Gałęzie operatora warunkowego ref nie mogą przywoływać zmiennych z niezgodnymi zakresami deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów odwołania w typie parametru „{0}” jest niezgodna z metodą możliwą do przechwycenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor_Title">
        <source>Nullability of reference types in type of parameter doesn't match interceptable method.</source>
        <target state="translated">Obsługa wartości null dla typów odwołania w typie parametru jest niezgodna z metodą możliwą do przechwycenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor">
        <source>Nullability of reference types in return type doesn't match interceptable method '{0}'.</source>
        <target state="translated">Obsługa wartości null dla typów odwołania w typie zwracanym jest niezgodna z metodą możliwą do przechwycenia „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor_Title">
        <source>Nullability of reference types in return type doesn't match interceptable method.</source>
        <target state="translated">Obsługa wartości null dla typów odwołania w typie zwracanym jest niezgodna z metodą możliwą do przechwycenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired">
        <source>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">Wymagana składowa „{0}” nie powinna mieć atrybutu „ObsoleteAttribute”, chyba że zawierający typ jest przestarzały lub wszystkie konstruktory są przestarzałe.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired_Title">
        <source>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">Składowe z atrybutem „ObsoleteAttribute” nie powinny być wymagane, chyba że typ zawierający jest przestarzały lub wszystkie konstruktory są przestarzałe.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch">
        <source>Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.</source>
        <target state="translated">Parametr {0} ma wartość domyślną „{1:10}” w wyrażeniu lambda, ale wartość „{2:10}” w docelowym typie delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch_Title">
        <source>The default parameter value does not match in the target delegate type.</source>
        <target state="translated">Domyślna wartość parametru nie jest zgodna w docelowym typie delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru „{0}” nie jest zgodny z odpowiednim parametrem „{1}” w przesłoniętej lub zaimplementowanej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in overridden or implemented member.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru nie jest zgodny z odpowiednim parametrem w przesłoniętej lub zaimplementowanej składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull">
        <source>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</source>
        <target state="translated">Parametr „{0}” musi mieć wartość inną niż null podczas kończenia działania, ponieważ parametr „{1}” ma wartość inną niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull_Title">
        <source>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</source>
        <target state="translated">Parametr musi mieć wartość inną niż null podczas kończenia działania, ponieważ parametr przywoływany przez element NotNullIfNotNull ma wartość inną niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
        <source>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.</source>
        <target state="translated">Parametr „{0}” występuje po elemencie „{1}” na liście parametrów, ale jest on używany jako argument dla konwersji procedury obsługi ciągów interpolowanych. Będzie to wymagać od wywołującego zmiany kolejności parametrów za pomocą nazwanych argumentów w lokacji wywołania. Rozważ umieszczenie parametru procedury obsługi ciągu interpolowanego po wszystkich zastosowanych argumentach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
        <source>Parameter to interpolated string handler conversion occurs after handler parameter</source>
        <target state="translated">Parametr konwersji procedury obsługi ciągu interpolowanego występuje po parametrze procedury obsługi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly">
        <source>Parameter {0} has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">Parametr {0} ma modyfikator params w wyrażeniu lambda, ale nie ma w docelowym typie delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly_Title">
        <source>Parameter has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">Parametr ma modyfikator params w wyrażeniu lambda, ale nie ma w docelowym typie delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialPropertySignatureDifference">
        <source>Partial property declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">Deklaracje właściwości częściowych „{0}” i „{1}” mają różnice w sygnaturach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialPropertySignatureDifference_Title">
        <source>Partial property declarations have signature differences.</source>
        <target state="translated">Deklaracje właściwości częściowych różnią się sygnaturami.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase">
        <source>Primary constructor parameter '{0}' is shadowed by a member from base.</source>
        <target state="translated">Podstawowy parametr konstruktora „{0}” jest w tle przez składową z bazy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase_Title">
        <source>Primary constructor parameter is shadowed by a member from base</source>
        <target state="translated">Podstawowy parametr konstruktora jest zasłaniany przez składową z bazy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode">
        <source>'{0}' defines 'Equals' but not 'GetHashCode'</source>
        <target state="translated">Element „{0}” definiuje element „Equals”, lecz nie element „GetHashCode”</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode_Title">
        <source>Record defines 'Equals' but not 'GetHashCode'.</source>
        <target state="translated">Rekord definiuje element „Equals”, lecz nie element „GetHashCode”.</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
        <source>Mixed declarations and expressions in deconstruction</source>
        <target state="translated">Mieszane deklaracje i wyrażenia w dekonstrukcji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference">
        <source>Partial method declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">Deklaracje metody częściowej „{0}” i „{1}” mają różnice w sygnaturach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference_Title">
        <source>Partial method declarations have signature differences.</source>
        <target state="translated">Deklaracje metod częściowych mają różnice w sygnaturach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Typy i aliasy nie powinny mieć nazwy „record”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed_Title">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Typy i aliasy nie powinny mieć nazwy „record”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">To odwołanie przypisuje element „{1}” do elementu „{0}”, ale „{1}” ma węższy zakres ucieczki niż „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower_Title">
        <source>This ref-assigns a value that has a narrower escape scope than the target.</source>
        <target state="translated">To odwołanie przypisuje wartość, która ma węższy zakres ucieczki niż element docelowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">To odwołanie przypisuje element „{1}” do „{0}”, ale „{1}” może tylko pominąć bieżącą metodę za pośrednictwem instrukcji return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly_Title">
        <source>This ref-assigns a value that can only escape the current method through a return statement.</source>
        <target state="translated">To odwołanie przypisuje wartość, która może tylko pomijać bieżącą metodę za pośrednictwem instrukcji return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">Ta wartość ref przypisuje „{1}” do „{0}”, ale „{1}” ma szerszy zakres ucieczki wartości niż „{0}”, umożliwiając przypisanie za pośrednictwem „{0}” wartości z węższymi zakresami ucieczki niż „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider_Title">
        <source>This ref-assigns a value that has a wider value escape scope than the target allowing assignment through the target of values with narrower escapes scopes.</source>
        <target state="translated">Ta wartość ref przypisuje wartość, która ma szerszy zakres ucieczki wartości niż wartość docelowa, umożliwiając przypisanie za pośrednictwem wartości docelowej wartości z węższymi zakresami ucieczki.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable">
        <source>Argument {0} should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">Argument {0} powinien być zmienną, ponieważ jest przekazywany do parametru „ref readonly”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable_Title">
        <source>Argument should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">Argument powinien być zmienną, ponieważ jest przekazywany do parametru „ref readonly”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue">
        <source>A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Dla parametru „ref readonly” „{0}” określono wartość domyślną, ale parametr „ref readonly” powinien być używany tylko dla odwołań. Rozważ zadeklarowanie parametru jako „in”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue_Title">
        <source>A default value is specified for 'ref readonly' parameter, but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Dla parametru „ref readonly” określono wartość domyślną, ale parametr „ref readonly” powinien być używany tylko dla odwołań. Rozważ zadeklarowanie parametru jako „in”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal">
        <source>This returns local '{0}' by reference but it is not a ref local</source>
        <target state="translated">Spowoduje to zwrócenie lokalnego elementu „{0}” przez odwołanie, ale nie jest to odwołanie lokalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2">
        <source>This returns a member of local '{0}' by reference but it is not a ref local</source>
        <target state="translated">Zwraca to składową lokalnego elementu „{0}” przez odwołanie, ale nie jest odwołaniem lokalnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2_Title">
        <source>This returns a member of local by reference but it is not a ref local</source>
        <target state="translated">Zwraca składową elementu lokalnego przez odwołanie, ale nie jest odwołaniem lokalnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal_Title">
        <source>This returns local by reference but it is not a ref local</source>
        <target state="translated">Spowoduje to zwrócenie wartości lokalnej przez odwołanie, ale nie jest odwołaniem lokalnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal">
        <source>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić elementu „{0}” przez referencję, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2">
        <source>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Składowa elementu „{0}” jest zwracana przez odwołanie, ale została zainicjowana do wartości, która nie może być zwracana przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2_Title">
        <source>A member is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Składowa jest zwracana przez odwołanie, ale została zainicjowany do wartości, która nie może być zwracana przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal_Title">
        <source>Local is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić elementu przez referencję, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter">
        <source>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Zwraca to parametr przez odwołanie „{0}” za pomocą parametru ref, ale można go bezpiecznie zwrócić tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2">
        <source>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru „{0}” za pomocą parametru ref, ale można ją bezpiecznie zwrócić tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2_Title">
        <source>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru za pomocą parametru ref; ale można je bezpiecznie zwrócić tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter_Title">
        <source>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Zwraca parametr przez odwołanie za pomocą parametru ref; ale można je bezpiecznie zwrócić tylko w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter">
        <source>This returns a parameter by reference '{0}' but it is not a ref parameter</source>
        <target state="translated">Zwraca parametr przez odwołanie „{0}”, ale nie jest to parametr ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2">
        <source>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru „{0}”, który nie jest parametrem ref ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2_Title">
        <source>This returns by reference a member of parameter that is not a ref or out parameter</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru, który nie jest parametrem ref ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter_Title">
        <source>This returns a parameter by reference but it is not a ref parameter</source>
        <target state="translated">Zwraca parametr przez odwołanie, ale nie jest parametrem ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter">
        <source>This returns a parameter by reference '{0}' but it is scoped to the current method</source>
        <target state="translated">Spowoduje to zwrócenie parametru przez odwołanie „{0}”, ale jest on ograniczony do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2">
        <source>This returns by reference a member of parameter '{0}' that is scoped to the current method</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru „{0}” w zakresie do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2_Title">
        <source>This returns by reference a member of parameter that is scoped to the current method</source>
        <target state="translated">Zwraca to przez odwołanie składową parametru o zakresie do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter_Title">
        <source>This returns a parameter by reference but it is scoped to the current method</source>
        <target state="translated">Spowoduje to zwrócenie parametru przez referencję, ale jego zakres jest ograniczony do bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Składowa struktury zwraca element „this” lub inne składowe wystąpienia według odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis_Title">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Składowa struktury zwraca element „this” lub inne składowe wystąpienia według odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull">
        <source>Return value must be non-null because parameter '{0}' is non-null.</source>
        <target state="translated">Wartość zwracana musi być inna niż null, ponieważ parametr „{0}” ma wartość inną niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull_Title">
        <source>Return value must be non-null because parameter is non-null.</source>
        <target state="translated">Wartość zwracana musi być inna niż null, ponieważ parametr ma wartość inną niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Modyfikator „scoped” parametru „{0}” nie jest zgodny z przesłoniętą lub zaimplementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
        <source>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</source>
        <target state="translated">Modyfikator „scoped” parametru nie jest zgodny z przesłoniętą lub zaimplementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Modyfikator „scoped” 'parametru „{0}” nie jest zgodny z 'elementem docelowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget_Title">
        <source>The 'scoped' modifier of parameter doesn't match target.</source>
        <target state="translated">Modyfikator „scoped” parametru nie jest zgodny z elementem docelowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych wartości typu wejściowego (nie jest wyczerpujące) obejmujących nienazwaną wartość wyliczenia. Na przykład nie jest uwzględniony wzorzec „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych wartości typu wejściowego (nie jest wyczerpujące) obejmujących nienazwaną wartość wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SyncAndAsyncEntryPoints">
        <source>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</source>
        <target state="translated">Metoda „{0}” nie będzie używana jako punkt wejścia, ponieważ znaleziono synchroniczny punkt wejścia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotFound">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">Typ „{0}” nie został zdefiniowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentList">
        <source>Unexpected argument list.</source>
        <target state="translated">Nieoczekiwana lista argumentów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedOrMissingConstructorInitializerInRecord">
        <source>A constructor declared in a type with parameter list must have 'this' constructor initializer.</source>
        <target state="translated">Konstruktor zadeklarowany w typie z listą parametrów musi mieć „ten” inicjalizator konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVarianceStaticMember">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</source>
        <target state="translated">Nieprawidłowa wariancja: parametr typu „{1}” musi być {3} prawidłowy w elemencie „{0}”, chyba że jest używana wersja języka „{4}” lub nowsza. „{1}” to {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">„{0}”: nie można jednocześnie określić klasy ograniczenia i ograniczenia „unmanaged”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
        <source>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</source>
        <target state="translated">Metody z atrybutem „UnmanagedCallersOnly” nie mogą mieć parametrów typu ogólnego i nie mogą być deklarowane w typie ogólnym.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyRequiresStatic">
        <source>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</source>
        <target state="translated">Element „UnmanagedCallersOnly” można stosować tylko do zwykłych statycznych metod nieabstrakcyjnych lub statycznych funkcji lokalnych.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być nienullowalnym typem wartości (podobnie jak wszystkie pola na wszystkich poziomach zagnieżdżenia), aby można było używać go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCallingConvention">
        <source>The calling convention of '{0}' is not supported by the language.</source>
        <target state="translated">Konwencja wywoływania elementu „{0}” nie jest obsługiwana przez język.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForRelationalPattern">
        <source>Relational patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Wzorców relacyjnych nie można używać na potrzeby wartości typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">Nie można użyć zmiennej użycia bezpośrednio w sekcji instrukcji switch (rozważ użycie nawiasów klamrowych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">Składnia „var” dla wzorca nie może odwoływać się do typu, ale element „{0}” należy tutaj do zakresu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">Wyliczenia, klasy i struktury nie mogą być deklarowane w interfejsie mającym parametr typu „in” lub „out”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongFuncPtrCallingConvention">
        <source>Calling convention of '{0}' is not compatible with '{1}'.</source>
        <target state="translated">Konwencja wywołania elementu „{0}” jest niezgodna z elementem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">Dopasowanie typu krotki „{0}” wymaga „{1}” wzorców podrzędnych, ale istnieje następująca liczba wzorców podrzędnych: „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Nazwa pliku „{0}” jest pusta, zawiera nieprawidłowe znaki, zawiera specyfikację dysku bez bezwzględnej ścieżki lub jest za długa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AddressOfMethodGroup">
        <source>&amp;method group</source>
        <target state="translated">grupa &amp;metod</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0 or higher) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.
-skipanalyzers[+|-]           Skip execution of diagnostic analyzers.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
-generatedfilesout:&lt;dir&gt;      Place files generated during compilation in the
                              specified directory.
-reportivts[+|-]                    Output information on all IVTs granted to this
                              assembly by all dependencies, and annotate foreign assembly
                              accessibility errors with what assembly they came from.
</source>
        <target state="translated">
                             Opcje kompilatora języka Visual C#

                       - PLIKI WYJŚCIOWE -
-out:&lt;file&gt;                   Określanie nazwy pliku wyjściowego (domyślnie: nazwa podstawowa
                              pliku z klasą główną lub pierwszym plikiem)
-target:exe                   Kompiluj plik wykonywalny konsoli (domyślnie) (skrócona
                              postać: -t:exe)
-target:winexe                   Kompiluj plik wykonywalny systemu Windows (skrócona postać:
                              -t:winexe)
-target:library               Utwórz bibliotekę (skrócona postać: -t:library)
-target:module                Tworzenie modułu, który można będzie dodać do innego
                              zestawu (skrócona postać: -t:module)
-target:appcontainerexe       Tworzenie pliku wykonywalnego Appcontainer (skrócona postać:
                              -t:appcontainerexe)
-target:winmdobj              Tworzenie pośredniego pliku środowiska uruchomieniowego systemu Windows, który
                              jest używany przez winMDExp (skrócona postać: -t:winmdobj)
-doc:&lt;file&gt;                       Plik dokumentacji XML do wygenerowania
-refout:&lt;file&gt;                    Odwołanie do danych wyjściowych zestawu do wygenerowania
-platform:&lt;string&gt;                Ograniczanie platformy, na których można uruchomić ten kod: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred lub
                              anycpu. Domyślną jest anycpu.

                       - PLIKI WEJŚCIOWE -
-recurse:&lt;wildcard&gt;               Uwzględnianie wszystkie plików w bieżącym katalogu oraz
                              podkatalogach zgodnie ze specyfikacjami
                              symbolu wieloznacznego
-reference:&lt;alias&gt;=&lt;file&gt;     Odwołanie do metadanych z określonego pliku
                              zestawu, używając danego aliasu (skrócona postać: -r)
-reference:&lt;file list&gt;            Odwołanie do metadanych z określonych plików
                              zestawu (skrócona postać: -r)
-addmodule:&lt;file list&gt;        Łączenie określonych modułów w tym zestawie
-link:&lt;file_list&gt;                 Osadzone metadane z określonych plików zestawu
                              międzyoperacyjności (skrócona postać: -l)
-analyzer:&lt;file_list&gt;             Uruchamianie analizatorów z tego zestawu
                              (skrócona postać: -a)
-additionalfile:&lt;file list&gt;   Dodatkowe pliki, które nie mają bezpośredniego wpływu na generowanie
                              kodu, ale mogą być używane przez analizatory do generowania
                              błędów i ostrzeżeń.
-embed                        Osadzanie wszystkich plików źródłowych w pliku PDB.
-embed:&lt;file list&gt;            Osadzanie określonych plików w pliku PDB.

                       - ZASOBY -
-win32res:&lt;file&gt;              Określanie plik zasobów Win32 (.res)
-win32icon:&lt;file&gt;             Używanie tej ikony dla danych wyjściowych
-win32manifest:&lt;file&gt;             Określanie plik manifestu Win32 (xml)
-nowin32manifest              Nie dołączaj domyślnego manifestu Win32
-resource:&lt;resinfo&gt;           Osadzanie określonego zasobu (skrócona postać: -res)
-linkresource:&lt;resinfo&gt;       Łączenie określonego zasobu z tym zestawem
                              (skrócona postać: -linkres) Gdzie format resinfo
                              jest &lt;file&gt;[,&lt;name&gt;[,public|private]]

                       - GENEROWANIE KODU -
-debug[+|-]                       Emitowanie informacji o debugowaniu
-debug:{full|pdbonly|portable|embedded}
                              Określanie typu debugowania (wartość „full” jest domyślna,
                              „portable” jest formatem międzyplatformowym,
                              „embedded” jest formatem międzyplatformowym osadzonym w
                              docelowym pliku .dll lub .exe.)
-optimize[+|-]                Włączanie optymalizacji (skrócona postać: -o)
-deterministic                    Generowanie zestawu deterministycznego
                              (w tym identyfikatora GUID i sygnatury czasowej wersji modułu)
-refonly                          Tworzenie zestawu odwołania zamiast wyjścia głównego
-instrument:TestCoverage          Generowanie zestawu instrumentowanego do zbierania
                              informacji o pokryciach
-sourcelink:&lt;file&gt;                Informacje o linku źródłowym do osadzenia w pliku PDB.

                       - BŁĘDY I OSTRZEŻENIA -
-warnaserror[+|-]                 Raportowanie wszystkich ostrzeżeń jako błędy.
-warnaserror[+|-]:&lt;warn list&gt; Raportowanie określonych ostrzeżeń jako błędy
                              (użyj wartości „nullable” dla wszystkich ostrzeżeń dotyczących dopuszczania wartości null)
-warn:&lt;n&gt;                     Ustawianie poziomu ostrzeżeń (0 lub wyższy) (skrócona postać: -w)
-nowarn:&lt;warn list&gt;           Wyłączanie określonych komunikatów ostrzegawczych
                              (użyj wartości „nullable” dla wszystkich ostrzeżeń dotyczących dopuszczania wartości null)
-ruleset:&lt;file&gt;                   Określanie pliku zestawu reguł, który wyłącza określoną
                              diagnostykę.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Określanie pliku do rejestrowania całej diagnostyki kompilatora
                              i analizatora.
                              sarif_version:{1|2|2.1} Wartość domyślna to 1. 2 i 2.1
                              obie oznaczające wersję SARIF 2.1.0.
-reportanalyzer                   Raportowanie dodatkowych informacje analizatora, takich jak
                              czas wykonania.
-skipanalyzers[+|-]               Pomijanie wykonywanie analizatorów diagnostycznych.

                       - JĘZYK -
-checked[+|-]                 Generowanie testów przepełnienia
-unsafe[+|-]                  Zezwalanie na kod „unsafe”
-define:&lt;symbol list&gt;             Definiowanie symboli kompilacji warunkowej (skrócona
                              postać: -d)
-langversion:?                Wyświetlanie dozwolone wartości dla wersji językowej
-langversion:&lt;string&gt;             Określanie wersji języka, na przykład
                              „latest” (najnowsza wersja, w tym wersje pomocnicze),
                              „default” (tak samo jak „latest”),
                              „latestmajor” (najnowsza wersja, z wyjątkiem wersji pomocniczych),
                              „preview” (najnowsza wersja, w tym funkcje w nieobsługiwanym wersji zapoznawczej),
                              lub dokładnych wersji, takich jak „6” lub „7.1”
-nullable[+|-]                Określanie włączenia|wyłączenia opcji kontekstu dopuszczania wartości null.
-nullable:{enable|disable|warnings|annotations}
                              Określanie opcji kontekstu dopuszczania wartości null enable|disable|warnings|annotations.

                       - ZABEZPIECZENIA -
-delaysign[+|-]                   Podpisywanie z opóźnieniem zestawu tylko przy użyciu publicznego
                              fragmentu silnego klucza nazwy
-publicsign[+|-]                  Podpisywanie publiczne zestawu tylko przy użyciu publicznego
                              fragmentu silnego klucza nazwy
-keyfile:&lt;file&gt;                   Określanie pliku silnego klucza nazwy.
-keycontainer:&lt;string&gt;            Określanie kontenera silnych kluczy nazw
-highentropyva[+|-]               Włączanie funkcji ASLR o wysokiej entropii.

                       - RÓŻNE -
@&lt;file&gt;                       Odczytywanie pliku odpowiedzi w celu uzyskania dodatkowych opcji
-help                         Wyświetlanie tego komunikatu o użyciu (skrócona postać: -?)
-nologo                       Wstrzymywanie komunikatu kompilatora o prawach autorskich
-noconfig                         Nie dołączaj automatycznie pliku CSC.RSP
-parallel[+|-]                    Współbieżna kompilacja.
-version                          Wyświetlanie numer wersji kompilatora i wyjście.

                       - ZAAWANSOWANE -
-baseaddress:&lt;address&gt;        Adres podstawowy dla bibiloteki, która ma być utworzona
-checksumalgorithm:&lt;alg&gt;          Określanie algorytmu obliczania pliku źródłowego
                              pliku źródłowego przechowywanego w pliku PDB. Obsługiwane wartości to:
                              SHA1 lub SHA256 (wartość domyślna).
-codepage:&lt;n&gt;                 Określanie strony kodowej do używania podczas otwierania plików
                              źródłowych
-utf8output                   Komunikaty kompilatora danych wyjściowych w kodowaniu UTF-8
-main:&lt;type&gt;                   Określanie typu zawierającego punktu wejścia
                              (ignoruj wszystkie inne możliwe punkty wejścia) (skrócona
                              postać: -m)
-fullpaths                    Kompilator generuje w pełni kwalifikowane ścieżki
-filealign:&lt;n&gt;               Określanie wyrównania używanego dla sekcji
                              pliku wyjściowego
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Określanie mapowania dla danych wyjściowych nazw ścieżek źródłowych przez
                              kompilatora.
-pdb:&lt;file&gt;                   Określanie nazwy pliku z informacjami o debugowaniu (domyślnie:
                              nazwa pliku wyjściowego z rozszerzeniem .pdb)
-errorendlocation             wiersz i kolumna danych wyjściowych lokalizacji końcowej
                              każdego błędu
-preferreduilang                  Określanie preferowanej nazwy języka danych wyjściowych.
-nosdkpath                        Wyłączanie wyszukiwania domyślnej ścieżki zestawu SDK dla zestawów bibliotek standardowych.
-nostdlib[+|-]                Nie odwołuj do biblioteki standardowej (mscorlib.dll)
-subsystemversion:&lt;version&gt;       Określanie wersji podsystemu zestawu
-lib:&lt;file list&gt;              Określanie dodatkowych katalogów do wyszukania
                              odwołań
-errorreport:&lt;string&gt;             Określanie sposobu obsługi wewnętrznych błędów kompilatora:
                              monit, wysyłanie, kolejka lub brak. Wartością domyślną jest
                              kolejka.
-appconfig:&lt;file&gt;             Określanie pliku konfiguracji aplikacji
                              zawierającego ustawienia powiązania zestawu
-moduleassemblyname:&lt;string&gt;  Nazwa zestawu, którego częścią będzie
                              ten moduł
-modulename:&lt;string&gt;          Określanie nazwy modułu źródłowego
-generatedfilesout:&lt;dir&gt;          Umieszczanie plików wygenerowane podczas kompilacji w
                              określonym katalogu.
-reportivts[+|-]                  Informacje dotyczące danych wyjściowych o wszystkich plikach IVT przyznanych temu
                              zestawowi przez wszystkie zależności i adnotowanie błędów
                              dotyczących dostępności zestawu, z którego one pochodzą.
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">domyślna implementacja interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">możliwy do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">alternatywne interpolowane ciągi dosłowne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAndPattern">
        <source>and pattern</source>
        <target state="translated">i wzorzec</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">asynchroniczna instrukcja using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">przypisanie łączące</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureConstantInterpolatedStrings">
        <source>constant interpolated strings</source>
        <target state="translated">interpolowane ciągi stałych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultTypeParameterConstraint">
        <source>default type parameter constraints</source>
        <target state="translated">domyślne ograniczenia parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">ogólne ograniczenia typów delegowania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">ogólne ograniczenia typów wyliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">deklaracje zmiennych wyrażeń w inicjatorach elementów członkowskich i zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPartialMethods">
        <source>extended partial methods</source>
        <target state="translated">rozszerzone metody częściowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">rozszerzalna instrukcja fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetAsyncEnumerator">
        <source>extension GetAsyncEnumerator</source>
        <target state="translated">Element GetAsyncEnumerator rozszerzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetEnumerator">
        <source>extension GetEnumerator</source>
        <target state="translated">Element GetEnumerator rozszerzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="translated">ustaw funkcje lokalne jako zewnętrzne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFunctionPointers">
        <source>function pointers</source>
        <target state="translated">wskaźniki funkcji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">operator indeksowania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">indeksowanie możliwych do przenoszenia buforów fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInitOnlySetters">
        <source>init-only setters</source>
        <target state="translated">metody ustawiające tylko do inicjowania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="translated">atrybuty funkcji lokalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">parametry odrzucania wyrażenia lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureMemberNotNull">
        <source>MemberNotNull attribute</source>
        <target state="translated">Atrybut MemberNotNull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleInitializers">
        <source>module initializers</source>
        <target state="translated">inicjatory modułów</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">zasłanianie nazw w funkcjach zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNativeInt">
        <source>native-sized integers</source>
        <target state="translated">liczby całkowite o wielkości natywnej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">Element stackalloc w wyrażeniach zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">ogólne ograniczenie typu notnull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotPattern">
        <source>not pattern</source>
        <target state="translated">nie wzorzec</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPointerConstantPattern">
        <source>null pointer constant pattern</source>
        <target state="translated">stały wzorzec pustego wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">typy referencyjne dopuszczające wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">przestarzałe w metodzie dostępu właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOrPattern">
        <source>or pattern</source>
        <target state="translated">lub wzorzec</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParenthesizedPattern">
        <source>parenthesized pattern</source>
        <target state="translated">wzorzec w nawiasie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">akcja warning: enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">operator zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">składowe tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecords">
        <source>records</source>
        <target state="translated">rekordy</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">wzorce rekursywne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">wyrażenie warunkowe ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">zmienne pętli for odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">zmienna iteracji foreach odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">ponowne przypisanie odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelationalPattern">
        <source>relational pattern</source>
        <target state="translated">wzorzec relacyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">inicjator stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAnonymousFunction">
        <source>static anonymous function</source>
        <target state="translated">statyczna funkcja anonimowa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">statyczne funkcje lokalne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;wyrażenie przełącznika&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTargetTypedConditional">
        <source>target-typed conditional expression</source>
        <target state="translated">wyrażenie warunkowe o typie docelowym</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">równość krotki</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypePattern">
        <source>type pattern</source>
        <target state="translated">wzorzec typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">parametry typu bez ograniczeń w operatorze łączenia wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">niezarządzane typy konstruowane</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">ogólne niezarządzane ograniczenia typów</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">deklaracje using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
        <source>variance safety for static interface members</source>
        <target state="translated">bezpieczeństwo wariancji dla elementów członkowskich interfejsu statycznego</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">ograniczenia dla przesłonięć i jawnych metod implementacji interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Parameter">
        <source>parameter</source>
        <target state="translated">parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Return">
        <source>return</source>
        <target state="translated">zwracanego</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;wyrażenie throw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(Lokalizacja symbolu związanego z poprzednim błędem)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(Lokalizacja symbolu związanego z poprzednim ostrzeżeniem)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TopLevelStatements">
        <source>top-level statements</source>
        <target state="translated">instrukcje najwyższego poziomu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> Nie można dołączyć nieprawidłowo sformułowanego pliku XML „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> Nie można wstawić części lub całości dołączonego kodu XML </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Tag Include jest nieprawidłowy </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> Dla następującego tagu Include nie znaleziono żadnych zgodnych elementów </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">Brak atrybutu pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">Brak atrybutu ścieżki</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;globalna przestrzeń nazw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">ogólne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">metody anonimowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">moduł jako specyfikator elementu docelowego atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">kwalifikator aliasu przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">bufory o ustalonym rozmiarze</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">klasy statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">struktury tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">typy częściowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">funkcja async</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">włącz typ wartości logicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">grupa metod</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">metoda anonimowa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">wyrażenie lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">kolekcja</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">modyfikatory dostępu we właściwościach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">iteratory</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">operator domyślny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">domyślny literał</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">prywatny chroniony</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">typy dopuszczające wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">dopasowanie wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">metoda dostępu właściwości treści wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">konstruktor i destruktor treści wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">wyrażenie throw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">niejawnie typizowana tablica</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">niejawnie typizowana zmienna lokalna</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">typy anonimowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">automatycznie zaimplementowane właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">automatycznie implementowane właściwości tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">inicjator obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">inicjator kolekcji</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">wyrażenie zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">metoda rozszerzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">metoda częściowa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">typ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">przestrzeń nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">pole</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">element</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">zmienna</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">etykieta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">zdarzenie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">alias użycia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">konstruktor</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">zmienna iteracji foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">zmienna ustalona</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">zmienna użycia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">kontrawariantny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">kontrawariantnie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">kowariantny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">kowariantnie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">niezmiennie</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">dynamiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">argument nazwany</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">parametr opcjonalny</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">filtr wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">typ wariancji</target>
        <note />
      </trans-unit>
      <trans-unit id="NotSameNumberParameterTypesAndRefKinds">
        <source>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</source>
        <target state="translated">Podano typy parametrów: {0} i rodzaje odwołań do parametrów: {1}. Te tablice muszą mieć taką samą długość.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutIsNotValidForReturn">
        <source>'RefKind.Out' is not a valid ref kind for a return type.</source>
        <target state="translated">Element „RefKind.Out” nie jest prawidłowym rodzajem odwołania dla zwracanego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">Element SyntaxTree nie jest częścią kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">Element SyntaxTree nie jest częścią kompilacji, więc nie można go usunąć</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">Nazwa „_” odwołuje się do stałej, a nie do wzorca odrzucania. Użyj elementu „var _”, aby odrzucić wartość, lub użyj elementu „@_”, aby odwołać się do stałej za pomocą tej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">Nie używaj elementu „_” dla stałej case.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked">
        <source>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Wartość stałej „{0}” może przepełnić element „{1}” w czasie wykonywania (użyj składni „unchecked”, aby przesłonić)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked_Title">
        <source>Constant value may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Wartość stałej może spowodować przepełnienie w czasie wykonywania (użyj składni „unchecked”, aby przesłonić)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Konwertowanie literału null lub możliwej wartości null na nienullowalny typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Konwertowanie literału null lub możliwej wartości null na nienullowalny typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Nie można użyć możliwej wartości null dla typu oznaczonego jako [NotNull] lub [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Nie można użyć możliwej wartości null dla typu oznaczonego jako [NotNull] lub [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">W metodzie „{0}” brakuje adnotacji „[DoesNotReturn]”, aby można było dopasować zaimplementowaną lub przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">W metodzie brakuje adnotacji „[DoesNotReturn]”, aby można było dopasować zaimplementowaną lub przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">Element „{0}” występuje już na liście interfejsów dla typu „{1}” z inną obsługą wartości null typów referencyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">Interfejs występuje już na liście interfejsów z inną obsługą wartości null typów referencyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Generator „{0}” nie mógł wygenerować źródła. W rezultacie nie będzie on współtworzyć danych wyjściowych i mogą wystąpić błędy kompilacji. Wyjątek był typu „{1}” z komunikatem „{2}”.
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">Generator nie mógł wygenerować źródła.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Generator „{0}” nie mógł przeprowadzić inicjalizacji. W rezultacie nie będzie on współtworzyć danych wyjściowych i mogą wystąpić błędy kompilacji. Wyjątek był typu „{1}” z komunikatem „{2}”.
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">Generator nie mógł przeprowadzić inicjalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Dane wyrażenie jest zawsze zgodne z podaną stałą.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Dane wyrażenie jest zawsze zgodne z podaną stałą.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie zawsze jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern_Title">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie zawsze jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie nigdy nie jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Dane wyrażenie nigdy nie jest zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">Wywołanie składowej innej niż tylko do odczytu „{0}” ze składowej zadeklarowanej jako „readonly” może spowodować niejawne utworzenie kopii elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">Wywołanie składowej innej niż tylko do odczytu ze składowej zadeklarowanej jako „readonly” może spowodować niejawne utworzenie kopii.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways">
        <source>An expression of type '{0}' always matches the provided pattern.</source>
        <target state="translated">Wyrażenie typu „{0}” jest zawsze zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways_Title">
        <source>The input always matches the provided pattern.</source>
        <target state="translated">Dane wejściowe zawsze są zgodne z podanym wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">Nazwa „_” odwołuje się do typu „{0}”, a nie do wzorca odrzucania. Użyj elementu „@_” aby odwołać się do typu, lub użyj elementu „var _”, aby odrzucić wartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">Nie używaj elementu „_” w celu odwoływania się do typu w wyrażeniu „is” z typem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull">
        <source>Member '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Składowa „{0}” musi mieć wartość inną niż null podczas kończenia działania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember">
        <source>Member '{0}' cannot be used in this attribute.</source>
        <target state="translated">Nie można użyć składowej „{0}” w tym atrybucie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember_Title">
        <source>Member cannot be used in this attribute.</source>
        <target state="translated">Nie można użyć składowej w tym atrybucie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen">
        <source>Member '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Składowa „{0}” musi mieć wartość inną niż null podczas kończenia działania z wartością „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen_Title">
        <source>Member must have a non-null value when exiting in some condition.</source>
        <target state="translated">Składowa musi mieć wartość inną niż null podczas kończenia działania w pewnym stanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull_Title">
        <source>Member must have a non-null value when exiting.</source>
        <target state="translated">Składowa musi mieć wartość inną niż null podczas kończenia działania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana tylko w kodzie z kontekstem adnotacji „#nullable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana w kodzie tylko w ramach kontekstu adnotacji „#nullable”. Wygenerowany automatycznie kod wymaga jawnej dyrektywy „#nullable” w źródle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana w kodzie tylko w ramach kontekstu adnotacji „#nullable”. Wygenerowany automatycznie kod wymaga jawnej dyrektywy „#nullable” w źródle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Adnotacja dla typów referencyjnych dopuszczających wartość null powinna być używana tylko w kodzie z kontekstem adnotacji „#nullable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Nie można przekonwertować literału o wartości null na nienullowalny typ referencyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Nie można przekonwertować literału o wartości null na nienullowalny typ referencyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">Możliwy argument odwołania o wartości null dla parametru „{0}” w „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">Możliwy argument odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">Możliwe przypisanie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">Możliwe przypisanie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">Inicjator obiektu lub kolekcji niejawnie wyłuskuje składową o możliwej wartości null „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">Inicjator obiektu lub kolekcji niejawnie wyłuskuje składową o możliwej wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Wyłuskanie odwołania, które może mieć wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Wyłuskanie odwołania, które może mieć wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">Możliwe zwrócenie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">Możliwe zwrócenie odwołania o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu typu „{0}” nie można użyć dla parametru „{2}” typu „{1}” w elemencie „{3}” z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu typu „{0}” nie można użyć jako danych wyjściowych typu „{1}” dla parametru „{2}” w elemencie „{3}” z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu nie można użyć jako danych wyjściowych dla parametru z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Argumentu nie można użyć dla parametru z powodu różnic w dopuszczalności wartości null przez typy referencyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w wartości typu „{0}” jest niezgodna z typem docelowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w wartości jest niezgodna z typem docelowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Obsługa wartości null w ograniczeniach dla parametru typu „{0}” metody „{1}” jest niezgodna z ograniczeniami parametru typu „{2}” metody interfejsu „{3}”. Rozważ użycie jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">Obsługa wartości null w ograniczeniach dla parametru typu jest niezgodna z ograniczeniami parametru typu w niejawnie implementowanej metodzie interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">Deklaracje metod częściowych elementu „{0}” mają niespójne opcje dopuszczania wartości null w ograniczeniach parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">Deklaracje metod częściowych mają niespójne opcje dopuszczania wartości null w ograniczeniach dla parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w jawnym specyfikatorze interfejsu jest niezgodna z interfejsem implementowanym przez typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w jawnym specyfikatorze interfejsu jest niezgodna z interfejsem implementowanym przez typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Obsługa wartości null dla typów referencyjnych w interfejsie implementowanym przez typ podstawowy jest niezgodna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Typ nie implementuje składowej interfejsu. Obsługa wartości null dla typów referencyjnych w interfejsie implementowanym przez typ podstawowy jest niezgodna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru „{0}” z elementu „{1}” nie jest zgodne z docelowym delegatem „{2}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru nie jest zgodne z docelowym delegatem (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” „{1}” jest niezgodna z niejawnie implementowaną składową „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru „{0}” jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie parametru jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w zwracanym typie „{0}” nie jest zgodne z docelowym delegatem „{1}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w zwracanym typie nie jest zgodne z docelowym delegatem (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z implementowaną składową „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym „{0}” jest niezgodna z niejawnie implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie zwracanym jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Nullowalność typów referencyjnych w zwracanym typie jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Nullowalność typów referencyjnych w zwracanym typie jest niezgodna z częściową deklaracją metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z implementowaną składową „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie „{0}” jest niezgodna z niejawnie implementowaną składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z niejawnie implementowaną składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Obsługa wartości null dla typów referencyjnych w typie jest niezgodna z przesłoniętą składową.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{3}” jest niezgodna z typem ograniczenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z typem ograniczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">Nie można użyć typu „{2}” jako parametru typu „{1}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{2}” jest niezgodna z ograniczeniem „notnull”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z ograniczeniem „notnull”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">Nie można użyć typu „{2}” jako parametru typu „{1}” w typie ogólnym lub metodzie „{0}”. Obsługa wartości null w argumencie typu „{2}” jest niezgodna z ograniczeniem „class”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">Nie można użyć typu jako parametru typu w typie ogólnym lub metodzie. Obsługa wartości null w argumencie typu jest niezgodna z ograniczeniem „class”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Typ wartości dopuszczający wartość null może być równy null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Typ wartości dopuszczający wartość null może być równy null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">Wartość parametru ze specyfikatorem out „{0}” musi być przypisana zanim sterowanie wyjdzie z bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned_Title">
        <source>An out parameter must be assigned to before control leaves the method</source>
        <target state="translated">Wartość parametru ze specyfikatorem out musi być przypisana, zanim sterowanie wyjdzie z metody</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Parametr „{0}” musi mieć wartość inną niż null podczas kończenia działania z wartością „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting in some condition.</source>
        <target state="translated">Parametr musi mieć wartość inną niż null podczas kończenia działania w pewnym stanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Parametr „{0}” musi mieć wartość inną niż null podczas kończenia działania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting.</source>
        <target state="translated">Parametr musi mieć wartość inną niż null podczas kończenia działania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">„{0}”: typów statycznych nie można użyć jako parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass_Title">
        <source>Static types cannot be used as parameters</source>
        <target state="translated">Typów statycznych nie można używać jako parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion">
        <source>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</source>
        <target state="translated">Nie można użyć operatora „{0}” w tym miejscu z powodu pierwszeństwa. Użyj nawiasów w celu rozróżnienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion_Title">
        <source>Operator cannot be used here due to precedence.</source>
        <target state="translated">Nie można użyć operatora w tym miejscu z powodu pierwszeństwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</source>
        <target state="translated">Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” nie jest wystąpieniem publicznym ani metodą rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance_Title">
        <source>Type does not implement the collection pattern; member is is not a public instance or extension method.</source>
        <target state="translated">Typ nie implementuje wzorca kolekcji; składowa nie jest publicznym wystąpieniem ani metodą rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">„{0}”: typów statycznych nie można użyć jako typów w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass_Title">
        <source>Static types cannot be used as return types</source>
        <target state="translated">Typów statycznych nie można używać jako typów zwracanych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Metoda z oznaczeniem [DoesNotReturn] nie powinna zwracać wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Metoda z oznaczeniem [DoesNotReturn] nie powinna zwracać wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">Drugi operand operatora „is” lub „as” nie może być typem statycznym „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs_Title">
        <source>The second operand of an 'is' or 'as' operator may not be a static type</source>
        <target state="translated">Drugi operand operatora „is” lub „as” nie może być typem statycznym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości typu wejściowego (nie jest wyczerpujące). Na przykład nie jest uwzględniony wzorzec „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null (nie jest wyczerpujące). Na przykład nie jest uwzględniony wzorzec „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null (nie jest kompletne). Na przykład wzorzec „{0}” nie jest uwzględniony. Jednak wzorzec z klauzulą „when” może być zgodny z tą wartością.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Wyrażenie switch nie obsługuje niektórych danych wejściowych o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości jego typu danych wejściowych (nie jest kompletne). Na przykład wzorzec „{0}” nie jest uwzględniony. Jednak wzorzec z klauzulą „when” może być zgodny z tą wartością.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości jego typu danych wejściowych (nie jest kompletne).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Wyrażenie switch nie obsługuje wszystkich możliwych wartości jego typu danych wejściowych (nie jest kompletne).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru „{0}” nie jest zgodny z odpowiadającym mu parametrem „{1}” w lokalizacji docelowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in target.</source>
        <target state="translated">Modyfikator rodzaju odwołania parametru nie jest zgodny z odpowiadającym mu parametrem w lokalizacji docelowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">Zgłoszona wartość może być równa null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">Zgłoszona wartość może być równa null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru „{0}” nie jest zgodne z zaimplementowaną składową „{1}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru nie jest zgodne z zaimplementowaną składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru „{0}” z elementu „{1}” nie jest zgodne z zaimplementowaną składową „{2}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie parametru nie jest zgodne z niejawnie zaimplementowaną składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typu parametru „{0}” nie jest zgodne z przesłoniętą składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typu parametru nie jest zgodne z przesłoniętą składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie zwracanym nie jest zgodne z zaimplementowaną składową „{0}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie zwracanym nie jest zgodne z zaimplementowaną składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie zwracanym „{0}” nie jest zgodne z niejawnie zaimplementowaną składową „{1}” (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typów referencyjnych w typie zwracanym nie jest zgodne z niejawnie zaimplementowaną składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typu zwracanego nie jest zgodne z przesłoniętą składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Dopuszczanie wartości null dla typu zwracanego nie jest zgodne z przesłoniętą składową (prawdopodobnie z powodu atrybutów dopuszczania wartości null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została zignorowana, ponieważ po drugiej stronie operatora == lub != krotki określono inną nazwę lub nie określono żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Nazwa elementu krotki została zignorowana, ponieważ po drugiej stronie operatora == lub != krotki określono inną nazwę lub nie określono żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co parametr typu z metody zewnętrznej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">Parametr typu ma ten sam typ co parametr typu z metody zewnętrznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion">
        <source>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Kontrolka jest zwracana do obiektu wywołującego przed jawnym przypisaniem właściwości „{0}”, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion_Title">
        <source>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Kontrolka jest zwracana do obiektu wywołującego przed jawnym przypisaniem właściwości, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Automatycznie implementowana właściwość „{0}” musi być w pełni przypisana, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie do wersji językowej „{1}”, aby automatycznie ustawić domyślną właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
        <source>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Automatycznie implementowana właściwość musi być w pełni przypisana, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie do wersji językowej, aby automatycznie ustawić domyślną właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion">
        <source>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Kontrolka jest zwracana do obiektu wywołującego przed jawnym przypisaniem pola „{0}”, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion_Title">
        <source>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Kontrolka jest zwracana do obiektu wywołującego przed jawnym przypisaniem pola, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Pole „{0}” musi być w pełni przypisane, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie pola do wersji językowej „{1}”, aby automatycznie ustawić domyślne pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion_Title">
        <source>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</source>
        <target state="translated">Pola struktury muszą być w pełni przypisane w konstruktorze, zanim kontrolka zostanie zwrócona do obiektu wywołującego. Rozważ zaktualizowanie wersji języka w celu automatycznego ustawienia domyślnego pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Konwersja unboxing wartości, która może być wartością null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Konwersja unboxing wartości, która może być wartością null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Atrybut EnumeratorCancellationAttribute zastosowany dla parametru „{0}” nie będzie miał żadnego efektu. Atrybut jest uwzględniany tylko dla parametru typu CancellationToken w asynchronicznej metodzie iteratora zwracającej interfejs IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Atrybut EnumeratorCancellationAttribute nie będzie miał żadnego efektu. Atrybut jest uwzględniany tylko dla parametru typu CancellationToken w asynchronicznej metodzie iteratora zwracającej interfejs IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Iterator asynchroniczny „{0}” ma co najmniej jeden parametr typu „CancellationToken”, ale żaden z nich nie ma atrybutu „EnumeratorCancellation” i dlatego zostanie wykorzystany parametr tokenu anulowania z wygenerowanego elementu „IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Składowa iteratora asynchronicznego ma co najmniej jeden parametr typu „CancellationToken”, ale żaden z nich nie ma atrybutu „EnumeratorCancellation” i dlatego zostanie wykorzystany parametr tokenu anulowania z wygenerowanego elementu „IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring the {0} as nullable.</source>
        <target state="translated">Niedopuszczający wartości null element {0} „{1}” musi zawierać wartość inną niż null podczas kończenia działania konstruktora. Rozważ dodanie modyfikatora „required” lub zadeklarowanie {0} jako dopuszczającego wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.</source>
        <target state="translated">Pole niedopuszczające wartości null musi zawierać wartość inną niż null podczas kończenia działania konstruktora. Rozważ dodanie modyfikatora „required” lub zadeklarowanie go jako dopuszczającego wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter">
        <source>Parameter '{0}' is unread.</source>
        <target state="translated">Parametr '{0}' jest nieodczytany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter_Title">
        <source>Parameter is unread.</source>
        <target state="translated">Parametr jest nieodczytany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter">
        <source>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Parametr „{0}” nie został odczytany. Czy zapomniano użyć go do zainicjowania właściwości o tej nazwie?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter_Title">
        <source>Parameter is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Parametr nie został odczytany. Czy zapomniano użyć go do zainicjowania właściwości o tej nazwie?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Użyto nieprzypisanej zmiennej lokalnej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion">
        <source>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Pole „{0}” jest odczytywane przed jawnym przypisaniem, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion_Title">
        <source>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Pole jest odczytywane przed jawnym przypisaniem, co powoduje wcześniejsze niejawne przypisanie wartości „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola „{0}”. Rozważ zaktualizowanie pola do wersji językowej „{1}”, aby automatycznie ustawić domyślne pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion_Title">
        <source>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola. Rozważ zaktualizowanie pola do wersji językowej, aby automatycznie ustawić domyślne pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField_Title">
        <source>Use of possibly unassigned field</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Użycie nieprzypisanego parametru ze specyfikatorem out „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut_Title">
        <source>Use of unassigned out parameter</source>
        <target state="translated">Użycie nieprzypisanego parametru ze specyfikatorem out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion">
        <source>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Automatycznie zaimplementowana właściwość „{0}” jest odczytywana przed jawnym przypisaniem, co powoduje wcześniejsze niejawne przypisanie elementu „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion_Title">
        <source>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Automatycznie zaimplementowana właściwość jest odczytywana przed jawnym przypisaniem, co powoduje wcześniejsze niejawne przypisanie elementu „default”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”. Rozważ zaktualizowanie do wersji językowej „{1}”, aby automatycznie ustawić domyślną właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion_Title">
        <source>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości. Rozważ zaktualizowanie do wersji językowej, aby automatycznie ustawić domyślną właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty_Title">
        <source>Use of possibly unassigned auto-implemented property</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField">
        <source>Ref field '{0}' should be ref-assigned before use.</source>
        <target state="translated">Pole odwołania „{0}” powinno zostać przypisane do odwołania przed użyciem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField_Title">
        <source>Ref field should be ref-assigned before use.</source>
        <target state="translated">Pole odwołania należy przypisać do odwołania przed użyciem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">Obiekt „this” jest odczytywany przed przypisaniem wszystkich jego pól, co powoduje, że wcześniejsze niejawne przypisania wartości „default” są przypisywane do pól nieprzypisanych jawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion_Title">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">Obiekt „this” jest odczytywany przed przypisaniem wszystkich jego pól, co powoduje, że wcześniejsze niejawne przypisania wartości „default” są przypisywane do pól nieprzypisanych jawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Nie można użyć obiektu „this” przed przypisaniem wszystkich jego pól. Rozważ zaktualizowanie nieprzypisanych pól do wersji językowej „{0}”, aby automatycznie ustawić domyślne pola niezaznaczone.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion_Title">
        <source>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</source>
        <target state="translated">Nie można użyć obiektu „this” przed przypisaniem wszystkich jego pól. Rozważ zaktualizowanie nieprzypisanych pól do wersji językowej, aby automatycznie ustawić domyślne pola niezaznaczone.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation_Title">
        <source>Use of unassigned local variable</source>
        <target state="translated">Użyto nieprzypisanej zmiennej lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'Element „{0}” jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">Typ jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">Znaków „{0}” nie można użyć w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">Użyto nieprawidłowej składni w komentarzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">Znaleziono nieprawidłowy znak wewnątrz odwołania do jednostki.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">Oczekiwano ciągu „&gt;” lub „/&gt;” zamykającego tag „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">Oczekiwano identyfikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Nieprawidłowy znak Unicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">Białe znaki są niedozwolone w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">Znaku „&lt;” nie można użyć w wartości atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">Brak znaku równości między atrybutem i wartością atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">Odwołanie do niezdefiniowanej jednostki „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">Oczekiwano literału ciągu, lecz nie znaleziono otwierającego znaku cudzysłowu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">Brak zamykającego znaku cudzysłowu dla literału ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">Nie można używać znaków cudzysłowu spoza zestawu znaków ASCII wokół literałów ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">Tag końcowy jest nieoczekiwany w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">Tag końcowy „{0}” nie jest zgodny z tagiem początkowym „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">Oczekiwano tagu końcowego dla elementu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">Brak wymaganego białego znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">Nieoczekiwany znak w tej lokalizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">Ciąg literału „]]&gt;” jest niedozwolony w zawartości elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Zduplikowany atrybut „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">Nie można znaleźć pliku metadanych „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">Odwołania do metadanych nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">Nie można otworzyć pliku metadanych „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w nieprzywoływanym zestawie. Musisz dodać odwołanie do zestawu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w module, który nie został dodany. Musisz dodać moduł „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">Nie można zapisać do pliku wyjściowego „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">W programie zdefiniowano więcej niż jeden punkt wejścia. Skompiluj z opcją /main, aby określić typ zawierający punkt wejścia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do argumentów operacji typu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">Dzielenie przez wartość stałą wynoszącą zero</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">Do wyrażenia typu „{0}” nie można zastosować indeksowania przy użyciu konstrukcji [].</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">Wewnątrz konstrukcji [] występuje niewłaściwa liczba indeksów. Oczekiwana liczba: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">Nie można zastosować operatora „{0}” do argumentu operacji typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">W przypadku statycznej właściwości, statycznej metody lub statycznego inicjatora pola użycie słowa kluczowego „this” jest nieprawidłowe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">W bieżącym kontekście słowo kluczowe „this” jest niedostępne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'Element „{0}” ma nieprawidłową sygnaturę i nie może być punktem wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">Metoda ma nieprawidłową sygnaturę i nie może być punktem wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">Nie można niejawnie przekonwertować typu „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">Nie można przekonwertować typu „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">Nie można przekonwertować wartości stałej „{0}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">Operator „{0}” jest niejednoznaczny dla operandów typu „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">Dla argumentu operacji typu „{0}” operator „{1}” jest niejednoznaczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">W parametrze wyjściowym nie może występować atrybut wejściowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">Nie można przekonwertować wartości null na „{0}”, ponieważ jest to nienullowalny typ wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">Nie można przekonwertować typu „{0}” na „{1}” za pomocą konwersji odwołania, konwersji pakującej, konwersji rozpakowującej, konwersji opakowującej ani konwersji na typ zerowy</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">Wystąpił nieoczekiwany błąd podczas zapisywania informacji debugowania — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż metoda „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż metoda „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">Niespójność dostępności: typ pola „{1}” jest mniej dostępny niż pole „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">Niespójność dostępności: typ właściwości „{1}” jest mniej dostępny niż właściwość „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany indeksatora „{1}” jest mniej dostępny niż indeksator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż indeksator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż operator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż operator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">Niespójność dostępności: klasa bazowa „{1}” jest mniej dostępna niż klasa „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">Niespójność dostępności: interfejs podstawowy „{1}” jest mniej dostępny niż interfejs „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': dla właściwości zdarzenia muszą istnieć metody dostępu Add i Remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">„{0}”: typ zdarzenia musi być zgodny z typem delegowanym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">Zdarzenie „{0}” nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">Zdarzenie nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">„{0}”: zdarzenie wystąpienia w interfejsie nie może mieć inicjatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">Zdarzenie „{0}” może występować tylko po lewej stronie symboli += lub -= (z wyjątkiem sytuacji, w której używane jest z wnętrza typu „{1}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">Jawna implementacja interfejsu zdarzenia musi używać składni metody dostępu zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">„{0}”: nie można przesłonić. Element „{1}” nie jest zdarzeniem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">Metoda dostępu add lub remove musi mieć treść</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">„{0}”: nie może istnieć inicjator zdarzenia abstrakcyjnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">Nazwa zestawu „{0}” jest zarezerwowana i nie można jej użyć jako odwołania w sesji interaktywnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">Nazwa typu wyliczeniowego „{0}” jest zarezerwowana i nie można jej użyć</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">Operatora „as” należy używać z typem referencyjnym lub typem nullowalnym („{0}” jest typem nienullowalnym)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">Sufiks „l” z łatwością można pomylić z cyfrą „1” — w celu zachowania jednoznaczności użyj sufiksu „L”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">Sufiks „l” można łatwo pomylić z cyfrą „1”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">Zdarzenie „{0}” może pojawić się tylko po lewej stronie wyrażenia += lub -=.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">Ograniczenia są niedozwolone w deklaracjach innych niż ogólne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">Deklaracja parametru typu musi być identyfikatorem, a nie typem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">Typ „{1}” już rezerwuje składową o nazwie „{0}” z tymi samymi typami parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">Nazwa parametru „{0}” jest duplikatem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">Przestrzeń nazw „{0}” już zawiera definicję dla „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">Typ „{0}” już zawiera definicję dla „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">Nazwa „{0}” nie istnieje w bieżącym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">Nazwa „{0}” nie istnieje w bieżącym kontekście (brak odwołania do zestawu „{1}”?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'Element „{0}” to niejednoznaczne odwołanie między elementem „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">Dyrektywa using dla elementu „{0}” już wystąpiła w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">Dyrektywa using występowała wcześniej w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">Modyfikator „{0}” jest nieprawidłowy dla tego elementu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">Więcej niż jeden modyfikator ochrony</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'Element „{0}” ukrywa odziedziczoną składową „{1}”. Użyj słowa kluczowego new, jeśli ukrycie jest zamierzone.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">Składowa ukrywa dziedziczoną składową; brak słowa kluczowego new</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">Zmienna została zadeklarowana przy użyciu tej samej nazwy co zmienna w typie bazowym. Jednak nie użyto słowa kluczowego new. To ostrzeżenie informuje o konieczności użycia słowa kluczowego new. Zmienna została zadeklarowana tak, jakby użyto słowa kluczowego new w deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">Składowa „{0}” nie ukrywa składowej z możliwością dostępu. Słowo kluczowe new nie jest wymagane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">Składowa nie ukrywa dziedziczonej składowej; słowo kluczowe new nie jest wymagane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">Obliczanie wartości stałej dla elementu „{0}” obejmuje definicję cykliczną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">Typ „{1}” już definiuje składową o nazwie „{0}” z tymi samymi typami parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member cannot be marked as '{0}'</source>
        <target state="translated">Składowa statyczna nie może być oznaczona jako „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">Dla składowej „{0}” ze specyfikatorem override nie można określić specyfikatora new ani virtual</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'Element „{0}” ukrywa odziedziczoną składową „{1}”. Aby przesłonić tę implementację bieżącą składową, dodaj słowo kluczowe override. W przeciwnym razie dodaj słowo kluczowe new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">Składowa ukrywa dziedziczoną składową; brak słowa kluczowego override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">„{0}”: nie znaleziono odpowiedniej metody do przesłonięcia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields, methods or statements</source>
        <target state="translated">Przestrzeń nazw nie może bezpośrednio zawierać składowych takich jak pola, metody lub instrukcje</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'Element „{0}” nie zawiera definicji „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'Element „{0}” to element {1}, ale jest używany jak element {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'Element „{0}” to element „{1}”, który jest nieprawidłowy w podanym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">Dla niestatycznego pola, metody lub właściwości „{0}” wymagane jest odwołanie do obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">Wystąpiło niejednoznaczne wywołanie między następującymi dwiema metodami lub właściwościami: „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'Element „{0}” jest niedostępny z powodu swojego poziomu ochrony.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">Żadne z przeciążeń dla elementu „{0}” nie pasuje do delegata „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">Wymagany jest obiekt, który można przekonwertować na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">Ponieważ element „{0}” zwraca wartość typu void, po słowie kluczowym nie może występować wyrażenie obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">Lokalna zmienna lub funkcja o nazwie „{0}” została już zdefiniowana w tym zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">Lewa strona przypisania musi być zmienną, właściwością lub indeksatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">„{0}”: konstruktor statyczny nie może mieć parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">Wyrażenie przypisane do elementu „{0}” musi być stałą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'Typ elementu „{0}” to „{1}”. Pole stałe typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">Element lokalny lub parametr o nazwie „{0}” nie może zostać zadeklarowany w tym zakresie, ponieważ ta nazwa jest już użyta w otaczającym zakresie lokalnym do zdefiniowania elementu lokalnego lub parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">Dyrektywa „using namespace” może być stosowana tylko do przestrzeni nazw. Element „{0}” to typ, a nie przestrzeń nazw. Zamiast tego rozważ użycie dyrektywy „using static”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">Dyrektywa „using static” może być stosowana tylko do typów. Element „{0}” to przestrzeń nazw, a nie typ. Zamiast tego rozważ użycie dyrektywy „using namespace”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">Za pomocą dyrektywy „using static” nie można deklarować aliasu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">Brak pętli otaczającej, w której ma nastąpić przerwanie lub kontynuowanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">Etykieta „{0}” jest duplikatem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">Typ „{0}” nie ma zdefiniowanego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract type or interface '{0}'</source>
        <target state="translated">Nie można utworzyć wystąpienia typu lub interfejsu abstrakcyjnego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">Pole stałej wymaga podania wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base type dependency involving '{0}' and '{1}'</source>
        <target state="translated">Cykliczna zależność typu bazowego obejmująca element „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">W delegacie „{0}” brak prawidłowego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">Oczekiwano nazwy metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">Oczekiwano wartości stałej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">Wyrażenie switch lub etykieta case musi być wartością logiczną, znakiem, ciągiem, liczbą całkowitą, wyliczeniem lub odpowiadającym typem dopuszczającym wartość null w języku C# 6 i wcześniejszych wersjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">Oczekiwano wartości typu całkowitoliczbowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">Instrukcja switch zawiera wiele etykiet case o wartości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">Instrukcja goto case jest prawidłowa tylko wewnątrz instrukcji switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">W tym kontekście nie można użyć właściwości lub indeksatora „{0}”, ponieważ brakuje dla niej metody dostępu Get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">Przechwycony lub zgłoszony typ musi pochodzić od klasy System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">Instrukcja throw bez żadnych argumentów jest niedozwolona poza klauzulą catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">Sterowanie nie może opuścić treści klauzuli finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">Etykieta „{0}” zasłania inną etykietę o takiej samej nazwie w zawartym zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">Brak etykiety „{0}” w zakresie instrukcji goto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki tego typu lub jego nadtypu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „true”, rozważ usunięcie tego filtru</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „true”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">„{0}”: nie wszystkie ścieżki w kodzie zwracają wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">Wykryto nieosiągalny kod</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">Wykryto nieosiągalny kod</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">Nie można przejść z jednej etykiety instrukcji case („{0}”) do innej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">Brak odwołania do tej etykiety</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">Brak odwołania do tej etykiety</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Użyto nieprzypisanej zmiennej lokalnej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">Zmienna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">Zmienna jest zadeklarowana, ale nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">Pole „{0}” nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">Pole nie jest nigdy używane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanego pola „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">Nie można określić typu wyrażenia warunkowego, ponieważ elementy „{0}” i „{1}” są wzajemnie niejawnie konwertowane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">Nie można określić typu wyrażenia warunkowego, ponieważ nie istnieje niejawna konwersja między elementem „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">Klasa bazowa jest wymagana dla odwołania „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">Użycie słowa kluczowego „base” jest nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">Nie można uzyskać dostępu do składowej „{0}” przy użyciu odwołania do wystąpienia. Należy użyć nazwy typu jako kwalifikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">Wartość parametru ze specyfikatorem out „{0}” musi być przypisana zanim sterowanie wyjdzie z bieżącej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">Nieprawidłowy specyfikator rangi: oczekiwano „,” lub „]”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny ani deklarować treści</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny ani zawierać inicjatora konstruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny i abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">Parametr „{0}” konstruktora atrybutu jest typu „{1}”, który nie jest prawidłowym typem parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">Argument atrybutu musi być wyrażeniem stałej, wyrażeniem TypeOf lub wyrażeniem tworzenia tablicy typu parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">Parametr „{0}” konstruktora atrybutu jest opcjonalny, ale nie została podana wartość domyślna parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">Podane wyrażenie jest zawsze określonego typu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'Podane wyrażenie wyrażenia „is” zawsze ma podany typ</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">Podane wyrażenie nigdy nie jest określonego typu („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'Podane wyrażenie wyrażenia „is” nigdy nie ma podanego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">„{0}” to nie jest typ referencyjny wymagany przez instrukcję lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">Użycie wartości null jest nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">Użycie domyślnego literału nie jest prawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">Konstrukcja __arglist jest prawidłowa tylko wewnątrz metody argumentu zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">Do wskaźnika należy zastosować operator * lub -&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">Wskaźnik musi być indeksowany tylko przez jedną wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Użycie elementu „{0}” jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania, ponieważ to jest pole klasy marshal-by-reference</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">Użycie pola klasy marshal-by-reference jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Nie można przypisać wartości do statycznego pola tylko do odczytu (jest to możliwe tylko w konstruktorze statycznym lub w inicjatorze zmiennej).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Statycznego pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze statycznym)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Nie można przypisać wartości do właściwości lub indeksatora „{0}” – jest on tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">Jako instrukcji można używać tylko wyrażeń przypisania, wywołania, zwiększenia, zmniejszenia, oczekiwania oraz utworzenia nowego obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">Instrukcja foreach wymaga, aby typ zwracany „{0}” dla elementu „{1}” miał odpowiednią metodę publiczną „MoveNext” i właściwość publiczną „Current”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">Dozwolonych jest tylko 65534 elementów lokalnych, włącznie z wygenerowanymi przez kompilator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Nie można wywołać abstrakcyjnej składowej bazowej: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A non ref-returning property or indexer may not be used as an out or ref value</source>
        <target state="translated">Nie można używać właściwości zwracającej inną wartość niż ref lub indeksatora jako wartości out lub ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">Nie można przyjąć adresu, pobrać rozmiaru lub zadeklarować wskaźnika typu zarządzanego („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">Typ zmiennej lokalnej zadeklarowanej w instrukcji fixed musi być typem wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">Inicjator musi zostać udostępniony w deklaracji instrukcji fixed lub using</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">Nie można pobrać adresu podanego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">Wewnątrz inicjatora instrukcji fixed można pobrać jedynie adres nieustalonego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">Nie można użyć instrukcji fixed do pobrania adresu już ustalonego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">Wskaźniki i bufory o ustalonym rozmiarze mogą zostać użyte tylko w kontekście słowa kluczowego „unsafe”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">Typ zwracany operatora True lub False musi być typem logicznym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">Operator „{0}” wymaga zdefiniowanego zgodnego operatora „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">Aby istniała możliwość zastosowania zdefiniowanego przez użytkownika operatora logicznego („{0}”) jako operatora „short circuit”, musi on mieć taki sam typ zwracany i typy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">Aby element „{0}” można było zastosować jako operator „short circuit”, jego typ deklarujący „{1}” musi definiować operatory true i false</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">Zmienna „{0}” jest przypisana, lecz jej wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">Zmienna jest przypisana, ale jej wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">Operacja przepełnia się w czasie kompilowania w trybie sprawdzonym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">Nie można przekonwertować wartości stałej „{0}” na „{1}” (w celu przesłonięcia należy użyć składni instrukcji „unchecked”).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">Metoda z atrybutem vararg nie może być ogólna, znajdować się w typie ogólnym ani mieć parametru params</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">Wyrażenie __arglist może się pojawić tylko wewnątrz wywołania lub nowego wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">Niebezpieczny kod może się pojawić tylko w przypadku kompilowania przy użyciu opcji /unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">Niejednoznaczność pomiędzy „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">W instrukcji foreach wymagany jest typ i identyfikator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a parameter list</source>
        <target state="translated">Parametr params musi być ostatnim parametrem na liście parametrów formalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">Element „{0}” nie ma wstępnie zdefiniowanego rozmiaru, dlatego operatora sizeof można użyć tylko w kontekście słowa kluczowego unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">Typ lub przestrzeń nazw „{0}” nie występuje w przestrzeni nazw „{1}” (czy nie brakuje odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">Inicjator pola nie może odwoływać się do niestatycznego pola, metody lub właściwości „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'Elementu „{0}” nie można zapieczętować, ponieważ nie jest przesłonięciem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">„{0}”: nie można przesłonić odziedziczonej składowej „{1}”, ponieważ jest ona zapieczętowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">Rozpatrywana operacja jest niezdefiniowana we wskaźnikach void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jest to metoda przesłonięcia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">W typach wskaźnika nie można używać operatorów „is” ani „as”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">Destruktory i metoda object.Finalize nie mogą być bezpośrednio wywoływane. Rozważ wywołanie metody IDisposable.Dispose, jeżeli jest dostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Nie można znaleźć nazwy typu lub przestrzeni nazw „{0}” (brak dyrektywy using lub odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">Nie można użyć ujemnego rozmiaru w przypadku słowa kluczowego stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">Nie można utworzyć tablicy z ujemnym rozmiarem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">Nie przesłaniaj metody object.Finalize. Zamiast tego udostępnij destruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base type Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">Nie wywołuj bezpośrednio metody Finalize typu bazowego. Metoda jest wywoływana automatycznie z destruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">Indeksowanie tablicy z ujemnym indeksem (indeksy tablicy zawsze rozpoczynają się od zera)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">Indeksowanie tablicy z ujemnym indeksem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie lewej strony na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań; lewa strona wymaga rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie prawej strony na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">Możliwe niezamierzone porównanie odwołań; prawa strona wymaga rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">Prawa strona przypisania instrukcji fixed nie może być wyrażeniem rzutowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">Słowo kluczowe stackalloc nie może być używane w bloku catch lub finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a parameter list</source>
        <target state="translated">Parametr __arglist musi być ostatnim parametrem formalnej listy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">Brak częściowego modyfikatora w deklaracji typu „{0}”. Istnieje inna częściowa deklaracja tego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</source>
        <target state="translated">Wszystkie częściowe deklaracje elementu "{0}" muszą być klasami, klasami rekordów, strukturami rekordów lub interfejsami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">Modyfikatory dostępu częściowych deklaracji elementu „{0}” powodują konflikt</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” nie mogą określać różnych klas bazowych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu w takiej samej kolejności</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” mają niezgodne ograniczenia parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">Nie można niejawnie przekonwertować typu „{0}” na „{1}”. Istnieje konwersja jawna (czy nie brakuje rzutu?).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', or a method or property return type.</source>
        <target state="translated">Modyfikator „partial” może pojawić się tylko bezpośrednio przed słowem kluczowym „class”, „record” „struct”, „interface” lub zwracanym typem metody lub właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base type dependency.</source>
        <target state="translated">Importowany typ „{0}” jest nieprawidłowy. Zawiera on cykliczną zależność typu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Użycie nieprzypisanego parametru ze specyfikatorem out „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">Rozmiaru tablicy nie można określić w deklaracji zmiennej (spróbuj przeprowadzić inicjowanie przy użyciu wyrażenia „new”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Get jest niedostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Set jest niedostępna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">Modyfikator dostępności dla metody dostępu „{0}” musi być bardziej restrykcyjny niż właściwość lub indeksator „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">Nie można określić modyfikatorów dostępności dla obu metod dostępu właściwości lub indeksatora „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">„{0}”: modyfikatorów dostępności można używać tylko wtedy, gdy właściwość lub indeksator mają metody dostępu Get i Set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie jest publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'Element „{0}” nie implementuje wzorca „{1}”. Elementy „{2}” i „{3}” są wzajemnie niejednoznaczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">Typ nie zawiera implementacji wzorca kolekcji; składowe są niejednoznaczne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” ma nieprawidłową sygnaturę.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">Typ nie zawiera implementacji wzorca kolekcji; składowa ma niewłaściwą sygnaturę</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale klucz publiczny zestawu wyjściowego („{1}”) nie jest zgodny z kluczem określonym przez atrybut InternalsVisibleTo w zestawie udzielającym dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale silna nazwa stanu podpisywania zestawu wyjściowego nie jest zgodna z nazwą określoną przez atrybut w zestawie udzielającym dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">Nie ma zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury „{0}”. Aby określić kolejność, wszystkie pola wystąpienia muszą znajdować się w tej samej deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">Brak zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">Typu „{0}” nie można zadeklarować jako const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">Nie można utworzyć wystąpienia typu zmiennej „{0}”, ponieważ nie ma ograniczenia new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">Użycie ogólnego elementu {1} „{0}” wymaga argumentów typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">Typu „{0}” nie można użyć jako argumentu typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Elementu {1} „{0}” nie można używać z argumentami typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Nieogólnego elementu {1} „{0}” nie można używać z argumentami typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'Element „{2}” musi być typem nieabstrakcyjnym z publicznym konstruktorem bez parametrów, aby można go było użyć jako parametru „{1}” w typie ogólnym lub metodzie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak niejawnej konwersji odwołania z typu „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”. Typy zerowalne nie mogą spełniać żadnych ograniczeń interfejsów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej lub konwersji parametru typu z „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej z „{3}” na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">Nazwa parametru „{0}” powoduje konflikt z nazwą parametru generowaną automatycznie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">Nie można odnaleźć nazwy typu lub przestrzeni nazw „{0}” w globalnej przestrzeni nazw (czy nie brakuje odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last restrictive constraint specified</source>
        <target state="translated">Ograniczenie new() musi być ostatnim określonym ograniczeniem restrykcyjnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">„{0}”: punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">Punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">Nie można przekonwertować wartości null na parametr typu „{0}”, ponieważ może on być nienullowalnym typem wartości. Zamiast tego rozważ użycie elementu „default({0}!)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">Zduplikowane ograniczenie „{0}” dla parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">Ograniczenie typu klasy „{0}” musi występować przed wszystkimi innymi ograniczeniami</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">„{1} {0}” ma nieprawidłowy zwracany typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">Niezgodność odwołań między metodą „{0}” a delegatem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">Klauzula ograniczenia została już określona dla parametru typu „{0}”. Wszystkie ograniczenia dla parametru typu muszą być określone w jednej klauzuli where.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">Nie można wywnioskować argumentów typu dla metody „{0}” na podstawie użytkowania. Spróbuj jawnie określić argumenty typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">„{0}”: parametr, zmienna lokalna lub funkcja lokalna nie może mieć tej samej nazwy co parametr typu metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">Parametru typu „{0}” nie można użyć z operatorem „as”, ponieważ nie ma ograniczenia typu klasy ani ograniczenia „class”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">Pole „{0}” jest przypisane, lecz jego wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">Pole jest przypisane, ale jego wartość nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w indeksatorze, który nie jest jawną deklaracją składowej interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">„{0}”: argument atrybutu nie może używać parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">„{0}”: nie można udostępnić argumentów podczas tworzenia wystąpienia typu zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract type cannot be sealed or static</source>
        <target state="translated">„{0}”: typ abstrakcyjny nie może być zapieczętowany ani statyczny</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">Niejednoznaczne odwołanie w atrybucie cref: „{0}”. Przyjęto element „{1}”, lecz inne elementy przeciążające także są zgodne, w tym „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">Niejednoznaczne odwołanie w atrybucie cref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">„{0}”: odwołanie do pola nietrwałego nie będzie traktowane jako nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">Odwołanie do pola nietrwałego nie będzie traktowane jak nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">Pole nietrwałe nie powinno być zwykle używane jako wartość ref ani out, ponieważ nie będzie traktowane jak pole nietrwałe. Istnieją wyjątki od tej reguły, takie jak wywołanie blokowanego interfejsu API.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">Ponieważ element „{1}” ma atrybut ComImport, element „{0}” musi być zewnętrzny lub abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">„{0}”: klasa o atrybucie ComImport nie może określać klasy bazowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Ograniczenia parametrów typu „{0}” metody „{1}” muszą być zgodne z ograniczeniami parametrów typu „{2}” metody interfejsu „{3}”. Rozważ użycie jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">Nazwy elementów krotki w podpisie metody „{0}” muszą być zgodne z nazwami elementów krotki metody interfejsu „{1}” (w tym w zwracanym typie).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">Nazwa typu „{0}” nie istnieje w typie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Nie można przekonwertować grupy metod „{0}” na typ niedelegowany „{1}”. Czy zamierzasz wywołać metodę?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">Alias zewnętrzny „{0}” nie został określony w opcji /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">Nie można użyć aliasu „{0}” ze znakami „::”, ponieważ alias odwołuje się do typu. Użyj znaku „.”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">Nie znaleziono aliasu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">Typ „{1}” istnieje zarówno w elemencie „{0}”, jak i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z typem „{3}” w elemencie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyta przestrzeń nazw zdefiniowana w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">Przestrzeń nazw powoduje konflikt z zaimportowanym typem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">Typ powoduje konflikt z zaimportowanym typem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowaną przestrzenią nazw „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">Typ powoduje konflikt z zaimportowaną przestrzenią nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">Typ „{1}” w elemencie „{0}” powoduje konflikt z przestrzenią nazw „{3}” w elemencie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">Deklaracja aliasu zewnętrznego musi poprzedzać wszystkie inne elementy zdefiniowane w przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">Definiowanie aliasu o nazwie „global” jest niezalecane, ponieważ łańcuch „global::” zawsze odwołuje się do globalnej przestrzeni nazw, a nie do aliasu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">Nie zaleca się definiowania aliasu o nazwie „global”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a type cannot be both static and sealed</source>
        <target state="translated">„{0}”: typ nie może być jednocześnie statyczny i zapieczętowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">„{0}”: właściwości abstrakcyjne nie mogą mieć prywatnych metod dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">Błąd składni; oczekiwano wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">Nie można zmodyfikować wyniku konwersji rozpakowującej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Instrukcja foreach nie może działać względem elementu „{0}”. Czy element „{0}” miał być wywołany?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">Typ zwracany przez operator ++ lub -- musi odpowiadać typowi parametru lub pochodzić od typu parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">„{0}”: nie można jednocześnie określić klasy ograniczenia i ograniczenia „class” lub „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">Ograniczenie „new()” nie może być używane z ograniczeniem „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być typem referencyjnym, aby można było używać go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Typ „{2}” musi być nienullowalnym typem wartości, aby można było użyć go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">Cykliczna zależność ograniczenia obejmująca elementy „{0}” i „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">Parametr typu „{0}” dziedziczy powodujące konflikt ograniczenia „{1}” i „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Parametr typu „{1}” ma ograniczenie „struct”, dlatego elementu „{1}” nie można użyć jako ograniczenia dla „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">Niejednoznaczne zdefiniowane przez użytkownika konwersje „{0}” i „{1}” podczas konwertowania z „{2}” na „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">Wynikiem wyrażenia jest zawsze element „null” typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">Wynikiem wyrażenia jest zawsze wartość „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">Nie można zwrócić elementu „this” przez referencję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.</source>
        <target state="translated">Nie można użyć konstruktora atrybutu „{0}”, ponieważ ma on parametry „in” lub „ref readonly”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">Ograniczenia dla przesłoniętych i jawnych metod implementacji interfejsu są dziedziczone z metody podstawowej, dlatego nie mogą być określone bezpośrednio, chyba że są to ograniczenia „class” lub „struct”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">Dziedziczone składowe „{0}” i „{1}” mają tę samą sygnaturę w typie „{2}”, dlatego nie mogą być przesłaniane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">Obliczenie wyrażenia ze stałą dziesiętną nie powiodło się</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">Porównanie z wartością null typu „{0}” zawsze daje wartość „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">Porównanie z wartością null typu struktury zawsze zwraca wartość „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora. Czy zamierzane było zadeklarowanie destruktora?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">To ostrzeżenie występuje w przypadku utworzenia klasy przy użyciu metody, której sygnatura to publiczny wirtualny element void Finalize.

Jeśli taka klasa zostanie użyta jako klasa bazowa i klasa pochodna definiuje destruktor, ten destruktor przesłoni metodę Finalize klasy bazowej, a nie element Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'Element „{0}” nie powinien mieć parametru params, ponieważ nie ma go element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">Wartości „goto case” nie można jawnie przekonwertować na typ „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">Nie można niejawnie przekonwertować wartości „goto case” na typ przełącznika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Metoda „{0}” nie może implementować metody dostępu interfejsu „{1}” dla typu „{2}”. Użyj jawnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">Jawna implementacja interfejsu „{0}” jest zgodna z więcej niż jedną składową interfejsu. Wybór interfejsu do użycia zależy od implementacji. Rozważ użycie zamiast niej implementacji niejawnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">Implementacja interfejsu jawnego jest zgodna z więcej niż jedną składową interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'W elemencie „{0}” nie może wystąpić deklaracja treści, ponieważ jest on oznaczony jako abstrakcyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'Element „{0}” musi zadeklarować treść, ponieważ nie jest oznaczony jako abstrakcyjny, zewnętrzny ani częściowy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'Element „{0}” nie może być zewnętrzny i zapieczętowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">Abstrakcyjny element {0} „{1}” nie może być oznaczona jako wirtualny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">Stałej „{0}” nie można oznaczyć jako statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest funkcją</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">„{0}”: nie można przesłonić odziedziczonej składowej „{1}”, ponieważ nie została ona oznaczona przy użyciu słowa kluczowego „virtual”, „abstract” ani „override”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">„{0}”: nie można zmienić modyfikatorów dostępu podczas przesłaniania elementu „{1}” dziedziczoną składową „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">„{0}”: nie można zmienić nazw elementów krotki w przypadku przesłaniania dziedziczonej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">„{0}”: typem zwracanym musi być „{2}”, aby być zgodnym z przesłoniętą składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">„{0}”: pochodzenie od zapieczętowanego typu „{1}” jest niemożliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract type '{1}'</source>
        <target state="translated">Element „{0}” jest abstrakcyjny, ale jest zawarty w nieabstrakcyjnym typie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">„{0}”: konstruktor statyczny nie może zawierać jawnego wywołania konstruktora „this” lub „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">„{0}”: modyfikatory dostępu są niedozwolone dla konstruktorów statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">Konstruktor „{0}” nie może wywołać sam siebie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">Konstruktor „{0}” nie może wywołać się za pośrednictwem innego konstruktora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">Element „{0}” nie ma klasy bazowej i nie może wywołać konstruktora bazowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” jest zadeklarowany w wielu przywoływanych zestawach: „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">„{0}”: struktury nie mogą wywoływać konstruktorów klasy bazowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Składowa „{0}” typu „{1}” powoduje wystąpienie cyklu w układzie struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">Interfejsy nie mogą zawierać pól wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">Interfejsy nie mogą zawierać konstruktorów wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">Typ „{0}” na liście interfejsów nie jest interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'Interfejs „{0}” już wyszczególniono na liście interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'Element „{0}” znajduje się już na liście interfejsów w typie „{2}” z różnymi nazwami elementów krotki jako „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">Dziedziczony interfejs „{1}” jest przyczyną wystąpienia cyklu w hierarchii interfejsów „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'Element „{0}” ukrywa dziedziczoną, abstrakcyjną składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'Element „{0}” nie implementuje odziedziczonej abstrakcyjnej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">Klasa System.Object nie może mieć klasy bazowej ani implementować interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'Element „{0}” w jawnej deklaracji interfejsu nie jest interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">W jawnej deklaracji interfejsu nie znaleziono elementu „{0}” wśród składowych interfejsu, które można implementować</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">„{0}”: typ zawierający nie implementuje interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</source>
        <target state="translated">„{0}”: jawna deklaracja interfejsu może występować tylko w klasie, rekordzie, strukturze lub interfejsie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">„{0}”: nazwy składowych nie mogą być takie same jak nazwa zawierającego je typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">„{0}”: wartość, która wystąpiła w module wyliczającym, jest zbyt duża, aby można było ją stosować przy użyciu typu tego modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest właściwością</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu get, którą można przesłonić</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu set, którą można przesłonić</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">„{0}”: właściwość ani indeksator nie mogą być typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">„{0}”: właściwość lub indeksator musi mieć co najmniej jedna metodę dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed type '{1}'</source>
        <target state="translated">„{0}” to nowa wirtualna składowa typu zapieczętowanego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'Element „{0}” dodaje metodę dostępu, której nie znaleziono w składowej interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">W jawnej implementacji interfejsu „{0}” brakuje metody dostępu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">„{0}”: zdefiniowane przez użytkownika konwersje na lub z interfejsu nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base type are not allowed</source>
        <target state="translated">„{0}”: zdefiniowane przez użytkownika konwersje na lub z typu bazowego nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived type are not allowed</source>
        <target state="translated">„{0}”: zdefiniowane przez użytkownika konwersje na lub z typu pochodnego nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot convert a type to itself</source>
        <target state="translated">Operator zdefiniowany przez użytkownika nie może dokonać konwersji typu na siebie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">Zdefiniowana przez użytkownika konwersja musi dokonywać konwersji na typ otaczający lub z niego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">Zduplikowana konwersja zdefiniowana przez użytkownika w typie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">Operator zdefiniowany przez użytkownika „{0}” musi być zadeklarowany ze specyfikatorami static i public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">Typ parametru dla operatora ++ lub -- musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">Parametr operatora jednoargumentowego musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">Jeden z parametrów operatora binarnego musi być typem zawierającym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type</source>
        <target state="translated">Pierwszy operand przeciążonego operatora przesunięcia musi mieć ten sam typ co typ zawierający</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">Wyliczenia nie mogą zawierać jawnych konstruktorów bez parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">„{0}” nie może przesłonić „{1}”, ponieważ nie jest to obsługiwane przez język</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'Element „{0}” nie jest obsługiwany przez język.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">„{0}”: nie można jawnie wywołać operatora lub metody dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">„{0}”: nie można odwołać się do typu przy użyciu wyrażenia. Spróbuj użyć „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of type</source>
        <target state="translated">Nazwa destruktora musi być zgodna z nazwą typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">Tylko typy klasy mogą zawierać destruktory</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">Przestrzeń nazw „{1}” zawiera definicję powodującą konflikt z aliasem „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">Alias „{0}” jest w konflikcie z definicją {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie "{0}", ponieważ jest to konstruktor, destruktor, operator, wyrażenie lambda lub wyraźna implementacja interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jego typem zwracanym nie jest void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Zduplikowany atrybut „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">Zduplikowany atrybut „{0}” w elemencie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">Atrybut Conditional jest nieprawidłowy w składowych interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">Zdefiniowane przez użytkownika operatory nie mogą zwracać wartości void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">„{0}”: zdefiniowane przez użytkownika konwersje na lub z typu dynamicznego nie są dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">Nieprawidłowa wartość argumentu dla atrybutu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">Parametr jest nieprawidłowy dla określonego niezarządzanego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">Należy podać parametr atrybutu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">Należy podać parametr atrybutu „{0}” lub „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Niezarządzany typ „{0}” jest nieprawidłowy dla pól.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Niezarządzany typ „{0}” jest prawidłowy tylko dla pól.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">W tej deklaracji typu atrybut „{0}” jest nieprawidłowy. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">Wartość stałej zmiennoprzecinkowej jest spoza zakresu typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">Atrybut Guid musi być określony z atrybutem ComImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">Nieprawidłowa wartość nazwanego argumentu atrybutu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">Dla metody oznaczonej przy użyciu słów kluczowych „static” i „extern” musi zostać określony atrybut DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">Nie można zaktualizować elementu „{0}”. Brak atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="translated">Atrybut DllImport nie może być zastosowany do metody, która jest ogólna lub zawarta w metodzie ogólnej lub typie ogólnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">Pole ani właściwość nie może mieć typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">Pole lub automatycznie implementowana właściwość nie może być typu „{0}”, chyba że jest to składowa struktury ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">W tablicy nie mogą występować elementy typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'Element „{0}” jest przestarzały</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Typ lub składowa jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">„{0}” to nie jest klasa atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">„{0}” nie jest prawidłowym argumentem nazwanego atrybutu. Argumentami nazwanego atrybutu muszą być pola, które nie są tylko do odczytu i nie są statyczne ani stałe, lub właściwości do odczytu/zapisu, które są publiczne, ale nie statyczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'Element „{0}” jest przestarzały: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Typ lub składowa jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'Element „{0}” jest przestarzały: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">Indeksowanie nie może być typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">„{0}”: wirtualne ani abstrakcyjne składowe nie mogą być prywatne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">Wyrażenia inicjatora tablicy mogą być używane tylko w celu przypisania wartości do typów tablicowych. Zamiast tego spróbuj użyć wyrażenia „new”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">Inicjatora tablicy można użyć tylko w inicjatorze zmiennej lub pola. Zamiast tego spróbuj użyć wyrażenia „new”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">„{0}”: pola wystąpienia w ramach typów oznaczonych elementem StructLayout(LayoutKind.Explicit) muszą mieć atrybut FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">Metoda, operator lub metoda dostępu „{0}” jest oznaczona jako zewnętrzna i nie ma atrybutów. Rozważ dodanie atrybutu DllImport w celu określenia implementacji zewnętrznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">Metoda, operator lub metoda dostępu są oznaczone jako zewnętrzne i nie zawierają atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed type</source>
        <target state="translated">„{0}”: w typie zapieczętowanym została zadeklarowana nowa chroniona składowa</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed type</source>
        <target state="translated">W typie zapieczętowanym zadeklarowano nową chronioną składową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Warunkowa składowa „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">Parametry „ref” i „out” są nieprawidłowe w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">Argument atrybutu „{0}” musi być prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Atrybut FieldOffset można umieścić tylko w składowych o typie oznaczonym przy użyciu atrybutu StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">Atrybut FieldOffset jest niedozwolony w polach typu static lub const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w klasach pochodzących od klasy System.Attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">„{0}” zduplikowany nazwany argument atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">„{0}” nie może pochodzić od klasy specjalnej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">Dla typu zawierającego indeksator nie można określić atrybutu DefaultMember.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'Element „{0}” jest typem obsługiwanym przez język.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">Do pola „{0}” nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">Do pola nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">Niewłaściwy deklarator tablicy. Aby zadeklarować tablicę zarządzaną, przed identyfikatorem zmiennej umieść specyfikator rangi tablicy. Aby zadeklarować pole buforu o ustalonym rozmiarze, przed typem pola użyj słowa kluczowego „fixed”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">Porównanie ze stałą całkowitoliczbową jest bezcelowe. Stała jest poza zakresem typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">Porównanie ze stałą całkowitoliczbową jest bezcelowe; stała jest poza zakresem typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">Nie można zastosować klasy atrybutów „{0}”, ponieważ jest ona abstrakcyjna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">„{0}” nie jest prawidłowym argumentem nazwanego atrybutu, ponieważ nie jest to prawidłowy typ parametru atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">Brak wymaganej przez kompilator składowej „{0}.{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">„{0}” to nie jest prawidłowa lokalizacja atrybutu tej deklaracji. Prawidłowe lokalizacje atrybutu tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">Nieprawidłowa lokalizacja atrybutu tej deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">„{0}” nie jest rozpoznawaną lokalizacją atrybutu. Prawidłowe lokalizacje atrybutu dla tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">Nie jest to rozpoznawana lokalizacja atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'Element „{0}” przesłania metodę Object.Equals(object o), lecz nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">Typ przesłania metodę Object.Equals(object o), ale nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">Typ definiuje operator == lub !=, ale nie przesłania metody Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">Typ definiuje operator == lub !=, ale nie przesłania metody Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">Nie można określić atrybutu Out dla parametru ref bez określania także atrybutu wejściowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'Element „{0}” nie może definiować przeciążonego elementu {1}, który różni się tylko modyfikatorami parametru „{2}” i „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">Nie można niejawnie przekonwertować literału typu double na typ „{1}”. W celu utworzenia literału tego typu należy użyć sufiksu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">Przypisanie w wyrażeniu warunkowym jest zawsze stałe. Czy zamiast operatora = miał zostać użyty operator == ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">Przypisanie w wyrażeniu warunkowym jest zawsze stałe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">„{0}”: nowa chroniona składowa zadeklarowana w strukturze</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">Istnieją dwa indeksatory o różnych nazwach. Dla każdego indeksatora w określonym typie należy użyć atrybutu IndexerName o takiej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">W klasie z atrybutem ComImport nie może występować konstruktor zdefiniowany przez użytkownika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">Typ pola nie może być typem void</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">Składowa „{0}” przesłania przestarzałą składową „{1}”. Dodaj atrybut Obsolete do składowej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">Składowa przesłania przestarzałą składową</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">W języku C# nie można użyć elementu System.Void. Aby uzyskać obiekt typu void, użyj elementu typeof(void).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">Operator LUB działający na bitach został użyty względem argumentu ze znakiem. Rozważ możliwość wcześniejszego rzutowania na mniejszy typ bez znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">Użyto operatora bitowego OR w argumencie operacji z rozszerzonym znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">Kompilator niejawnie poszerzył zmienną i rozszerzył jej znak, a następnie użył wartości wynikowej w operacji bitowej OR. Może to powodować nieoczekiwane działanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">„{0}”: pole nietrwałe nie może być typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">„{0}”: pole nie może być jednocześnie nietrwałe i tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">Modyfikator „abstract” w polach jest nieprawidłowy. Spróbuj zamiast niego użyć właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">„{0}” nie może implementować „{1}”, ponieważ nie jest to obsługiwane przez język</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'Jawna implementacja metody „{0}” nie może implementować elementu „{1}”, ponieważ jest to metoda dostępu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'Interfejs „{0}” z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">Interfejs z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Warunkowa składowa „{0}” nie może mieć parametru wyjściowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Metoda dostępu „{0}” nie może implementować składowej interfejsu „{1}” dla typu „{2}”. Należy użyć implementacji interfejsu jawnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">Kwalifikator aliasu przestrzeni nazw „::” jest zawsze rozpoznawany jako typ lub przestrzeń nazw, dlatego jest tutaj niedozwolony. Zamiast niego rozważ możliwość użycia kwalifikatora „.”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">Nie może pochodzić od „{0}”, ponieważ jest to parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">Zduplikowany parametr typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co parametr typu zewnętrznego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">Parametr typu ma tę samą nazwę co parametr typu zewnętrznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">Parametr typu „{0}” ma tę samą nazwę co zawierający typ lub metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'Element „{0}” nie może implementować jednocześnie elementu „{1}” i „{2}”, ponieważ mogą się one łączyć przy niektórych podstawieniach parametrów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">Element „{1}” nie definiuje parametru typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">„{0}” to nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">Ograniczenie nie może być specjalną klasą „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">Niespójność dostępności: typ ograniczony „{1}” jest mniej dostępny niż „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">Nie można wyszukać składowej innej niż wirtualna w elemencie „{0}”, ponieważ to jest parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">Nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">„{0}”: nie można zadeklarować składowych wystąpienia w klasie statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">„{1}”: nie można utworzyć na podstawie klasy statycznej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">Klasy statyczne nie mogą mieć konstruktorów wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">Klasy statyczne nie mogą zawierać destruktorów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">Nie można utworzyć wystąpienia klasy statycznej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">Klasa statyczna „{0}” nie może pochodzić od typu „{1}”. Klasy statyczne muszą pochodzić od obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">„{0}”: klasy statyczne nie mogą implementować interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">„{0}”: klasy statyczne nie mogą zawierać operatorów zdefiniowanych przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">Nie można przekonwertować na typ statyczny „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">„{0}”: klas statycznych nie można używać jako ograniczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">„{0}”: typów statycznych nie można używać jako argumentów typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">„{0}”: elementy tablicy nie mogą być typu statycznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">„{0}”: nie można zadeklarować indeksatorów w klasie statycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">„{0}”: typów statycznych nie można użyć jako parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">„{0}”: typów statycznych nie można użyć jako typów w instrukcji return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">Nie można zadeklarować zmiennej typu statycznego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">Instrukcja throw bez argumentów jest niedozwolona w klauzuli finally zagnieżdżonej w najbliższej otaczającej klauzuli catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">„{0}” nie jest prawidłowym specyfikatorem formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">Prawdopodobnie niepoprawne przypisanie do elementu lokalnego „{0}”, który jest argumentem instrukcji using lub lock. Wywołanie metody Dispose lub odblokowanie nastąpi dla oryginalnej wartości elementu lokalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">Możliwe niepoprawne przypisanie do zmiennej lokalnej będącej argumentem instrukcji using lub lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">Typ „{0}” jest zdefiniowany w tym zestawie, ale zdefiniowano dla niego funkcję przesyłania typu dalej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">Nie można przesłać typu „{0}”, ponieważ jest to zagnieżdżony typ „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">Funkcja przesyłania dalej dla typu „{0}” w zestawie „{1}” powoduje wystąpienie cyklu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">Opcję /moduleassemblyname można określić tylko w przypadku kompilowania elementu docelowego typu „module”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">Określono nieprawidłowy typ jako argument dla atrybutu TypeForwardedTo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu wystąpienia „{1}”. Element „{2}” nie może zaimplementować składowej interfejsu, ponieważ jest ona statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować składowej interfejsu, ponieważ jest niepubliczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ brak pasującego zwracanego typu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">„{0}” zduplikowany atrybut TypeForwardedToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">Treść zapytania musi kończyć się klauzulą „select” lub „group”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „on”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">Oczekiwano kontekstowego słowa kluczowego „by”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">Nieprawidłowy deklarator składowej typu anonimowego. Składowe typu anonimowego muszą być deklarowane przy użyciu przypisania składowej, nazwy prostej lub dostępu do składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">Nieprawidłowy deklarator inicjującej składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Niespójne użycie parametrów lambda. Wszystkie typy parametrów muszą być albo jawne, albo niejawne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberNotExplicit">
        <source>A partial member may not explicitly implement an interface member</source>
        <target state="translated">Częściowy element członkowski nie może wyraźnie implementować elementu członkowskiego interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">Obie deklaracje metody częściowej muszą być metodami rozszerzenia albo żadna z nich nie może być metodą rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">Metoda częściowa nie może mieć wielu deklaracji definiujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">Metoda częściowa nie może mieć wielu deklaracji implementujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">Nie znaleziono deklaracji definiującej na potrzeby implementowania częściowej metody „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Deklaracje metod częściowych elementu „{0}” mają niespójne ograniczenia dla parametru typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">Nie można utworzyć delegata z metody „{0}”, ponieważ jest to metoda częściowa bez deklaracji implementującej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberStaticDifference">
        <source>Both partial member declarations must be static or neither may be static</source>
        <target state="translated">Obie deklaracje częściowych elementów członkowskich muszą być statyczne lub żadna z nich nie może być statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">W drzewach wyrażeń nie można używać metod częściowych zawierających tylko deklarację definiującą ani usuniętych metod warunkowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">Przestarzała składowa „{0}” przesłania nieprzestarzałą składową „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">Przestarzała składowa przesłania nieprzestarzałą składową</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">W pełni kwalifikowana nazwa elementu „{0}” jest za długa dla informacji debugowania. Skompiluj bez opcji „/debug”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">W pełni kwalifikowana nazwa jest za długa dla informacji debugowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">Nie można przypisać elementu {0} do zmiennej o typie określonym niejawnie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">Zmienne o typie określonym niejawnie muszą być inicjowane</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">Zmienne o typie określonym niejawnie nie mogą mieć wiele deklaratorów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">Nie można zainicjować zmiennej o typie określonym niejawnie za pomocą inicjatora tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">Zmienne lokalne o typie określonym niejawnie nie mogą być ustalone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">Zmienne o typie określonym niejawnie nie mogą być stałymi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">Konstruktor „{0}” jest oznaczony jako zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">Konstruktor jest oznaczony jako zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">Kontekstowe słowo kluczowe „var” może występować tylko w deklaracji zmiennej lokalnej lub kodzie skryptu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">Nie odnaleziono najlepszego typu dla tablicy o typie określonym niejawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">Nie można przypisać elementu {0} do właściwości typu anonimowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora przypisania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">Typ anonimowy nie może mieć wielu właściwości o tej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">Wyrażenia lambda z treścią instrukcji nie można skonwertować na drzewo wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">Nie można skonwertować wyrażenia lambda na drzewo wyrażenia, którego argument typu „{0}” nie jest typem delegowanym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">W wyrażeniu stałym nie można użyć typu anonimowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">Pierwszy argument operacji operatora „is” lub „as” nie może być wyrażeniem lambda, metodą anonimową ani grupą metod.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">Pierwszy operand operatora „as” nie może być literałem krotki bez typu naturalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać inicjatora tablicy wielowymiarowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">Brak argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">Typu elementu „{0}” nie można wywnioskować, ponieważ jego inicjator bezpośrednio lub pośrednio przywołuje definicję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem. Deklaracja zmiennej lokalnej powoduje ukrycie pola „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać operatora łączącego z literałem domyślnym lub o wartości null po lewej stronie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Oczekiwano identyfikatora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">Oczekiwano średnika (;)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">Błąd składni, oczekiwano elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">Zduplikowany modyfikator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">Metoda dostępu do właściwości jest już zdefiniowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">Oczekiwano typu byte, sbyte, short, ushort, int, uint, long lub ulong.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">Nierozpoznana sekwencja ucieczki</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">W stałej występuje symbol przejścia do następnego wiersza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">Pusty literał znakowy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">Za wiele znaków w literale znakowym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">Oczekiwano metody dostępu get lub set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">Oczekiwano typu object, string lub class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">Oczekiwano argumentu atrybutu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Klauzule catch nie mogą następować po ogólnej klauzuli catch instrukcji try.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">Oczekiwano słowa kluczowego „this” lub „base”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">Oczekiwano operatora jednoargumentowego z możliwością przeciążenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">Oczekiwano operatora binarnego z możliwością przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">Za duża wartość stałej całkowitej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">Oczekiwano definicji typu lub przestrzeni nazw albo znacznika końca pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">Oczekiwano definicji składowej, instrukcji albo znacznika końca pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">Osadzona instrukcja nie może być instrukcją deklaracji ani instrukcją etykiety.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">Oczekiwano dyrektywy preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">Oczekiwano znaku )</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">Oczekiwano dyrektywy #endif.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">Nieoczekiwana dyrektywa preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#błąd: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">Dyrektywa #warning</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">Oczekiwano typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">Nie można zdefiniować/usunąć definicji symboli preprocesora po pierwszym tokenie w pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">Nie można użyć dyrektywy #r po pierwszym tokenie w pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">Napotkano znacznik końca pliku. Oczekiwano znaków "*/".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">Napotkano znacznik konfliktu scalania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">Nie używaj opcji refout, gdy używana jest opcja refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">Nie można skompilować modułów sieciowych, gdy używana jest opcja /refout lub /refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">Oczekiwano operatora z możliwością przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">Oczekiwano dyrektywy #endregion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">Niezakończony literał ciągu znaków</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">Dyrektywy preprocesora muszą wystąpić w wierszu jako pierwsze znaki inne niż spacja.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">Oczekiwano identyfikatora; „{1}” jest słowem kluczowym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">Oczekiwano znaku { lub ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">W instrukcjach deklaracji „for”, „using”, „fixed”, „or” nie można użyć większej liczby typów niż jeden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">Oczekiwano metody dostępu Add lub Remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Nieoczekiwany znak „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">Nieoczekiwany token „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">„{0}”: klasy statyczne nie mogą zawierać chronionych składowych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki. Wszystkie wywołane elementy niebędące wyjątkami zostaną opakowane w elemencie System.Runtime.CompilerServices.RuntimeWrappedException.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">Poprzednia klauzula catch przechwytuje już wszystkie wyjątki</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">To ostrzeżenie występuje, gdy blok catch() nie ma określonego typu wyjątku po bloku catch (System.Exception e). Ostrzeżenie zawiera zalecenie, aby blok catch() nie przechwytywało żadnych wyjątków.

Blok catch() po bloku catch (System.Exception e) może przechwytywać wyjątki niezgodne ze specyfikacją CLS, jeśli element RuntimeCompatibilityAttribute ma ustawioną wartość false w pliku AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Jeśli ten atrybut nie ma jawnie ustawionej wartości false, wszystkie zgłaszane wyjątki niezgodne ze specyfikacją CLS są opakowywane jako wyjątki przez blok catch (System.Exception e).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">Argument operatora zwiększania lub zmniejszania musi być zmienną, właściwością lub indeksatorem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Element „{0}” nie zawiera definicji „{1}” i nie odnaleziono dostępnej metody rozszerzenia „{1}”, która przyjmuje pierwszy argument typu „{0}” (czy nie brakuje dyrektywy using lub odwołania do zestawu?).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'Element „{0}” nie zawiera definicji elementu „{1}” i nie można znaleźć metody rozszerzenia „{1}” przyjmującej pierwszy argument typu „{0}” (brak dyrektywy using dla elementu „{2}”?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">Metoda „{0}” zawiera modyfikator parametru „this”, który nie znajduje się w pierwszym parametrze</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated">Modyfikator parametru „{0}” nie może być używany z elementem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">Pierwszy parametr metody rozszerzenia nie może być parametrem typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">Tablicy parametrów nie można używać z modyfikatorem „this” w metodzie rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">Metoda rozszerzenia musi być statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">Metoda rozszerzenia musi być zdefiniowana w nieogólnej klasie statycznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">Parametr może mieć tylko jeden modyfikator „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">Metody rozszerzenia muszą być zdefiniowane w statycznych klasach najwyższego poziomu. „{0}” to klasa zagnieżdżona</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">Nie można zdefiniować nowej metody rozszerzenia, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania do System.Core.dll?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">Nie używaj „System.Runtime.CompilerServices.ExtensionAttribute”. Zamiast niego użyj słowa kluczowego „this”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">Nie używaj „System.Runtime.CompilerServices.DynamicAttribute”. Zamiast niego użyj słowa kluczowego „dynamic”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">Wywołanie konstruktora musi być przydzielane dynamicznie, ale jest to niemożliwe, ponieważ jest częścią inicjatora konstruktora. Rozważ możliwość rzutowania argumentów dynamicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">Metody rozszerzenia „{0}” zdefiniowanej dla typu wartości „{1}” nie można użyć do tworzenia delegatów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">Żadne przeładowanie metody „{0}” nie pobiera następującej liczby argumentów: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">Argument „{0}”: nie można przekonwertować z „{1}” na „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">Nie można otworzyć pliku źródłowego „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">Nie można połączyć plików zasobów podczas kompilowania modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">Identyfikator zasobu „{0}” został już użyty w tym zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">Nazwa pliku każdego połączonego zasobu i modułu musi być unikatowa. Nazwę pliku „{0}” określono więcej niż raz w tym zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">Przywoływany plik „{0}” nie jest zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">Wartość ref lub out musi być zmienną umożliwiającą przypisanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">W metodzie statycznej słowo kluczowe „base” jest niedostępne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">W bieżącym kontekście słowo kluczowe „base” jest niedostępne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">Oczekiwano znaku }</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">Oczekiwano znaku {</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'Oczekiwano słowa kluczowego „in”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">Nieprawidłowe wyrażenie preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, record, struct, or interface member declaration</source>
        <target state="translated">Nieprawidłowy token „{0}” w deklaracji składowej klasy, rekordu, struktury lub interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">Metoda musi mieć typ zwracany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">Nieprawidłowy typ podstawowy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">Pusty blok „switch”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">Pusty blok „switch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">Oczekiwano instrukcji „catch” lub „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">W wyrażeniu występuje nieprawidłowe określenie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires an argument list or (), [], or {} after type</source>
        <target state="translated">Wyrażenie new wymaga listy argumentów lub znaków (), [] lub {} po typie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">Elementów definiowanych w przestrzeni nazw nie można jawnie deklarować jako prywatnych, chronionych, chronionych wewnętrznych lub prywatnych chronionych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">Oczekiwano znaku ; lub = (w deklaracji nie można określić argumentów konstruktora).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">Klauzula „using” musi występować przed wszystkimi innymi elementami zdefiniowanymi w przestrzeni nazw poza deklaracjami aliasów zewnętrznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">Przeciążony operator binarny „{0}” przyjmuje dwa parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">Przeciążony operator jednoargumentowy „{0}” przyjmuje jeden parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">Nieprawidłowy typ parametru (void)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">Alias użycia „{0}” pojawił się poprzednio w tej przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">Nie można uzyskać dostępu do składowej chronionej „{0}” za pośrednictwem kwalifikatora typu „{1}”. Wymagany jest kwalifikator typu „{2}” (lub typu pochodzącego od tego typu).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'Nie można dodać elementu „{0}” do tego zestawu, ponieważ jest to już zestaw</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metody dostępu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metodę dostępu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">W tym kontekście nie można użyć słowa kluczowego „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">Dla indeksatora trzeba zdefiniować co najmniej jeden parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">Specyfikator typu tablicy — [] — musi wystąpić przed nazwą parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">Nieprawidłowa deklaracja; zamiast niej użyj konstrukcji „{0} operator &lt;typ_docelowy&gt; (...”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Nie można znaleźć elementu „{0}” określonego dla metody Main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</source>
        <target state="translated">Element „{0}” określony dla metody Main musi być nieogólną klasą, rekordem, strukturą lub interfejsem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">Element „{0}” nie ma odpowiedniej statycznej metody „Main”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">Nie można użyć elementu „{0}” dla metody Main, ponieważ jest on zaimportowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">Dla wyjść bez źródła trzeba określić opcję /out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">Określono opcje powodujące konflikt: plik zasobów Win32; manifest Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">Określono opcje powodujące konflikt: plik zasobów Win32; ikona Win32.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas odczytywania zasobu „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">Błąd zapisu w pliku dokumentacji XML: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">Komentarz XML ma nieprawidłowo sformułowany kod XML — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">Komentarz XML ma nieprawidłowo sformułowany kod XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag param dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag param</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag param dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag param, ale nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Komentarz XML elementu „{1}” ma tag paramref dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">Komentarz XML ma tag paramref, ale nie ma parametru o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">Parametr „{0}” nie ma zgodnego tagu param w komentarzu XML elementu „{1}” (lecz inne parametry mają)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">Parametr nie ma zgodnego tagu param w komentarzu XML (ale inne parametry mają ten tag)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">Komentarz XML ma atrybut cref „{0}”, którego nie można rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">Komentarz XML zawiera atrybut cref, którego nie można rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">W wyrażeniu stackalloc po nazwie typu wymagane jest użycie specyfikatora [].</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">Nie określono numeru wiersza dla dyrektywy #line lub określony numer jest nieprawidłowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano nazwy pliku w cudzysłowie, jednowierszowego komentarza lub końca wiersza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">Oczekiwano nazwy pliku w cudzysłowach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">Dyrektywa #r jest dozwolona tylko w skryptach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">Instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ typ „{0}” nie zawiera publicznego wystąpienia lub definicji rozszerzenia dla elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">Nieprawidłowy typ parametru {0} w atrybucie cref komentarza XML: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy typ parametru w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Błąd odczytu zasobów Win32 — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">Komentarz XML zawiera składniowo niepoprawny atrybut cref „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">Komentarz XML zawiera składniowo niepoprawny atrybut cref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">Modyfikator składowej „{0}” musi wystąpić przed definicją typu i nazwy składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">Do utworzenia tablicy wymagane jest określenie rozmiaru tablicy lub inicjatora tablicy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Komentarz XML nie został umieszczony w prawidłowym elemencie języka</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Komentarz XML nie został umieszczony w prawidłowym elemencie języka</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">Nie można dołączyć fragmentu XML „{1}” pliku „{0}” — {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">Nie można dołączyć fragmentu XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">Nieprawidłowy element include w kodzie XML — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">Nieprawidłowy element include w kodzie XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">Brak komentarza XML dla widocznego publicznie typu lub składowej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">Brak komentarza XML dla widocznego publicznie typu lub składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">Określono opcję kompilatora /doc, ale co najmniej jedna konstrukcja nie ma komentarzy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Nieprawidłowo sformułowany kod XML znajduje się w pliku komentarzy — „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Nieprawidłowo sformułowany kod XML w pliku komentarzy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">Delegat „{0}” nie przyjmuje argumentów {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">Użycie średnika po bloku metody lub metody dostępu jest nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>The return type of a method, delegate, or function pointer cannot be '{0}'</source>
        <target state="translated">Typem zwracanym metody, delegata lub wskaźnika funkcji nie może być „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">Kompilacja anulowana przez użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">Nie można przywołać zmiennej typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">Nie można przypisać wartości do elementu „{0}” ponieważ jest on tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">Atrybut RequiredAttribute jest niedozwolony dla typów C#</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">Nie można używać modyfikatorów w deklaracjach metod dostępu do zdarzeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">Parametr params nie może zostać zadeklarowany jako {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">Nie można zmodyfikować zwracanej wartości „{0}”, ponieważ nie jest to zmienna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">Nie można znaleźć zarządzanej klasy otoki coclass „{0}” interfejsu „{1}” (brak odwołania do zestawu?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</source>
        <target state="translated">Element „{0}” nie jest jednoznaczny w zakresie od „{1}” do „{2}”. Użyj opcji „@{0}” lub jawnie uwzględnij sufiks „Attribute”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">Argumentu „{0}” nie można przekazać ze słowem kluczowym „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">Opcja „{0}” przesłania atrybut „{1}” podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">Opcja przesłania atrybut podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">To ostrzeżenie występuje, jeśli atrybut zestawu AssemblyKeyFileAttribute lub AssemblyKeyNameAttribute w źródle powoduje konflikt z opcją wiersza polecenia /keyfile lub /keycontainer albo z nazwą pliku klucza lub kontenerem określonymi we właściwościach projektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla /langversion. Użyj opcji „/langversion:?”, aby wyświetlić listę obsługiwanych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">Nie można utworzyć delegata z „{0}”, ponieważ on albo metoda, którą przesłania, ma atrybut „Conditional”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">Nie można utworzyć pliku tymczasowego — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">Argument „{0}” musi być przekazywany ze słowem kluczowym „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">Nie można używać instrukcji yield wewnątrz metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">Nie można zwrócić wartości z iteratora. Użyj instrukcji yield return, aby zwrócić wartość, lub yield break, aby zakończyć iterację.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">Iteratory nie mogą mieć parametrów ref, in ani out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">Treść „{0}” nie może być blokiem iteratora, ponieważ „{1}” nie jest typem interfejsu iteratora</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">Nie można użyć instrukcji yield w treści klauzuli finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">Nie można użyć instrukcji yield z wartością w treści bloku try z klauzulą catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">Oczekiwano wyrażenia po instrukcji yield return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Nie można użyć parametru ref, out ani in „{0}” wewnątrz metody anonimowej, wyrażenia lambda, wyrażenia zapytania lub funkcji lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">Nie można użyć instrukcji yield z wartością w treści klauzuli catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">Kontrolka nie może opuścić tekstu metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Nierozpoznana dyrektywa #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Nierozpoznana dyrektywa #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">Oczekiwano elementu „disable” lub „restore”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">Oczekiwano elementu „disable” lub „restore” po ostrzeżeniu #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">Nie można przywrócić ostrzeżenia „CS{0}”, ponieważ zostało wyłączone globalnie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">Nie można przywrócić ostrzeżenia, ponieważ zostało globalnie wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">Element „__arglist” jest niedozwolony w liście parametrów iteratorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have pointer type parameters</source>
        <target state="translated">Iteratory nie mogą mieć parametrów typu wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">Sygnatura „{0}” zarządzanej klasy otoki coclass dla interfejsu „{1}” nie jest prawidłową sygnaturą nazwy klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Instrukcja foreach nie może używać zmiennych typu „{0}”, ponieważ implementuje wiele utworzeń wystąpienia elementu „{1}”. Spróbuj rzutowania na konkretne utworzenie wystąpienia interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">Pole buforu o ustalonym rozmiarze musi mieć specyfikator rozmiaru tablicy po nazwie pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">Pola buforu o ustalonym rozmiarze mogą być tylko składowymi struktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">Nie dla wszystkich ścieżek w kodzie jest zwracana wartość w {0} typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Funkcja „{0}” nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Funkcja nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">Słowo kluczowe, identyfikator lub ciąg oczekiwany po specyfikatorze kalki: @.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Składowych pola tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</source>
        <target state="translated">Nie można przypisać do pola tylko do odczytu (poza konstruktorem lub metodą ustawiającą tylko do inicjowania typu, w której pole jest zdefiniowane, lub inicjatorze zmiennej)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">Nie można modyfikować składowych pola tylko do odczytu „{0}” (z wyjątkiem składowych w konstruktorze lub inicjatorze zmiennych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">Nie można użyć elementu {0} „{1}” jako wartości ref ani out, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">Składowe elementu {0} „{1}” nie mogą być używane jako wartość ref ani out, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Nie można przypisać do {0} „{1}” lub użyć go jako prawej strony przypisania odwołania, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Nie można przypisać składowej{0} „{1}” lub użyć jej jako prawej strony przypisania odwołania, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">Nie można zwrócić elementu {0} „{1}” przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">Składowe elementu {0} „{1}” nie mogą być zwracane przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Polom statycznego pola tylko do odczytu „{0}” nie można przypisać wartości (z wyjątkiem pól w konstruktorze statycznym lub inicjatorze zmiennych).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Pól pola statycznego tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze statycznym)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">Nie można zmodyfikować składowych „{0}”, ponieważ jest to „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Nie można użyć pól elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">Nie można przypisać wartości do elementu „{0}”, ponieważ jest to „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}. Patrz także błąd CS{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">Ostrzeżenie przesłania błąd</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">Kompilator emituje to ostrzeżenie w przypadku przesłonięcia błędu z ostrzeżeniem. Aby uzyskać informacje dotyczące tego problemu, wyszukaj podany kod błędu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">Nie można przekonwertować elementu {0} na typ „{1}”, ponieważ nie jest to typ delegowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">Nie można przekonwertować elementu {0} na typ „{1}”, ponieważ typy parametrów nie pasują do typów parametru delegowanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">Nie można przekonwertować bloku „{0}” na zamierzony typ delegowany, ponieważ niektóre typy zwracane występujące w bloku nie umożliwiają niejawnej konwersji na zwracany typ delegowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than '{1}'</source>
        <target state="translated">Ponieważ jest to metoda asynchroniczna, zwracane wyrażenie musi być typu „{0}”, a nie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">Nie można przekonwertować elementu async {0} na typ delegowany „{1}”. Element async {0} może zwrócić wartość void, Task lub Task&lt;T&gt;, a żadne z tych typów nie mogą być przekonwertowane na „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">Typ buforu o ustalonym rozmiarze musi być jednym z następujących typów: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float lub double.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">Bufor o ustalonym rozmiarze o długości {0} i typie „{1}” jest za duży</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">Bufory o ustalonym rozmiarze muszą mieć długość większą niż zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">Nie można użyć buforów o ustalonym rozmiarze zawartych w wyrażeniach unfixed. Spróbuj użyć instrukcji fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Atrybut „{0}” nie jest prawidłowy w metodach dostępu do właściwości lub zdarzeń. Jest on prawidłowy tylko w deklaracjach „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">Określono nieprawidłową ścieżkę wyszukiwania „{0}” w elemencie „{1}” — „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">Określono nieprawidłową ścieżkę wyszukiwania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">Element „__arglist” jest nieprawidłowy w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">Element params jest nieprawidłowy w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">Deklaracja przestrzeni nazw nie może mieć modyfikatorów ani atrybutów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla opcji /platform; wymagana wartość to anycpu, x86, Itanium, arm, arm64 lub x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.</source>
        <target state="translated">Anonimowe metody, wyrażenia lambda, wyrażenia zapytania i funkcje lokalne wewnątrz struktur nie mogą uzyskiwać dostępu do składowych wystąpień elementu „this”. Rozważ możliwość skopiowania elementu „this” do zmiennej lokalnej poza metodą anonimową, wyrażeniem lambda, wyrażeniem zapytania lub funkcją lokalną i użycie zamiast niego zmiennej lokalnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'.</source>
        <target state="translated">„{0}”: typ użyty w instrukcji using musi implementować typ „System.IDisposable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">Parametr „{0}” musi być deklarowany za pomocą słowa kluczowego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">Parametr {0} nie powinien być deklarowany za pomocą słowa kluczowego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">Parametr {0} jest deklarowany jako typ „{1}{2}”, a powinien być „{3}{4}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowy alias zewnętrzny dla opcji „/reference”; wartość „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">Nieprawidłowa opcja aliasu odwołania: „{0}=” — brak nazwy pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">Nie można ponownie zdefiniować globalnego aliasu zewnętrznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">Odwołanie do typu „{0}” określa, że jest zdefiniowane w tym zestawie, lecz nie jest zdefiniowane w module źródłowym ani w żadnym z dodanych modułów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">Odwołanie do typu „{0}” określa, że jest zdefiniowane w elemencie „{1}”, lecz nie można go znaleźć</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” jest zdefiniowany w wielu zestawach aliasu globalnego. Zostanie użyta definicja z elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">Wstępnie zdefiniowany typ występuje w wielu zestawach w aliasie globalnym</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">Ten błąd występuje w przypadku odnalezienia wstępnie zdefiniowanego typu, takiego jak System.Int32, w dwóch zestawach. Może się tak dziać, gdy utworzono odwołanie do elementu mscorlib lub biblioteki System.Runtime.dll w dwóch różnych miejscach, na przykład podczas próby uruchomienia dwóch wersji programu .NET Framework obok siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">Adresu elementu lokalnego „{0}” lub jego składowych nie można pobrać i użyć wewnątrz metody anonimowej lub wyrażenia lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">Nie można przekonwertować bloku metody anonimowej bez listy parametrów na typ delegowany „{0}”, ponieważ ma on jeden lub kilka parametrów out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">Atrybut „{0}” jest prawidłowy tylko w przypadku metod lub klas atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Dostęp do składowej elementu „{0}” może spowodować wystąpienie wyjątku czasu wykonywania, ponieważ to jest pole w klasie marshal-by-reference</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">Dostęp do składowej pola w klasie marshal-by-reference może spowodować wystąpienie wyjątku czasu wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">To ostrzeżenie występuje, gdy w przypadku próby wywołania metody, właściwości lub indeksatora w składowej klasy pochodnej elementu MarshalByRefObject składowa jest typem wartości. Obiekty dziedziczące po elemencie MarshalByRefObject zwykle powinny być kierowane przez referencję w domenie aplikacji. Jeśli kod spróbuje bezpośrednio uzyskać dostęp do składowej typu wartości takiego obiektu w domenie aplikacji, wystąpi wyjątek czasu wykonywania. Aby rozwiązać problem podany w ostrzeżeniu, skopiuj składową do zmiennej lokalnej i wywołaj metodę w tej zmiennej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">„{0}” to nie jest prawidłowy numer ostrzeżenia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">Nieprawidłowy numer ostrzeżenia</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">Numer przekazany do dyrektywy preprocesora ostrzeżenia #pragma nie jest prawidłowym numerem ostrzeżenia. Upewnij się, że numer reprezentuje ostrzeżenie, a nie błąd.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">Nieprawidłowy numer</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora. Nazwa pliku jest za długa lub nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">Nieprawidłowa składnia sumy kontrolnej #pragma checksum; powinna być następująca: #pragma checksum "nazwa_pliku" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">Nieprawidłowa składnia sumy kontrolnej #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza po dyrektywie #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">Podano różne sumy kontrolne dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">Podano różne wartości sumy kontrolnej #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">Odwołanie do zestawu jest nieprawidłowe i nie można go rozpoznać</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">To ostrzeżenie oznacza, że nie określono poprawnie atrybutu, takiego jak InternalsVisibleToAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">Zostało zaimportowanych wiele zestawów o równoważnej tożsamości: „{0}” i „{1}”. Usuń jedno ze zduplikowanych odwołań.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">Zestaw o tej samej prostej nazwie „{0}” został już zaimportowany. Spróbuj usunąć jedno z odwołań (np. „{1}”) lub podpisz je, aby umożliwić działanie obok siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">Zestaw „{0}” z tożsamością „{1}” używa elementu „{2}”, który ma wyższą wersję niż przywoływany zestaw „{3}” z tożsamością „{4}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">Do buforów o ustalonym rozmiarze można uzyskać dostęp tylko przez elementy lokalne lub pola</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag typeparam dla elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">Komentarz XML zawiera zduplikowany tag typeparam</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparam dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparam, ale nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML elementu „{1}” ma tag typeparamref dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">Komentarz XML ma tag typeparamref, ale nie ma parametru typu o takiej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">Parametr typu „{0}” nie ma zgodnego tagu typeparam w komentarzu XML elementu „{1}” (lecz inne parametry typu mają)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">Parametr typu nie ma zgodnego tagu typeparam w komentarzu XML (ale inne parametry mają ten tag)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">„{0}”: typ musi być „{2}”, aby być zgodnym z przesłoniętą składową „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">Nie używaj atrybutu „System.Runtime.CompilerServices.FixedBuffer”. Zamiast niego użyj modyfikatora pola „fixed”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">Wykonano przypisanie do tej samej zmiennej. Czy chcesz przypisać coś innego?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">Ustawiono przypisanie do tej samej zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">Wykonano porównanie z tą samą zmienną. Czy chcesz porównać coś innego?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">Wykonano porównanie z tą samą zmienną</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas otwierania pliku zasobów Win32 „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">Wyrażenie zawsze spowoduje wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość elementu „{0}” to null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">Wyrażenie będzie zawsze powodować wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość typu to null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">Klasa „{0}” nie może zawierać wielu klas bazowych: „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">Przed interfejsami musi występować klasa bazowa „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">Komentarz XML zawiera atrybut cref „{0}” przywołujący parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">Komentarz XML zawiera atrybut cref przywołujący parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Deklaracje InternalsVisibleTo nie mogą mieć określonej wersji, kultury, tokena klucza publicznego ani architektury procesora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Zestawy podpisane silnymi nazwami muszą określać klucz publiczny w swoich deklaracjach InternalsVisibleTo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">Nie można powiązać obiektu delegowanego z elementem „{0}”, ponieważ jest to składowa typu „System.Nullable&lt;T&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'Element „{0}” nie zawiera konstruktora przyjmującego następującą liczbę argumentów: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">Atrybuty zestawu i modułu muszą występować przed wszystkimi innymi elementami zdefiniowanymi w pliku poza klauzulami using i deklaracjami aliasów zewnętrznych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">Oczekiwano wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">Nieprawidłowa wersja „{0}” dla opcji /subsystemversion. Wymagana jest 6.02 lub nowsza dla ARM lub AppContainerExe oraz wersja 4.00 lub nowsza w pozostałych przypadkach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">Osadzona metoda międzyoperacyjna „{0}” zawiera treść.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be zero or greater</source>
        <target state="translated">Poziom ostrzeżeń musi mieć wartość zero lub większą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">Nieprawidłowa opcja „{0}” dla opcji /debug; wymagana wartość to „portable”, „embedded”, „full” lub „pdbonly”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">Nieprawidłowa opcja „{0}”; widoczność zasobu musi mieć wartość „public” lub „private”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">Typ argumentu atrybutu DefaultParameterValue musi być zgodny z typem parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">Argumentu typu „{0}” nie można stosować do atrybutu DefaultParameterValue</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">Zduplikowana inicjacja składowej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">Nie można zainicjować składowej „{0}”. To nie jest pole ani właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">Statycznego pola lub właściwości „{0}” nie można przypisać w inicjatorze obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Do składowych pola tylko do odczytu „{0}” typu „{1}” nie można przypisać inicjatora obiektu, ponieważ jest ono typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Składowych właściwości „{0}” typu „{1}” nie można przypisać za pomocą inicjatora obiektu, ponieważ jest on typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">Nie można użyć niezabezpieczonego typu „{0}” do tworzenia obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">Inicjator elementu nie może być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">Najlepiej dopasowana metoda przeciążona elementu „{0}” zawiera niewłaściwą sygnaturę dla elementu inicjatora. Możliwa do zainicjowania metoda Add musi być dostępną metodą wystąpienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">Nie można zainicjować typu „{0}” za pomocą inicjatora kolekcji, ponieważ nie implementuje on interfejsu „System.Collections.IEnumerable”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">Błąd podczas odczytywania pliku manifestu Win32 „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">„{0}” nie zawiera definicji dla „{1}”, a najlepsze przeciążenie metody rozszerzenia „{2}” wymaga odbiorcy typu „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">Zmienna zakresu „{0}” jest już zadeklarowana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">Zmienna zakresu „{0}” powoduje konflikt z poprzednią deklaracją zmiennej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">Nie można przypisać elementu „{0}” do zmiennej zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Rozważ jawne określenie typu zmiennej zakresu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Być może brakuje wymaganych odwołań do zestawów lub używasz dyrektywy dla przestrzeni nazw „System.Linq”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Nazwa „{0}” jest poza zakresem lewej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Nazwa „{0}” jest poza zakresem prawej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">Nie można przekazać zmiennej zakresu „{0}” jako parametru ze specyfikatorem out lub ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">Znaleziono wiele implementacji wzorca zapytania dla typu źródłowego „{0}”. Niejednoznaczne wywołanie elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Typ jednego z wyrażeń w klauzuli {0} jest nieprawidłowy. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Typ wyrażenia w klauzuli {0} jest niepoprawny. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">Wyrażenie typu „{0}” jest niedozwolone w kolejnej klauzuli from w wyrażeniu zapytania z typem źródłowym „{1}”. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać niebezpiecznej operacji wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać wyrażenia metody anonimowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">Nie można przekonwertować wyrażenia metody anonimowej na drzewo wyrażenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Nie można wykonać przypisania do zmiennej zakresu „{0}” — można ją tylko odczytać</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">Zmienna zakresu „{0}” nie może mieć takiej samej nazwy jak parametr typu metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">Nie można używać kontekstowego słowa kluczowego „var” w deklaracji zmiennej zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">Niektóre argumenty najlepiej dopasowanej przeciążonej metody Add „{0}”dla inicjatora kolekcji są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać parametrów ref, in ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać metody z argumentami zmiennych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać grupy metod</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">Nie można użyć najlepiej dopasowanej przeciążonej metody Match „{0}” dla elementu inicjatora kolekcji. Metody „Add” inicjatora kolekcji nie mogą mieć parametrów ref ani out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">Składowej „{0}”, której nie można wywoływać, nie można używać jak metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">Składowa „{0}” implementuje składową interfejsu „{1}” w typie „{2}”. W czasie wykonywania składowa interfejsu jest zgodna z wieloma metodami. Od implementacji zależy, która metoda zostanie wywołana.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">Składowa implementuje składową za pomocą wielu dopasowań w czasie wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">To ostrzeżenie może zostać wygenerowane, gdy dwie metody interfejsu różnią się tylko oznaczeniem określonego parametru specyfikatorem ref lub out. Aby zapobiec występowaniu tego ostrzeżenia, zmień kod, ponieważ nie można jednoznacznie określić ani zagwarantować, która metoda zostanie wywołana w czasie wykonywania.

Język C# rozróżnia specyfikatory out i ref, jednak dla środowiska CLR są one takie same. Wybiera ono dowolny z nich podczas określania, która metoda zawiera implementację interfejsu.

Musisz umożliwić kompilatorowi rozróżnienie metod. Możesz na przykład nadać im różne nazwy lub określić dla jednej z nich dodatkowy parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</source>
        <target state="translated">Składowa „{1}” przesłania element „{0}”. W czasie wykonywania jest możliwych wiele różnych przesłonięć. Od implementacji zależy, która metoda zostanie wywołana. Użyj nowszego środowiska uruchomieniowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">Składowa przesłania podstawową składową za pomocą wielu możliwych przesłonięć w czasie wykonywania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">Nie można zastosować wyrażeń inicjatora obiektu i kolekcji do wyrażenia tworzenia delegata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'Element „{0}” jest typu „{1}”. W deklaracji stałej należy określić typ sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, typ wyliczeniowy lub typ odwołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">Nie można znaleźć pliku źródłowego „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">Plik źródłowy „{0}” jest określony wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">Plik źródłowy został określony wiele razy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">Brak specyfikacji pliku dla opcji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">Błąd składni wiersza polecenia: brak elementu „{0}” dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Nierozpoznana opcja: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">Nie określono plików źródłowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">Nie określono plików źródłowych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">Oczekiwano skryptu (plik CSX), ale go nie określono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">Błąd podczas otwierania pliku odpowiedzi „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">Nie można otworzyć „{0}” do zapisu — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">Nieprawidłowy numer podstawowy obrazu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'Plik „{0}” jest plikiem binarnym, a nie plikiem tekstowym</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">Strona kodowa „{0}” jest nieprawidłowa lub niezainstalowana</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">Algorytm „{0}” nie jest obsługiwany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">W czasie kompilowania modułu lub biblioteki nie można określić opcji /main</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">Nieprawidłowy typ elementu docelowego dla opcji /target: musisz podać typ „exe”, „winexe”, „library” lub „module”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">Nieprawidłowe wyrównanie sekcji pliku „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa wyjścia: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">Nieprawidłowy format informacji debugowania: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'Składnia „id#” nie jest już używana. Zamiast niej użyj składni „$id”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">Nie można utworzyć krótkiej nazwy pliku „{0}”, jeśli już istnieje długa nazwa pliku, której krótka wersja jest taka sama</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">Opcja /reference, która deklaruje alias zewnętrzny, może mieć tylko jedną nazwę pliku. Aby określić wiele aliasów lub nazw plików, użyj wielu opcji /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">Błąd składni wiersza polecenia: brak elementu „:&lt;liczba&gt;” dla opcji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">Opcja /pdb wymaga również użycia opcji /debug </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać wywołania modelu COM z pominiętym parametrem ref przy argumentach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">Błąd składni wiersza polecenia: nieprawidłowy format identyfikatora GUID „{0}” dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">Błąd składni wiersza polecenia: brak identyfikatora Guid dla opcji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">Typ argumentu „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">Typ argumentu nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">Zwracany typ „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">Typ zwracany nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">Typ elementu „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">Typ nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">Typ zmiennej publicznej, chronionej zmiennej lub chronionej zmiennej wewnętrznej musi być zgodny ze specyfikacją CLS (Common Language Specification).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">Identyfikator „{0}” różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">Identyfikator różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda „{0}” różniąca się tylko specyfikacją ref lub out parametru lub rangą tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda różniąca się tylko parametrem ref lub out albo rangą tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda „{0}” różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Przeciążona metoda różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">Ten błąd występuje, gdy przeciążona metoda korzysta z tablicy nieregularnej i jedyną różnicą między sygnaturami metod jest typ elementu tablicy. Aby uniknąć tego błędu, rozważ użycie tablicy regularnej zamiast tablicy nieregularnej, użyj dodatkowego parametru w celu odróżnienia wywołania funkcji, zmień nazwy przeciążonych metod lub usuń atrybut CLSCompliantAttribute, jeśli zgodność ze specyfikacją CLS nie jest wymagana.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">Identyfikator „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">Identyfikator nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">„{0}”: typ podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">Typ podstawowy nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">Typ podstawowy został oznaczony jako element, który nie musi być zgodny ze specyfikacją CLS (Common Language Specification), w zestawie oznaczonym jako zgodny ze specyfikacją CLS. Usuń atrybut określający, że zestaw jest zgodny ze specyfikacją CLS, lub usuń atrybut określający, że typ nie jest zgodny ze specyfikacją CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">„{0}”: interfejsy zgodne ze specyfikacją CLS muszą mieć tylko składowe zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">Interfejsy zgodne ze specyfikacją CLS muszą mieć tylko składowe zgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">„{0}”: tylko składowe zgodne ze specyfikacją CLS mogą być abstrakcyjne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">Tylko składowe zgodne ze specyfikacją CLS mogą być abstrakcyjne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Nie można oznaczyć typu lub składowej jako zgodnej ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'Element „{0}” nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">Typ nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ jest to składowa typu „{1}” niezgodnego ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">Nie można oznaczyć typu jako zgodnego ze specyfikacją CLS, ponieważ jest to składowa typu niezgodnego ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane dla elementu „{0}”, ponieważ nie jest on widoczny spoza tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane, ponieważ nie jest on widoczny spoza tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'Element „{0}” nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Typ lub składowa nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do parametrów. Zamiast tego spróbuj umieścić go w metodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do zwracanych typów. Zamiast tego spróbuj umieścić go w metodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do typów zwracanych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">Typ ograniczenia „{0}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">Typ ograniczenia nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">Pole zgodne ze specyfikacją CLS „{0}” nie może mieć specyfikatora volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">Pole zgodne ze specyfikacją CLS nie może być nietrwałe</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'Element „{0}” nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">Typ nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy nie jest zgodny ze specyfikacją CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">Operator „await” wymaga, aby typ {0} miał odpowiednią metodę „GetAwaiter”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">Nie można zdefiniować oczekiwania na „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">Operator „await” wymaga, aby zwracany typ „{0}” metody „{1}.GetAwaiter()” miał odpowiednie składowe „IsCompleted”, „OnCompleted” i „GetResult” oraz implementował interfejs „INotifyCompletion” lub „ICriticalNotifyCompletion”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">Operator „await” wymaga, aby typ {0} miał przypisaną odpowiednią metodę „GetAwaiter”. Czy brakuje dyrektywy using dla elementu „System”?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">Nie można zdefiniować oczekiwania na „void”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'Operatora „await” nie można użyć jako identyfikatora w metodzie asynchronicznej ani wyrażeniu lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">„{0}” nie implementuje „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression</source>
        <target state="translated">Ponieważ „{0}” jest metodą asynchroniczną, która zwraca wartość „{1}”, po zwrotnym słowie kluczowym nie może występować wyrażenie obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">Typ zwracany metody asynchronicznej musi być elementem void, Task lub Task&lt;T&gt;, typem podobnym do zadania albo elementem IAsyncEnumerable&lt;T&gt; lub IAsyncEnumerator&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">Nie można zwrócić wyrażenia typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">Element „__arglist” jest niedozwolony na liście parametrów metod asynchronicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>Instance of type '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Nie można zachować wystąpienia typu „{0}” w granicach „await” lub „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have pointer type parameters</source>
        <target state="translated">Metody asynchroniczne nie mogą mieć parametrów typu wskaźnika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">Metody asynchroniczne nie mogą zawierać parametrów ref, in ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">Operatora „await” można używać tylko wtedy, gdy zawierająca go metoda lub wyrażenie lambda zostaną oznaczone modyfikatorem „async”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">Operatora „await” można używać tylko w elemencie asynchronicznym {0}. Rozważ oznaczenie elementu {0} za pomocą modyfikatora „async”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">Operatora „await” można używać tylko w metodzie asynchronicznej. Rozważ oznaczenie tej metody za pomocą modyfikatora „async” i zmianę jej typu zwracanego na „Task&lt;{0}&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">Operatora „await” można używać tylko wewnątrz metody asynchronicznej. Rozważ możliwość oznaczenia tej metody za pomocą modyfikatora „async” i zmiany zwracanego przez nią typu na „Task”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania w treści klauzuli „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania wewnątrz klauzuli „catch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">Nie można zdefiniować oczekiwania w wyrażeniu filtru klauzuli „catch”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">Nie można zdefiniować oczekiwania w treści instrukcji „lock”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">Operatora „await” nie można użyć w inicjalizatorze statycznej zmiennej skryptu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">Nie można zdefiniować oczekiwania w kontekście słowa kluczowego „unsafe”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">Modyfikatora „async” można używać tylko w metodach mających treść.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">Atrybutu zabezpieczeń „{0}” nie można zastosować dla metody asynchronicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">Metody asynchroniczne są niedozwolone w interfejsach, klasach lub strukturach z atrybutem „SecurityCritical” lub „SecuritySafeCritical”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">Operatora „await” można użyć tylko w wyrażeniu zapytania w pierwszym wyrażeniu kolekcji początkowej klauzuli „from” albo w wyrażeniu kolekcji klauzuli „join”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">W tej metodzie asynchronicznej brakuje operatorów „await”, dlatego będzie wykonywana synchronicznie. Rozważ możliwość użycia operatora „await” w celu zdefiniowania oczekiwania na nieblokujące wywołania interfejsów API albo wyrażenia „await Task.Run(...)” w celu przeniesienia wykonywania zadań intensywnie angażujących procesor do wątku w tle.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">Metoda asynchroniczna nie zawiera operatorów „await” i zostanie uruchomiona synchronicznie</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">Ponieważ to wywołanie nie jest oczekiwane, wykonywanie bieżącej metody będzie kontynuowane bez oczekiwania na ukończenie wywołania. Rozważ możliwość zastosowania operatora „await” do wyniku wywołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">To wywołanie nie jest oczekiwane, dlatego wykonywanie bieżącej metody będzie kontynuowane do czasu ukończenia wywołania</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">Bieżąca metoda wywołuje metodę asynchroniczną, która zwraca zadanie lub wynik Task&lt;TResult&gt; i która nie stosuje operatora await do wyniku. Wywołanie metody asynchronicznej rozpoczyna zadanie asynchroniczne. Jednak ze względu na niezastosowanie operatora await działanie programu będzie kontynuowane bez oczekiwania na zakończenie zadania. W większości przypadków jest to nieoczekiwane zachowanie. Przeważnie inne aspekty metody wywołującej zależą do wyników wywołania lub przynajmniej działanie wywołanej metody powinno zakończyć się przed powrotem z metody zawierającej wywołanie.

Równie ważnym problemem jest to, co dzieje się z wyjątkami zgłoszonymi przez wywołaną metodę asynchroniczną. Wyjątek zgłoszony w ramach metody zwracającej zadanie lub wynik Task&lt;TResult&gt; jest przechowywany w zwróconym zadaniu. Jeśli nie wykonasz operacji await dla zadania ani jawnie nie wyszukasz wyjątków, wyjątek zostanie utracony. Jeśli wykonasz operację await dla zadania, wyjątek zostanie ponownie zgłoszony.

Najlepsze rozwiązanie to wykonywanie operacji await dla zadania za każdym razem.

Pominięcie ostrzeżenia należy wziąć pod uwagę tylko w sytuacji, gdy na pewno nie chcesz czekać na zakończenie wywołania asynchronicznego oraz gdy wywołana metoda nie zgłosi żadnych wyjątków. W tym przypadku można pominąć ostrzeżenie, przydzielając wynik zadania wywołania do zmiennej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'Atrybutu „MethodImplOptions.Synchronized” nie można stosować do metody asynchronicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerLineNumberAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerFilePathAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Klasy CallerMemberNameAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerLineNumberAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerFilePathAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">Atrybut CallerMemberNameAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerLineNumberAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerLineNumberAttribute nie odniesie żadnego skutku, ponieważ dotyczy on składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Atrybut CallerFilePathAttribute zastosowany do parametru „{0}” nie będzie mieć efektu, ponieważ jest stosowany do składowej używanej w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Atrybut CallerFilePathAttribute nie będzie mieć efektu, ponieważ jest stosowany do składowej używanej w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku, ponieważ dotyczy on składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">Program nie zawiera statycznej metody „Main” odpowiedniej jako punkt wejścia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">Oczekiwano inicjatora tablicy o długości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">Oczekiwano zagnieżdżonego inicjatora tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">Nieprawidłowy modyfikator wariancji. Jako wariant można określić tylko parametry typu interface i delegate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">Nieoczekiwane użycie nazwy z aliasem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">Nieoczekiwane użycie nazwy ogólnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">Nieoczekiwane użycie niepowiązanej nazwy ogólnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">Wyrażenia i instrukcje mogą znajdować się tylko w treści metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">Dostęp do tablicy nie może mieć specyfikatora argumentu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">Ta funkcja językowa („{0}”) nie jest jeszcze zaimplementowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">Wartości domyślne w tym kontekście są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">Błąd podczas otwierania pliku ikony {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">Błąd podczas otwierania pliku manifestu Win32 {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Błąd kompilacji zasobów Win32 — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">Parametry opcjonalne muszą występować po wszystkich parametrach wymaganych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">Nie można dziedziczyć interfejsu „{0}” z określonymi typami parametrów, ponieważ spowoduje to, że metoda „{1}” będzie zawierać przeciążenia, które będą się różnić tylko parametrami ref i out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu i modyfikatory wariancji w takiej samej kolejności</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">Nieprawidłowa wariancja: parametr typu „{1}” musi być elementem {3} prawidłowym dla elementu „{0}”. Element „{1}” to „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">„{0}”: nie może pochodzić od typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">„{0}”: nie może implementować interfejsu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">Ograniczenie nie może być typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">Ograniczenie nie może być typu dynamicznego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można odnaleźć przynajmniej jednego typu wymaganego do skompilowania wyrażenia dynamicznego. Czy nie brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">Długość nazwy „{0}” przekracza maksymalną długość dozwoloną w metadanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">Atrybuty w tym kontekście są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'Alias zewnętrzny w tym kontekście jest nieprawidłowy</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">Użycie elementu „{0}” do testowania zgodności z elementem „{1}” jest w zasadzie identyczne z testowaniem zgodności z elementem „{2}” i powiedzie się dla wszystkich wartości innych niż null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">Testowanie zgodności z typem „dynamic” za pomocą operatora „is” jest zasadniczo identyczne z testowaniem zgodności z typem „Object”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">Nie można użyć instrukcji „yield” w kodzie skryptu najwyższego poziomu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">Nie można zadeklarować przestrzeni nazw w kodzie skryptu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">Atrybuty zestawów i modułów nie są dozwolone w tym kontekście</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">Delegat „{0}” nie ma metody wywołania lub ma metodę wywołania z typem zwracanym lub typami parametrów, które nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global code; ignoring '{0}' entry point.</source>
        <target state="translated">Punkt wejścia programu to kod globalny; punkt wejścia „{0}” jest ignorowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global code; ignoring entry point</source>
        <target state="translated">Punkt wejścia programu to kod globalny; punkt wejścia jest ignorowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">Niespójność dostępności: typ zdarzenia „{1}” jest mniej dostępny niż zdarzenie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">Specyfikacje argumentów nazwanych muszą występować po wszystkich stałych argumentach, które zostały określone. Użyj wersji języka {0} lub nowszej, aby zezwalać na argumenty nazwane inne niż końcowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">Specyfikacje argumentu nazwanego muszą występować po wszystkich stałych argumentach, które zostały określone w dynamicznym wywołaniu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Najlepsza metoda przeładowania dla elementu „{0}” nie ma parametru o nazwie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Delegat „{0}” nie ma parametru o nazwie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">Nazwanego argumentu „{0}” nie można wprowadzać wiele razy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">Nazwany argument „{0}” określa parametr, dla którego argument pozycyjny został już wskazany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">Nazwany argument „{0}” jest używany poza pozycją, ale następuje po nim nienazwany argument</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">Nie można określić wartości domyślnej parametru w połączeniu z klasami DefaultParameterAttribute lub OptionalAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">Wartość domyślna parametru „{0}” musi być stałą czasu kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">Parametr ref lub out nie może mieć wartości domyślnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">Nie można określić wartości domyślnej dla parametru „this”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter collection</source>
        <target state="translated">Nie można określić wartości domyślnej dla tablicy parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">Wartości typu „{0}” nie można użyć jako domyślnego parametru, ponieważ nie ma standardowych konwersji do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">Wartości typu „{0}” nie można użyć jako domyślnego parametru dla parametru dopuszczającego wartość null „{1}”, ponieważ typ „{0}” nie jest typem prostym</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'Typ elementu „{0}” to „{1}”. Wartość domyślnego parametru typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Domyślna wartość określona dla parametru „{0}” nie odniesie żadnego skutku, ponieważ jest zastosowana dla składowej używanej w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Zastosowanie określonej wartości domyślnej nie odniesie żadnego skutku, ponieważ dotyczy ona składowej, która jest używana w kontekstach niezezwalających na argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z pliku „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z kontenera „{0}” — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">Operator typeof nie może zostać użyty dla typu dynamicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operacji dynamicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">Asynchronicznych wyrażeń lambda nie można konwertować na drzewa wyrażeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można zdefiniować klasy ani składowej korzystającej z typu „dynamic”, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">Nie można przekazać wartości null dla nazwy przyjaznego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">W pliku klucza „{0}” brakuje klucza prywatnego potrzebnego do podpisania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">Określono publiczne podpisywanie, które wymaga klucza publicznego, lecz nie podano klucza publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">Publiczne podpisywanie nie jest obsługiwane w przypadku modułów sieciowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">Określony ciąg wersji „{0}” jest niezgodny z wymaganym formatem — major[.minor[.build[.revision]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">Określony ciąg wersji „{0}” zawiera znaki wieloznaczne, które nie są zgodne z determinizmem. Usuń znaki wieloznaczne z ciągu wersji lub wyłącz determinizm dla tej kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">Określony ciąg wersji „{0}” nie jest zgodny z wymaganym formatem — major.minor.build.revision (bez znaków wieloznacznych)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Określony ciąg wersji „{0}” nie jest zgodny z zalecanym formatem — major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">Pliki wykonywalne nie mogą być zestawami satelity, element Culture powinien zawsze być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</source>
        <target state="translated">Nie podano argumentu odpowiadającego wymaganemu parametrowi „{0}” z „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">Przełącznik wiersza polecenia „{0}” nie został jeszcze wdrożony i został zignorowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">Przełącznik wiersza polecenia nie jest jeszcze zaimplementowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">Wyemitowanie modułu „{0}” nie powiodło się: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Ustalonego, lokalnego elementu „{0}” nie można używać w metodzie anonimowej, wyrażeniu lambda ani wyrażeniu zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać specyfikacji argumentu nazwanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać połączenia lub wywołania, które używa argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać właściwości indeksowanej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">Właściwość indeksowana „{0}” ma nieopcjonalne argumenty, które muszą być określone</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">Właściwość indeksowana „{0}” musi mieć wszystkie argumenty opcjonalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">Wystąpienia typu „{0}” nie można użyć wewnątrz funkcji zagnieżdżonej, wyrażenia zapytania, bloku iteratora ani metody asynchronicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">Pierwszy argument atrybutu zabezpieczeń musi być prawidłową wartością SecurityAction</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">Atrybut zabezpieczeń „{0}” ma nieprawidłową wartość SecurityAction „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla typu lub metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutu PrincipalPermission</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">Nie można rozpoznać ścieżki pliku „{0}” określonej dla argumentu nazwanego „{1}” atrybutu PermissionSet</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">Błąd podczas odczytu pliku „{0}” określonego przez argument nazwany „{1}” atrybutu PermissionSet: „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można odnaleźć nazwy typu „{0}” w globalnej przestrzeni nazw. Ten typ został przesłany dalej do zestawu „{1}”. Rozważ możliwość dodania odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można odnaleźć nazwy typu „{0}” w przestrzeni nazw „{1}”. Ten typ został przesłany dalej do zestawu „{2}”. Rozważ możliwość dodania odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">Nie można znaleźć nazwy typu „{0}”. Ten typ został przekazany do zestawu „{1}”. Rozważ dodanie odwołania do tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">Zestawy „{0}” i „{1}” odwołują się do tych samych metadanych, ale tylko jeden z nich jest odwołaniem połączonym (określonym za pomocą opcji /link); rozważ usunięcie jednego z odwołań.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">Atrybut zabezpieczeń „{0}” jest nieprawidłowy w tym typie deklaracji. Atrybuty zabezpieczeń są prawidłowe tylko dla deklaracji zestawu, typu i metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">Nie można użyć wyrażenia typu „{0}” jako argumentu do operacji przydzielanej dynamicznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">Nie można użyć wyrażenia lambda jako argumentu do operacji przydzielanej dynamicznie bez uprzedniego rzutowania go na delegata lub typ drzewa wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">Nie można użyć grupy metod jako argumentu do operacji przydzielanej dynamicznie. Czy zamierzane było wywołanie metody?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Wywołanie metody „{0}” musi być przydzielane dynamicznie, lecz to nie jest możliwe, ponieważ jest ona częścią wyrażenia dostępu bazowego. Rozważ rzutowanie argumentów dynamicznych lub wyeliminowanie dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">Wyrażenia zapytań w odniesieniu do typu źródła „dynamic” lub z sekwencją złączenia typu „dynamic” nie są dozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Dostęp indeksatora musi być przydzielany dynamicznie, ale jest to niemożliwe, ponieważ jest częścią wyrażenia dostępu bazowego. Rozważ możliwość rzutowania argumentów dynamicznych lub wykluczenia dostępu bazowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">Dynamicznie przydzielane wywołanie metody „{0}” może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">Dynamicznie przydzielane wywołanie może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">„{0}” nie ma odpowiedniej metody o nazwie „{1}”, ale wygląda na to, że ma metodę rozszerzenia o tej nazwie. Metody rozszerzenia nie mogą być przydzielane dynamicznie. Rozważ rzutowanie dynamicznych argumentów lub wywołanie metody rozszerzenia bez składni metody rozszerzenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerFilePathAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerFilePathAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Zastosowanie elementu CallerFilePathAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">Wyrażenie musi umożliwiać niejawną konwersję na typ Boolean lub jego typ „{0}” musi definiować operator „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'Element „{0}” nie może implementować elementu „{1}”, ponieważ „{2}” to zdarzenie środowiska wykonawczego systemu Windows, a „{3}” to zwykłe zdarzenie środowiska .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">Wywołaj metodę Call System.IDisposable.Dispose() dla alokowanego wystąpienia elementu {0}, zanim wszystkie odwołania do niego znajdą się poza zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">Wywołaj metodę System.IDisposable.Dispose() dla alokowanego wystąpienia zanim wszystkie odwołania do niego znajdą się poza zakresem</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">Alokowane wystąpienie elementu {0} nie jest usuwane we wszystkich ścieżkach wyjątku. Wywołaj metodę System.IDisposable.Dispose(), zanim wszystkie odwołania do niego znajdą się poza zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">Nie usunięto alokowanego wystąpienia ze wszystkich ścieżek wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">Obiektu „{0}” nie można usunąć więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">Nie można usunąć obiektu więcej niż raz</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}”. Użyj zamiast tego odpowiedniego interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Typu „{0}” nie można osadzić, ponieważ to jest typ zagnieżdżony. Rozważ ustawienie właściwości „Osadź typy międzyoperacyjne” na wartość false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Typ „{0}” nie może być osadzony, ponieważ ma on argument ogólny. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">Osadzona struktura międzyoperacyjna „{0}” może zawierać tylko publiczne pola wystąpień.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Zdarzenia środowiska wykonawczego systemu Windows nie można przekazać jako parametru ze specyfikatorem out lub ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">Interfejs źródłowy „{0}” nie zawiera metody „{1}” wymaganej do osadzenia zdarzenia „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">Interfejs „{0}” zawiera nieprawidłowy interfejs źródłowy wymagany do osadzenia zdarzenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}”, ponieważ brakuje w nim wymaganego atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}” lub „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Nie można osadzić typu międzyoperacyjnego „{0}” znajdującego się jednocześnie w zestawach „{1}” i „{2}”. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Osadzenie typu międzyoperacyjnego „{0}” z zestawu „{1}” powoduje konflikt nazw w bieżącym zestawie. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego „{0}” z powodu pośredniego odwołania do tego zestawu utworzonego przez zestaw „{1}”. Rozważ zmianę właściwości „Osadź typy międzyoperacyjne” w jednym z zestawów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego z powodu pośredniego odwołania do tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">Dodano odwołanie do zestawu przy użyciu opcji /link (ustawienie wartości True dla właściwości Osadź typy międzyoperacyjne). Nakazuje to kompilatorowi osadzenie informacji o typie międzyoperacyjnym z tego zestawu. Jednak kompilator nie może osadzić informacji o typie międzyoperacyjnym z tego zestawu, ponieważ inny przywoływany zestaw odwołuje się do tego zestawu przy użyciu opcji /reference (ustawienie wartości False dla właściwości Osadź typy międzyoperacyjne).

Aby osadzić informacje o typie międzyoperacyjnym dla obu zestawów, użyj opcji /link dla odwołań do każdego zestawu (ustaw wartość True dla właściwości Osadź typy międzyoperacyjne).

Aby usunąć ostrzeżenie, możesz zamiast tego użyć opcji /reference (ustaw wartość False dla właściwości Osadź typy międzyoperacyjne). W takiej sytuacji informacje o typie międzyoperacyjnym udostępnia podstawowy zestaw międzyoperacyjny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">Typ „{0}” z zestawu „{1}” nie może być używany między granicami zestawów, ponieważ ma argument typu ogólnego, który jest osadzonym typem międzyoperacyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">Nie można znaleźć typu międzyoperacyjnego zgodnego z osadzonym typem międzyoperacyjnym „{0}”. Czy brakuje odwołania do zestawu?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">Nazwa modułu „{0}” przechowywana w elemencie „{1}” musi być zgodna z nazwą jego pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa modułu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">Nieprawidłowa wartość „{0}”: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">Ścieżka AppConfigPath musi być bezwzględna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Atrybut „{0}” z modułu „{1}” zostanie zignorowany na korzyść wystąpienia w źródle</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Atrybut zostanie zignorowany na rzecz wystąpienia w źródle</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">Atrybut „{0}” podany w pliku źródłowym jest w konflikcie z opcją „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">Ustalony bufor może mieć tylko jeden wymiar.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">Przywoływany zestaw „{0}” nie ma silnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">Przywoływany zestaw nie ma silnej nazwy</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">W atrybucie AssemblySignatureKeyAttribute określono nieprawidłowy klucz publiczny sygnatury.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Typ przesłany „{0}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” przesłanym do zestawu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">Przywoływany zestaw „{0}” ma inne ustawienie kultury — „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">Przywoływany zestaw ma inne ustawienie kultury</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">Zestaw agnostyczny nie może mieć modułu specyficznego dla procesora „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">Zestaw i moduł „{0}” nie mogą wskazywać różnych procesorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">Celem przywołanego zestawu „{0}” jest inny procesor.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">Celem przywołanego zestawu jest inny procesor</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">Wystąpił błąd kryptograficzny w czasie tworzenia mieszań.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">Brak odwołania do modułu netmodule „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">Moduł „{0}” jest już zdefiniowany w tym zestawie. Nazwa pliku każdego modułu musi być unikatowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">Nie można odczytać pliku konfiguracyjnego „{0}” — „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">Nie można kontynuować, ponieważ edycja zawiera odwołanie do typu osadzonego: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">Dostęp do składowej „{0}” dodanej podczas bieżącej sesji debugowania można uzyskać tylko w deklarowanym zestawie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">Nie można równocześnie określić opcji kompilacji „{0}” i „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">Połączone metadane modułu netmodule muszą określać pełny obraz PE: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred można używać tylko z /t:exe, /t:winexe i /t:appcontainerexe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;lista ścieżek&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;tekst&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">operator propagowania wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">metoda z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">właściwość z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">indeksator z wyrażeniem w treści</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">inicjator właściwości automatycznej</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;przestrzeń nazw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">zmienne lokalne i wartości zwracane byref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">odwołania tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">struktury ref</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">Kompilacja (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">Węzeł składni znajduje się poza drzewem składni</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Lokalizacja musi być określona, aby zapewnić minimalną kwalifikację typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Klasa SyntaxTreeSemanticModel musi być dostępna, aby zapewnić minimalną kwalifikację typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">Nie można odwołać się do kompilacji typu „{0}” z kompilacji {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">Drzewo składni już istnieje</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">Przesłanie może zawierać tylko kod skryptu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">Przesłanie może mieć co najwyżej jedno drzewo składni.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">drzewo musi zawierać węzeł główny z elementem SyntaxKind.CompilationUnit</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">Argument typu nie może mieć wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">Nieprawidłowa liczba argumentów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">Nazwa {0} powoduje konflikt nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">Kombinacja opcji elementu LookupOptions jest nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">Element items: nie może być pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier lub Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier do utworzenia tokenów identyfikatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów znakowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów liczbowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">Tej metody można użyć tylko do tworzenia tokenów — element {0} nie jest rodzajem tokenu.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">Ogólny parametr jest definicją, a oczekiwano odwołania {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">Wywołano metodę GetDeclarationName dla węzła deklaracji, który może zawierać wiele deklaratorów zmiennych.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">Pozycja nie znajduje się w drzewie składni o pełnym zasięgu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">Nazwa języka „{0}” jest nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">Nazwa języka jest nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">Dostęp do składowej z użyciem przezroczystego identyfikatora dla pola „{0}” typu „{1}” nie powiódł się. Czy odpytywane dane implementują wzorzec zapytania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">Parametr ma wiele różnych domyślnych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">Pole ma wiele unikatowych wartości stałych.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">To nie symbol języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">Niepotrzebna dyrektywa using.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">Nieużywany alias zewnętrzny.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">Elementy nie mogą mieć wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">zmienna środowiskowa LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">opcja /LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH opcja</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">katalog nie istnieje</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">ścieżka jest za długa lub nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">Nie znaleziono wartości elementu RuntimeMetadataVersion. Nie znaleziono żadnego zestawu zawierającego element System.Object ani nie określono wartości elementu RuntimeMetadataVersion za pomocą opcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">Nie odnaleziono wartości elementu RuntimeMetadataVersion</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">Oczekiwano elementu SemanticModel {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">wyrażenie lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 1. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 2. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 3. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 4. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 5. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 6. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.0. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">„eksperymentalna”</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">Pozycja musi znajdować się w zasięgu drzewa składni.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">Drzewo składni do przeanalizowania nie może należeć do drzewa składni bieżącej kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">Tworzenie łańcuchów spekulacyjnego modelu semantycznego nie jest obsługiwane. Należy utworzyć model spekulacyjny z nadrzędnego modelu niespekulacyjnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Kompilator Microsoft (R) Visual C#</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} w wersji {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Obsługiwane wersje językowe:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">„{0}”: klasa o atrybucie ComImport nie może określać inicjatorów pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">Lokalna nazwa „{0}” jest za długa dla pliku PDB. Rozważ skrócenie jej lub skompilowanie bez opcji /debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">Nazwa lokalna jest za długa dla pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">Funkcja anonimowa przekonwertowana na delegata zwracającego typ void nie może zwracać wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a '{0}' returning delegate cannot return a value</source>
        <target state="translated">Asynchroniczne wyrażenie lambda przekonwertowana na delegata zwracającego „{0}” nie może zwracać wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">Wystąpienia analizatora {0} nie można utworzyć z elementu {1}: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">Nie można utworzyć wystąpienia analizatora</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">Zestaw {0} nie zawiera żadnych analizatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">Zestaw nie zawiera analizatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">Nie można załadować zestawu analizatora {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">Nie można załadować zestawu analizatora</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">Niektóre typy zestawu analizatora {0} zostaną pominięte z powodu wyjątku ReflectionTypeLoadException: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">Błąd podczas odczytywania pliku zestawu reguł {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">Błąd podczas odczytywania informacji dotyczących debugowania elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">Operacja spowodowała przepełnienie stosu.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">Oczekiwano identyfikatora lub literału liczbowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">Oczekiwano identyfikatora lub literału liczbowego</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties, or properties that use the 'field' keyword, can have initializers.</source>
        <target state="needs-review-translation">Tylko właściwości zaimplementowane automatycznie mogą mieć inicjatory.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">Właściwości zaimplementowane automatycznie w interfejsach muszą mieć metody dostępu get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">Automatycznie implementowane właściwości muszą przesłaniać wszystkie metody dostępu przesłanianej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">Struktury bez jawnych konstruktorów nie mogą zawierać składowych z inicjatorami.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">Nie można wyemitować informacji debugowania dla tekstu źródłowego bez kodowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">Treści bloku i treści wyrażenia nie mogą być jednocześnie udostępnione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">Kontrolka nie może wykraczać poza przełącznik z końcowej etykiety case („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">Argumenty typu nie są dozwolone w operatorze nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać operatora propagowania wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać inicjatora słownika.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">Metoda Add rozszerzenia nie jest obsługiwana w przypadku inicjatora kolekcji w operatorze lambda wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">operator nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">inicjator słownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">Brak zamykającego znaku ograniczającego „}” dla interpolowanego wyrażenia rozpoczynającego się od znaku „{”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">W ciągu interpolowanym nie można użyć jednowierszowego komentarza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">Wyrażenie jest zbyt długie lub zbyt złożone do skompilowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">Wyrażenie nie ma nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">Podwyrażenie nie może być używane w argumencie operatora „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">Nazwa kwalifikowana za pomocą aliasu nie jest wyrażeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">Parametry typu nie są dozwolone w grupie metod jako argument operatora „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">Oczekiwano elementu SearchCriteria.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">Ciągi kultury zestawu nie mogą zawierać osadzonych znaków NUL.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">ciągi interpolowane</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">Instrukcja await w blokach catch i finally</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">literały binarne</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">separatory cyfr</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">funkcje lokalne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">W przypadku znaku „{0}” należy zastosować ucieczkę (przez wpisanie dwóch takich znaków) w ciągu interpolowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">W przypadku znaku „{0}” ucieczkę można zastosować tylko przez wpisanie dwóch znaków „{0}{0}” w ciągu interpolowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">Specyfikator formatu nie może kończyć się białym znakiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">Pusty specyfikator formatu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">Wystąpił błąd w przywoływanym zestawie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">Oczekiwano wyrażenia lub instrukcji deklaracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">Grupy metod rozszerzeń nie są dozwolone jako argument elementu „nameof”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">Wartość wyrównania {0} jest większa niż {1} i może powodować powstanie ciągu w dużym formacie.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">Nieużywany alias zewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">Niepotrzebna dyrektywa using</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">Pomiń ładowanie typów w zestawie analizatora zakończonych niepowodzeniem z powodu wyjątku ReflectionTypeLoadException</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">Wartość wyrównania może powodować powstanie ciągu w dużym formacie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">Długość stałej typu String w wyniku łączenia przekracza wartość System.Int32.MaxValue. Spróbuj podzielić ciąg na wiele stałych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">Krotka musi zawierać co najmniej dwa elementy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">Punkt wejściowy debugowania musi być definicją metody zadeklarowanej w bieżącej kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">element #load jest dozwolony tylko w skryptach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">Nie można używać elementu #load po pierwszym tokenie w pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">Nie można znaleźć pliku.</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">Element SyntaxTree jest wynikiem dyrektywy #load i nie można go bezpośrednio usunąć ani zastąpić.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">Odwołania do plików źródłowych nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">Opcja pathmap jest nieprawidłowo sformatowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">Nieprawidłowy literał liczby rzeczywistej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">Właściwości zaimplementowane automatycznie nie mogą zwracać wartości przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">Właściwości zwracające wartość przez referencję muszą mieć metodę dostępu get</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">Właściwości zwracające wartość przez referencję nie mogą mieć metod dostępu set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">Element „{0}” musi odpowiadać zwracanej przez referencję przesłoniętej składowej „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">Wartości zwracane przez referencję mogą być używane tylko w metodach zwracających wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">Wartości zwracanych przez wartość można użyć tylko w metodach zwracających wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">Zwracane wyrażenie musi być typu „{0}”, ponieważ ta metoda zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ nie ma pasującej wartości zwracanej przez referencję.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">Treść elementu „{0}” nie może być blokiem iteratora, ponieważ element „{0}” zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">Wyrażeń lambda, które zwracają wartość przez referencję, nie można przekonwertować na drzewa wyrażeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">Drzewo wyrażenia lambda nie może zawierać wywołania metody, właściwości ani indeksatora, który zwraca wartość przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">Nie można użyć wyrażenia w tym kontekście, ponieważ może ono nie zostać przekazane lub zwrócone przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić elementu „{0}” przez referencję, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Nie można zwrócić przez referencję składowej elementu „{0}”, ponieważ została ona zainicjowana przy użyciu wartości, której nie można zwrócić przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">Elementu „{0}” nie można zwrócić przez referencję, ponieważ jest tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">Nie można zwrócić zmiennej zakresu „{0}” przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">Nie można zwrócić elementu „{0}” przez referencję, ponieważ to jest element „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">Nie można zwrócić pola tylko do odczytu przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">Statycznego pola tylko do odczytu nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Składowych pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Pól statycznego pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref parameter</source>
        <target state="translated">Nie można zwrócić parametru przez referencję „{0}”, ponieważ to nie jest parametr referencyjny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">Nie można zwrócić składowej parametru „{0}” przez referencję, ponieważ to nie jest parametr ref ani out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Nie można zwrócić zmiennej lokalnej „{0}” przez referencję, ponieważ to nie jest zmienna lokalna ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Nie można zwrócić składowej zmiennej lokalnej „{0}” przez referencję, ponieważ to nie jest zmienna lokalna ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">Składowe struktury nie mogą zwracać obiektu „this” ani innych składowych wystąpienia przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">Nie można używać wyrażenia w tym kontekście, ponieważ pośrednio może ujawniać zmienne poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Nie można używać wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Nie można używać składowej wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Ta kombinacja argumentów dla elementu „{0}” jest niedozwolona, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Gałęzie operatora warunkowego ref nie mogą przywoływać zmiennych z niezgodnymi zakresami deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">Nie można używać wyniku wyrażenia stackalloc typu „{0}” w tym kontekście, ponieważ może zostać ujawniony poza metodą zawierającą</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">Nie można zainicjować zmiennej dostępnej przez wartość za pomocą odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">Nie można zainicjować zmiennej dostępnej przez odwołanie za pomocą wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">Wyrażenie musi być typu „{0}”, ponieważ jest przypisywane przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">Deklaracja zmiennej dostępnej przez odwołanie musi mieć inicjator</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Nie można użyć zmiennej lokalnej typu ref „{0}” wewnątrz metody anonimowej, wyrażenia lambda ani wyrażenia zapytania</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Odwołanie zwrócone przez wywołanie „{0}” nie może zostać zachowane w granicach „await” lub „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'Element „await” nie może być używany w wyrażeniu zawierającym operator warunkowy ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">Obie wartości operatora warunkowego muszą być wartościami ref lub żadna z nich nie może być wartością ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">Wyrażenie musi być typu „{0}”, aby było zgodne z alternatywną wartością ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać odwołania do funkcji lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">Nie można przekazać argumentu z dynamicznym typem do parametru params „{0}” lokalnej funkcji „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">Drzewo składni powinno zostać utworzone na podstawie przesłanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">Całkowita długość ciągów użytkownika używanych przez program przekracza dozwolony limit. Spróbuj ograniczyć użycie literałów ciągów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</source>
        <target state="translated">Użycie typu dopuszczającego wartość null „{0}?” jest niedozwolone we wzorcu. Użyj zamiast tego bazowego typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">Wystąpił błąd podczas zapisywania pliku wyjściowego: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">Nazwy elementów krotek muszą być unikatowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">Nazwa elementu krotki „{0}“ jest dozwolona tylko na pozycji {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">Nazwa elementu krotki „{0}“ nie jest dozwolona na żadnej pozycji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">Nie znaleziono składowej „{0}” dla typu „{1}” z zestawu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">krotki</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">Nie znaleziono odpowiedniego wystąpienia „Deconstruct” lub metody rozszerzenia dla typu „{0}” z {1} parametrami wyjściowymi i typem zwracanym void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">Przypisanie dekonstrukcji wymaga wyrażenia o typie podanym po prawej stronie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">Wyrażenie switch musi być wartością; znaleziono element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">Atrybut „{0}” jest ignorowany w przypadku określenia podpisywania publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">Atrybut jest ignorowany w przypadku określenia podpisywania publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">Opcja „{0}” musi być ścieżką bezwzględną.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">Nie można przekonwertować krotki z {0} elementami na typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">deklaracja zmiennej wyjściowej</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">Odwołanie do zmiennej wyjściowej z niejawnym typem „{0}” jest niedozwolone na tej samej liście argumentów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">Nie można wywnioskować typu zmiennej wyjściowej z niejawnym typem „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">Nie można wnioskować typu wprowadzonej niejawnie zmiennej dekonstrukcji „{0}“.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">Nie można wywnioskować typu odrzucenia o typie określonym niejawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">Nie można dekonstruować krotki „{0}” elementów do „{1}” zmiennych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">Nie można dekonstruować obiektów dynamicznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">Dekonstrukcja musi zawierać co najmniej dwie zmienne.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została zignorowana, ponieważ typ elementu docelowego „{1}” określa inną nazwę lub nie określa żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">Nazwa elementu krotki została zignorowana, ponieważ element docelowy przypisania określa inną nazwę lub nie określa żadnej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">Wstępnie zdefiniowany typ „{0}” musi być strukturą.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'Atrybutu „new” nie można użyć z typem krotki. Użyj wyrażenia literału krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">Forma „var (...)” dekonstrukcji nie zezwala na specyficzny typ wartości „var”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Nie można zdefiniować klasy lub składowej, która wykorzystuje krotki, ponieważ nie można znaleźć wymaganego typu kompilatora „{0}”. Czy brakuje odwołania?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">Nie można odwołać się do atrybutu „System.Runtime.CompilerServices.TupleElementNamesAttribute” jawnie. Użyj składni krotek, aby zdefiniować nazwy krotek.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać deklaracji zmiennej argumentu wyjściowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać odrzucenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać operatora zgodnego z wzorcem „is”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać literału krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">Drzewo wyrażenia nie może zawierać konwersji krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">Przełącznik /sourcelink jest obsługiwany tylko w przypadku emitowania pliku PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">Przełącznik /embed jest obsługiwany tylko w przypadku emitowania pliku PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">Nieprawidłowy rodzaj instrumentacji: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">Składnia „var (...)“ jako wartość lvalue jest zastrzeżona.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">Oczekiwano symbolu { lub ; lub =&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">Wyrażenie throw jest niedozwolone w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">Deklaracja jest niedozwolona w tym kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Pętla foreach musi deklarować swoje zmienne iteracji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">Nazwy elementów krotek nie są dozwolone po lewej stronie dekonstrukcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">Aby rzutować wartość ujemną, musisz ją ująć w nawias.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">Drzewo wyrażeń nie może zawierać wyrażenia throw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">Nieprawidłowa nazwa zestawu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">Aby typ „{0}” mógł zostać użyty jako element AsyncMethodBuilder dla typu „{1}”, jego właściwość zadania powinna zwracać typ „{1}” zamiast typu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">Moduł „{0}” w zestawie „{1}” przekazuje typ „{2}” do wielu zestawów: „{3}” i „{4}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">Używanie typu „dynamic” we wzorcu nie jest dozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">Podany tryb dokumentacji jest nieobsługiwany lub nieprawidłowy: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">Podany rodzaj kodu źródłowego jest nieobsługiwany lub nieprawidłowy: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">Podana wersja języka jest nieobsługiwana lub nieprawidłowa: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.1. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.2. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">Określona wersja „{0}” języka nie może mieć zer wiodących</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">Nie można przypisać wyrażenia typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Element „{0}” jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach. Wstrzymaj tę diagnostykę, aby kontynuować.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Typ jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach. Wstrzymaj tę diagnostykę, aby kontynuować.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">Wersja kompilatora: „{0}”. Wersja języka: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">asynchroniczna funkcja main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">Nazwa elementu krotki „{0}” została wywnioskowana. Użyj wersji języka {1} lub nowszej, aby uzyskać dostęp do elementu według jego wywnioskowanej nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">Spójna kolekcja nie może zawierać wartości typu „void”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">Punkt wejścia zwracający wartości void lub int nie może być asynchroniczny</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}” w języku C# {2}. Użyj języka w wersji {3} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">Funkcja lokalna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">Funkcja lokalna jest zadeklarowana, ale nie jest nigdy używana</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="translated">Funkcja lokalna „{0}” musi deklarować treść, ponieważ nie jest oznaczona jako „static extern”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">Nie można odczytać informacji debugowania metody „{0}” (token 0x{1:X8}) z zestawu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} nie jest prawidłowym wyrażeniem konwersji języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">Nie można przekazać argumentu o typie dynamicznym do ogólnej funkcji lokalnej „{0}” z argumentami typu wywnioskowanego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">wiodący separator cyfr</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">Nie używaj elementu „{0}”. Jest on zarezerwowany do użycia przez kompilator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">Nazwa typu „{0}” jest zarezerwowana do użycia przez kompilator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">Pierwszy parametr „in” lub „ref „readonly” metody rozszerzenia „{0}” musi być konkretnym (nie ogólnym) typem wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">Wystąpienia pól struktur tylko do odczytu muszą być tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">Automatycznie implementowane właściwości wystąpienia w strukturach tylko do odczytu muszą być tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">Zdarzenia podobne do pól nie są dozwolone w strukturach tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">metody rozszerzenia ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">Konwersja wyrażenia stackalloc typu „{0}” na typ „{1}” nie jest możliwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">Pierwszy parametr metody rozszerzenia „ref” „{0}” musi być typem wartości lub typem ogólnym ograniczonym do struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">W parametrze wejściowym nie może występować atrybut wyjściowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} nie jest prawidłową złożoną operacją przypisania w języku C#</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”, rozważ usunięcie klauzuli catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”, rozważ usunięcie bloku try-catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">Wyrażenie filtru jest stałą wartością „false”. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">Element __arglist nie może mieć argumentu typu void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">Wyrażenie warunkowe nie może być używane bezpośrednio w interpolacji ciągu, ponieważ znak „:” kończy interpolację. Umieść wyrażenie warunkowe w nawiasie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">Nie używaj atrybutu „System.Runtime.CompilerServices.FixedBuffer” względem właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku C# 7.3. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">Atrybuty docelowe dla pól w ramach właściwości automatycznych nie są obsługiwane w języku w wersji {0}. Użyj języka w wersji {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">Atrybuty docelowe dla pól w ramach właściwości automatycznych nie są obsługiwane w tej wersji języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">strumienie asynchroniczne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">„{0}”: typ użyty w asynchronicznej instrukcji using musi implementować typ „System.IAsyncDisposable” lub odpowiednią metodę „DisposeAsync”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">Asynchroniczna instrukcja foreach wymaga, aby zwracany typ „{0}” elementu „{1}” miał odpowiednią metodę publiczną „MoveNextAsync” i właściwość publiczną „Current”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Asynchroniczna instrukcja foreach nie może używać zmiennych typu „{0}”, ponieważ implementuje wiele utworzeń wystąpienia elementu „{1}”. Spróbuj rzutowania na konkretne utworzenie wystąpienia interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</source>
        <target state="translated">Operatory konwersji, równości lub nierówności zadeklarowane w interfejsach muszą być abstrakcyjne lub wirtualne</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">Docelowe środowisko uruchomieniowe nie obsługuje domyślnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">Element „{0}” nie może implementować składowej interfejsu „{1}” w typie „{2}”, ponieważ docelowe środowisko uruchomieniowe nie obsługuje domyślnej implementacji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</source>
        <target state="translated">Element „{0}” nie implementuje składowej interfejsu „{1}”. Element „{2}” nie może niejawnie zaimplementować niepublicznego elementu członkowskiego w języku C# {3}. Użyj wersji językowej „{4}” lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">Składowa interfejsu „{0}” nie ma najbardziej specyficznej implementacji. Ani implementacja „{1}”, ani „{2}” nie jest najbardziej specyficzna.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>