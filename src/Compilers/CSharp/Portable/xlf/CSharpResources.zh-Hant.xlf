<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">無法從另一個建構的泛型型別建立建構的泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">無法從另一個非泛型型別建立建構的泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">'{0}' 抽象事件無法使用事件存取子語法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">若要在插入的逐字字串使用 '@$' 而不是 '$@'，請使用 '{0}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">無法將運算子 '{0}' 套用至 'default' 和類型為 '{1}' 的運算元，原因是其為未知參考型別的型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">無法在建立物件時使用可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">當透過 'System.Runtime.CompilerServices.ITuple' 進行模式比對時，不允許元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">在運算式中使用可為 Null 的參考型別 '{0}?' 不合法，請改用基礎類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在事件存取子上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">因為自動實作屬性 '{0}' 有 'set' 存取子，所以無法將其標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">無法將自動實作 'set' 存取子 '{0}' 標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance definition for '{1}'</source>
        <target state="translated">因為 '{0}' 不包含適用於 '{1}' 的公用執行個體定義，所以非同步的 foreach 陳述式無法在類型為 '{0}' 的變數上運作</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體定義，所以非同步的 foreach 陳述式無法在型別 '{0}' 的變數上作業。您指的是 'foreach' 而不是 'await foreach' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">無法在非同步 foreach 中使用動態類型的集合</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">/nullable 的選項 '{0}' 無效; 必須為 'disable'、'enable'、'warnings' 或 'annotations'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">typeof 運算子不得用於可為 Null 的參考型別上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">模式比對運算元無效; 需要值，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">命令列語法錯誤: '{0}' 對 '{1}' 選項而言不是有效的值。此值的格式必須是 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">__arglist 不得包含 'in' 或 'out' 傳遞的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">類型參數 '{1}' 有 'unmanaged' 條件約束，因此 '{1}' 不可作為 '{0}' 的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="new">Local function '{0}' must be 'static' in order to use the Conditional attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">類型 '{0}' 的運算式無法由類型 '{1}' 的模式處理。請使用語言 '{2}' 版或更新版本，以比對開放式類型與常數模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">名稱 '{0}' 與對應的 'Deconstruct' 參數 '{1}' 不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">因為類型 '{0}' 有非抽象成員，所以無法內嵌。請考慮將 [內嵌 Interop 類型] 屬性設為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">預設常值沒有目標類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">預設常值 'default' 作為模式無效。請使用另一個適當的常值 (例如 '0' 或 'null')。若要比對所有項目，請使用捨棄模式 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">捨棄模式不可為 switch 陳述式中的 case 標籤。針對捨棄模式，請使用 'case var _:'，針對名為 '_' 的常數，則請使用 'case @_:'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">'{0}' 已明確實作多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">重複 Null 隱藏運算子 ('!')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">在屬性和索引子 '{0}' 的存取子上均無法指定 'readonly' 修飾元。請改在屬性自身上放置 'readonly' 修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">'else' 無法開始陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">不允許明確應用 'System.Runtime.CompilerServices.NullableAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">指定運算式無法用於 fixed 陳述式中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">運算式樹狀結構不可包含 null 聯合指派</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">運算式樹狀架構不可包含 ref 結構或限制型別 '{0}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="new">An expression tree may not contain a from-end index ('^') expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternIndexOrRangeIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="new">An expression tree may not contain a pattern System.Index or System.Range indexer access</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="new">An expression tree may not contain a range ('..') expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">運算式樹狀結構不可包含 switch 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">運算式樹狀架構不得包含元組 == 或 != 運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'{0}': 外部事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">功能 '{0}' 目前處於預覽階段，且*不受支援*。若要使用預覽功能，請使用「預覽語言」版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">功能 '{0}' 仍在實驗階段且不具支援；請使用 '/features:{1}' 來啟用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 8.0 中無法使用功能 '{0}'。請使用 {1} 或更新的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 8.0 中無法使用功能 '{0}'。請使用 {1} 或更新的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">類似欄位的事件 '{0}' 不能是 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體定義，所以 foreach 陳述式無法在型別 '{0}' 的變數上作業。您指的是 'await foreach' 而不是 'foreach' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">在相同區塊內，goto 不可跳到 using 宣告前的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">goto 不可跳到 using 宣告後的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">此內容不允許隱藏項目運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">隱含 Index 索引子的引動過程無法為引數命名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">隱含 Range 索引子的引動過程無法為引數命名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">具有 'in' 修飾元的引數不可用於動態分派的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">因為介面成員 '{1}' 包含 __arglist 參數，所以 '{0}' 無法在類型 '{2}' 中實作此介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">C# 編譯器中的內部錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">雜湊演算法名稱無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">無效的物件建立</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">無法同時在屬性或索引子 '{0}' 和其存取子上同時指定 'readonly' 修飾元。請移除其中一個。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">"陣序規範無效: 必須是 ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">在 is-type 運算式中使用可為 Null 的參考型別 '{0}' 不合法嗎? 請改用基礎類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">類型為 '{0}' 的運算式永遠無法符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">具有迭代區塊的方法 '{0}' 必須為「非同步」才能傳回 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">缺少模式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">多個分析器組態檔無法處於相同目錄 ('{0}') 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">無法在多個參數上使用屬性 [EnumeratorCancellation]。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">new()' 條件約束不能和 'unmanaged' 條件約束一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">'{0}': 在非同步 using 陳述式中使用的類型，必須可隱含地轉換為 'System.IAsyncDisposable' 或實作合適的 'DisposeAsync' 方法。您指的是否為 'using'，而非 'await using'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">'{0}': using 陳述式中使用的類型必須可以隱含轉換為 'System.IDisposable'。您指的是 'await using' 而不是 'using' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="new">Output directory could not be determined</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstraintMustBeFirst">
        <source>The 'notnull' constraint must come before any other constraints</source>
        <target state="translated">'notnull' 限制式必須在所有其他限制式之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">應為 'enable'、'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">必須是 'warnings'、'annotations' 或指示詞結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">'{0}' 值無效: 若是 C# {2}，則為 '{1}'。請使用 '{3}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">可為 Null 的型別參數必須已知為實值型別或不可為 Null 的參考型別。建議新增 'class'、'struct' 或型別條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">out 變數不可宣告為 ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">方法 '{0}' 會為型別參數 '{1}' 指定 'class' 條件約束，但覆寫或明確實作的方法 '{3}' 對應型別參數 '{2}' 不屬於參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">方法 '{0}' 會為型別參數 '{1}' 指定 'struct' 條件約束，但覆寫或明確實作的方法 '{3}' 對應型別參數 '{2}' 是不可為 Null 實值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReadOnlyDifference">
        <source>Both partial method declarations must be readonly or neither may be readonly</source>
        <target state="translated">兩個部份方法宣告必須都為唯讀，或者都不為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">指標類型不允許進行模式比對。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">async-iterator 方法的主體必須包含 'yield' 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">async-iterator 方法的主體必須包含 'yield' 陳述式。建議將 'async' 從方法宣告移除，或新增 'yield' 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">屬性子模式需要對屬性或欄位的參考才能比對，例如 '{{ Name: {0} }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">因為類型 '{0}' 有重新抽象成員 (來自基底介面)，所以無法內嵌。請考慮將 [內嵌 Interop 類型] 屬性設為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 只有在屬性或索引子同時具有 get 和 set 存取子時，才能在存取子上使用 'readonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">不能將 '{1}' 參考指派至 '{0}'，因為 '{1}' 的逸出範圍比 '{0}' 還要窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref local or parameter.</source>
        <target state="translated">參考指派的左側必須為參考本機或參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">目標執行階段不支援介面成員的 'protected'、'protected internal' 或 'private protected' 存取權。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">單一元素解構模式需要一些其他語法才能使其明確。建議在右括弧 ')' 後新增捨棄指示項 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">靜態區域函式不可包含對 'this' 或 'base' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">靜態區域函式不可包含對 '{0}' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">靜態成員 '{0}' 不能標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="new">stdin argument '-' is specified, but input has not been redirected from the standard input stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern has already been handled by a previous arm of the switch expression.</source>
        <target state="translated">模式已由 switch 運算式的前一個標籤處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case has already been handled by a previous case.</source>
        <target state="translated">先前的案例已處理切換案例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">找不到 switch 運算式的最佳類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">switch 主導的運算式前後必須有括弧。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">未預期的字元順序 '...'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">名稱 '{0}' 無法識別元組元素 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">作為 == 或 != 運算子之運算元使用的元組類型，必須具有相符的基數。但此運算子在左側的元組類型為基數 {0}，在右側則為 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">'{0}': 不可在指定條件約束類型的同時，又指定 'unmanaged' 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintMustBeFirst">
        <source>The 'unmanaged' constraint must come before any other constraints</source>
        <target state="translated">'unmanaged' 條件約束必須在所有其他條件約束之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 及任何巢狀層級的所有欄位必須是不可為 null 的值類型，如此才能在泛型型別或方法 '{0}' 中將其用為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">不可直接在 switch 區段內使用 using 變數 (建議使用大括弧)。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">不允許模式的語法 'var' 參考類型，但 '{0}' 在此處的範圍中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">無法在有 'in' 或 'out' 型別參數的介面中宣告列舉、類別和結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">需要 '{1}' 子模式才能比對元組類型 '{0}'，但此處為 '{2}' 子模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">檔案名稱 '{0}' 是空的、包含了無效字元、指定了磁碟機但不是絕對路徑，或太長了。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.
 
                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0-4) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
</source>
        <target state="needs-review-translation">
                             Visual C# 編譯器選項

                       - 輸出檔案 -
-out:&lt;檔案&gt;                   指定輸出檔案名稱 (預設: 含有主要類別
                              之基底檔案的名稱或第一個檔案的名稱)
-target:exe                   建置主控台可執行檔 (預設) (簡短
                              形式: -t:exe)
-target:winexe                建置 Windows 可執行檔 (簡短形式:
                              -t:winexe)
-target:library               建置程式庫 (簡短形式: -t:library)
-target:module                建置可以新增到其他組件的
                              模組 (簡短形式: -t:module)
-target:appcontainerexe       建置 Appcontainer 可執行檔 (簡短形式:
                              -t:appcontainerexe)
-target:winmdobj              建置可供 WinMDExp 取用的 Windows 執行階段
                              中繼檔案 (簡短形式: -t:winmdobj)
-doc:&lt;檔案&gt;                   要產生的 XML 文件檔案
-refout:&lt;檔案&gt;                要產生的參考組件輸出
-platform:&lt;字串&gt;            限制能夠執行此程式碼的平台: x86、
                              Itanium、x64、arm、arm64、anycpu32bitpreferred 或
                              anycpu。預設為 anycpu。

                       - INPUT FILES -
-recurse:&lt;萬用字元&gt;           依據指定的萬用字元，
                              包含目前目錄與子目錄中的
                              所有檔案
-reference:&lt;別名&gt;=&lt;檔案&gt;    使用指定的別名，參考指定組件
                              檔案中的中繼資料 (簡短形式: -r)
-reference:&lt;檔案清單&gt;        參考指定組件檔案中的中繼資料
                              (簡短形式: -r)
-addmodule:&lt;檔案清單&gt;        將指定的模組連結到其組件
-link:&lt;檔案清單&gt;             內嵌指定 Interop 組件檔案中的
                              中繼資料 (簡短形式: -l)
-analyzer:&lt;檔案清單&gt;         執行此組件中的分析器
                              (簡短形式: -a)
-additionalfile:&lt;檔案清單&gt;   不會直接影響程式碼產生，但可能為分析器所用，
                             以產生錯誤或警告的 
                              額外檔案。
-embed                        將所有來源檔案嵌入 PDB。
-embed:&lt;檔案清單&gt;            將特定檔案嵌入 PDB。

                       - RESOURCES -
-win32res:&lt;檔案&gt;              指定 Win32 資源檔案 (.res)
-win32icon:&lt;檔案&gt;             輸出使用此圖示
-win32manifest:&lt;檔案&gt;         指定 Win32 資訊清單檔案 (.xml)
-nowin32manifest              不包含預設的 Win32 資訊清單
-resource:&lt;資源資訊&gt;           內嵌指定的資源 (簡短形式: -res)
-linkresource:&lt;資源資訊&gt;       將指定的資源連結到此組件
                              (簡短形式: -linkres) 其中「資源資訊」的格式
                              為 &lt;檔案&gt;[,&lt;字串名稱&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   發出偵錯資訊
-debug:{full|pdbonly|portable|embedded}
                              指定偵錯類型 ('full' 為預設值;
                              'portable' 為跨平台格式; 
                              'embedded' 為跨平台格式，會嵌入
                              目標 .dll 或 .exe)
-optimize[+|-]                啟用最佳化 (簡短形式: -o)
-deterministic                產生確定性組件
                              (含模組版本 GUID 與時間戳記)
-refonly                      產生用以取主要輸出的參考組件
-instrument:TestCoverage      產生經過檢測的組件以供收集
                              coverage information
-sourcelink:&lt;檔案&gt;            要嵌入 PDB 的來源連結資訊。

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             將所有警告視為錯誤回報
-warnaserror[+|-]:&lt;警告清單&gt; 將特定警告視為錯誤回報
-warn:&lt;n&gt;                     設定警告層級 (0-4) (簡短形式: -w)
-nowarn:&lt;警告清單&gt;           停用特定的警告訊息
-ruleset:&lt;檔案&gt;               指定原則集檔案，以停用特定的
                              診斷。
-errorlog:&lt;檔案&gt;[,version=&lt;sarif 版本&gt;]
                              指定用以記錄所有編譯器與分析器診斷的
                              檔案。
                              sarif 版本:{1|2|2.1} 預設值為 1. 2 及 2.1
                              兩者皆表示 SARIF 版本 2.1.0。
-reportanalyzer               回報額外的分析器資訊，例如
                              執行時間。

                       - LANGUAGE -
-checked[+|-]                 產生溢位檢查
-unsafe[+|-]                  允許不安全的程式碼
-define:&lt;符號清單&gt;         定義條件式編譯符號 (簡短
                              形式: -d)
-langversion:?                顯示允許的語言版本值
-langversion:&lt;字串&gt;         指定語言版本，例如
                              `latest` (最新版本，包含次要版本);
                              `default` (同 `latest`);
                              `latestmajor` (最新版本，但不含次要版本);
                              `preview` (最新版本，含不支援之預覽版中的功能);
                              或特定的版本，例如 `6` 或 `7.1`
-nullable[+|-]                指定可以是 null 的內容選項 enable|disable。
-nullable:{enable|disable|warnings|annotations}
                              指定可以是 null 的內容選項 enable|disable|warnings|annotations。

                       - SECURITY -
-delaysign[+|-]               只使用強名稱金鑰的公開部分
                              延後簽署組件
-publicsign[+|-]              只使用強名稱金鑰的公開部分
                              公開簽署組件
-keyfile:&lt;檔案&gt;               指定強名稱金鑰檔案
-keycontainer:&lt;字串&gt;        指定強名稱金鑰容器
-highentropyva[+|-]           啟用高熵  ASLR

                       - MISCELLANEOUS -
@&lt;檔案&gt;                       讀取回應檔案，以查看更多選項
-help                         顯示此用法訊息 (簡短形式: -?)
-nologo                       不顯示編譯器著作權訊息
-noconfig                     不自動包含 CSC.RSP 檔案
-parallel[+|-]                平行建置。
-version                      顯示編譯器版本號碼後結束。

                       - ADVANCED -
-baseaddress:&lt;位址&gt;        要建置之程式庫的基底位址
-checksumalgorithm:&lt;演算法&gt;      指定演算法，以計算儲存在 PDF 中之
                              來源檔案的總和檢查碼。支援的值:
                              SHA1 或 SHA256 (預設)。
-codepage:&lt;n&gt;                 指定開啟來源檔案時所要使用的
                             字碼頁
-utf8output                   以 UTF-8 編碼輸出編譯器訊息
-main:&lt;類型&gt;                  指定包含進入點的類型
                              (忽略所有其他可能的進入點) (簡短
                              形式: -m)
-fullpaths                    編譯器產生完整的路徑
-filealign:&lt;n&gt;                指定輸出檔使用的標準e
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              指定編輯器輸出之
                              來源路徑名稱的對應。
-pdb:&lt;檔案&gt;                   指定偵錯資訊檔案名稱 (預設:
                              副檔名為 .pdb 的輸出檔名稱)
-errorendlocation             每個錯誤之結束位置的輸出
                              行與欄
-preferreduilang              指定慣用的輸出語言名稱。
-nosdkpath                    停用搜尋標準程式庫組件的預設 SDK 路徑。
-nostdlib[+|-]                不參考標準程式庫 (mscorlib.dll)
-subsystemversion:&lt;字串&gt;    指定此組件的子系統版本
-lib:&lt;檔案清單&gt;              指定額外的目錄，從中搜尋
                              參考
-errorreport:&lt;字串&gt;         指定如何處理內部編譯器錯誤:
                              prompt、send、queue 或 none。預設為
                              queue。
-appconfig:&lt;檔案&gt;             指定包含組件繫結設定的
                              應用程式設定檔
-moduleassemblyname:&lt;字串&gt;  此模組即將歸入之組件的
                              名稱
-modulename:&lt;字串&gt;          指定來源模組的名稱
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">預設介面實作</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">可處置</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">插入的逐字替代字串</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">非同步 using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">聯合指派</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">委派泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">列舉泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">成員初始設定式及查詢中之運算式變數的宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">可延伸 fixed 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="new">extern local functions</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">索引運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">對可移動的固定緩衝區編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="new">local function attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">lambda 捨棄參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">巢狀函式中的名稱鏡像處理</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">巢狀運算式中的 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">notnull 泛型型別限制式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">可為 Null 的參考型別</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">在屬性存取子上淘汰</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">警告動作 enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">範圍運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">唯讀成員</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">遞迴模式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">參考條件運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">參考 for 迴圈變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">參考 foreach 反覆運算變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">參考重新指派</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">stackalloc 初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">靜態區域函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;切換運算式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">元組相等</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">Null 聯合運算子中的非限制式型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">非受控建構的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">Unmanaged 泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">using 宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">適用於覆寫和明確介面實作方法的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;throw 運算式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(與之前錯誤相關符號的位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(與之前警告相關符號的位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> 無法納入格式錯誤的 XML 檔 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> 無法插入某些或所有 include 的 XML </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Include 標籤無效 </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> 找不到與下列 include 標籤相符的項目 </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">遺漏檔案屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">遺漏路徑屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;全域命名空間&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">泛型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">匿名方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">模組做為屬性目標規範</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">命名空間別名限定詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">固定大小緩衝區</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">靜態類別</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">唯讀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">部分類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">非同步函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">布林類型的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">方法群組</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">匿名方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">Lambda 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">集合</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">屬性的存取修飾詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">迭代器</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">預設運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">預設常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">可為 Null 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">模式比對</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">運算式主體屬性存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">運算式主體建構函式及解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">Throw 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">隱含類型陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">隱含類型區域變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">匿名類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">自動實作的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">自動實作的唯讀屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">物件初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">集合初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">命名空間</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">元素</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">事件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">使用別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">foreach 反覆運算變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">固定變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">使用變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">contravariant</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">以 Contravariant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">Covariant</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">以 Covariant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">非 Variant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">動態</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">具名引數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">選擇性參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">例外狀況篩選條件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">類型變異數</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">SyntaxTree 不屬於編譯的一部份</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">因為 SyntaxTree 不屬於編譯的一部份，所以無法將其移除</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">名稱 '_' 參考常數而非捨棄模式。請使用 'var _' 來捨棄值，或使用 '@_' 來依該名稱參考常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">不可對 case 常數使用 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">正在將 Null 常值或可能的 Null 值轉換為不可為 Null 的型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">正在將 Null 常值或可能的 Null 值轉換為不可為 Null 的型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">可能的 Null 值不能用於標有 [NotNull] 或 [DisallowNull] 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">可能的 Null 值不能用於標有 [NotNull] 或 [DisallowNull] 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="new">Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="new">Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">'{0}' 已列在類型 '{1}' 上的介面清單中，並具有不同的參考類型可 NULL 性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">介面已列在介面清單中，並具有不同的參考類型可 NULL 性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定的運算式永遠符合提供的常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定的運算式永遠符合提供的常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定的運算式永遠不符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定的運算式永遠不符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">從 'readonly' 成員呼叫非 readonly 成員 '{0}' 會產生 '{1}' 的隱含複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">從 'readonly' 成員呼叫非 readonly 成員會產生隱含複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">名稱 '_' 參考類型 '{0}'，而非捨棄模式。請為類型使用 '@_'，或使用 'var _' 捨棄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">請勿使用 '_' 參考 is-type 運算式中的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">可為 Null 的參考型別註釋應只用於 '#nullable' 註釋內容中的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">因為可為 null 之參考型別的註釋應只於 '#nullable' 註釋內容的程式碼中使用。自動產生的的程式碼需要來源中的明確 '#nullable' 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">因為可為 null 之參考型別的註釋應只於 '#nullable' 註釋內容的程式碼中使用。自動產生的的程式碼需要來源中的明確 '#nullable' 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">可為 Null 的參考型別註釋應只用於 '#nullable' 註釋內容中的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">無法將 null 常值轉換成不可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">無法將 null 常值轉換成不可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">'{1}' 中的參數 '{0}' 可能有 Null 參考引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">可能有 Null 參考引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">可能有 Null 參考指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">可能有 Null 參考指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">物件或集合初始設定式意味會解除參考可能的 null 成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">物件或集合初始設定式意味會解除參考可能為 null 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">可能 null 參考的取值 (dereference)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">可能 null 參考的取值 (dereference)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">可能有 Null 參考傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">可能有 Null 參考傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以無法針對 '{3}' 內類型 '{1}' 的參數 '{2}' 使用類型 '{0}' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以無法將類型 '{0}' 的引數用作 '{3}' 中參數 '{2}' 的類型 '{1}' 輸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以引數無法用作參數的輸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以引數無法用於參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">型別 '{0}' 的值中參考型別可 Null 性與目標型別 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">值中參考型別的可 Null 性與目標型別不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">方法 '{1}' 的型別參數 '{0}' 條件約束可 Null 性與介面方法 '{3}' 的型別參數 '{2}' 條件約束不符合。請考慮改用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">方法的型別參數條件約束與介面方法的型別參數條件約束不符合。請考慮改用隱含的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' 的部分方法宣告在類型參數 '{1}' 的限制式中，有不一致的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">部分方法宣告在類型參數的限制式中，有不一致的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明確介面指定名稱中參考類型可 NULL 性與類型所實作的介面不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明確介面指定名稱中參考類型可 NULL 性與類型所實作的介面不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。基底類型所實作之介面中的參考類型可 NULL 性不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">類型未實作介面成員。基底類型所實作之介面中的參考類型可 NULL 性不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}'.</source>
        <target state="translated">'{1}' 之參數 '{0}' 型別中的參考型別可 Null 性與目標委派 '{2}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與目標委派不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter doesn't match implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">參數 '{1}' 之 '{0}' 型別中參考型別的可 Null 性與隱含實作的成員 '{2}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter doesn't match implicitly implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverrideBecauseOfAttributes">
        <source>Type of parameter '{0}' doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Type of parameter '{0}' doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverrideBecauseOfAttributes_Title">
        <source>Type of parameter doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Type of parameter doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與部分方法宣告不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與部分方法宣告不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}'.</source>
        <target state="translated">'{0}' 的傳回型別中參考型別的可 Null 性與目標委派 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與目標委派不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與實作的成員 '{0}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implemented member '{0}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in return type doesn't match implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">傳回型別 '{0}' 中參考型別的可 Null 性與隱含實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implicitly implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverrideBecauseOfAttributes">
        <source>Return type doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Return type doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverrideBecauseOfAttributes_Title">
        <source>Return type doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Return type doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">型別中參考型別的可 Null 性與實作的成員 '{0}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' 的型別中參考型別的可 Null 性與隱含實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">型別 '{3}' 無法作為型別參數 '{2}' 用於泛型型別或方法 '{0}' 中。型別引數 '{3}' 的可 Null 性與條件約束型別 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與條件約束型別不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">型別 '{2}' 無法作為型別參數 '{1}' 用於泛型型別或方法 '{0}' 中。型別引數 '{2}' 的可 Null 性與 'notnull' 限制式不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與 'notnull' 限制式不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">型別 '{2}' 無法作為型別參數 '{1}' 用於泛型型別或方法 '{0}' 中。型別引數 '{2}' 的可 Null 性與 'class' 條件約束不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與 'class' 條件約束不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">可為 Null 的實值型別可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">可為 Null 的實值型別可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' may not have a null value when exiting with '{1}'.</source>
        <target state="translated">當參數 '{0}' 以 '{1}' 結束時，不能有 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter may not have a null value when exiting in some condition.</source>
        <target state="translated">當參數在某些條件下結束時，不能有 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">標記 [DoesNotReturn] 的方法不應傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">標記 [DoesNotReturn] 的方法不應傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 運算式未處理其輸入類型可能的值 (並非全部)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive).</source>
        <target state="translated">Switch 運算式未處理某些 null 輸入 (並不徹底)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Switch 運算式未處理某些 null 輸入。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 運算式未處理其輸入類型可能的值 (並非全部)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">擲回值可能為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">擲回值可能為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">因為元組 == 或 != 運算子的另一端指定了不同的名稱或未指定名稱，所以會忽略元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">因為元組 == 或 != 運算子的另一端指定了不同的名稱或未指定名稱，所以會忽略元組元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">類型參數 '{0}' 與外部方法 '{1}' 的類型參數，名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">類型參數與外部方法的類型參數，類型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Unboxing 可能 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Unboxing 可能 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">套用到參數 '{0}' 的 EnumeratorCancellationAttribute 不會有任何作用。屬性只有在會傳回 IAsyncEnumerable 的非同步迭代器方法中，在類型 CancellationToken 的參數上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">EnumeratorCancellationAttribute 不會有任何作用。屬性只有在會傳回 IAsyncEnumerable 的非同步迭代器方法中，在類型 CancellationToken 的參數上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同步迭代器 '{0}' 有一或多個類型 'CancellationToken' 的參數，但因為沒有任何參數有裝飾 'EnumeratorCancellation' 屬性，所以將不會取用來自已產生 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消權杖參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同步迭代器成員有一或多個類型 'CancellationToken' 的參數，但因為沒有任何參數有裝飾 'EnumeratorCancellation' 屬性，所以將不會取用來自已產生 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消權杖參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' is uninitialized. Consider declaring the {0} as nullable.</source>
        <target state="translated">不可為 null 的 {0} '{1}' 未初始化。請考慮將 {0} 宣告為可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field is uninitialized. Consider declaring as nullable.</source>
        <target state="translated">不可為 null 的欄位未初始化。請考慮宣告為可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">此位置不可使用字元 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">註解中使用的語法錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">實體參考中發現無效的字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">必須以 '&gt;' 或 '/&gt;' 做為結束標籤 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">必須是識別項。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Unicode 字元無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">此位置不可使用空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">屬性值中不可使用字元 '&lt;'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">屬性與屬性值之間少了等號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">參考未定義的實體 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">必須是字串常值，但未找到左引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">遺漏字串常值的右引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">字串常值前後不可使用非 ASCII 引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">此位置不可出現結束標籤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">結束標籤 '{0}' 與起始標籤 '{1}' 不對稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">必須是元素 '{0}' 的結束標籤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">遺漏了必要的空格。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">此位置處找到未預期的字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">常值字串 ']]&gt;' 不可用在元素內容中。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">找不到中繼資料檔 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">不支援中繼資料參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">無法開啟中繼資料檔'{0}' -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">類型 '{0}' 定義在未參考的組件中。您必須加入組件 '{1}' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">類型 '{0}' 定義在未加入的模組中。您必須加入模組 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">無法寫入輸出檔 '{0}' -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">程式已定義了一個以上的進入點。請以 /main 進行編譯，以指定包含進入點的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">運算子 '{0}' 不可套用至類型為 '{1}' 和 '{2}' 的運算元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">除以常數零</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">無法套用有 [] 的索引至類型為 '{0}' 的運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">[] 內的索引數目錯誤; 必須是 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">運算子 '{0}' 不可套用至類型為 '{1}' 的運算元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefault">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">運算子 '{0}' 不可套用至運算元 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">關鍵字 'this' 在靜態屬性、靜態方法或靜態欄位初始設定式中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">關鍵字 'this' 在目前內容中無法使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'{0}' 的進入點簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">方法的進入點簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">無法將類型 '{0}' 隱含轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">無法將類型 '{0}' 轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">常數值 '{0}' 不可轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">運算子 '{0}' 在類型為 '{1}' 和 '{2}' 的運算元上模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands 'default' and 'default'</source>
        <target state="translated">運算子 '{0}' 在運算元 'default' 和 'default' 不明確</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">運算子 '{0}' 在類型為 '{1}' 的運算元上模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">out 參數不能有 In 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">無法將 null 轉換成 '{0}'，因為它是不可為 null 的實值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">無法透過參考轉換、boxing 轉換、unboxing 轉換、wrapping 轉換或 null 類型轉換，來將類型 '{0}' 轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">寫入偵錯資訊時發生未預期的錯誤 -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比方法 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比方法 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">不一致的存取範圍: 欄位類型 '{1}' 比欄位 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">不一致的存取範圍: 屬性類型 '{1}' 比屬性 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">不一致的存取範圍: 索引子傳回類型 '{1}' 比索引子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比索引子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比運算子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比運算子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比委派 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比委派 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">不一致的存取範圍: 基底類別 '{1}' 比類別 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">不一致的存取範圍: 基底介面 '{1}' 比介面 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': 事件屬性必須同時要有 add 和 remove 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'{0}': 事件必須為委派類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">事件 '{0}' 從未使用過</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">從未使用過事件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'{0}': 介面中的執行個體事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">事件 '{0}' 只可出現在 += 或 -= 的左側 (除非從類型 '{1}' 中使用)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">事件的明確介面實作必須使用存取子語法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'{0}': 無法覆寫; '{1}' 不是事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">add 或 remove 存取子必須具有主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'{0}': 抽象事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">組件名稱 '{0}' 已保留，不可用做為互動工作階段中的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">列舉程式名稱 '{0}' 已保留，且無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">as 運算子必須搭配參考類型或可為 Null 的類型一起使用 ('{0}' 是不可為 Null 的實值類型)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">字尾 'l' 很容易與數字 '1' 混淆 -- 請使用 'L' 以避免困擾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">字尾 'l' 很容易與數字 '1' 混淆</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">事件 '{0}' 只可出現在 += 或 -= 的左側</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">非泛型宣告中不可使用條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">類型參數宣告必須是識別項，而非類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">類型 '{1}' 已保留了一個具有相同參數類型且名為 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">參數名稱 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">命名空間 '{1}' 已包含 '{0}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">類型 '{0}' 已包含 '{1}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">名稱 '{0}' 不存在於目前的內容中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">名稱 '{0}' 不存在於目前的內容中 (是否遺漏了組件 '{1}' 的參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'{0}' 是 '{1}' 與 '{2}' 之間模稜兩可的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">{0}' 的 using 指示詞之前曾出現於此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">Using 指示詞先前出現在此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">修飾元 '{0}' 對此項目無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">有一個以上的保護修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'{0}' 會隱藏繼承的成員 '{1}'。若本意即為要隱藏，請使用 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">成員隱藏所繼承的成員; 遺漏 new 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base class. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">所宣告的變數名稱與基底類別中的變數相同。不過，未使用 new 關鍵字。此警告通知您應該使用 new; 宣告變數的方式就像已將 new 用於宣告一樣。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">成員 '{0}' 並未隱藏可存取的成員。不需要 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">成員未隱藏所繼承的成員; 不需要 new 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">{0}' 常數值的運算發生循環定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">類型 '{1}' 已定義了一個具有相同參數類型且名為 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member '{0}' cannot be marked as override, virtual, or abstract</source>
        <target state="translated">靜態成員 '{0}' 不可標記為 override、virtual 或 abstract。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">標記為 override 的成員 '{0}'，不可標記為 new 或 virtual。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'{0}' 會隱藏繼承的成員 '{1}'。若要讓目前的成員覆寫該實作，請加入 override 關鍵字; 否則請加入 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">成員隱藏所繼承的成員; 遺漏 override 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'{0}': 未找到任何合適的方法可覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields or methods</source>
        <target state="translated">命名空間不能直接包含如欄位或方法等成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'{0}' 是 {1}，但卻當成 {2} 使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'{0}' 是 {1}，其在指定內容中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">需要有物件參考，才可使用非靜態欄位、方法或屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">以下方法或屬性之間的呼叫模稜兩可: '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'{0}' 由於其保護層級之故，所以無法存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">{0}' 沒有任何多載符合委派 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">需要可轉換成 '{0}' 之類型的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">因為 '{0}' 傳回了 void，所以 return 關鍵字之後不可接著物件運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">已經在此範圍內定義名為 '{0}' 的區域變數或函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">指派的左側必須是變數、屬性或索引子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'{0}': 靜態建構函式不能使用參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">指派至 '{0}' 的運算式必須為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'{0}' 為類型 '{1}'。非字串之參考類型的 const 欄位，只能以 null 初始設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">無法在此範圍宣告名為 '{0}' 的區域變數或參數，因為該名稱已用於封入區域變數範圍，以定義區域變數或參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">using namespace' 指示詞只能套用至命名空間; '{0}' 是類型而非命名空間。請考慮改用 'using static' 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">using static' 指示詞只能套用至類型; '{0}' 是命名空間而非類型。請考慮改用 'using namespace' 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">using static' 指示詞不能用來宣告別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">沒有可中斷或繼續的封閉式迴圈</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">標籤 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">類型 '{0}' 未定義任何建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract class or interface '{0}'</source>
        <target state="translated">無法建立抽象類別或介面 '{0}' 的執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">需要為 const 欄位提供值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base class dependency involving '{0}' and '{1}'</source>
        <target state="translated">循環基底類別相依包括 '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">委派 '{0}' 沒有有效的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">必須是方法名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">必須是常數值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">Switch 運算式或 case 標籤必須是 bool、char、string、integral、enum 或 C# 6 及舊版中對應的可為 Null 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">必須是整數類型的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">switch 陳述式包含多個標籤值為 '{0}' 的情況</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">goto case 只有在 switch 陳述式中有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">屬性或索引子 '{0}' 無法用在此內容中，因為它缺少 get 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">類型 catch 或 throw 必須衍生自 System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">沒有引數的 throw 陳述式不可用於 catch 子句之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">控制項不可脫離 finally 子句的主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">標籤 '{0}' 所包含的範圍內以相同的名稱遮蔽了另一個標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">goto 陳述式的範圍內沒有這種標籤 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">之前的 catch 子句已取得所有屬於此類型或超級類型 ('{0}') 的例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">篩選條件運算式是常數 'true'，請考慮移除此篩選條件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">篩選條件運算式是常數 'true'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'{0}': 不是所有程式碼路徑都有傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">偵測到執行不到的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">偵測到執行不到的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">程式控制權無法從一個 case 標籤 ('{0}') 繼續到另一個</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">未參考此標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">未參考此標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">使用未指派的區域變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">已宣告變數 '{0}'，但從未使用過它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">已宣告變數，但從未使用過它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">欄位 '{0}' 從未使用過</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">從未使用過欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">使用可能未指派的欄位 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">可能使用了未指派的自動實作屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThis">
        <source>Field '{0}' must be fully assigned before control is returned to the caller</source>
        <target state="translated">在程式控制權回到呼叫端之前，必須完整指派欄位 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">無法判斷條件運算式的類型，因為 '{0}' 和 '{1}' 會互相隱含轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">無法確認條件運算式的類型，因為 '{0}' 和 '{1}' 之間沒有隱含轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">base' 參考需要基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">在此內容中使用關鍵字 'base' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">成員 '{0}' 無法以執行個體參考進行存取; 請改用類型名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">在程式控制權脫離目前的方法之前，必須指派 out 參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">陣序規範無效: 必須是 ',' 或 ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'{0}' 不可同時為外部並宣告主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'{0}' 不可同時為外部並具有建構函式初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'{0}' 不可同時為外部與抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">屬性建構函式參數 '{0}' 的類型為 '{1}'，但是該類型不是有效的屬性參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">屬性引數必須是常數運算式、typeof 運算式或屬性參數類型的陣列建立運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">屬性建構函式參數 '{0}' 為選擇性參數，但並未指定預設參數值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">指定的運算式一律會是提供的 ('{0}') 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'is' 運算式的指定運算式一律會是提供的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">指定的運算式絕不是提供的 ('{0}') 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'is' 運算式的指定運算式絕不是提供的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'{0}' 不是 lock 陳述式所需的參考類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">在此內容中使用 null 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">在此內容中使用預設常值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThis">
        <source>The 'this' object cannot be used before all of its fields are assigned to</source>
        <target state="translated">指定其所有欄位前，無法使用 'this' 物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">__arglist 建構函式只有在變數引數方法中才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">必須對指標套用 * 或 -&gt; 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">只能使用一個值對指標編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">若將 '{0}' 用作為 ref 或 out 值或取得其位址，皆可能會導致執行階段例外狀況，因為其為傳址封送類別的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">若將傳址封送類別的欄位用作為 ref 或 out 值或取得其位址，皆可能會導致執行階段例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">不可指定為靜態唯讀欄位 (除非在靜態建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">無法將靜態唯讀欄位用作為 ref 或 out 值 (除非在靜態建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">無法指派為屬性或索引子 '{0}' -- 其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">只有指派、呼叫、遞增、遞減以及新的物件運算式，可以用做為陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">foreach 要求 '{1}' 的傳回類型 '{0}' 必須要有適合的公用 MoveNext 方法以及公用 Current 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">只可使用 65534 個區域變數，包括由編譯器所產生的區域變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">無法呼叫抽象基底成員: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A property or indexer may not be passed as an out or ref parameter</source>
        <target state="translated">屬性或索引子不可以 out 或 ref 參數形式傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">無法取得 Managed 類型 ('{0}') 的位址、大小，也無法宣告指向它的指標。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">在 fixed 陳述式中宣告的區域變數類型必須為指標類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">在 fixed 或 using 陳述式宣告中，必須提供初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">無法取得指定運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">您只能取得 fixed 陳述式初始設定式中 unfixed 運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">您不能使用 fixed 陳述式來取得原本就是 fixed 運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">指標和固定大小緩衝區只能使用於 unsafe 內容中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">運算子 True 或 False 的傳回類型必須為 bool</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">運算子 '{0}' 需要也同時定義對稱的運算子 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">為了可以當成最少運算 (Short Circuit) 運算子使用，使用者定義的邏輯運算子 ('{0}') 必須具有相同的傳回類型與參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">為了讓 '{0}' 可以當成最少運算 (short circuit) 的運算子使用，其宣告類型 '{1}' 必須定義運算子 true 和運算子 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">已指派變數 '{0}'，但是從未使用過它的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">已指派變數，但從未使用過其值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">檢查模式下，作業於編譯時期溢位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">常數值 '{0}' 不可轉換成 '{1}' (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">具有 vararg 的方法不可為泛型、泛型類型或是具有 params 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeArray">
        <source>The params parameter must be a single dimensional array</source>
        <target state="translated">params 參數必須是單一維度陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">__arglist 運算式只可出現於呼叫或 new 運算式中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">只有在編譯時指定了 /unsafe，才會出現 unsafe 程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">{0}' 與 '{1}' 之間模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">在 foreach 陳述式中同時需要類型與識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">params 參數必須是型式參數清單中的最後一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">'{0}' 沒有預先定義的大小，因此 sizeof 只能用於 unsafe 內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">命名空間 '{1}' 中沒有類型或命名空間名稱 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">欄位初始設定式無法參考非靜態欄位、方法或屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'因為 '{0}' 不是 override，所以無法密封。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'{0}': 無法覆寫繼承的成員 '{1}'，因為其已密封。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">在 Void 指標上未定義有問題的作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其為覆寫方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">is' 或 'as' 在指標類型上都無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">無法直接呼叫解構函式與 object.Finalize。請考慮呼叫 IDisposable.Dispose (若有的話)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">找不到類型或命名空間名稱 '{0}' (是否遺漏了 using 指示詞或組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">stackalloc 無法使用負值大小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">無法以負值大小建立陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">請勿覆寫 object.Finalize，請改為提供解構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base class Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">請勿直接呼叫您的基底類別 Finalize 方法。其會從您的解構函式自動呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">正在以負值索引檢索陣列 (陣列索引一律從 0 開始)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">對具有負索引的陣列編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">可能誤用了參考比較; 若要進行數值比較，請將左側轉型為類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">可能誤用參考比較; 左端需要轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">可能誤用了參考比較; 若要進行數值比較，請將右側轉型為類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">可能誤用參考比較; 右端需要轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">fixed 陳述式指派的右側，不可為 cast 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">在 catch 或 finally 區塊中不可使用 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">__arglist 參數必須是型式參數清單的最後一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">類型 '{0}' 的宣告中遺漏 partial 修飾元; 還存在此類型的其他部分宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all structs, or all interfaces</source>
        <target state="translated">{0}' 的部分宣告必須全部為類別、全部為結構，或全部為介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">{0}' 的部分宣告出現相 衝突的存取範圍修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">{0}' 的部分宣告不得指定不同的基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">{0}' 的部分宣告必須要有相同順序的相同類型參數名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">{0}' 的部分宣告對類型參數 '{1}' 有不一致的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">無法將類型 '{0}' 隱含轉換成 '{1}'。已存在明確轉換 (是否漏了轉型?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'struct', 'interface', or 'void'</source>
        <target state="translated">partial' 修飾元只可緊接在 'class'、'struct'、'interface' 或 'void' 之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base class dependency.</source>
        <target state="translated">匯入的類型 '{0}' 無效。其包含循環基底類別相依性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">使用未指派的 out 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">變數宣告中不可指定陣列大小 (請嘗試使用 'new' 運算式進行初始設定)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">無法在此內容中使用屬性或索引子 '{0}'，因為無法存取 get 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">無法在此內容中使用屬性或索引子 '{0}'，因為無法存取 set 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">{0}' 存取子的存取範圍修飾元，必須比屬性或索引子 '{1}' 更嚴格。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">不可同時對屬性或索引子 '{0}' 的兩個存取子，指定存取範圍修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 存取子上的存取範圍修飾元，只有在屬性或索引子同時有 get 和 set 存取子時，才可使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'，因為 '{2}' 並非公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'{0}' 未實作 '{1}' 模式，因為 '{2}' 與 '{3}' 之間模稜兩可。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">類型未實作集合模式; 成員模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is either static or not public.</source>
        <target state="translated">'{0}' 未實作 '{1}' 模式，因為 '{2}' 為靜態或並非公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible_Title">
        <source>Type does not implement the collection pattern; member is either static or not public</source>
        <target state="translated">類型未實作集合模式; 成員為靜態或非公用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'{0}' 未實作 '{1}' 模式。'{2}' 的簽章錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">類型未實作集合模式; 成員的簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">{0}' 已授與 Friend 存取權限，但輸出組件 ('{1}') 的公開金鑰，與授與之組件中 InternalsVisibleTo 屬性所指定的公開金鑰不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">{0}' 已授與 Friend 存取權限，但輸出組件的強式名稱簽署狀態不符合授與組件的強式名稱簽署狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">在部分結構 '{0}' 的多重宣告中，欄位之間沒有已定義的順序。若要指定順序，所有執行個體欄位都必須在同一個宣告中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">在多個局部結構宣告中，欄位之間未定義順序</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">類型 '{0}' 不可宣告為 const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">無法建立變數類型 '{0}' 的執行個體，因為其無 new() 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">使用泛型 {1} '{0}' 時需要 {2} 個類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">類型 '{0}' 不可用做類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} '{0}' 不可搭配類型引數一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">非泛型 {1} '{0}' 不可搭配類型引數一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'{2}' 必須是具有公用無參數建構函式的非抽象類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的隱含參考轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。可為 Null 的類型 '{3}' 無法滿足 '{1}' 的條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。可為 Null 的類型 '{3}' 無法滿足 '{1}' 的條件約束。可為 Null 的類型無法滿足任何介面條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的 Boxing 轉換或類型參數轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的 Boxing 轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">參數名稱 '{0}' 與自動產生的參數名稱衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">全域命名空間中找不到類型或命名空間名稱 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last constraint specified</source>
        <target state="translated">new() 條件約束必須是最後指定的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'{0}': 進入點不可為泛型，也不可為泛型類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">進入點不可為泛型，也不可為泛型類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">無法將 null 轉換成類型參數 '{0}'，因為其可能是不可為 null 的實值類型。請考慮改用 'default({0})'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCantBeGeneric">
        <source>Cannot apply attribute class '{0}' because it is generic</source>
        <target state="translated">無法套用屬性類別 '{0}'，因為其為泛型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">類型參數 '{1}' 出現重複的條件約束 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">類別類型條件約束 '{0}' 必須在所有其他條件約束之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'{1} {0}' 的傳回類型錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">{0}' 與委派 '{1}' 之間的參考不符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">已為類型參數 '{0}' 指定了條件約束子句。類型參數的所有條件約束，都必須在單一 where 子句中指定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">方法 '{0}' 的類型引數不可從使用方式推斷。請嘗試明確地指定類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'{0}': 參數、區域變數或區域函式的名稱不得與方法類型參數相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">類型參數 '{0}' 不可與 'as' 運算子一起使用，因為它沒有類別類型條件約束或 'class' 條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">已指派欄位 '{0}'，但從未使用過其值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">已指派欄位，但從未使用過其值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">{0}' 屬性只有在非明確介面成員宣告的索引子上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'{0}': 屬性引數不可使用類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'{0}': 不能在建立變數類型的執行個體時，提供引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract class cannot be sealed or static</source>
        <target state="translated">'{0}': 為抽象類別，不可為密封或靜態。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">cref 屬性中有模稜兩可的參考: '{0}'。已假設為 '{1}'，但也可能符合其他多載，包括 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">cref 屬性中的參考模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'{0}': volatile 欄位的參考不會視為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">volatile 欄位的參考不會視為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">通常不應該將 volatile 欄位用作為 ref 或 out 值，因為不會將它視為 volatile。但有例外狀況，例如呼叫連鎖 API 時。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">因為 '{1}' 具有 ComImport 屬性，所以 '{0}' 必須為 extern 或 abstract。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'{0}': 具有 ComImport 屬性的類別不可指定基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">方法 '{1}' 之類型參數 '{0}' 的條件約束，必須符合介面方法 '{3}' 之類型參數 '{2}' 的條件約束。請考慮改用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">方法 '{0}' 的特徵標記中元組元素必須與介面方法 '{1}' 的元組元素名稱相符 (包括在傳回類型)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">類型名稱 '{0}' 不存在於類型 '{1}' 中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">無法將方法群組 '{0}' 轉換成非委派類型 '{1}'。原本希望叫用該方法嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">/reference 選項中未指定外部別名 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">別名 '{0}' 不能搭配 '::' 一起使用，因為別名會參考類型。請改用 '.'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">找不到別名 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">類型 '{1}' 同時存在於 '{0}' 和 '{2}' 中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">{0}' 中的命名空間 '{1}' 與 '{2}' 中的類型 '{3}' 相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">{0}' 中的命名空間 '{1}' 與 '{2}' 中匯入的類型 '{3}' 相衝突。請使用 '{0}' 中定義的命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">命名空間與所匯入的類型衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">{0}' 中的類型 '{1}' 與 '{2}' 中匯入的類型 '{3}' 相衝突。請使用 '{0}' 中定義的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">類型與所匯入的類型衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">{0}' 中的類型 '{1}' 與 '{2}' 中匯入的命名空間 '{3}' 相衝突。請使用 '{0}' 中定義的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">類型與所匯入的命名空間衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">{0}' 中的類型 '{1}' 與 '{2}' 中的命名空間 '{3}' 相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">外部別名宣告必須位於命名空間中所有其他定義的元素之前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">最好不要定義名為 'global' 的別名，因為 'global::' 一定會去參考全域命名空間，而不會去參考別名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">最好不要定義名為 'global' 的別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a class cannot be both static and sealed</source>
        <target state="translated">'{0}': 類別不可同時為 static 和 sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'{0}': 抽象屬性不可有私用存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">語法錯誤; 應為值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">無法修改 Unboxing 轉換的結果</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Foreach 無法在 '{0}' 上運作。原本是要叫用 '{0}' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">++ 或 -- 運算子的傳回類型，必須符合此參數類型或衍生自此參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundMustBeFirst">
        <source>The 'class' or 'struct' constraint must come before any other constraints</source>
        <target state="translated">class' 或 'struct' 條件約束必須在所有其他條件約束之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'{0}': 不可在指定條件約束類型的同時，又指定 'class' 或 'struct' 條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">new()' 條件約束不能和 'struct' 條件約束一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 必須是參考類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 必須是不可為 null 的實值類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">循環條件約束相依性包括 '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">類型參數 '{0}' 繼承了衝突的條件約束 '{1}' 和 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">類型參數 '{1}' 有 'struct' 條件約束，因此 '{1}' 不可做為 '{0}' 的條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">從 '{2}' 轉換成 '{3}' 時，使用者定義的轉換 '{0}' 與 '{1}' 模稜兩可。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">運算式的結果一律會是類型 '{0}' 的 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">運算式的結果一律是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">無法藉傳址方式傳回「這個」。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it is has 'in' parameters.</source>
        <target state="translated">因為屬性建構函式 '{0}' 有 'in' 參數，所以無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">覆寫及明確介面實作方法的條件約束，繼承自基底方法，所以無法直接指定，但 'class' 或 'struct' 限制式除外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">繼承的成員 '{0}' 和 '{1}'，在類型 '{2}' 中有相同的簽章，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">運算十進位常數運算式失敗</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">與類型 '{0}' 的 null 進行比較，一律會產生 'false'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">與 struct 類型的 null 進行比較，一律會產生 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">引進可能會妨礙解構函式引動過程的 'Finalize' 方法。是否想要宣告解構函式?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">採用 'Finalize' 方法可能會妨礙解構函式的引動過程</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">如果用以建立類別的方法，其簽章是公用虛擬 void Finalize，則會發生此警告。

如果這類類別用做基底類別，而且衍生類別定義解構函式，則解構函式會覆寫基底類別 Finalize 方法，而非 Finalize。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'{0}' 不應有 params 參數，因為 '{1}' 沒有此參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">goto case' 值未隱含轉換成類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">goto case' 值未隱含轉換成參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">方法 '{0}' 無法實作類型 '{2}' 的介面存取子 '{1}'。請使用明確介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">運算式的結果一律會是 '{0}'，因為類型 '{1}' 的值絕對不會等於類型 '{2}' 的 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">運算式的結果一律會相同，因為此類型的值絕對不會等於 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">運算式的結果一律會是 '{0}'，因為類型 '{1}' 的值絕對不會等於類型 '{2}' 的 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">運算式的結果一律會相同，因為此類型的值絕對不會等於 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">明確介面實作 '{0}' 符合多個介面成員。實際選擇的介面成員，與實作相關。請考慮改用非明確實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">明確介面實作符合多個介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'因為 '{0}' 已標記為抽象，所以它無法宣告主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'{0}' 並未標記成 abstract、extern 或 partial，所以必須宣告主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'{0}' 不可同時為抽象與密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">抽象 {0} '{1}' 不可標記為虛擬</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">常數 '{0}' 不可標記為 static</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'{0}': 因為 '{1}' 不是函式，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'{0}': 無法覆寫繼承的成員 '{1}'，因為其未標記為 virtual、abstract 或 override。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'{0}': 覆寫 '{1}' 繼承的成員 '{2}' 時，無法變更存取修飾詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'{0}': 在覆寫繼承的成員 '{1}' 時無法變更元組元素名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 傳回類型必須是 '{2}' 才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'{0}': 無法衍生自密封類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract class '{1}'</source>
        <target state="translated">'{0}' 為抽象，因為其包含在非抽象類別 '{1}' 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'{0}': 靜態建構函式不可有明確的 'this' 或 'base' 建構函式呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'{0}': 靜態建構函式中不可使用存取修飾詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">建構函式 '{0}' 不可呼叫其本身</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">建構函式 '{0}' 不可透過其他建構函式呼叫自己</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">'{0}' 沒有基底類別且無法呼叫基底建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">未定義或匯入預先定義的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">未定義或匯入預先定義的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">在多個參考組件中宣告了預先定義的類型 '{0}': '{1}' 與 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'{0}': 結構無法呼叫基底類別建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">類型為 '{1}' 的結構成員 '{0}'，在結構配置中造成循環。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">介面不能包含執行個體欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">介面不能包含執行個體建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">介面清單中的類型 '{0}' 不是介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'{0}' 已列於介面清單中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' 已列於元組元素名稱不同的類型 '{2}' 介面清單中，名稱為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">繼承的介面 '{1}' 造成 '{0}' 介面階層架構中出現循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'{0}' 會隱藏繼承的抽象成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'{0}' 未實作繼承的抽象成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">類別 System.Object 不能有基底類別或實作介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'在明確介面宣告中的 '{0}' 不是介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">在明確介面宣告中，無法在可實作的介面成員間找到 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'{0}': 包含類型未實作介面 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, struct or interface</source>
        <target state="translated">'{0}': 明確的介面宣告只能在類別、結構或介面中宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'{0}': 成員名稱不可與其封入類型名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'{0}': 就其類型而言，此列舉值過大。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'{0}': 因為 '{1}' 不是屬性，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'{0}': 因為 '{1}' 沒有可覆寫的 get 存取子，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'{0}': 因為 '{1}' 沒有可覆寫的 set 存取子，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'{0}': 屬性或索引子不可有 void 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'{0}': 屬性或索引子至少必須要有一個存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed class '{1}'</source>
        <target state="translated">'{0}' 是密封類別 '{1}' 中新的虛擬成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'{0}' 加入了在介面成員 '{1}' 中找不到的存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">明確介面實作 '{0}' 遺失存取子 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'{0}': 介面之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base class are not allowed</source>
        <target state="translated">'{0}': 在基底類別之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived class are not allowed</source>
        <target state="translated">'{0}': 衍生類別之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type</source>
        <target state="translated">使用者定義的運算子無法攜帶封入類型的物件和轉換為封入類型的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">使用者定義的轉換必須轉換為封入類型或從封入類型轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">類型 '{0}' 中出現重複的使用者定義之轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">使用者定義的運算子 '{0}' 必須宣告為 static 和 public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">++ 或 -- 運算子的參數類型必須是包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">一元運算子的參數必須為包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">二元運算子的一個參數必須為包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int</source>
        <target state="translated">多載移位 (Shift) 運算子的第一個運算元的類型必須和包含類型相同，而第二個運算元的類型必須是 int</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructsCantContainDefaultConstructor">
        <source>Structs cannot contain explicit parameterless constructors</source>
        <target state="translated">結構無法包含明確無參數的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">列舉不能包含明確的無參數建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}': 因為此語言不支援 '{1}'，所以無法覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'此語言不支援 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'{0}': 無法明確呼叫運算子或存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'{0}': 不可透過運算式參考類型; 請嘗試改用 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitializerInStruct">
        <source>'{0}': cannot have instance property or field initializers in structs</source>
        <target state="translated">'{0}': 結構中不可有執行個體屬性或欄位初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of class</source>
        <target state="translated">解構函式的名稱必須符合類別的名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">只有類別類型可以包含解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">命名空間 '{1}' 包含與別名 '{0}' 相衝突的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">別名 '{0}' 與 {1} 定義相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, or explicit interface implementation</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其為建構函式、解構函式、運算子或明確介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其傳回類型不是 void。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">{1}' 中的 '{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">Conditional 屬性不能用在介面成員上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">使用者定義的運算子無法傳回 void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'{0}': 動態類型之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">{0}' 屬性的引數值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">參數對於指定的 Unmanaged 類型無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">必須指定屬性參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">必須指定屬性參數 '{0}' 或 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Unmanaged 類型 '{0}' 對欄位無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Unmanaged 類型 '{0}' 只對欄位有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在此宣告類型上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">浮點常數的值超出類型 '{0}' 的範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">指定 Guid 屬性時必須同時指定 ComImport 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">具名屬性引數 '{0}' 的值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">DllImport 屬性必須指定在標記為 'static' 和 'extern' 的方法上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">無法更新 '{0}'; 缺少屬性 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="needs-review-translation">DllImport 屬性無法套用至泛型方法，或套用至包含在泛型類型中的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">欄位或屬性不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">欄位或自動實作屬性的類型不可為 '{0}'，除非它是 ref struct 的執行個體成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">陣列元素不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'{0}' 已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">類型或成員已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'{0}' 不是屬性類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'{0}' 不是有效的具名屬性引數。具名屬性引數必須為欄位，且不可為 readonly、static 或 const，也不可以是 public 且非 static 的 read-write 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' 已經過時: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">類型或成員已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' 已經過時: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">索引子不能有 void 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'{0}': 虛擬或抽象成員不可為私用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">只可使用陣列初始設定式運算式，指派給陣列類型。請嘗試改用 new 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">陣列初始設定式只可用於變數或欄位初始設定式中。請嘗試改用 new 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">'{0}': 標記有 StructLayout(LayoutKind.Explicit) 之類型的執行個體欄位，必須要有 FieldOffset 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">方法、運算子或存取子 '{0}' 已標記為外部，但其上沒有屬性。請考慮加入 DllImport 屬性來指定外部實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">方法、運算子或存取子標記為外部，而且其上沒有屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed class</source>
        <target state="translated">'{0}': 在密封類別中宣告了新的 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed class</source>
        <target state="translated">在密封類別中已宣告新的受保護成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Conditional 成員 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">ref 和 out 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">{0}' 屬性的引數必須是有效的識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 屬性僅能置於標記為 StructLayout(LayoutKind.Explicit) 類型的成員上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">static 或 const 欄位不能有 FieldOffset 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">屬性 '{0}' 只有在衍生自 System.Attribute 的類別上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">可能誤用了空白的陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">可能誤用了空白的陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'{0}' 有重複的具名屬性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'{0}' 不可衍生自特殊類別 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">無法在包含索引子的類型上指定 DefaultMember 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'此語言不支援類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">從未指派欄位 '{0}'，會持續使用其預設值 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">從未指派欄位，會持續使用其預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">陣列宣告子無效: 若要宣告 Managed 陣列，陣序規範必須位於變數識別項之前。若要宣告固定大小緩衝區欄位，請在欄位類型之前使用 fixed 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">與整數常數比較無意義，因為此常數位於類型 '{0}' 的範圍外。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">與整數常數比較無意義; 此常數位於類型的範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">無法套用屬性類別 '{0}'，因為其抽象。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'{0}' 不是有效的具名屬性引數，因為其不是有效的屬性參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">遺漏編譯器必要成員 '{0}.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' 對此宣告而言，不是有效的屬性位置。對此宣告有效的屬性位置是 '{1}'。將會忽略此區塊中的所有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">不是此宣告的有效屬性位置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' 不是可辨認的屬性位置。此宣告的有效屬性位置為 '{1}'。將會忽略此區塊中的所有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">不是可辨識的屬性位置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' 會覆寫 Object.Equals(object o)，但是不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">類型會覆寫 Object.Equals(object o)，但不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'{0}' 定義了運算子 == 或運算子 !=，但不會覆寫 Object.Equals(object o)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">類型會定義運算子 == 或運算子 !=，但不會覆寫 Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' 定義了運算子 == 或運算子 !=，但不會覆寫 Object.GetHashCode()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">類型會定義運算子 == 或運算子 !=，但不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">無法在 ref 參數上僅指定 Out 屬性，卻不指定 In 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'{0}' 無法定義多載的 {1}，後者僅在參數修飾元 '{2}' 和 '{3}' 有所不同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">不可將類型 double 的常值，隱含轉換成類型 '{1}'; 請使用 '{0}' 後置詞來建立此類型的常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">條件運算式中的指派一直是常數; 這表示您要使用 == 代替 = ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">條件運算式中的指派一律是常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'{0}': 在結構中宣告了新的 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">兩個索引子具有不同的名稱; 類型中每個索引子上都必須使用同名的 IndexerName 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">擁有 ComImport 屬性的類別無法有使用者定義的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">欄位不能有 void 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">成員 '{0}' 會覆寫過時的成員 '{1}'。請將 Obsolete 屬性加入 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">成員會覆寫過時成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">無法從 C# 使用 System.Void -- 請使用 typeof(void) 取得 void 類型物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArray">
        <source>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">請勿使用 'System.ParamArrayAttribute'。請改用 'params' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">用於 sign-extend 運算元的 Bitwise-or 運算子; 請先考慮轉換為較小的不帶正負號類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">用於 sign-extended 運算元上的 Bitwise-or 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">編譯器會隱含地擴大，而且 sign-extended 變數，然後在位元 OR 運算中使用結果值。這可能會導致非預期的行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'{0}': Volatile 欄位不可為類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'{0}': 欄位不可同時為 volatile 和 readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">修飾元 'abstract' 在欄位上無效。請嘗試改用屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}' 不可實作 '{1}'，因為此語言不支援它。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'{0}' 明確方法實作無法實作 '{1}'，因為其為存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'{0}' 介面標記為 'CoClassAttribute'，而非標記為 'ComImportAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">介面標記為 'CoClassAttribute'，而非標記為 'ComImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Conditional 成員 '{0}' 不可有 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">存取子 '{0}' 無法為類型 '{2}' 實作介面成員 '{1}'。請使用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">命名空間別名限定詞 '::' 一定會解析為類型或命名空間，所以不能用在這裡。請考慮用 '.' 替代。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">無法從 '{0}' 衍生，因為其為類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">類型參數 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">類型參數 '{0}' 與外部類型 '{1}' 的類型參數名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">類型參數與外部類型的類型參數名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">類型參數 '{0}' 與包含類型或方法的名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'{0}' 不可同時實作 '{1}' 和 '{2}'，因為它們可能會整合某些類型參數的替代。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericDerivingFromAttribute">
        <source>A generic type cannot derive from '{0}' because it is an attribute class</source>
        <target state="translated">泛型類型不可衍生自 '{0}'，因為其為屬性類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">'{1}' 未定義類型參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'{0}' 不是有效的條件約束。用做為條件約束的類型，必須是介面、非密封類別或類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">條件約束不可為特殊類別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">不一致的存取範圍: 條件約束類型 '{1}' 比 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">無法在 '{0}' 中進行成員查詢，因為其為類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">條件約束類型無效。用做為條件約束的類型，必須是介面、非密封類別或類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'{0}': 不可在靜態類別中宣告執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'{1}': 不可衍生自靜態類別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">靜態類別不能有執行個體建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">靜態類別不能包含解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">無法建立靜態類別 '{0}' 的執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">靜態類別 '{0}' 不可衍生自類型 '{1}'。靜態類別必須衍生自 object。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'{0}': 靜態類別無法實作介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructInterfaceImpl">
        <source>'{0}': ref structs cannot implement interfaces</source>
        <target state="translated">'{0}': ref struct 無法實作介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'{0}': 靜態類別不可包含使用者定義的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">無法轉換成靜態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'{0}': 靜態類別不可用做為條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'{0}': 靜態類型不可用做為類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'{0}': 陣列元素不可為靜態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'{0}': 不可在靜態類別中宣告索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': 靜態類型不可用做為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': 靜態類型不可用做為傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">無法宣告靜態類型 '{0}' 的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">最內層 catch 子句中巢狀 finally 子句不允許沒有引數的 throw 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}' 不是有效的格式規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">可能對引數 '{0}' 進行了不正確的指派，而其為 using 或 lock 陳述式的引數。此區域變數的原始值，將會發生 Dispose 呼叫或解除鎖定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">可能不正確地指派給其為 using 或 lock 陳述式引數的本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">類型 '{0}' 定義於此組件中，但已為其指定類型轉送子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">無法轉送類型 '{0}'，因為其為 '{1}' 的巢狀類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">組件 '{1}' 中類型 '{0}' 的類型轉送子造成循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">只有在建置 'module' 的目標類型時，才可指定 /moduleassemblyname 選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">組件參考 '{0}' 無效，無法解析。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">指定做為 TypeForwardedTo 屬性引數的類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is static.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作介面成員，因為其為靜態。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作介面成員，因為其並非公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作 '{1}'，因為其沒有符合的傳回類型 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'{0}' 與 TypeForwardedToAttribute 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">查詢主體必須以 select 或 group 子句結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">必須是內容關鍵字 'on'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">必須是內容關鍵字 'equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">必須是內容關鍵字 'by'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">匿名類型成員宣告子無效。匿名類型成員必須以成員指派、簡單名稱或成員存取加以宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">初始設定式成員宣告子無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Lambda 參數用法不一致; 參數類型必須全部為明確類型或全部為隱含類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInvalidModifier">
        <source>A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers</source>
        <target state="translated">部分方法不可有存取修飾詞或 virtual、abstract、override、new、sealed 或 extern 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyInPartialClass">
        <source>A partial method must be declared within a partial class, partial struct, or partial interface</source>
        <target state="translated">在部分類別、部分結構或部分介面中必須宣告部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodCannotHaveOutParameters">
        <source>A partial method cannot have out parameters</source>
        <target state="translated">部分方法不可有 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodNotExplicit">
        <source>A partial method may not explicitly implement an interface method</source>
        <target state="translated">部分方法不可明確地實作介面方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">兩個部分方法宣告必須都是擴充方法，或者都不是擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">部分方法不可有多重定義宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">部分方法不能有多重實作的宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamsDifference">
        <source>Both partial method declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">兩個部分方法宣告都必須使用 params 參數，或兩者都不使用 params 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">找不到用以實作部分方法 '{0}' 宣告的定義宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentTupleNames">
        <source>Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">部份方法宣告 '{0}' 與 '{1}' 必須使用相同的元組元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">{0}' 的部分方法宣告對型別參數 '{1}' 有不一致的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">無法從方法 '{0}' 建立委派，因為它是無實作宣告的部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodStaticDifference">
        <source>Both partial method declarations must be static or neither may be static</source>
        <target state="translated">兩個部分方法宣告必須都是靜態，或者都不是靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodUnsafeDifference">
        <source>Both partial method declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">兩個部分方法宣告必須都是 unsafe，或者都不是 unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">在運算式樹狀結構中，不可使用只具有定義宣告或已移除條件式方法的部分方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustReturnVoid">
        <source>Partial methods must have a void return type</source>
        <target state="translated">部分方法必須有 void 傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">過時的成員 '{0}' 會覆寫非過時的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">過時成員會覆寫非過時成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">{0}' 的完整名稱對於偵錯資訊而言太長。在編譯時請勿使用 '/debug' 選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">偵錯資訊的完整名稱太長</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">無法將 {0} 指派給隱含類型變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">隱含類型變數必須經過初始設定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">隱含類型變數不可有多重宣告子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">無法使用陣列初始設定式來初始設定隱含類型變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">隱含類型區域變數不可為 fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">隱含類型變數不可為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">建構函式 '{0}' 標記為外部</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">建構函式標記為外部</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">內容關鍵字 'var' 只可出現在區域變數宣告或指令碼中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">找不到隱含類型陣列的最佳類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">無法將 '{0}' 指派給匿名型別屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">運算式樹狀結構不可包含基底存取</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">運算式樹狀結構不可包含指派運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">匿名類型不可具有多個同名的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">具有陳述式主體的 Lambda 運算式，不可轉換成運算式樹狀架構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">如果運算式樹狀結構的類型引數 '{0}' 不是委派類型，就無法將 Lambda 轉換成運算式樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">在常數運算式中不可使用匿名類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">is' 或 'as' 運算子的第一個運算元，不可為 Lambda 運算式、匿名方法或方法群組。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">as' 運算子的第一運算元不得為不含自然對數的元組常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">運算式樹狀結構不可包含多維陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">遺失引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">在宣告區域變數 '{0}' 之前，無法使用此變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">無法推斷 '{0}' 的類型，因為其初始設定式會直接或間接參考定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoProperty">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller.</source>
        <target state="translated">在控制權回到呼叫端之前，必須完整指派自動實作的屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">在宣告區域變數 '{0}' 之前，無法使用此變數。區域變數的宣告會隱藏欄位 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含左側為 null 或預設常值的聯合運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">必須是識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">必須是 ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">語法錯誤，必須是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">{0}' 修飾元重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">屬性存取子已定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">必須是 byte、sbyte、short、ushort、int、uint、long 或 ulong 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">逸出序列無法辨認</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">常數中包含新行字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">空的字元常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">字元常值中有太多字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">必須是 get 或 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">必須是物件、字串或類別類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">必須是具名屬性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Catch 子句無法接在 try 陳述式的一般 catch 字句之後</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">應有關鍵字 'this' 或 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">必須是可多載的一元運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">必須是可多載的二元運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">整數常數太大</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">必須是類型或命名空間定義，或檔案結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">必須是成員定義、陳述式或檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">內嵌的陳述式不能為宣告或標記陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">必須是前置處理器指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">必須是單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">必須是 )</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">必須是 #endif 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">未預期的前置處理器指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#error: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">#warning 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">必須是類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">於檔案第一個語彙基元後無法定義或取消定義前置處理器符號</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">無法在檔案的第一個語彙基元後使用 #r</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">找到檔案結尾，必須是 '*/'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">偵測到合併衝突標記</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">使用 refonly 時，請勿使用 refout。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">使用 /refout 或 /refonly 時無法編譯網路模組。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">必須是可多載的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">必須是 #endregion 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">未結束的字串常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">前置處理器指示詞必須出現為行中第一個非空白字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">必須是識別項; '{1}' 為關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">必須是 { 或 ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">無法在 for、using、fixed 或宣告陳述式中使用一個以上的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">必須是 add 或 remove 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">未預期的字元 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">未預期的語彙基元 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'{0}': 靜態類別不可包含 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">上一個 catch 子句已經攔截所有的例外狀況。所有擲回的非例外狀況都將包裝在 System.Runtime.CompilerServices.RuntimeWrappedException 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">前一個 catch 子句已提取所有例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">如果 catch() 區塊未在 catch (System.Exception e) 區塊後面指定例外狀況類型，則會導致此警告。此警告會建議 catch() 區塊將不會擷取任何例外狀況。

如果 AssemblyInfo.cs 檔案中的 RuntimeCompatibilityAttribute 設定為 false，則 catch (System.Exception e) 區塊後面的 catch() 區塊可以擷取非 CLS 例外狀況: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]。如果此屬性未明確地設定為 false，則所有擲回的非 CLS 例外狀況都會包裝為例外狀況，而 catch (System.Exception e) 區塊會加以擷取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">遞增或遞減運算子的運算元必須是變數、屬性或索引子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，也找不到可接受類型 '{0}' 第一個引數的可存取擴充方法 '{1}' (是否遺漏 using 指示詞或組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，也找不到擴充方法 '{1}' 可接受類型 '{0}' 的第一個引數 (是否遺漏 '{2}' 的 using 指示詞?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">方法 '{0}' 具有參數修飾元 'this'，但其不在第一個參數上。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> 參數修飾元 '{0}' 不可搭配 '{1}' 使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">擴充方法的第一個參數不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">擴充方法中，參數陣列不可用於 'this' 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">擴充方法必須為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">擴充方法必須在非泛型靜態類別中定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">參數只能有一個 '{0}' 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">擴充方法必須定義在最上層靜態類別中; {0} 為巢狀類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">無法定義新的擴充方法，因為找不到編譯器的必要類型 '{0}'。是否遺漏了 System.Core.dll 的參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.ExtensionAttribute'。請改用 'this' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.DynamicAttribute'。請改用 'dynamic' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">建構函式呼叫必須以動態方式分派，但因為其為建構函式初始設定式的一部分，所以無法動態分派。請考慮將動態引數轉型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">實值類型 '{1}' 上定義的擴充方法 '{0}'，無法用以建立委派。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">方法 '{0}' 沒有任何多載使用 {1} 個引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">引數 {0}: 無法從 '{1}' 轉換成 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">無法開啟原始程式檔 '{0}' -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">建立模組時無法連結資源檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">在此組件中已使用了資源識別項 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">每個連結資源與模組，都必須要有不重複的檔案名稱。在此組件中指定了一次以上的檔案名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">參考檔 '{0}' 不是組件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">ref 或 out 值必須是可指派的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">關鍵字 'base' 在靜態方法中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">在目前的內容中無法使用關鍵字 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">必須是 }</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">必須是 {</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'必須是 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">前置處理器運算式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, struct, or interface member declaration</source>
        <target state="translated">類別、結構或介面成員宣告中的語彙基元 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">方法必須要有傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">基底類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">空的 switch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">空的 switch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">必須是 catch 或 finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">運算式詞彙 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires (), [], or {} after type</source>
        <target state="translated">new 運算式在類型後需要有 ()、[] 或 {}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">在命名空間中定義的元素無法明確宣告為 private、protected、protected internal 或 private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">必須是 ; 或 = (無法在宣告中指定建構函式引數)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">using 子句必須位於所有其他命名空間中所定義的元素之前 (外部別名宣告除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">多載二元運算子 '{0}' 接受兩個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">多載一元運算子 '{0}' 接受一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">參數類型 'void' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">using 別名 '{0}' 之前曾出現於此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">無法經由類型 '{1}' 的限定詞，來存取保護的成員 '{0}'; 限定詞必須是類型 '{2}' (或從其衍生的類型)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'{0}' 因為已是組件，所以無法加入此組件中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">此語言不支援屬性、索引子或事件 '{0}'; 請嘗試直接呼叫存取子方法 '{1}' 或 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">此語言不支援屬性、索引子或事件 '{0}'; 請嘗試直接呼叫存取子方法 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">在此內容中不可使用關鍵字 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">索引子至少要有一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">陣列類型規範 [] 必須出現在參數名稱之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">宣告無效; 請改用 '{0} operator &lt;dest-type&gt; (...'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">找不到為 Main 方法所指定的 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, struct, or interface</source>
        <target state="translated">為 Main 方法指定的 '{0}' 必須為非泛型類別、結構或介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">'{0}' 沒有適合的靜態 Main 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">無法為 Main 方法使用 '{0}'，因為其為匯入物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">沒有來源的輸出必須有指定的 /out 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">指定的選項衝突: Win32 資源檔; Win32 資訊清單</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">指定的選項衝突: Win32 資源檔; Win32 圖示</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">讀取資源 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">寫入 XML 文件檔案時發生錯誤: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">XML 註解有格式錯誤的 XML -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">XML 註解有格式錯誤的 XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">XML 註解中的 '{0}' 有重複的 param 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">XML 註解中有重複的 param 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">XML 註解中的 '{0}' 有 param 標籤，但沒有該名稱的參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">XML 註解具有 param 標籤，但是沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">{1}' 上的 XML 註解中的 '{0}' 有 paramref 標籤，但沒有該名稱的參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">XML 註解具有 paramref 標籤，但是沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">參數 '{0}' 在 '{1}' 的 XML 註解中沒有相符的 param 標籤 (但其他參數有)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">在 XML 註解中，參數沒有相符的 param 標籤 (但其他參數則相反)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">XML 註解有無法解析的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">XML 註解有無法解析的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">stackalloc 運算式在類型之後需要有 []</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">為 #line 指示詞指定的行號遺漏或無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">必須是檔案名稱、單行註解或行結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">必須是以引號括住的檔案名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">#r 只可用於指令碼中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'</source>
        <target state="translated">foreach 陳述式不可用在類型 '{0}' 的變數上，因為 '{0}' 未包含 '{1}' 的公用執行個體定義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">XML 註解 cref 屬性中參數 {0} 的類型無效: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的參數類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的傳回類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的傳回類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">讀取 Win32 資源時發生錯誤 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">XML 註解有句法不正確的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">XML 註解有句法不正確的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">成員修飾元 '{0}' 必須在成員類型與名稱之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">建立陣列必須有陣列大小或陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 註解沒有放置在有效的語言項目前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 註解沒有放置在有效的語言項目前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">無法納入檔案 '{0}' 的 XML 片段 '{1}' -- {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">無法包含 XML 片段</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">XML include 元素無效 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">無效的 XML include 項目</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">遺漏公用可見類型或成員 '{0}' 的 XML 註解</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">遺漏公用可見類型或成員的 XML 註解</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">已指定 /doc 編譯器選項，但是一個或多個建構沒有註解。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Include 註解檔中的 XML 格式錯誤 -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Include 註解檔中的 XML 格式錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">委派 '{0}' 不接受 {1} 個引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">方法或存取子區塊後的分號無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>Method or delegate cannot return type '{0}'</source>
        <target state="translated">方法或委派無法傳回類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">使用者取消了編譯</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">無法製作類型 '{0}' 之變數的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">無法指派給 '{0}'，因為其為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">無法將 '{0}' 用作為 ref 或 out 值，因其為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">C# 類型上不可使用 RequiredAttribute 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">修飾元不能置於事件存取子宣告中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">params 參數不可宣告為 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">無法修改 '{0}' 的傳回值，因為其非變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">找不到介面 '{1}' 的 Managed coclass 包裝函式類別 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'; use either '@{0}' or '{0}Attribute'</source>
        <target state="translated">'{0}' 在 '{1}' 與 '{2}' 之間模稜兩可; 請使用 '@{0}' 或 '{0}Attribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">傳遞引數 {0} 時不可包含 '{1}' 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">選項 '{0}' 會覆寫原始程式檔或加入的模組中所指定之屬性 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">選項會覆寫原始程式檔或加入的模組中所指定的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">如果來源中所找到的組件屬性 AssemblyKeyFileAttribute 或 AssemblyKeyNameAttribute，與 [專案屬性] 中所指定的 /keyfile 或 /keycontainer 命令列選項或金鑰檔案名稱或金鑰容器衝突，則會發生此警告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">/langversion 的選項 '{0}' 無效。請使用 '/langversion:?' 來列出支援的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">無法以 '{0}' 建立委派，因為其或其所覆寫的方法具有 Conditional 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">無法建立暫存檔 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">傳遞引數 {0} 時必須包含 '{1}' 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">在匿名方法或 Lambda 運算式內不可使用 yield 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">無法從迭代器傳回值。請使用 yield return 陳述式傳回值，或使用 yield break 結束反覆運算。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">迭代器不能有 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">{0}' 的主體不可是迭代區塊，因為 '{1}' 不是 Iterator 介面類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">finally 子句的主體中不可使用 yield</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">在具有 catch 子句的 try 區塊主體中不可使用 yield 產生值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">yield return 之後應接著運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">無法在匿名方法、Lambda 運算式、查詢運算式或區域函式中使用 ref、out 或 in 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalInnerUnsafe">
        <source>Unsafe code may not appear in iterators</source>
        <target state="translated">Unsafe 程式碼不可出現在迭代器中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">無法在 catch 子句主體中使用 yield 產生值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">程式控制權不能從匿名方法或 Lambda 運算式的主體離開</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">無法辨認的 #pragma 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">無法辨認的 #pragma 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">應為 'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">#pragma 警告後應有 'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">無法還原警告 'CS{0}'，因為其已全域停用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">無法還原警告，因為已全域予以停用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">迭代器的參數清單中不可有 __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have unsafe parameters or yield types</source>
        <target state="translated">迭代器不能有 Unsafe 參數或 yield 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">介面 '{1}' 的 Managed coclass 包裝函式類別簽章 '{0}'，不是有效的類別名稱簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">foreach 陳述式不可用在類型 '{0}' 的變數上，因為其會實作 '{1}' 的多個具現化; 請嘗試轉型為特定的介面具現化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">固定大小緩衝區欄位在欄位名稱後面必須有陣列大小規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">固定大小緩衝區欄位必須是結構的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">並非所有程式碼路徑都會在類型為 '{1}' 的 {0} 中傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">{0}' 功能不包括在標準化 ISO C# 語言規格中，在其他編譯器上可能無法接受。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">功能不包括在標準化 ISO C# 語言規格中，在其他編譯器上可能無法接受</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">逐字規範 "@" 之後應接著關鍵字、識別項或字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">無法將唯讀欄位用作為 ref 或 out 值 (除非在建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">無法將唯讀欄位 '{0}' 的成員用作為 ref 或 out 值使用 (除非在建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor of the class in which the field is defined or a variable initializer))</source>
        <target state="translated">無法予以指派項目的唯讀欄位 (除非位於定義欄位所在類別的建構函式中或位於變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">唯讀欄位 '{0}' 的成員不可修改 (除非在建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' 無法用為 ref 或 out 值，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' 的成員不可用為 ref 或 out 值，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' because it is a readonly variable</source>
        <target state="translated">無法指派至 {0} '{1}'，因為它不是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' because it is a readonly variable</source>
        <target state="translated">無法指派給 {0} '{1}' 的成員，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">無法以可寫入傳址方式傳回 {0} '{1}'，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">無法以可寫入傳址方式傳回 {0} '{1}' 的成員，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">無法指派為靜態唯讀欄位 '{0}' 的欄位 (除非在靜態建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">無法將靜態唯讀欄位 '{0}' 的欄位用作為 ref 或 out 值 (除非在靜態建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">無法修改 '{0}' 的成員，因為其為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">無法將 '{0}' 的欄位用作為 ref 或 out 值，因其為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">無法指派給 '{0}'，因為其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">無法將 '{0}' 用作為 ref 或 out 值，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}。請參閱錯誤 CS{1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">警告會覆寫錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">編譯器將錯誤覆寫為警告時會發出此警告。如需此問題的相關資訊，請搜尋提及的錯誤碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">無法將 {0} 轉換成類型 '{1}'，因為其非委派類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">因為參數類型與委派參數類型不符，所以無法將 {0} 轉換為類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">無法將 {0} 轉換成想要的委派類型，因為區塊中的某些傳回類型，無法隱含轉換成委派傳回類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than 'Task&lt;{0}&gt;'</source>
        <target state="translated">因為此為非同步方法，所以傳回運算式的類型必須是 '{0}' 而非 'Task&lt;{0}&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">無法將非同步 {0} 轉換成委派類型 '{1}'。非同步 {0} 可能會傳回 void、Task 或 Task&lt;T&gt;，而這些都無法轉換成 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">固定大小緩衝區類型必須是下列其中一項: bool、byte、short、int、long、char、sbyte、ushort、uint、ulong、float 或 double。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">長度為 {0} 且類型為 '{1}' 的固定大小緩衝區太大</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">固定大小緩衝區的長度必須大於零</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">您不能使用包含在 unfixed 運算式中的固定大小緩衝區。請嘗試使用 fixed 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在屬性或事件存取子上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">在 '{1}' 中指定了的搜尋路徑 '{0}' 無效 -- '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">指定的搜尋路徑無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">__arglist 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">params 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">命名空間宣告不能有修飾元或屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">/platform 的 '{0}' 選項無效; 必須是 anycpu、x86、Itanium、arm、arm64 或 x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.</source>
        <target state="translated">結構內部的匿名方法、Lambda 運算式和查詢運算式無法存取 'this' 的執行個體成員。請考慮將 'this' 複製到匿名方法、Lambda 運算式或查詢運算式外部的區域變數，並改用這個區域變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.</source>
        <target state="translated">'{0}': using 陳述式中使用的類型必須可以隱含轉換為 'System.IDisposable'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">參數 {0} 必須以 '{1}' 關鍵字宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">參數 {0} 不可以 '{1}' 關鍵字宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">參數 {0} 宣告為類型 '{1}{2}'，但應該是 '{3}{4}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">/reference' 的外部別名無效; '{0}' 不是有效的識別項。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">參考別名選項無效: '{0}=' -- 遺漏檔案名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">您不能重新定義全域外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">類型 '{0}' 的參考表示它定義在此組件中，但是在原始檔或任何加入的模組中都未定義它。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">類型 '{0}' 的參考表示它定義在 '{1}' 中，但找不到。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">預先定義的類型 '{0}' 在全域別名的多個組件中都有定義; 請使用 '{1}' 中的定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">預先定義的類型定義在全域別名的多個組件中</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">如果在兩個組件中找到預先定義的系統類型 (例如 System.Int32)，則會發生此錯誤。可能發生此狀況的其中一種原因是參考兩個不同位置的 mscorlib 或 System.Runtime.dll，例如嘗試並排執行兩個版本的 .NET Framework。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">無法取得區域變數 '{0}' 或其成員的位址，這些也無法用於匿名方法或 Lambda 運算式內部。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">原始程式檔已超過 PDB 所能顯示的上限 16,707,565 行; 偵錯資訊可能會不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">原始程式檔已超過 PDB 所能顯示的上限 16,707,565 行; 偵錯資訊可能會不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">無法將沒有參數清單的匿名方法區塊，轉換成委派類型 '{0}'，因為其有一或多個 out 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">屬性 '{0}' 只有在方法或屬性類別上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">存取 '{0}' 上的成員可能會造成執行階段例外狀況，因為其為傳址封送類別的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">存取傳址封送類別之欄位上的成員，可能會導致執行階段例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">如果嘗試在類別衍生自 MarshalByRefObject 的成員上呼叫方法、屬性或索引子，而且成員是實值類型，則會發生此警告。繼承自 MarshalByRefObject 的物件通常是要透過參考跨應用程式定義域進行封送處理。如果任何程式碼曾經嘗試跨應用程式定義域直接存取這類物件的 value-type 成員，則會發生執行階段例外狀況。若要解決此警告，請先將成員複製至區域變數，並對該變數呼叫此方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">'{0}' 不是有效的警告編號</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">不是有效的警告號碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">傳遞給 #pragma 警告前置處理器指示詞的號碼不是有效的警告號碼。請驗證號碼代表警告，而不是錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">對前置處理器指示詞指定了無效的檔名。檔名太長或者不是有效的檔名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">針對前置處理器指示詞所指定的檔名無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">#pragma checksum 語法無效; 應該是 #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">#pragma 總和檢查碼語法無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">必須是單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">#pragma 指示詞後面必須有單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">為 '{0}' 指定了不同的總和檢查碼值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">指定不同的 #pragma 總和檢查碼值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">組件參考 '{0}' 無效，無法解析。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">組件參考無效，無法進行解析</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">此警告指出未正確地指定屬性 (例如 InternalsVisibleToAttribute)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">假設 '{1}' 所使用的組件參考 '{0}' 符合 '{3}' 的識別 '{2}'，您可能會需要提供執行階段原則。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">假設組件參考符合識別</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">兩個組件的版次和 (或) 版本號碼不同。若要進行統一，您必須在應用程式的 .config 檔案中指定指示詞，而且您必須提供組件的正確強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">假設 '{1}' 所使用的組件參考 '{0}' 符合 '{3}' 的識別 '{2}'，您可能會需要提供執行階段原則。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">假設組件參考符合識別</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">兩個組件的版次和 (或) 版本號碼不同。若要進行統一，您必須在應用程式的 .config 檔案中指定指示詞，而且您必須提供組件的正確強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">已匯入具有相同識別的多個組件: '{0}' 和 '{1}'。請移除其中一個重複的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">匯入了具有相同簡單名稱 '{0}' 的組件。請嘗試移除其中一個參考 (例如 '{1}')，或簽署它們以啟用並存。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">識別為 '{1}' 的組件 '{0}' 會使用 '{2}'，而後者的版本高於識別為 '{4}' 的參考組件 '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">固定大小緩衝區只能透過區域變數或欄位存取</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">XML 註解中的 '{0}' 有重複的 typeparam 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">XML 註解中有重複的 typeparam 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">XML 註解中的 '{0}' 有 typeparam 標籤，但沒有該名稱的類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">XML 註解具有 typeparam 標籤，但是沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">{1}' 上的 XML 註解中的 '{0}' 有 typeparamref 標籤，但沒有該名稱的類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">XML 註解具有 typeparamref 標籤，但是沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">類型參數 '{0}' 在 '{1}' 的 XML 註解中沒有相符的 typeparam 標籤 (但是其他類型參數有)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">在 XML 註解中，類型參數沒有相符的 typeparam 標籤 (但其他類型參數則相反)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 類型必須是 '{2}' 才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.FixedBuffer' 屬性。請改用 'fixed' 欄位修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">對同一個變數進行指派; 您是否想要指派別的東西?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">對相同變數進行的指派</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">對同一個變數進行比較; 您是否想要比較別的東西?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">對相同變數進行的比較</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">開啟 Win32 資源檔 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">運算式一律會造成 System.NullReferenceException，因為 '{0}' 的預設值為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">運算式一律會造成 System.NullReferenceException，因為類型的預設值為 null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">類別 '{0}' 不可有多重基底類別: '{1}' 和 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">基底類別 '{0}' 必須在所有介面之前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">XML 註解具有參考類型參數的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">XML 註解具有參考類型參數的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Friend 組件參考 '{0}' 無效。InternalsVisibleTo 宣告不可指定版本、文化特性、公開金鑰語彙基元或處理器架構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Friend 組件參考 '{0}' 無效。以強式名稱簽署的組件，在其 InternalsVisibleTo 宣告中必須指定公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">無法將委派繫結至 '{0}'，因為其為 'System.Nullable&lt;T&gt;' 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'{0}' 未包含使用 {1} 個引數的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">組件和模組屬性必須位於檔案中所有定義的其他項目之前 (using 子句與外部別名宣告除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">必須是運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">/subsystemversion 的版本 {0} 無效。ARM 或 AppContainerExe 的版本必須是 6.02 (含) 以上的版本，其他則必須是 4.00 (含) 以上的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">內嵌 Interop 方法 '{0}' 包含主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be in the range 0-4</source>
        <target state="translated">警告層級必須介於範圍 0 到 4 之間</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">/debug 的選項 '{0}' 無效; 必須為 'portable'、'embedded'、'full' 或 'pdbonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">選項 '{0}' 無效; 資源可見度必須是 'public' 或 'private'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">DefaultParameterValue 屬性的引數類型和參數類型必須相符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">類型 '{0}' 的引數不適用於 DefaultParameterValue 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">成員 '{0}' 的初始設定重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">成員 '{0}' 無法進行初始設定，它不是欄位或屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">無法在物件初始設定式中指派靜態欄位或屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">類型為 '{1}' 的唯讀欄位 '{0}' 之成員，無法以物件初始設定式進行指派，因為其為實值類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">類型 '{1}' 且屬性為 '{0}' 的成員，無法以物件初始設定式進行指派，因為其為實值類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">建立物件時不能使用 Unsafe 類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">項目初始設定式不可為空白</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">最符合 '{0}' 的多載方法，沒有正確的初始設定式元素簽章。可初始化的 Add 必須是可存取的執行個體方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">無法使用集合初始設定式來初始設定類型 '{0}'，因為其未實作 'System.Collections.IEnumerable'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">讀取 Win32 資訊清單檔 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">因為模組的 /win32manifest 僅適用於組件，因此將予以忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">因為模組的 /win32manifest 僅適用於組件，因此將予以忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，且最佳擴充方法多載 '{2}' 需要類型 '{3}' 的接收器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">已宣告範圍變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">範圍變數 '{0}' 與之前的 '{0}' 宣告相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">無法指派 {0} 至範圍變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。請考慮明確地指定範圍變數 '{2}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。是否遺漏了 'System.Core.dll' 的參考或 'System.Linq' 的 using 指示詞?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名稱 '{0}' 不在 'equals' 左側的範圍內。請考慮交換 'equals' 任一側的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名稱 '{0}' 不在 'equals' 右側的範圍內。請考慮交換 'equals' 任一側的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">無法將範圍變數 '{0}' 以 out 或 ref 參數的方式傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">為來源類型 '{0}' 找到多個查詢模式實作。模稜兩可的 '{1}' 呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 子句中的其中一個運算式類型不正確。呼叫 '{1}' 時發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 子句中的運算式類型不正確。呼叫 '{1}' 時發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">在具來源類型為 '{1}' 的查詢運算式內的後續 from 子句中，不可使用類型 '{0}' 的運算式。呼叫 '{2}' 時，發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">運算式樹狀結構不可包含 unsafe 指標作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">運算式樹狀結構不可包含匿名方法運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">匿名方法運算式無法轉換成運算式樹狀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">無法指派為範圍變數 '{0}' -- 其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">範圍變數 '{0}' 不可與方法類型參數同名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">無法在範圍變數宣告中使用內容關鍵字 'var'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">集合初始設定式最符合的多載 Add 方法 '{0}'，有一些無效的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含具有變數引數的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含方法群組</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">無法使用集合初始設定式項目最符合的多載方法 '{0}'。集合初始設定式 'Add' 方法不能具有 ref 或 out 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">非可叫用成員 '{0}' 不能用做為方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">成員 '{0}' 會實作類型 '{2}' 的介面成員 '{1}'。在執行階段發現多個相符的介面成員。實作將會視所呼叫的方法而定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">成員會在執行階段實作具有多個相符項的介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">當兩介面方法的差異只在於特定參數的標記方式是 ref 還是 out 時，便可能產生此警告。因為在執行階段所呼叫方法既不明顯，也沒辦法預先確認，所以最好變更程式碼來避免此警告。

雖然 C# 會區分 out 與 ref，但是 CLR 會將它們視為相同。決定實作介面的方法時，CLR 只會選擇其中一個。

請為編譯器提供呼叫方法的區分方式。例如，您可以為它們指定不同的名稱，或在其上提供其他參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">成員 '{1}' 會覆寫 '{0}'。在執行階段有多個覆寫候選項。實作將視所呼叫的方法而定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">成員會在執行階段覆寫具有多個覆寫候選項的基底成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">物件與集合初始設定式運算式不可套用到委派建立運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'{0}' 為類型 '{1}'。常數宣告中指定的類型，必須為 sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、string、列舉類型或參考類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">找不到原始程式檔 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">已指定多次原始程式檔 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">已指定多次原始程式檔</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">遺漏 '{0}' 選項的檔案規格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">命令列語法錯誤: 遺漏 '{1}' 選項的 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">選項無法辨認: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">未指定任何原始程式檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">未指定任何原始程式檔</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">必須是指令碼 (.csx 檔)，但未指定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">開啟回應檔 '{0}' 時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">無法開啟 '{0}' 進行寫入 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">映像基底編號 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'{0}' 是二進位檔案而非文字檔</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">字碼頁 '{0}' 無效或未安裝</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">不支援演算法 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">在建置模組或程式庫時不能指定 /main</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">/target: 的目標類型無效。必須指定 'exe'、'winexe'、'library' 或 'module'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">因為在回應檔中已指定 /noconfig 選項，所以將會忽略該選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">因為在回應檔中已指定 /noconfig 選項，所以將會忽略該選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">無效的檔案區段記憶體對齊 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">無效的輸出名稱: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">無效的偵錯資訊格式: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'不再支援 'id#' 語法。請改用 '$id'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; '{0}' 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">無法建立短的檔名 '{0}'，因為已有長檔名的名稱和該短檔名相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">宣告外部別名的 /reference 選項只能有一個檔名。若要指定多個別名或檔名，請用多個 /reference 選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">命令列語法錯誤: 遺漏 '{0}' 選項的 ':&lt;number&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">/pdb 選項需要同時使用 /debug 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含引數上省略 ref 的 COM 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">命令列語法錯誤: 選項 '{1}' 的 Guid 格式 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">命令列語法錯誤: 遺漏選項 '{1}' 的 Guid</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">具有變數引數的方法不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">具有變數引數的方法不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">引數類型 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">引數類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 的傳回類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">傳回類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 的類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">公用、保護或保護內部變數的類型必須符合 Common Language Specification (CLS) 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">只有大小寫不相同的識別項 '{0}'，不符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">只有大小寫不同的識別項，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">只有 ref/out 或陣列陣序差異的多載方法 '{0}'，不符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">只有 ref/out 或陣列陣序差異的多載方法，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">只有未命名陣列類型有差異的多載方法 '{0}'，不符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">只有未命名陣列類型有差異的多載方法，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">如果您的多載方法採用不規則陣列，而且方法簽章之間的唯一差異是陣列的項目類型，則會發生此錯誤。若要避免此錯誤，請考慮使用矩形陣列，而非不規則陣列; 請使用其他參數來釐清函式呼叫; 請重新命名一個或多個多載方法; 或者，如果不需要符合 CLS 規範，請移除 CLSCompliantAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">識別項 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">識別項不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}': 基底類型 '{1}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">基底類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">在標記為符合 CLS 規範的組件中，基底類型標記為不需要符合 Common Language Specification (CLS) 規範。移除指定組件符合 CLS 規範的屬性，或移除指出類型不符合 CLS 規範的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'{0}': 符合 CLS 規範的介面內，所有成員都必須符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">符合 CLS 規範的介面內，所有成員都必須符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'{0}': 只有符合 CLS 規範的成員，才可為抽象。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">只有符合 CLS 規範的成員，才可為抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">您必須在組件 (而非模組) 上指定 CLSCompliant 屬性，以啟用 CLS 合規性檢查。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">您必須在組件 (而非模組) 上指定 CLSCompliant 屬性，以啟用 CLS 合規性檢查。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">新增的模組必須以 CLSCompliant 屬性標記，才能與這個組件相符</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">新增的模組必須以 CLSCompliant 屬性標記，才能與這個組件相符</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'因為組件沒有 CLSCompliant 屬性，所以 '{0}' 不可標記為符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">因為組件沒有 CLSCompliant 屬性，所以類型或成員不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'{0}' 沒有僅使用符合 CLS 規範之類型的可存取建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">類型沒有僅使用符合 CLS 規範之類型的可存取建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">以陣列做為屬性引數不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">以陣列做為屬性引數不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">在模組上指定的 CLSCompliant 屬性不能與組件上的 CLSCompliant 屬性不同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">在模組上指定的 CLSCompliant 屬性不能與組件上的 CLSCompliant 屬性不同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'因為 '{0}' 是不符合 CLS 規範之類型 '{1}' 的成員，所以不可標記為符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">因為類型是不符合 CLS 規範之類型的成員，所以不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">將不會在 '{0}' 上執行 CLS 合規性檢查，因為從此組件之外無法看到它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">將不會執行 CLS 合規性檢查，因為這個組件不是外部可見的</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'{0}' 不需要 CLSCompliant 屬性，因為組件並沒有 CLSCompliant 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">因為組件沒有 CLSCompliant 屬性，所以類型或成員不需要 CLSCompliant 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 屬性套用在參數上沒有意義，請改為置於方法上。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">CLSCompliant 屬性在套用至參數時沒有任何意義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 屬性套用至傳回類型沒有意義，請改為置於方法上。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">CLSCompliant 屬性在套用至傳回類型時沒有任何意義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">條件約束類型 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">條件約束類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">符合 CLS 規範的欄位 '{0}' 不可為 Volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">符合 CLS 規範的欄位不可為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}' 不符合 CLS 規範，因為基底介面 '{1}' 不符合 CLS 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">類型不符合 CLS 規範，因為基底介面不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">'await' 要求類型 {0} 必須要有適合的 GetAwaiter 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">無法等候 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">'await' 要求 '{1}.GetAwaiter()' 的傳回類型 '{0}' 必須是適合的 IsCompleted、OnCompleted 和 GetResult 成員，且實作 INotifyCompletion 或 ICriticalNotifyCompletion。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">'await' 要求類型 '{0}' 必須要有適合的 GetAwaiter 方法。是否遺漏了 'System' 的 using 指示詞?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">無法等候 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'await' 不能當做非同步方法或 Lambda 運算式中的識別項使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'{0}' 未實作 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">因為 '{0}' 是會傳回 'Task' 的非同步方法，所以 return 關鍵字之後不可接著物件運算式。原本希望傳回 'Task&lt;T&gt;' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">非同步方法的傳回類型必須為 void、Task、Task&lt;T&gt;、task-like 類型、IAsyncEnumerable&lt;T&gt; 或 IAsyncEnumerator&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">無法傳回類型 'void' 的運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">非同步方法的參數清單中不可出現 __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>'await' cannot be used in an expression containing the type '{0}'</source>
        <target state="translated">'await' 不得用於包含類型 '{0}' 的運算式中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have unsafe parameters or return types</source>
        <target state="translated">非同步方法不能有 Unsafe 參數或 return 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">非同步方法不可出現 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">await' 運算子只有在包含於以 'async' 修飾元標記的方法或 Lambda 運算式中時，才可使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">await' 運算子只可用在非同步 {0} 中。請考慮以 'async' 修飾元標記此 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">await' 運算子只可用在非同步方法中。請考慮以 'async' 修飾元標記此方法，並將其傳回類型變更為 'Task&lt;{0}&gt;'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">await' 運算子只可用於非同步方法中。請考慮以 'async' 修飾元標記此方法，並將其傳回類型變更為 'Task'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">無法在 finally 子句的主體中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">無法在 catch 子句中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">無法在 catch 子句的篩選條件運算式中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">無法在 lock 陳述式的主體中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">await' 運算子不可用於靜態指令碼變數初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">無法在不安全的內容中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">async' 修飾元只可用於具有主體的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefLocal">
        <source>Parameters or locals of type '{0}' cannot be declared in async methods or lambda expressions.</source>
        <target state="translated">類型 '{0}' 的參數或區域變數，不可在非同步方法或 Lambda 運算式中宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefIterator">
        <source>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.</source>
        <target state="translated">foreach 陳述式無法對 async 或 iterator 方法中類型 '{0}' 的列舉值進行操作，因為 '{0}' 為 ref struct。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">安全屬性 '{0}' 無法套用至非同步方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">具有 'SecurityCritical' 或 'SecuritySafeCritical' 屬性的介面、類別或結構中，不可使用非同步方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">await' 運算子只能用在初始 'from' 子句的第一個集合運算式或 'join' 子句的集合運算式中的查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">這個非同步方法缺少 'await' 運算子，因此將以同步方式執行。請考慮使用 'await' 運算子等候未封鎖的應用程式開發介面呼叫，或使用 'await Task.Run(...)' 在背景執行緒上執行 CPU-bound 工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">Async 方法缺乏 'await' 運算子，將同步執行</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">因為未等候此呼叫，所以在呼叫完成之前會繼續執行目前的方法。請考慮將 'await' 運算子套用至呼叫的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">因為未等待此呼叫，所以在完成呼叫之前會繼續執行目前方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">目前方法會呼叫傳回 Task 或 Task&lt;TResult&gt; 的 async 方法，而且不會將 await 運算子套用至結果。呼叫 async 方法會啟動非同步工作。不過，因為未套用 await 運算子，所以程式會繼續進行，而不會等待工作完成。在大多數情況下，該行為不會是您預期的行為。通常，calling 方法的其他層面取決於呼叫結果，或者至少必須先 called 方法，您才能從包含該呼叫的方法傳回。

另一個同樣重要的問題是，在 called async 方法中所引發的例外狀況會發生什麼情況。傳回 Task 或 Task&lt;TResult&gt; 之方法中所引發的例外狀況，會儲存在傳回的工作中。如果您不等待工作或明確地檢查例外狀況，則會遺失例外狀況。如果您等待工作，則會重新擲出其例外狀況。

最佳做法是一律等待呼叫。

只有在確定不想要等待非同步呼叫完成，且 called 方法不會引發任何例外狀況時，才應該考慮隱藏警告。在該情況下，將呼叫的工作結果指派給變數，即可隱藏警告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'MethodImplOptions.Synchronized' 無法套用至非同步方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerLineNumberAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerFilePathAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerMemberNameAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerLineNumberAttribute 將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute 將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerFilePathAttribute 將沒有作用，因為它套用到不允許選擇性引數的內容中所使用的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerFilePathAttribute 將沒有作用，因為它套用到不允許選擇性引數的內容中所使用的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">程式未包含適合進入點的靜態 'Main' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">必須是長度為 '{0}' 的陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">必須是巢狀的陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">變異數修飾元無效。只有介面及委派類型參數才可指定為變異數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">未預期的別名用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">未預期的泛型名稱用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">未預期的未繫結泛型名稱用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">運算式與陳述式只可出現在方法主體中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">陣列存取不能有具名引數規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">尚未實作語言功能 ('{0}')。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">預設值在此內容中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">開啟圖示檔 {0} 時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">開啟 Win32 資訊清單檔案 {0} 時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">建置 Win32 資源時發生錯誤 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">選擇性參數必須出現在所有必要參數之後</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">無法繼承具有指定之類型參數的介面 '{0}'，因為其會讓方法 '{1}' 包含只有在 ref 和 out 上有所差異的多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">{0}' 的部分宣告必須具有相同順序的相同類型參數名稱與變異數修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">變異數無效: 類型參數 '{1}' 必須是在 '{0}' 上有效的 {3}。'{1}' 是 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'{0}': 無法衍生自動態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'{0}': 無法實作動態介面 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">條件約束不可為動態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">條件約束不可為動態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">找不到編譯動態運算式所需的一或多種類型。您是否遺漏了參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">名稱 '{0}' 超過中繼資料內所允許的長度上限。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">屬性在此內容中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'extern alias' 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">使用 '{0}' 測試與 '{1}' 的相容性，基本上和測試與 '{2}' 的相容性是一樣的，而且對所有非 null 值都會成功。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">使用 'is' 測試與 'dynamic' 的相容性，基本上與測試與 'Object' 的相容性相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">無法在頂層指令碼中使用 'yield'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">無法在指令碼中宣告命名空間</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">此內容中不可使用組件與模組屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">委派 '{0}' 沒有叫用方法，或是叫用方法包含了不支援的傳回類型或參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global script code; ignoring '{0}' entry point.</source>
        <target state="translated">程式的進入點為全域指令碼; 將略過 '{0}' 進入點。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global script code; ignoring entry point</source>
        <target state="translated">程式的進入點是全域指令碼; 將忽略進入點</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">is' 或 'as' 運算子的第二個運算元不可為靜態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">不一致的存取範圍: 事件類型 '{1}' 比事件 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">必須在所有固定引數皆已指定之後，具名引數規格才可出現。請使用語言版本 {0} 或更高的版本，以允許非後置的具名引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">必須在所有固定引數皆已在動態引動過程中指定之後，具名引數規格才可出現。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">最符合 '{0}' 的多載，沒有名稱為 '{1}' 的參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">委派 '{0}' 沒有名稱為 '{1}' 的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">不可指定多次具名引數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">具名引數 '{0}' 會指定已指定其位置引數的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">具名引數 '{0}' 未用在正確的位置，但後面接著未命名引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">不能連同 DefaultParameterAttribute 或 OptionalAttribute 一起指定預設參數值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">{0}' 的預設參數值必須是編譯時期的常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">ref 或 out 參數不能有預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">無法指定 'this' 參數的預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter array</source>
        <target state="translated">無法指定參數陣列的預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">類型 '{0}' 的值不可用做為預設參數，因為沒有標準轉換至類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">類型 '{0}' 的值不可用做為可為 Null 之參數 '{1}' 的預設參數，因為 '{0}' 不是簡單類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'{0}' 為類型 '{1}'。非字串之參考類型的預設參數值，只能以 null 初始設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">為參數 '{0}' 指定的預設值將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">指定的預設值將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">使用檔案 '{0}' 的公開金鑰簽署輸出時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">使用容器 '{0}' 的公開金鑰簽署輸出時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">typeof 運算子不能用於動態類型上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">運算式樹狀結構不可包含動態作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">非同步 Lambda 運算式不可轉換成運算式樹狀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">無法定義利用 'dynamic' 的類別或成員，因為找不到編譯器的必要類型 '{0}'。是否遺漏了參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">無法傳遞 Null 做為 Friend 組件名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">金鑰檔案 '{0}' 遺漏簽署所需的私密金鑰</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">公開簽章已指定且需要公開金鑰，但並未指定任何公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">對 netmodule 不支援公開簽署。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">指定了延遲簽署且需要公開金鑰，但未指定任何公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">指定了延遲簽署且需要公開金鑰，但未指定任何公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">指定的版本字串不符合所需的格式 - major[.minor[.build[.revision]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">指定的版本字串包含萬用字元，但這與確定性不相容。請移除版本字串中的萬用字元，或停用此編譯的確定性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">指定的版本字串不符合所需的格式: major.minor.build.revision (不含萬用字元)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定的版本字串不符合建議的格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定的版本字串不符合建議的格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">可執行檔不可為附屬組件; 文化特性需保留為空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'</source>
        <target state="translated">未提供任何可對應到 '{1}' 之必要型式參數 '{0}' 的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">命令列參數 '{0}' 尚未獲實作，已忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">尚未實作命令列參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">無法發出模組 '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">無法在匿名方法、Lambda 運算式或查詢運算式中，使用固定的區域變數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">運算式樹狀結構不可包含具名引數規格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">運算式樹狀結構不可包含使用選擇性引數的呼叫或引動過程</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">運算式樹狀結構不可包含具備索引的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">索引屬性 '{0}' 有必須提供的非選擇性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">索引屬性 '{0}' 的所有引數都必須是選擇性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">類型 '{0}' 的執行個體不可用於巢狀函式、查詢運算式、迭代區塊或非同步方法中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">安全屬性的第一個引數必須是有效的 SecurityAction</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">安全屬性 '{0}' 出現無效的 SecurityAction 值 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">SecurityAction 值 '{0}' 對套用至組件的安全屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">SecurityAction 值 '{0}' 對套用至類型或方法的安全屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">SecurityAction 值 '{0}' 對 PrincipalPermission 屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">運算式樹狀結構不可包含 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">無法解析為 PermissionSet 屬性的具名引數 '{1}' 所指定之檔案路徑 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">讀取為 PermissionSet 屬性的具名引數 '{1}' 所定之檔案 '{0}' 時，發生錯誤: '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">全域命名空間中找不到類型名稱 '{0}'。此類型已轉送到組件 '{1}'，請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">命名空間 '{1}' 中找不到類型名稱 '{0}'。此類型已轉送到組件 '{2}'，請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">找不到類型名稱 '{0}'。此類型已經轉送給組件 '{1}'。請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">組件 '{0}' 和 '{1}' 參考相同的中繼資料，但只有一個是連結的參考 (使用 /link 選項指定); 請考慮移除其中一個參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">集合初始設定式項目最符合的多載 Add 方法已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">集合初始設定式項目最符合的多載 Add 方法已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorInInteractive">
        <source>Yield statements may not appear at the top level in interactive code.</source>
        <target state="translated">Yield 陳述式不可出現在互動式程式碼的最上層。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">安全屬性 '{0}' 在此宣告類型上無效。安全屬性只有在組件、類型和方法宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">無法將類型 '{0}' 的運算式用做為動態分派作業的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">無法將 Lambda 運算式用做為動態分派作業的引數，但卻未先將其轉型為委派或運算式樹狀結構類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">無法將方法群組用做為動態分派作業的引數。原本希望叫用此方法嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">方法 '{0}' 的呼叫必須以動態方式分派，但因為它是基底存取運算式的一部分，所以無法動態分派。請考慮將動態引數轉型，或排除基底存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">不允許透過來源類型 'dynamic' 或使用類型 'dynamic' 之聯結序列的查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">索引子存取必須以動態方式分派，但因為其為基底存取運算式的一部分，所以無法動態分派。請考慮將動態引數轉型，或排除基底存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">以動態方式將呼叫分派至方法 '{0}' 可能會在執行階段失敗，因為有一個或多個適用的多載為條件式方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">以動態分派的呼叫可能會在執行階段失敗，因為一個或多個適用的多載是條件式方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">'{0}' 沒有名稱為 '{1}' 的適用方法，但似乎有使用該名稱的擴充方法。擴充方法不可以動態方式分派。請考慮將動態引數轉型，或不要利用擴充方法語法來呼叫擴充方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為 CallerFilePathAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果; CallerFilePathAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為 CallerLineNumberAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果; CallerLineNumberAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerFilePathAttribute 將沒有作用，因為 CallerLineNumberAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerFilePathAttribute 將沒有效果; CallerLineNumberAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">運算式必須可隱含轉換成布林值，或是其類型 '{0}' 必須定義運算子 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'{0}' 不可實作 '{1}'，因為 '{2}' 是 Windows 執行階段事件，而 '{3}' 是一般 .NET 事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">於配置的 {0} 執行個體的所有參考都超出範圍之前，在該執行個體上呼叫 System.IDisposable.Dispose()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">在所配置執行個體的所有參考超出範圍之前，對其呼叫 System.IDisposable.Dispose()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">配置的 {0} 執行個體並非沿著所有例外狀況路徑處置。請在其所有參考都超出範圍之前，呼叫 System.IDisposable.Dispose()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">所配置的執行個體未沿著所有例外路徑處置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">可以多次處置物件 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">可以多次處置物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">無法內嵌 Interop 類型 '{0}'。請改用適當的介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌類型 '{0}'，因為其為巢狀類型。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌類型 '{0}'，因為它有泛型引數。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">內嵌 Interop 結構 '{0}' 只可包含公用執行個體欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Windows 執行階段事件不可以 out 或 ref 參數形式傳遞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">來源介面 '{0}' 遺漏了內嵌事件 '{2}' 所需的方法 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">介面 '{0}' 的來源介面無效，但內嵌事件 '{1}' 需要該介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">無法內嵌 Interop 類型 '{0}'，因為其遺漏必要的 '{1}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">無法從組件 '{0}' 內嵌 Interop 類型，因為其遺漏了 '{1}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">無法從組件 '{0}' 內嵌 Interop 類型，因為其遺漏了 '{1}' 屬性或 '{2}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌組件 '{1}' 和 '{2}' 中都有的 Interop 類型 '{0}'。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">從組件 '{1}' 內嵌 Interop 類型 '{0}'，會造成目前組件中的名稱衝相突。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">已建立內嵌 Interop 組件 '{0}' 的參考，因為該組件的間接參考已由組件 '{1}' 所建立。請考慮變更其中任一組件的 [內嵌 Interop 類型] 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">已建立內嵌 Interop 組件的參考，因為參考間接組件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">您已使用 /link 新增組件參考 (內嵌 Interop 類型屬性設定為 True)。這會指示編譯器內嵌該組件中的 Interop 類型資訊。不過，編譯器無法內嵌該組件中的 Interop 類型資訊，因為您已參考的另一個組件也會使用 /reference 來參考該組件 (內嵌 Interop 類型屬性設定為 False)。

若要內嵌兩個組件的 Interop 類型資訊，請針對每一個組件參考使用 /link (內嵌 Interop 類型屬性設定為 True)。

若要移除警告，您可以改用 /reference (內嵌 Interop 類型屬性設定為 False)。在此情況下，主要 Interop 組件 (PIA) 會提供 Interop 類型資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">因為組件 '{1}' 的類型 '{0}' 具有屬於內嵌 Interop 類型的泛型類型引數，所以不可跨組件的界限使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">找不到符合內嵌 Interop 類型 '{0}' 的 Interop 類型。是否遺漏了組件參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefReturnUnsupported">
        <source>By-reference return type 'ref {0}' is not supported.</source>
        <target state="translated">不支援傳址方式傳回類型 'ref {0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">儲存在 '{1}' 中的模組名稱 '{0}'，必須符合其檔案名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">模組名稱 {0} 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">無效的 '{0}' 值: '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath 必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">將會忽略模組 '{1}' 中的屬性 '{0}'，改用出現在來源中的執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">因來源中出現的執行個體，將會忽略屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">原始程式檔中所提供的屬性 '{0}'，與選項 '{1}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">固定緩衝區只能有一個維度。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">參考組件 '{0}' 沒有強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">參考的組件沒有強式名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">AssemblySignatureKeyAttribute 中指定的簽章公開金鑰無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">從模組 '{1}' 匯出的類型 '{0}' 與此組件的主要模組中所宣告之類型相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">從模組 '{1}' 匯出的類型 '{0}' 與從模組 '{3}' 匯出的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">轉送的類型 '{0}' 與此組件主要模組中所宣告的類型相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">轉送到組件 '{1}' 的類型 '{0}' 與轉送到組件 '{3}' 的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">轉送到組件 '{1}' 的類型 '{0}' 與從模組 '{3}' 匯出的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">參考組件 '{0}' 有不同的文化特性設定 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">參考的組件具有不同文化特性設定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">無從驗證的組件不可有處理器專屬的模組 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">組件與模組 '{0}' 的目標處理器不可不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">參考組件 '{0}' 以不同的處理器為目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">參考的組件以不同的處理器為目標</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">建立雜湊時密碼編譯失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">遺漏 '{0}' netmodule 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">模組 '{0}' 已定義在此組件中。每個模組都必須要有不重複的檔案名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">無法讀取組態檔 '{0}' -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">無法繼續，因為編輯包含內嵌類型的參考: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">在目前偵錯工作階段期間加入的成員 '{0}'，只能從其宣告組件中 '{1}' 存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">不得同時指定編輯選項 '{0}' 與 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">連結的 netmodule 中繼資料必須提供完整的 PE 影像: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred 只可與 /t:exe、/t:winexe 和 /t:appcontainerexe 一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;路徑清單&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;文字&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">null 散佈運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">運算式主體方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">運算式主體屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">運算式主體索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">Auto 屬性初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;命名空間&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">Byref 本機與傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">唯讀參考</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">編譯 (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">語法節點不在語法樹狀結構內</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必須提供位置，才可提供最基本的類型限定性條件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必須提供 SyntaxTreeSemanticModel，才可提供最基本的類型限定性條件。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">無法從 {1} 編譯來參考類型為 '{0}' 的編譯</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">語法樹狀結構已存在</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">提交只能包含指令碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">提交最多可以有一個語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">樹狀結構必須要有包含 SyntaxKind.CompilationUnit 的根節點</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">類型引數不可為 null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">類型引數的數目錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">名稱 {0} 發生名稱衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions 的選項組合無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">項目: 不可為空白</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier 或 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier 來建立識別項語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 來建立字元常值語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 來建立數值常值語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">此方法只可用以建立語彙基元 - {0} 不是語彙基元種類。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">泛型參數為定義，但其必須是參考 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">為可能包含多重變數宣告子的宣告節點，呼叫了 GetDeclarationName。</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeNotPartOfCompilation">
        <source>tree not part of compilation</source>
        <target state="translated">樹狀結構不是編譯的一部分</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">位置不在有完整範圍 {0} 的語法樹狀結構內</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">語言名稱 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">語言名稱無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">透明識別項成員存取 '{1}' 的欄位 '{0}' 失敗。目前正在查詢的資料是否會實作查詢模式?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">此參數有多個相異的預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">此欄位有多個相異的常數值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">在 cref 屬性中，泛型類型的巢狀類型必須符合規定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">在 cref 屬性中，泛型類型的巢狀類型必須符合規定</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">不是 C# 符號。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">不必要的 using 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">未使用的外部別名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">項目不可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">LIB 環境變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">/LIB 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">目錄不存在</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">路徑太長或無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">找不到 RuntimeMetadataVersion 的值。找不到任何包含 System.Object 的組件，也未透過選項指定 RuntimeMetadataVersion 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">找不到 RuntimeMetadataVersion 的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">必須是 {0} SemanticModel。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">Lambda 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">C# 1 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">C# 2 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">C# 3 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">C# 4 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">C# 5 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">C# 6 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.0 中未提供功能 '{0}'。請使用語言版本 {1} 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsUnimplemented">
        <source>Feature '{0}' is not implemented in this compiler.</source>
        <target state="translated">功能 '{0}' 未在此編譯器實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'「實驗」</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">位置必須在語法樹狀結構的範圍內。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">要推測的語法節點，不可屬於目前編譯的語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">不支援鏈結理論式語意模型。應從非理論式 ParentModel 建立理論式模型。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Microsoft (R) Visual C# 編譯器</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} 版 {1} </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">支援的語言版本:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'{0}': 具有 ComImport 屬性的類別不可指定欄位初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">區域變數名稱 '{0}' 對 PDB 而言太長。請考慮將其縮短，或在編譯時不要使用 /debug。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">PDB 的本機名稱太長</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">轉換成 void 傳回委派的匿名函式，不可傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">轉換成 'Task' 傳回委派的非同步 Lambda 運算式，不可傳回值。原本希望傳回 'Task&lt;T&gt;' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">不可從 {1} 建立分析器 {0} 的執行個體: {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">無法建立分析器執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">組件 {0} 不包含任何分析器。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">組件不包含任何分析器</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">無法載入分析器組件 {0} : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">無法載入分析器組件</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">因為 ReflectionTypeLoadException 之故，所以略過分析器組件 {0} 中的某些類型: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">讀取規則集檔案 {0} 時發生錯誤 - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">讀取 '{0}' 的偵錯資訊時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">作業導致了堆疊溢位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">必須是識別項或數值常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">必須是識別項或數值常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties can have initializers.</source>
        <target state="translated">只有自動實作的屬性可以有初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">自動實作的屬性必須要有 get 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">自動實作的屬性必須覆寫已覆寫屬性的所有存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">沒有明確建構函式的結構，不可包含有初始設定式的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">無法在不編碼的情況下，對原始程式文字發出偵錯資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">不可同時提供區塊主體與運算式主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">控制項的位置不可位於最後一個 case 標籤 ('{0}') 的參數之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">Nameof 運算子中不可使用類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含 null 散佈運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含字典初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">運算式 Lambda 中的集合初始設定式不支援擴充功能 Add 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">nameof 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">字典初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">以 '{' 開頭的插入運算式遺漏結束分隔符號 '}' </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">差補字串中不能使用單行註解。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">運算式太長或太複雜，造成編譯困難</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">運算式沒有名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">nameof 的引數中不可使用子運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">別名限定的名稱不是運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">方法群組上不可使用類型參數做為 'nameof' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">必須是 SearchCriteria。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">組件文化特性字串可能不包含內嵌的 NUL 字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">使用靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">內插字串</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">等待於 catch 區塊與 finally 區塊中</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">二進位常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">數字分隔符號</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">區域函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">在差補字串中，必須將 '{0}' 字元逸出 (重複兩次)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">在差補字串中，只能以重複兩次 ('{0}{0}') 的方式，將 '{0}' 字元逸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">格式規範的尾端不可以是空白字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">空白的格式規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">參考組件 '{0}' 中有錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">必須是運算式或宣告陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">擴充方法群組不允許做為 'nameof' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">對齊值 {0} 的範圍大於 {1}，而且可能會導致大型格式化字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">未使用的外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">不必要的 using 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">跳過載入分析器組件中因 ReflectionTypeLoadException 而失敗的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">對齊值的範圍可能會導致大型格式化字串</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">從串連產生的字串常數長度超過 System.Int32.MaxValue。請嘗試將字串分割為多個常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">元組必須包含至少兩個項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">偵錯進入點必須是目前編譯中所宣告方法的定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load 只允許用於指令碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">無法在檔案中第一個語彙基元後使用 #load</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">找不到檔案。</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">SyntaxTree 從 #load 指示詞所產生，無法直接移除或取代。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">不支援原始程式檔參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">pathmap 選項格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">無效的實際常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">無法藉傳址方式傳回自動實作屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">藉傳址方式傳回的屬性必須有 get 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">藉傳址方式傳回的屬性不能有 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">'{0}' 必須符合覆寫成員 '{1}' 的藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">藉傳址傳回只能用於藉傳址方式傳回的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">傳值傳回只能用於以傳值方式傳回的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">傳回運算式的類型必須是類型 '{0}'，因為此方法藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。因為 '{2}' 沒有相符的藉傳址方式傳回，所以無法實作 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">{0}' 的主體不可是迭代區塊，因為 '{0}' 是藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">無法將藉傳址方式傳回的 Lambda 運算式轉換為運算式樹狀架構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">運算式樹狀架構 Lambda 不能包含呼叫藉傳址方式傳回的方法、屬性或索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">因為參考可能不會傳遞或傳回運算式，所以無法於此內容中使用運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因為已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">無法藉傳址方式傳回 '{0}' 的成員，因為已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">無法藉傳址方式傳回範圍變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal2Cause">
        <source>Cannot return fields of '{0}' by reference because it is a '{1}'</source>
        <target state="translated">無法藉傳址方式傳回 '{0}' 欄位，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回唯讀欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回靜態的唯讀欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回唯讀欄位 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回靜態唯讀欄位 '{0}' 的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref or out parameter</source>
        <target state="translated">無法藉傳址方式 '{0}' 傳回參數，因為其非 ref 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">無法藉傳址方式傳回參數 '{0}' 的成員，因為它不是 ref 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">無法藉傳址方式傳回本機 '{0}'，因為其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">無法藉傳址方式傳回本機 '{0}' 的成員，因為其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">結構成員無法藉傳址方式傳回 'this' 或其他執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用運算式，因為它會在其宣告範圍外間接公開變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeLocal">
        <source>Cannot use local '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用本機 '{0}'，因為它會將參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用 '{0}' 的結果，因為它會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用 '{0}' 結果的成員，因為它會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">不允許對 '{0}' 使用此引數組合，因為它會在其宣告範圍外公開參數 '{1}' 所參考的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ref 條件運算子的分支不能參考具有不相容宣告範圍的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">無法在此內容中使用類型 '{0}' 的 stackalloc 運算式結果，因為它會公開在包含方法之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">無法使用參考將傳值變數初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">無法使用值將傳址變數初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">運算式的類型必須是類型 '{0}'，因為其藉傳址方式指派</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">傳址變數的宣告必須具有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">無法在匿名方法、Lambda 運算式或查詢運算式中使用參考本機 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorLocalType">
        <source>Iterators cannot have by-reference locals</source>
        <target state="translated">Iterator 不可有 by-reference local</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLocalType">
        <source>Async methods cannot have by-reference locals</source>
        <target state="translated">非同步方法不可有 by-reference local</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>'await' cannot be used in an expression containing a call to '{0}' because it returns by reference</source>
        <target state="translated">'await' 不能用於包含呼叫 '{0}' 的運算式，因為其藉傳址方式傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'包含 ref 條件運算子的運算式無法使用 'await'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">這兩個條件運算子的值都必須是 ref 值，或兩個都不是 ref 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">運算式類型必須是 '{0}'，才符合替代的 ref 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">運算式樹狀目錄不可包含區域函式的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">無法將具有動態類型的引數傳遞給本機函式 '{1}' 的 params 參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">提交時就應該建立語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">程式所使用的使用者字串加起來長度超過允許限制。請嘗試減少使用字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}' in a pattern; use the underlying type '{1}' instead.</source>
        <target state="translated">在模式中使用可為 Null 的型別 '{0}' 不合法; 請改用基礎類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">寫入輸出檔案時發生錯誤: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">元組元素名稱不得重複。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">只有位置 {1} 允許元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">任何位置都不允許元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">在組件 '{2}' 的類型 '{1}' 上找不到成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">元組</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">使用 {1} out 參數及 void 傳回型別找不到適合類型 '{0}' 的解構執行個體或擴充方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">需要具有右邊類型的運算式，才能解構指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">switch 運算式必須是值; 但找到的是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">類型為 '{1}' 的模式無法處理類型為 '{0}' 的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">如有指定公用簽章，屬性 '{0}' 將予忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">如有指定公用簽章，屬性將予忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">選項 '{0}' 必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">具有 {0} 元素的 Tuple 無法轉換為類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">out 變數宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">不允許在相同引數清單中參考隱含型別 out 變數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">無法推斷隱含型別 out 變數 '{0}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">無法推斷隱含型別解構變數 '{0}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">無法推斷隱含型別捨棄的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">無法將 '{0}' 項目的元組解構為 '{1}' 變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">無法解構動態物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">解構必須包含至少兩個變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">因為目標類型 '{1}' 指定了不同的名稱或未指定名稱，所以會忽略元組項目名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">因為指派目標指定了不同的名稱或未指定名稱，所以會忽略元組項目名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">預先定義的類型 '{0}' 必須為結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'new' 不得搭配元組類型使用。請改用元組常值運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">解構 `var (...)` 表單不允許 'var' 的特定類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">因為找不到編譯器所需的類型 '{0}'，所以無法定義利用元組的類別或成員。是否遺漏參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">無法明確參考 'System.Runtime.CompilerServices.TupleElementNamesAttribute'。請使用元組語法定義元組名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">運算式樹狀架構不得包含 out 引數變數宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">運算式樹狀架構不可包含 discard。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">運算式樹狀架構不得包含 'is' 模式比對運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">運算式樹狀架構不得包含元組常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">運算式樹狀架構不得包含元組轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">只有在發出 PDB 時才支援 /sourcelink 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">只有在發出 PDB 時才支援 /embed 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">檢測設備種類無效: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">已保留作為左值的語法 'var (...)'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">需要 { 或 ; 或 =&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">此內容不允許 throw 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixedDeconstructionUnsupported">
        <source>A deconstruction cannot mix declarations and expressions on the left-hand-side.</source>
        <target state="translated">解構不得混合左側的宣告與運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">此內容中不允許宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Foreach 迴圈必須宣告其反覆運算變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">解構左側不允許元組元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">若要轉換負值，必須以括號括住該值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">運算式樹狀架構不可包含 throw 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">組件名稱 {0} 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">若要讓 '{0}' 類型作為 '{1}' 類型的 AsyncMethodBuilder，其 Task 屬性應傳回 '{1}' 類型，而非 '{2}' 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesInLocalFuncDecl">
        <source>Attributes are not allowed on local function parameters or type parameters</source>
        <target state="translated">區域函式參數或型別參數中不允許屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">組件 '{1}' 中的模組 '{0}' 正在將類型 '{2}' 轉送給多個組件: '{3}' 及 '{4}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">在模式中使用類型 'dynamic' 不合法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的文件模式不受支援或無效: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">提供的原始程式碼類型不受支援或無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的語言版本不受支援或無效: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; '{0}' 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.1 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.2 無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">指定的語言版本 '{0}' 不可以零作為開頭</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">可能未指派 'void' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}' 僅供評估之用。後續更新時可能會有所變更或移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">類型僅供評估之用。後續更新時可能會有所變更或移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">編譯器版本: '{0}'。語言版本: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">非同步主要</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">元組項目名稱 '{0}' 從推斷而來。請使用語言版本 {1} 或更新版本，依推斷名稱存取項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">元組不可包含 'void' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">不得同步傳回進入點的 void 或 int</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">在 C# {2} 中，類型為 '{1}' 的模式無法處理類型為 '{0}' 的運算式。請使用語言版本 {3} 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">區域函式 '{0}' 已宣告，但從未使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">區域函式已宣告但從未使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="needs-review-translation">'{0}' 是區域函式，因此必須具有主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">無法從組件 '{2}' 讀取方法 '{0}' 的偵錯資訊 (權杖 0x{1:X8})</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} 不是有效的 C# 轉換運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">無法將具有動態類型的引數傳遞到具有推斷類型引數的一般區域函式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">前置數字分隔符號</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">請勿使用 '{0}'。此保留供編譯器使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">類型名稱 '{0}' 保留供編譯器使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">'in' 擴充方法 '{0}' 中的第一個參數必須是實體 (非泛型) 實值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">唯讀結構的執行個體欄位必須為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">使用唯讀結構的自動實作執行個體屬性必須為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">唯讀結構中不允許欄位型的事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">ref 擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">類型 '{0}' 的 stackalloc 運算式不可能轉換成類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">ref' 擴充方法 '{0}' 的第一個參數，必須是限制為結構的實值型別或泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">in 參數不能有 Out 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} 不是有效的 C# 複合指派作業</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">篩選條件運算式是常數 'false'，請考慮移除 catch 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">篩選條件運算式是常數 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">篩選條件運算式是常數 'false'，請考慮移除 try-catch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">篩選條件運算式是常數 'false'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">__arglist 不能有 void 類型的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">因為內插補點的結尾是 ':'，所以無法直接在字串內插補點使用條件式運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">請勿在屬性 (property) 上使用 'System.Runtime.CompilerServices.FixedBuffer' 屬性 (attribute)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">在 C# 7.3 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">語言版本 {0} 不支援自動屬性 (property) 上以欄位為目標的屬性 (attribute)。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">此語言版本不支援自動屬性 (property) 上以欄位為目標的屬性 (attribute)。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">非同步資料流</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">'{0}': 在非同步 using 陳述式中使用的類型，必須可隱含地轉換為 'System.IAsyncDisposable' 或實作合適的 'DisposeAsync' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">非同步的 foreach 需要 '{1}' 的傳回型別 '{0}'，必須要有合適的公用 'MoveNextAsync' 方法和公用 'Current' 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">因為它實作 '{1}' 的多個具現化，所以非同步的 foreach 陳述式無法在型別 '{0}' 的變數上作業; 請嘗試轉換至特定的介面具現化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Interfaces cannot contain conversion, equality, or inequality operators</source>
        <target state="translated">介面不能包含轉換、等式或不等式運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">目標執行階段不支援預設介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">因為目標執行階段不支援預設介面實作，所以 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationModifier">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">修飾元 '{0}' 在 C# {1} 中對此項目無效。請使用 '{2}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法隱含地實作非公開成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">介面成員 '{0}' 沒有最具體的實作。'{1}' 和 '{2}' 都不是最具體的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">因為功能 '{3}' 不適用於 C# {4}，所以 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'。請使用語言 '{5}' 版或更新版本。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>