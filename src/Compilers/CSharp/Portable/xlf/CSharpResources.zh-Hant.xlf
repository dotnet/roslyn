<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CallingConventionTypeIsInvalid">
        <source>Cannot use '{0}' as a calling convention modifier.</source>
        <target state="translated">無法使用 '{0}' 作為呼叫慣例修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallingConventionTypesRequireUnmanaged">
        <source>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</source>
        <target state="translated">除非 '{1}' 為 'SignatureCallingConvention'，否則傳遞 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">無法從另一個建構的泛型型別建立建構的泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">無法從另一個非泛型型別建立建構的泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractConversionNotInvolvingContainedType">
        <source>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</source>
        <target state="translated">介面中的使用者定義轉換必須轉換成類型參數，或從被限制為封閉類型的封閉類型上的型別參數轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">'{0}' 抽象事件無法使用事件存取子語法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInIterator">
        <source>The '&amp;' operator cannot be used on parameters or local variables in iterator methods.</source>
        <target state="translated">迭代器方法的參數或區域變數不得使用 '&amp;' 運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfMethodGroupInExpressionTree">
        <source>'&amp;' on method groups cannot be used in expression trees</source>
        <target state="translated">不得在運算式樹狀架構中對方法群組使用 '&amp;'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfToNonFunctionPointer">
        <source>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</source>
        <target state="translated">無法將方法群組 '{0}' 轉換成非函式指標類型 '{1}'(&amp;M)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AllowsClauseMustBeLast">
        <source>The 'allows' constraint clause must be the last constraint specified</source>
        <target state="translated">'allows' 限制式子句必須是最後一個指定的限制式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">若要在插入的逐字字串使用 '@$' 而不是 '$@'，請使用 '{0}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</source>
        <target state="translated">運算元 '{1}' 和 '{2}' 上的運算子 '{0}' 模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">無法將運算子 '{0}' 套用至 'default' 和類型為 '{1}' 的運算元，原因是其為未知參考型別的型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver">
        <source>Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.</source>
        <target state="translated">在此內容中，類型 '{1}' 與參數 '{2}' 之間的識別碼 '{0}' 不明確。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">無法在建立物件時使用可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseRefLike">
        <source>Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">無法使用在匿名方法、Lambda 運算式、查詢運算式或區域函式內具有類似參考類型的參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterCaptured">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member</source>
        <target state="translated">結構內的匿名方法、Lambda 運算式、查詢運算式和區域函式無法存取也在執行個體成員內使用的主要建構函式參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterInMember">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter</source>
        <target state="translated">結構的執行個體成員內的匿名方法、Lambda 運算式、查詢運算式和區域函式無法存取主要建構函式參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">當透過 'System.Runtime.CompilerServices.ITuple' 進行模式比對時，不允許元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">在運算式中使用可為 Null 的參考型別 '{0}?' 不合法，請改用基礎類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">無法指派唯讀類型的主要建構函式參數 (類型的 init-only setter 或變數初始設定式中除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">無法修改唯讀類型的主要建構函式參數 '{0}' 的成員 (類型的 init-only setter 或變數初始設定式中除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</source>
        <target state="translated">只有物件初始設定式中，或執行個體建構函式中 'this' 或 'base' 上僅供初始化的屬性或索引子 '{0}' 或 'init' 存取子可以指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">無法在此內容中使用類型 '{0}'，因為它無法在中繼資料中表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrTypeArgCannotBeTypeVar">
        <source>'{0}': an attribute type argument cannot use type parameters</source>
        <target state="translated">'{0}': 屬性型別引數不可使用型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在事件存取子上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesRequireParenthesizedLambdaExpression">
        <source>Attributes on lambda expressions require a parenthesized parameter list.</source>
        <target state="translated">Lambda 運算式上的屬性需要小括號內的參數清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">因為自動實作屬性 '{0}' 有 'set' 存取子，所以無法將其標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">無法將自動實作 'set' 存取子 '{0}' 標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體或延伸模組定義，所以非同步的 foreach 陳述式無法在型別 '{0}' 的變數上運作</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體或延伸模組定義，所以非同步的 foreach 陳述式無法在型別 '{0}' 的變數上運作。您指的是 'foreach' 而不是 'await foreach' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">二元運算子的其中一個參數必須是包含類型，或其型別參數受其限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractEqualityOperatorSignature">
        <source>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</source>
        <target state="translated">介面 '{0}' 中宣告之等式或不等式運算子的其中一個參數在 '{0}' 必須是限制為 '{0}' 的型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecRetType">
        <source>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</source>
        <target state="translated">++ 或 -- 運算子的傳回型別必須符合參數類型，或是衍生自參數類型，或為包含類型的型別參數受其限制，除非參數類型是不同的型別參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">++ 或 -- 運算子的參數必須是包含類型，或其型別參數受其限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</source>
        <target state="translated">多載移位 (Shift) 運算子的第一個運算元的類型必須和包含的類型相同，或是其型別參數受限於該運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractStaticMemberAccess">
        <source>A static virtual or abstract interface member can be accessed only on a type parameter.</source>
        <target state="translated">只能在型別參數上存取靜態虛擬或抽象介面成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">一元運算子的其中一個參數必須是包含類型，或其型別參數受其限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAllowByRefLikeEnumerator">
        <source>foreach statement cannot operate on enumerators of type '{0}' because it is a type parameter that allows ref struct and it is not known at compile time to implement IDisposable.</source>
        <target state="translated">foreach 語句無法對 '{0}' 類型中的列舉值運作，因為該型別參數允許 ref struct，而且在實作 IDisposable 的編譯期間為未知。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRefLangVersion">
        <source>Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.</source>
        <target state="translated">引數 {0} 可能無法以語言版本 {1} 中的 'ref' 關鍵字傳遞。若要將 'ref' 引數傳遞至 'in' 參數，請升級為語言版本 {2} 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryReadOnlySpanConcatenation">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</source>
        <target state="translated">運算子 '{0}' 無法套用到型別為 '{1}' 的運算元，而 '{2}' 不是 UTF-8 位元組標記法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
        <source>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerArgumentExpressionAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCaseInSwitchArm">
        <source>A switch expression arm does not begin with a 'case' keyword.</source>
        <target state="translated">切換運算式 ARM 不會以 'case' 關鍵字開頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">無法在非同步 foreach 中使用動態類型的集合</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFieldTypeInRecord">
        <source>The type '{0}' may not be used for a field of a record.</source>
        <target state="translated">類型 '{0}' 不可用於記錄的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerArgCount">
        <source>Function pointer '{0}' does not take {1} arguments</source>
        <target state="translated">函式指標 '{0}' 不接受 {1} 個引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerParamModifier">
        <source>'{0}' cannot be used as a modifier on a function pointer parameter.</source>
        <target state="translated">'{0}' 無法作為函式指標參數上的修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInheritanceFromRecord">
        <source>Only records may inherit from records.</source>
        <target state="translated">只有記錄可以繼承自記錄。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInitAccessor">
        <source>The 'init' accessor is not valid on static members</source>
        <target state="translated">靜態成員上的 'Init' 存取子無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonVirtualInterfaceMemberAccessOnAllowsRefLike">
        <source>A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.</source>
        <target state="translated">允許 ref struct 的型別參數無法存取非虛擬執行個體介面成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">/nullable 的選項 '{0}' 無效; 必須為 'disable'、'enable'、'warnings' 或 'annotations'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableReferenceTypeInUsingAlias">
        <source>Using alias cannot be a nullable reference type.</source>
        <target state="translated">使用別名不可以是可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">typeof 運算子不得用於可為 Null 的參考型別上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefaultOrNew">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">運算子 '{0}' 不可套用至運算元 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">模式比對運算元無效; 需要值，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordBase">
        <source>Records may only inherit from object or another record</source>
        <target state="translated">記錄只能繼承自物件或其他記錄</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordMemberForPositionalParameter">
        <source>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</source>
        <target state="translated">記錄成員 '{0}' 必須是類型 '{1}' 的可讀取執行個體屬性或欄位，才能符合位置參數 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefIterator">
        <source>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct or a type parameter that allows ref struct.</source>
        <target state="translated">foreach 陳述式無法對 async 或 iterator 方法中 '{0}' 類型的列舉值運作，因為 '{0}' 是 ref struct 或允許 ref struct 的型別參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefParameter">
        <source>Parameters of type '{0}' cannot be declared in async methods or async lambda expressions.</source>
        <target state="translated">類型 '{0}' 的參數不得在非同步方法或非同步 Lambda 運算式中宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefInUsingAlias">
        <source>Using alias cannot be a 'ref' type.</source>
        <target state="translated">使用別名不可以是 'ref' 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticAfterUnsafe">
        <source>'static' modifier must precede 'unsafe' modifier.</source>
        <target state="translated">'static' 修飾元必須在 'unsafe' 修飾元之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">命令列語法錯誤: '{0}' 對 '{1}' 選項而言不是有效的值。此值的格式必須是 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnsafeInUsingDirective">
        <source>Only a 'using static' or 'using alias' can be 'unsafe'.</source>
        <target state="translated">只有 'using static' 或 'using alias' 可以是 'unsafe'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingStaticType">
        <source>'{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.</source>
        <target state="translated">'{0}' 類型對 'using static' 無效。只能使用類別、結構、介面、列舉、委派或命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInUnsafe">
        <source>Cannot use 'yield return' in an 'unsafe' block</source>
        <target state="translated">無法在 'unsafe' 區塊中使用 'yield return'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BuilderAttributeDisallowed">
        <source>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</source>
        <target state="translated">沒有明確傳回型別的匿名方法上不允許 AsyncMethodBuilder 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToMember">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on this member.</source>
        <target state="new">Cannot use 'OverloadResolutionPriorityAttribute' on this member.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToOverride">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.</source>
        <target state="new">Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeConvertedToUtf8">
        <source>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</source>
        <target state="translated">輸入字串無法轉換成對等的 UTF-8 位元組表示法。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'{0}' 不可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotClone">
        <source>The receiver type '{0}' is not a valid record type and is not a struct type.</source>
        <target state="translated">接收器類型 '{0}' 不是有效的記錄類型，而且不是結構類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertAddressOfToDelegate">
        <source>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</source>
        <target state="translated">無法將方法群組 '{0}' 轉換成委派類型 '{1}'(&amp;M)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDynamicInvokeOnExpression">
        <source>Cannot perform a dynamic invocation on an expression with type '{0}'.</source>
        <target state="translated">無法對具有類型 '{0}' 的運算式執行動態叫用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferDelegateType">
        <source>The delegate type could not be inferred.</source>
        <target state="translated">無法推斷委派類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotMatchOnINumberBase">
        <source>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specifc numeric type.</source>
        <target state="translated">無法在 '{0}' 上使用數值常數或關聯式模式，因為它繼承自或延伸 'INumberBase&lt;T&gt;'。請考慮使用類型模式來縮小為特定數數值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
        <source>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</source>
        <target state="translated">'managed' 呼叫慣例不得與未受控的呼叫慣例指定名稱並用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseFunctionPointerAsFixedLocal">
        <source>The type of a local declared in a fixed statement cannot be a function pointer type.</source>
        <target state="translated">在 fixed 陳述式中宣告的區域變數類型不得為函式指標類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
        <source>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">使用 'UnmanagedCallersOnly' 屬性化的方法上，不能使用 '{0}' 作為{1}型別。</target>
        <note>1 is the localized word for 'parameter' or 'return'. UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_CannotUseReducedExtensionMethodInAddressOf">
        <source>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</source>
        <target state="translated">無法使用具有接收器的擴充方法作為 '&amp;' 運算子的目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseRefInUnmanagedCallersOnly">
        <source>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">無法在具有 'UnmanagedCallersOnly' 的方法簽章中使用 'ref'、'in' 或 'out'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
        <source>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</source>
        <target state="translated">InterpolatedStringHandlerArgumentAttribute 引數無法參考屬性所使用的參數。</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_CantChangeInitOnlyOnOverride">
        <source>'{0}' must match by init-only of overridden member '{1}'</source>
        <target state="translated">'{0}' 必須符合被覆寫之成員 '{1}' 的僅供初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturnType">
        <source>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</source>
        <target state="translated">無法將 {0} 轉換成類型 '{1}'，因為傳回型別不符合委派傳回型別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">__arglist 不得包含 'in' 或 'out' 傳遞的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
        <source>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</source>
        <target state="translated">此建構函式必須新增 'SetsRequiredMembers'，因為它鏈結至具有該屬性的建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOperatorNeedsMatch">
        <source>The operator '{0}' requires a matching non-checked version of the operator to also be defined</source>
        <target state="translated">運算子 '{0}' 需要也同時定義運算子的相符未檢查版本</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassIsCombinedWithRefStruct">
        <source>Cannot allow ref structs for a type parameter known from other constraints to be a class</source>
        <target state="translated">無法允許已知來自於其他限制式之型別參數別的 ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloneDisallowedInRecord">
        <source>Members named 'Clone' are disallowed in records.</source>
        <target state="translated">記錄中不允許名為 'Clone' 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotStatic">
        <source>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</source>
        <target state="translated">'{0}' 未實作靜態介面成員 '{1}'。因為 '{2}' 為靜態，所以無法實作介面成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidMethodName">
        <source>The CollectionBuilderAttribute method name is invalid.</source>
        <target state="translated">CollectionBuilderAttribute 方法名稱無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidType">
        <source>The CollectionBuilderAttribute builder type must be a non-generic class or struct.</source>
        <target state="translated">CollectionBuilderAttribute 組建器類型必須是非泛型類別或結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeMethodNotFound">
        <source>Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan&lt;{1}&gt;' and return type '{2}'.</source>
        <target state="translated">找不到具有預期簽章的可存取 '{0}' 方法：具有類型 'ReadOnlySpan&lt;{1}&gt;' 的單一參數，且傳回類型 '{2}' 的靜態方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderNoElementType">
        <source>'{0}' has a CollectionBuilderAttribute but no element type.</source>
        <target state="translated">'{0}' 具有 CollectionBuilderAttribute，但沒有元素類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionEscape">
        <source>A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</source>
        <target state="translated">無法在此內容中使用類型 '{0}' 的集合運算式，因為它可能會在目前範圍外公開。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionImmutableArray">
        <source>This version of '{0}' cannot be used with collection expressions.</source>
        <target state="translated">此版本的 '{0}' 無法與集合運算式一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingAdd">
        <source>Collection expression type '{0}' must have an instance or extension method 'Add' that can be called with a single argument.</source>
        <target state="translated">集合運算式類型 '{0}' 必須有可以使用單一引數來呼叫的執行個體或延伸模組方法 'Add'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingConstructor">
        <source>Collection expression type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">集合運算式型別必須具有可在不帶引數的情況下呼叫的適用建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionNoTargetType">
        <source>There is no target type for the collection expression.</source>
        <target state="translated">集合運算式沒有目標類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetNoElementType">
        <source>Collection expression target '{0}' has no element type.</source>
        <target state="translated">集合運算式目標 '{0}' 沒有元素型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetTypeNotConstructible">
        <source>Cannot initialize type '{0}' with a collection expression because the type is not constructible.</source>
        <target state="translated">無法使用集合運算式將類型 '{0}' 初始化，因為該類型為不可建構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitializerInfiniteChainOfAddCalls">
        <source>Collection initializer results in an infinite chain of instantiations of collection '{0}'.</source>
        <target state="new">Collection initializer results in an infinite chain of instantiations of collection '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">類型參數 '{1}' 有 'unmanaged' 條件約束，因此 '{1}' 不可作為 '{0}' 的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="translated">區域函式 '{0}' 必須為 'static' 才能使用 Conditional 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">類型 '{0}' 的運算式無法由類型 '{1}' 的模式處理。請使用語言 '{2}' 版或更新版本，以比對開放式類型與常數模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantValueOfTypeExpected">
        <source>A constant value of type '{0}' is expected</source>
        <target state="translated">必須為 '{0}' 類型的常數值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorMustInvokeBaseCopyConstructor">
        <source>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</source>
        <target state="translated">若記錄繼承自物件，則記錄中的複製建構函式，必須呼叫基底的複製建構函式，或未設定任何參數的物件建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorWrongAccessibility">
        <source>A copy constructor '{0}' must be public or protected because the record is not sealed.</source>
        <target state="translated">因為記錄不是密封的，所以複製建構函式 '{0}' 必須是公用或受保護。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">名稱 '{0}' 與對應的 'Deconstruct' 參數 '{1}' 不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructVariableCannotBeByRef">
        <source>A deconstruction variable cannot be declared as a ref local</source>
        <target state="translated">解構變數不可宣告為參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultConstraintOverrideOnly">
        <source>The 'default' constraint is valid on override and explicit interface implementation methods only.</source>
        <target state="translated">'default' 條件約束只在覆寫和明確介面實作方法上有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">因為類型 '{0}' 有非抽象成員，所以無法內嵌。請考慮將 [內嵌 Interop 類型] 屬性設為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">預設常值沒有目標類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">預設常值 'default' 作為模式無效。請使用另一個適當的常值 (例如 '0' 或 'null')。若要比對所有項目，請使用捨棄模式 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeneathPatternCombinator">
        <source>A variable may not be declared within a 'not' or 'or' pattern.</source>
        <target state="translated">不得在 'not' 或 'or' 模式中宣告變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">捨棄模式不可為 switch 陳述式中的 case 標籤。針對捨棄模式，請使用 'case var _:'，針對名為 '_' 的常數，則請使用 'case @_:'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseEqualityContract">
        <source>'{0}' does not override expected property from '{1}'.</source>
        <target state="translated">'{0}' 不會覆寫 '{1}' 的必要屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseMethod">
        <source>'{0}' does not override expected method from '{1}'.</source>
        <target state="translated">'{0}' 不會覆寫 '{1}' 的必要方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideMethodFromObject">
        <source>'{0}' does not override expected method from 'object'.</source>
        <target state="translated">'{0}' 不會覆寫 'object' 的必要方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupReturnTypeMod">
        <source>A return type can only have one '{0}' modifier.</source>
        <target state="translated">傳回型別只能有一個 '{0}' 修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">'{0}' 已明確實作多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterceptor">
        <source>The indicated call is intercepted multiple times.</source>
        <target state="translated">對指定的呼叫進行多次攔截。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithDifferencesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</source>
        <target state="translated">'{0}' 已列於類型 '{2}' 的介面清單中，名稱為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">重複 Null 隱藏運算子 ('!')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">在屬性和索引子 '{0}' 的存取子上均無法指定 'readonly' 修飾元。請改在屬性自身上放置 'readonly' 修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicDispatchToParamsCollection">
        <source>'{0}' is applicable only with expanded form of non-array params collection which is not supported during dynamic dispatch.</source>
        <target state="translated">'{0}' 只適用於展開格式的非陣列參數集合，但其在動態分派期間無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">'else' 無法開始陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EntryPointCannotBeUnmanagedCallersOnly">
        <source>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">無法使用 'UnmanagedCallersOnly' 將應用程式進入點屬性化。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_EqualityContractRequiresGetter">
        <source>Record equality contract property '{0}' must have a get accessor.</source>
        <target state="translated">記錄相等 contract 屬性 '{0}' 必須要有 get 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeVariable">
        <source>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用變數 '{0}'，因為它會將參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInterpolatedString">
        <source>Expected interpolated string</source>
        <target state="translated">預期為差補字串</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplementationOfOperatorsMustBeStatic">
        <source>Explicit implementation of a user-defined operator '{0}' must be declared static</source>
        <target state="translated">使用者定義的運算子 '{0}' 的明確實作必須宣告為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">不允許明確應用 'System.Runtime.CompilerServices.NullableAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArrayOrCollection">
        <source>Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">請勿使用 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'。請改用 'params' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMismatchInitOnly">
        <source>Accessors '{0}' and '{1}' should both be init-only or neither</source>
        <target state="translated">存取子 '{0}' 與 '{1}' 不得同時是或不是僅供初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitRequiredMember">
        <source>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.RequiredMemberAttribute'。請改為在必要的欄位和屬性上使用 'required' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitScopedRef">
        <source>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.ScopedRefAttribute'。請改用 'scoped' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">指定運算式無法用於 fixed 陳述式中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">運算式樹狀結構不可包含 null 聯合指派</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">運算式樹狀架構不可包含 ref 結構或限制型別 '{0}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
        <source>An expression tree may not contain an access of static virtual or abstract interface member</source>
        <target state="translated">運算式樹狀架構不可包含靜態虛擬或抽象介面成員的存取權</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsCollectionExpression">
        <source>An expression tree may not contain a collection expression.</source>
        <target state="translated">運算式樹狀架構不得包含集合運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="translated">運算式樹狀架構不可包含 from-end index ('^') 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInlineArrayOperation">
        <source>An expression tree may not contain an inline array access or conversion</source>
        <target state="translated">運算式樹狀架構不可包含內嵌陣列存取或轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
        <source>An expression tree may not contain an interpolated string handler conversion.</source>
        <target state="translated">運算式樹狀架構不可包含差補字串處理常式轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternImplicitIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="translated">運算式樹狀架構不可包含 System.Index 或 System.Range 索引子存取模式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="translated">運算式樹狀架構不可包含 range ('..') 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">運算式樹狀結構不可包含 switch 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">運算式樹狀架構不得包含元組 == 或 != 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsUtf8StringLiterals">
        <source>An expression tree may not contain UTF-8 string conversion or literal.</source>
        <target state="translated">運算式樹狀結構不能包含 UTF-8 字串轉換或常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsWithExpression">
        <source>An expression tree may not contain a with-expression.</source>
        <target state="translated">運算式樹狀架構不得包含 with 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'{0}': 外部事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">功能 '{0}' 目前處於預覽階段，且*不受支援*。若要使用預覽功能，請使用「預覽語言」版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">功能 '{0}' 仍在實驗階段且不具支援；請使用 '/features:{1}' 來啟用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion10">
        <source>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 10.0 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion11">
        <source>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 11.0. 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion12">
        <source>Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 12.0. 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion13">
        <source>Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.</source>
        <target state="new">Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 8.0 中無法使用功能 '{0}'。請使用 {1} 或更新的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 8.0 中無法使用功能 '{0}'。請使用 {1} 或更新的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion9">
        <source>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</source>
        <target state="translated">在 C# 9.0 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">類似欄位的事件 '{0}' 不能是 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileLocalDuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}' in this file.</source>
        <target state="translated">命名空間 '{1}' 已在此檔案中包含 '{0}' 的定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FilePathCannotBeConvertedToUtf8">
        <source>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</source>
        <target state="translated">無法使用檔案-本機類型 '{0}'，因為無法將包含的檔案路徑轉換成相等的 UTF-8 位元組標記法。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedAndNormalNamespace">
        <source>Source file can not contain both file-scoped and normal namespace declarations.</source>
        <target state="translated">來源檔案不能同時包含以檔案為範圍和一般的命名空間宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedNamespaceNotBeforeAllMembers">
        <source>File-scoped namespace must precede all other members in a file.</source>
        <target state="translated">以檔為範圍的命名空間必須在檔案中的所有其他成員之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeBase">
        <source>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</source>
        <target state="translated">檔案-本機類型 '{0}' 不能做為非檔案-本機類型 '{1}' 的基底類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeDisallowedInSignature">
        <source>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</source>
        <target state="translated">檔案-本機類型 '{0}' 不能用於非檔案本機類型 '{1}' 的成員簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNameDisallowed">
        <source>Types and aliases cannot be named 'file'.</source>
        <target state="translated">類型和別名不能命名為 'file'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNested">
        <source>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</source>
        <target state="translated">檔案-本機類型 '{0}' 必須在最上層類型中定義; '{0}' 是巢狀類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNoExplicitAccessibility">
        <source>File-local type '{0}' cannot use accessibility modifiers.</source>
        <target state="translated">檔案-本機類型 '{0}' 無法使用協助工具修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNonUniquePath">
        <source>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</source>
        <target state="translated">檔案-本機類型 '{0}' 必須在具有唯一路徑的檔案中宣告。路徑 '{1}' 用於多個檔案。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedFieldMustNotBeRef">
        <source>A fixed field must not be a ref field.</source>
        <target state="translated">修正的欄位不能是 ref 欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體或延伸模組定義，所以 foreach 陳述式無法在型別 '{0}' 的變數上運作。您指的是 'await foreach' 而不是 'foreach' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrMethMustBeStatic">
        <source>Cannot create a function pointer for '{0}' because it is not a static method</source>
        <target state="translated">因為函式指標不是靜態方法，所以無法建立 '{0}' 的函式指標</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrRefMismatch">
        <source>Ref mismatch between '{0}' and function pointer '{1}'</source>
        <target state="translated">'{0}' 與函式指標 '{1}' 之間的參考不符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointerTypesInAttributeNotSupported">
        <source>Using a function pointer type in this context is not supported.</source>
        <target state="translated">不支援在此內容中使用函式指標類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointersCannotBeCalledWithNamedArguments">
        <source>A function pointer cannot be called with named arguments.</source>
        <target state="translated">無法以具名引數呼叫函式指標。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
        <source>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</source>
        <target state="translated">介面 '{0}' 不可用做為型別引數。靜態成員 '{1}' 在介面中沒有最具體的實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingInNamespace">
        <source>A global using directive cannot be used in a namespace declaration.</source>
        <target state="translated">全域 using 指示詞不能用在命名空間宣告中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingOutOfOrder">
        <source>A global using directive must precede all non-global using directives.</source>
        <target state="translated">全域 using 指示詞必須在所有非全域 using 指示詞之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingStaticFileType">
        <source>File-local type '{0}' cannot be used in a 'global using static' directive.</source>
        <target state="translated">檔案-本機類型 '{0}' 不能用在 'global using static' 指示詞中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">在相同區塊內，goto 不可跳到 using 宣告前的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">goto 不可跳到 using 宣告後的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HiddenPositionalMember">
        <source>The positional member '{0}' found corresponding to this parameter is hidden.</source>
        <target state="translated">找到之與此參數對應的「{0}」位置成員已隱藏。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAtSequence">
        <source>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</source>
        <target state="translated">不允許 '@' 字元序列。逐字字串或識別碼只可有一個 '@' 字元，而原始字串不可有任何字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">此內容不允許隱藏項目運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitConversionOperatorCantBeChecked">
        <source>An 'implicit' user-defined conversion operator cannot be declared checked</source>
        <target state="translated">無法將「隱式」使用者定義轉換運算子宣告為已檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法隱含地實作無法存取的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">隱含 Index 索引子的引動過程無法為引數命名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationIllegalTargetType">
        <source>The type '{0}' may not be used as the target type of new()</source>
        <target state="translated">new() 的目標類型不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNoTargetType">
        <source>There is no target type for '{0}'</source>
        <target state="translated">'{0}' 沒有任何目標類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNotValid">
        <source>Use of new() is not valid in this context</source>
        <target state="translated">此內容中不可使用 new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">隱含 Range 索引子的引動過程無法為引數命名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedDefaultParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have a default value.</source>
        <target state="translated">隱含輸入的 Lambda 參數 '{0}' 不能有預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">具有 'in' 修飾元的引數不可用於動態分派的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritingFromRecordWithSealedToString">
        <source>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</source>
        <target state="translated">C # {0} 不支援從具有密封的 'Object.ToString' 的記錄繼承。請使用 '{1}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitCannotBeReadonly">
        <source>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</source>
        <target state="translated">'init' 存取子不得標記為 'readonly'。改為將 '{0}' 標記為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayAttributeOnRecord">
        <source>Attribute 'System.Runtime.CompilerServices.InlineArray' cannot be applied to a record struct.</source>
        <target state="translated">屬性 'System.Runtime.CompilerServices.InlineArray' 無法套用至記錄結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayBadIndex">
        <source>Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.</source>
        <target state="translated">內嵌陣列類型的元素只可以隱含方式轉換為 'int'、'System.Index' 或 'System.Range' 的單一引數來存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToReadOnlySpanNotSupported">
        <source>Cannot convert expression to '{0}' because it may not be passed or returned by reference</source>
        <target state="translated">無法將運算式轉換為 '{0}'，因為它可能不會按照參考傳遞或傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToSpanNotSupported">
        <source>Cannot convert expression to '{0}' because it is not an assignable variable</source>
        <target state="translated">無法將運算式轉換為 '{0}'，因為它不是可指派的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayForEachNotSupported">
        <source>foreach statement on an inline array of type '{0}' is not supported</source>
        <target state="translated">不支援類型為 '{0}' 之內嵌陣列上的 foreach 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayIndexOutOfRange">
        <source>Index is outside the bounds of the inline array</source>
        <target state="translated">索引超出內嵌陣列的界限。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayUnsupportedElementFieldModifier">
        <source>Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.</source>
        <target state="translated">不可將內嵌陣列元素欄位宣告為必要、readonly、易變或為固定的大小緩衝區。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstancePropertyInitializerInInterface">
        <source>Instance properties in interfaces cannot have initializers.</source>
        <target state="translated">介面中的執行個體屬性不可有初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptableMethodMustBeOrdinary">
        <source>Cannot intercept '{0}' because it is not an invocation of an ordinary member method.</source>
        <target state="translated">無法攔截 '{0}'，因為它不是一般成員方法的叫用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorArityNotCompatible">
        <source>Method '{0}' must be non-generic or have arity {1} to match '{2}'.</source>
        <target state="translated">方法 '{0}' 必須是非泛型或具有 arity {1}，才能符合 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotBeGeneric">
        <source>Method '{0}' must be non-generic to match '{1}'.</source>
        <target state="translated">方法 '{0}' 必須是非泛型，才能符合 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotInterceptNameof">
        <source>A nameof operator cannot be intercepted.</source>
        <target state="translated">無法攔截 nameof 運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotUseUnmanagedCallersOnly">
        <source>An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.</source>
        <target state="translated">攔截器不能以 'UnmanagedCallersOnlyAttribute' 標示。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCharacterOutOfRange">
        <source>The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.</source>
        <target state="translated">指定的行字元長度為 '{0}'，少於提供的字元數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorContainingTypeCannotBeGeneric">
        <source>Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</source>
        <target state="translated">方法 '{0}' 無法作為攔截器，因為其包含類型具有類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorFilePathCannotBeNull">
        <source>Interceptor cannot have a 'null' file path.</source>
        <target state="translated">攔截器不能有 'null' 檔案路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorGlobalNamespace">
        <source>An interceptor cannot be declared in the global namespace.</source>
        <target state="translated">無法在全域命名空間中宣告攔截器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineCharacterMustBePositive">
        <source>Line and character numbers provided to InterceptsLocationAttribute must be positive.</source>
        <target state="translated">提供給 InterceptsLocationAttribute 的行數和字元數必須是正數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineOutOfRange">
        <source>The given file has '{0}' lines, which is fewer than the provided line number '{1}'.</source>
        <target state="translated">指定的檔案有 '{0}' 行，少於提供的行數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMethodMustBeOrdinary">
        <source>An interceptor method must be an ordinary member method.</source>
        <target state="translated">攔截器方法必須是一般成員方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustHaveMatchingThisParameter">
        <source>Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.</source>
        <target state="translated">攔截器在 '{1}' 上必須有 'this' 參數符合參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustNotHaveThisParameter">
        <source>Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.</source>
        <target state="translated">攔截器不能有 'this' 參數，因為 '{0}' 沒有 'this' 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustReferToStartOfTokenPosition">
        <source>The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?</source>
        <target state="translated">提供的行數和字元數並未參照權杖 '{0} 的開頭。您是否要使用行 '{1}' 和字元 '{2}'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNameNotInvoked">
        <source>Possible method name '{0}' cannot be intercepted because it is not being invoked.</source>
        <target state="translated">無法攔截可能的方法名稱 '{0}'，因為未對其叫用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNonUniquePath">
        <source>Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.</source>
        <target state="translated">無法攔截路徑為 '{0}' 的檔案中呼叫，因為編譯中的多個檔案具有此路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNotAccessible">
        <source>Cannot intercept call with '{0}' because it is not accessible within '{1}'.</source>
        <target state="translated">無法攔截與 '{0}' 的呼叫，因為無法在 '{1}' 內存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilation">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'.</source>
        <target state="translated">無法攔截: 編譯未包含路徑為 '{0}' 的檔案。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithCandidate">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?</source>
        <target state="translated">無法攔截: 編譯未包含路徑為 '{0}' 的檔案。是否要使用 '{1}'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithUnmappedCandidate">
        <source>Cannot intercept: Path '{0}' is unmapped. Expected mapped path '{1}'.</source>
        <target state="translated">無法攔截:路徑 '{0}' 未對應。預期的對應路徑 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPositionBadToken">
        <source>The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.</source>
        <target state="translated">提供的行數和字元數並未參照可攔截的方法名稱，而是指權杖 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorScopedMismatch">
        <source>Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.</source>
        <target state="translated">因為 'scoped' 修飾元或 '[UnscopedRef]' 屬性不同，所以無法攔截具有 '{1}' 對 '{0}' 的呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorSignatureMismatch">
        <source>Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.</source>
        <target state="translated">無法攔截攔截器為 '{1}' 的方法 '{0}'，因為簽章不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorsFeatureNotEnabled">
        <source>The 'interceptors' experimental feature is not enabled in this namespace. Add '{0}' to your project.</source>
        <target state="translated">未在此命名空間中啟用「攔截器」實驗功能。將 '{0}' 新增至您的專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidFormat">
        <source>The data argument to InterceptsLocationAttribute is not in the correct format.</source>
        <target state="translated">InterceptsLocationAttribute 的資料引數格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidPosition">
        <source>The data argument to InterceptsLocationAttribute refers to an invalid position in file '{0}'.</source>
        <target state="translated">InterceptsLocationAttribute 的資料引數在檔案 '{0}' 中的位置無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDuplicateFile">
        <source>Cannot intercept a call in file '{0}' because it is duplicated elsewhere in the compilation.</source>
        <target state="translated">無法攔截檔案 '{0}' 中的呼叫，因為編譯時在他處複製了該呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationFileNotFound">
        <source>Cannot intercept a call in file '{0}' because a matching file was not found in the compilation.</source>
        <target state="translated">無法攔截檔案 '{0}' 中的呼叫，因為編譯時找不到相符的檔案。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationUnsupportedVersion">
        <source>Version '{0}' of the interceptors format is not supported. The latest supported version is '1'.</source>
        <target state="translated">不支援 '{0}' 版的攔截器。支援的最新版本為 ‘1’。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
        <source>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">'UnmanagedCallersOnly' 方法 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">因為介面成員 '{1}' 包含 __arglist 參數，所以 '{0}' 無法在類型 '{2}' 中實作此介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">C# 編譯器中的內部錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
        <source>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</source>
        <target state="translated">套用到參數 '{0}' 的 InterpolatedStringHandlerArgumentAttribute 格式不正確，無法轉譯。手動建構 '{1}' 的執行個體。</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
        <source>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</source>
        <target state="translated">參數 '{0}' 是參數 '{1}' 上插補字串處理常式轉換的引數，但對應的引數是在插補字串運算式之後指定。重新排序引數，將 '{0}' 移動到 '{1}' 之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
        <source>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</source>
        <target state="translated">未明確提供參數 '{0}'，但做為參數 '{1}' 上插補字串處理常式轉換的引數。在 '{1}' 之前先指定 '{0}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
        <source>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</source>
        <target state="translated">差補字串處理常式建構不能使用動態。手動建構 '{0}' 的執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnInconsistent">
        <source>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</source>
        <target state="translated">差補字串處理常式方法 '{0}' 的傳回型別不一致。預期會傳回 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnMalformed">
        <source>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</source>
        <target state="translated">差補字串處理常式方法 '{0}' 格式不正確。它不會傳回 'void' 或 'bool'。</target>
        <note>void and bool are keywords</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
        <source>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</source>
        <target state="translated">參考要編制索引的執行個體的差補字串處理常式轉換無法用於索引子成員初始化程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExperimentalDiagID">
        <source>The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</source>
        <target state="translated">'Experimental' 屬性的 diagnosticId 引數必須是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFuncPointerReturnTypeModifier">
        <source>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</source>
        <target state="translated">'{0}'不是有效的函式指標傳回型別修飾元。有效的修飾元為 'ref' 與 'ref readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFunctionPointerCallingConvention">
        <source>'{0}' is not a valid calling convention specifier for a function pointer.</source>
        <target state="translated">'{0}' 對函式指標而言，不是有效的呼叫慣例指定名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">雜湊演算法名稱無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayFields">
        <source>Inline array struct must declare one and only one instance field.</source>
        <target state="translated">內嵌陣列結構必須宣告一個且只可有一個執行個體欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLayout">
        <source>Inline array struct must not have explicit layout.</source>
        <target state="translated">內嵌陣列結構不可有明確的版面配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLength">
        <source>Inline array length must be greater than 0.</source>
        <target state="translated">內嵌陣列長度必須大於 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not a valid parameter name from '{1}'.</source>
        <target state="translated">'{0}' 不是來自 '{1}' 的有效參數名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierForLanguageVersion">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">修飾元 '{0}' 在 C# {1} 中對此項目無效。請使用 '{2}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameInSubpattern">
        <source>Identifier or a simple member access expected.</source>
        <target state="translated">必須是識別碼或簡單成員存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">無效的物件建立</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPrimaryConstructorParameterReference">
        <source>Cannot use primary constructor parameter '{0}' in this context.</source>
        <target state="translated">無法在此內容中使用主要建構函式參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">無法同時在屬性或索引子 '{0}' 和其存取子上同時指定 'readonly' 修飾元。請移除其中一個。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">"陣序規範無效: 必須是 ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUnmanagedCallersOnlyCallConv">
        <source>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</source>
        <target state="translated">'{0}' 對 'UnmanagedCallersOnly' 而言，不是有效的呼叫慣例類型。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InvalidWithReceiverType">
        <source>The receiver of a `with` expression must have a non-void type.</source>
        <target state="translated">'with' 運算式的接收器不得為 void 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">在 is-type 運算式中使用可為 Null 的參考型別 '{0}' 不合法嗎? 請改用基礎類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">類型為 '{0}' 的運算式永遠無法符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">具有迭代區塊的方法 '{0}' 必須為「非同步」才能傳回 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaExplicitReturnTypeVar">
        <source>The contextual keyword 'var' cannot be used as an explicit lambda return type</source>
        <target state="translated">內容關鍵字 'var' 不得做為明確的 Lambda 傳回型別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaWithAttributesToExpressionTree">
        <source>A lambda expression with attributes cannot be converted to an expression tree</source>
        <target state="translated">具有屬性的 Lambda 運算式，不可轉換成運算式樹狀架構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">因為功能 '{3}' 不適用於 C# {4}，所以 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'。請使用語言 '{5}' 版或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContainsDifferentWhitespace">
        <source>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</source>
        <target state="translated">行包含與原始字串常值結尾行不同的空白: '{0}' 與 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineDoesNotStartWithSameWhitespace">
        <source>Line does not start with the same whitespace as the closing line of the raw string literal.</source>
        <target state="translated">行開頭的空白與原始字串常值結尾行的空白不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveEndLessThanStart">
        <source>The #line directive end position must be greater than or equal to the start position</source>
        <target state="translated">#line 指示詞結束位置必須大於或等於開始位置</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveInvalidValue">
        <source>The #line directive value is missing or out of range</source>
        <target state="translated">#line 指示詞值遺漏或超出範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveRequiresSpace">
        <source>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</source>
        <target state="translated">#line span 指示詞的第一個括弧前、字元位移前及檔案名前需要空格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ListPatternRequiresLength">
        <source>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</source>
        <target state="translated">清單模式不能用於型別 '{0}' 的值。找不到適當的 'Length' 或 'Count' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethFuncPtrMismatch">
        <source>No overload for '{0}' matches function pointer '{1}'</source>
        <target state="translated">'{0}' 沒有任何多載符合函式指標 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedRecord">
        <source>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</source>
        <target state="translated">未預期的關鍵字 'record'。您是指 'record struct' 或 'record class'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedSlicePattern">
        <source>Slice patterns may only be used once and directly inside a list pattern.</source>
        <target state="translated">切片模式只能在清單模式中使用一次且直接使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedUnchecked">
        <source>Unexpected keyword 'unchecked'</source>
        <target state="translated">未預期的關鍵字 'unchecked'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddressOf">
        <source>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</source>
        <target state="translated">無法將方法群組轉換成函式指標 (您是否缺少 '&amp;'?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">缺少模式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
        <source>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">無法使用 'UnmanagedCallersOnly' 將模組初始設定式屬性化。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
        <source>Module initializer method '{0}' must not be generic and must not be contained in a generic type</source>
        <target state="translated">模組初始設定式方法 '{0}' 不得為泛型，且不得包含在泛型型別中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
        <source>Module initializer method '{0}' must be accessible at the module level</source>
        <target state="translated">模組初始設定式方法 '{0}' 必須可在模組層級中存取</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeOrdinary">
        <source>A module initializer must be an ordinary member method</source>
        <target state="translated">模組初始設定式必須是一般成員方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
        <source>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</source>
        <target state="translated">模組初始設定式方法 '{0}' 必須是靜態且非虛擬，不得具有任何參數，而且必須傳回 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">多個分析器組態檔無法處於相同目錄 ('{0}') 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">無法在多個參數上使用屬性 [EnumeratorCancellation]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleFileScopedNamespace">
        <source>Source file can only contain one file-scoped namespace declaration.</source>
        <target state="translated">來源檔案只能包含一個以檔案為範圍的命名空間宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleRecordParameterLists">
        <source>Only a single partial type declaration may have a parameter list</source>
        <target state="translated">只有單一部分類型宣告可以有參數清單</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForInlineArray">
        <source>An inline array access may not have a named argument specifier</source>
        <target state="translated">內嵌陣列存取不能有具名引數指定名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">new()' 條件約束不能和 'unmanaged' 條件約束一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintCannotHaveRequiredMembers">
        <source>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</source>
        <target state="translated">'{2}' 無法滿足泛型型別或方法 '{0}' 中參數 '{1}' 的 'new()' 限制式，因為 '{2}' 具有必要的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
        <source>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</source>
        <target state="translated">C# {0} 不支援非逐字差補字串內的新行。請使用語言版本 {1} 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="needs-review-translation">'{0}': 在非同步 using 陳述式中使用的類型，必須可隱含地轉換為 'System.IAsyncDisposable' 或實作合適的 'DisposeAsync' 方法。您指的是否為 'using'，而非 'await using'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="needs-review-translation">'{0}': using 陳述式中使用的類型必須可以隱含轉換為 'System.IDisposable'。您指的是 'await using' 而不是 'using' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerArgumentExpressionParam">
        <source>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerArgumentExpressionAttribute，因為從類型 '{0}' 到類型 '{1}' 沒有標準轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCopyConstructorInBaseType">
        <source>No accessible copy constructor found in base type '{0}'.</source>
        <target state="translated">在基底類型 '{0}' 中找不到可存取的複製建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDelegateConstraint">
        <source>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</source>
        <target state="translated">關鍵字 'delegate' 無法做為限制式。您是指 'System.Delegate'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEnumConstraint">
        <source>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</source>
        <target state="translated">關鍵字 'enum' 無法做為限制式。您是指 'struct, System.Enum'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvTargetTypedConditional">
        <source>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</source>
        <target state="translated">因為在 '{1}' 和 '{2}' 之間找不到通用類型，所以在語言版本 {0} 中條件運算式無效。若要使用以目標為類型的轉換，請升級至語言版本 {3} 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnUsing">
        <source>Modifiers cannot be placed on using declarations</source>
        <target state="translated">修飾元不能置於 using 宣告中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="translated">無法判斷輸出目錄</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPrivateAPIInRecord">
        <source>Record member '{0}' must be private.</source>
        <target state="translated">記錄成員 '{0}' 必須為私人。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonProtectedAPIInRecord">
        <source>Record member '{0}' must be protected.</source>
        <target state="translated">記錄成員 '{0}' 必須受保護。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicAPIInRecord">
        <source>Record member '{0}' must be public.</source>
        <target state="translated">記錄成員 '{0}' 必須為公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicParameterlessStructConstructor">
        <source>The parameterless struct constructor must be 'public'.</source>
        <target state="translated">無參數結構建構函式必須是 'public'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughCloseBracesForRawString">
        <source>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</source>
        <target state="translated">內插補點結尾的右括弧數目必須與原始字串常值開頭的 '$' 字元數相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughQuotesForRawString">
        <source>Not enough quotes for raw string literal.</source>
        <target state="translated">原始字串常值的引號不足。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not an instance method, the receiver cannot be an interpolated string handler argument.</source>
        <target state="translated">'{0}' 不是執行個體方法，接收器不可為差補字串處理常式引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableAPIInRecord">
        <source>'{0}' must allow overriding because the containing record is not sealed.</source>
        <target state="translated">'{0}' 必須允許覆寫，因為包含的記錄並未密封。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotRefStructConstraintNotSatisfied">
        <source>The type '{2}' may not be a ref struct or a type parameter allowing ref structs in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 不得為 ref struct，也不得為允許 ref struct 的型別參數，才能在泛型型別或方法 '{0}' 中將其用為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullInvalidInterpolatedStringHandlerArgumentName">
        <source>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</source>
        <target state="translated">null 不是有效的參數名稱。若要取得執行個體方法接收器的存取權，請使用空字串做為參數名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">應為 'enable'、'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">必須是 'warnings'、'annotations' 或指示詞結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">'{0}' 值無效: 若是 C# {2}，則為 '{1}'。請使用 '{3}' 或更高的語言版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">除非使用語言版本 '{0}' 或更新版本，否則就必須知道可為 Null 的型別參數是實值型別還是不可為 Null 的參考型別。請考慮變更語言版本，或新增 'class'、'struct' 或類型條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedTypeArgument">
        <source>Omitting the type argument is not allowed in the current context</source>
        <target state="translated">不允許在目前的內容中省略型別引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantBeChecked">
        <source>User-defined operator '{0}' cannot be declared checked</source>
        <target state="translated">使用者定義的運算子 '{0}' 無法宣告為已檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefReadonlyParam">
        <source>A ref readonly parameter cannot have the Out attribute.</source>
        <target state="translated">ref readonly 參數不能有 Out 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">out 變數不可宣告為 ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideDefaultConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</source>
        <target state="translated">方法 '{0}' 會為型別參數 '{1}' 指定 'default' 條件約束，但覆寫或明確實作方法 '{3}' 的對應型別參數 '{2}' 會限制為參考型別或實值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideMustHaveRequired">
        <source>'{0}' must be required because it overrides required member '{1}'</source>
        <target state="translated">'{0}' 必須為必要項目，因為它會覆蓋必要的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">方法 '{0}' 會為型別參數 '{1}' 指定 'class' 條件約束，但覆寫或明確實作的方法 '{3}' 對應型別參數 '{2}' 不屬於參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">方法 '{0}' 會為型別參數 '{1}' 指定 'struct' 條件約束，但覆寫或明確實作的方法 '{3}' 對應型別參數 '{2}' 是不可為 Null 實值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNullCheckingNotSupported">
        <source>The 'parameter null-checking' feature is not supported.</source>
        <target state="translated">不支援 'parameter null-checking' 功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionConstructorDoesntInitializeRequiredMember">
        <source>Constructor '{0}' leaves required member '{1}' uninitialized.</source>
        <target state="translated">建構函式 '{0}' 未初始化必要的成員 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExpressionTree">
        <source>An expression tree may not contain an expanded form of non-array params collection parameter.</source>
        <target state="translated">運算式樹狀架構不能包含展開的非陣列參數集合參數形式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExtensionAddMethod">
        <source>'{0}' does not contain a definition for a suitable instance 'Add' method</source>
        <target state="translated">'{0}' 不包含適當執行個體 'Add' 方法的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionInfiniteChainOfConstructorCalls">
        <source>Creation of params collection '{0}' results in an infinite chain of invocation of constructor '{1}'.</source>
        <target state="translated">建立參數集合 '{0}' 產生無限鏈結的建構函式 '{1}' 叫用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionMissingConstructor">
        <source>Non-array params collection type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">非陣列參數集合型別必須具有可在不帶引數的情況下呼叫的適用建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMemberCannotBeLessVisibleThanDeclaringMember">
        <source>Method '{0}' cannot be less visible than the member with params collection '{1}'.</source>
        <target state="translated">方法 '{0}' 不能小於具有參數集合 '{1}' 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeCollection">
        <source>The params parameter must have a valid collection type</source>
        <target state="translated">params 參數必須具有有效的集合型別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberAccessibilityDifference">
        <source>Both partial member declarations must have identical accessibility modifiers.</source>
        <target state="translated">兩個部分成員宣告都必須具有完全相同的協助工具修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberCannotBeAbstract">
        <source>A partial member cannot have the 'abstract' modifier</source>
        <target state="translated">部分成員不能有 'abstract' 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberInconsistentTupleNames">
        <source>Both partial member declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">兩個部份成員宣告 '{0}' 和 '{1}' 都必須使用相同的 Tuple 元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberOnlyInPartialClass">
        <source>A partial member must be declared within a partial type</source>
        <target state="translated">部分成員必須在部分型別內宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberParamsDifference">
        <source>Both partial member declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">兩個部分成員宣告都必須使用 params 參數，或兩者都不使用 params 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberReadOnlyDifference">
        <source>Both partial member declarations must be readonly or neither may be readonly</source>
        <target state="translated">兩個部份成員宣告都必須是唯讀，或者都不是唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberExtendedModDifference">
        <source>Both partial member declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</source>
        <target state="translated">兩個部分成員宣告都必須具有完全相同的 'virtual'、'override'、'sealed' 及 'new' 修飾元組合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberRefReturnDifference">
        <source>Partial member declarations must have matching ref return values.</source>
        <target state="translated">部分成員宣告必須有相符的參考傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberUnsafeDifference">
        <source>Both partial member declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">兩個部分成員宣告皆必須為非受控，或者皆不為非受控</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReturnTypeDifference">
        <source>Both partial method declarations must have the same return type.</source>
        <target state="translated">兩個部分方法宣告都必須有相同的傳回型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
        <source>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</source>
        <target state="translated">因為部分方法 '{0}' 有存取範圍修飾詞，所以其必須有實作部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithExtendedModMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</source>
        <target state="translated">因為部分方法 '{0}' 有 'virtual'、'override'、'sealed'、'new' 或 'extern' 修飾元，所以其必須有存取範圍修飾詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</source>
        <target state="translated">因為部分方法 '{0}' 有非 void 的傳回型別，所以其必須有存取範圍修飾詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithOutParamMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</source>
        <target state="translated">因為部分方法 '{0}' 有 'out' 參數，所以其必須有存取範圍修飾詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateDefinition">
        <source>A partial property may not have multiple defining declarations, and cannot be an auto-property.</source>
        <target state="translated">部分屬性不可具有多個定義宣告，而且不能是自動屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateImplementation">
        <source>A partial property may not have multiple implementing declarations</source>
        <target state="translated">部分屬性不可具有多個實作的宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyInitMismatch">
        <source>Property accessor '{0}' must be '{1}' to match the definition part</source>
        <target state="translated">屬性存取子 '{0}' 必須是 '{1}' 以符合定義部分</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingAccessor">
        <source>Property accessor '{0}' must be implemented because it is declared on the definition part</source>
        <target state="translated">屬性存取子 '{0}' 必須實作，因為它是在定義部分上宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingDefinition">
        <source>Partial property '{0}' must have a definition part.</source>
        <target state="translated">部分屬性 '{0}' 必須有定義部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingImplementation">
        <source>Partial property '{0}' must have an implementation part.</source>
        <target state="translated">部分屬性 '{0}' 必須有實作部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyRequiredDifference">
        <source>Both partial property declarations must be required or neither may be required</source>
        <target state="translated">兩個部分屬性宣告都必須是必要項，或者都不是必要項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyTypeDifference">
        <source>Both partial property declarations must have the same type.</source>
        <target state="translated">兩個部分屬性宣告都必須有相同型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyUnexpectedAccessor">
        <source>Property accessor '{0}' does not implement any accessor declared on the definition part</source>
        <target state="translated">屬性存取子 '{0}' 未實作定義部分上宣告的任何存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternSpanCharCannotBeStringNull">
        <source>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</source>
        <target state="translated">不支援字串 'null' 常數做為 '{0}' 的模式。請改為使用空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">指標類型不允許進行模式比對。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">async-iterator 方法的主體必須包含 'yield' 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">async-iterator 方法的主體必須包含 'yield' 陳述式。建議將 'async' 從方法宣告移除，或新增 'yield' 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">屬性子模式需要對屬性或欄位的參考才能比對，例如 '{{ Name: {0} }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringDelimiterOnOwnLine">
        <source>Raw string literal delimiter must be on its own line.</source>
        <target state="translated">原始字串常值分隔符號必須位於自己的行。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringInVerbatimInterpolatedStrings">
        <source>Multi-line raw string literals are only allowed in verbatim interpolated strings.</source>
        <target state="translated">多行原始字串常值只允許在逐字差補字串中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringMustContainContent">
        <source>Multi-line raw string literals must contain at least one line of content.</source>
        <target state="translated">多行原始字串常值至少必須包含一行內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringNotInDirectives">
        <source>Raw string literals are not allowed in preprocessor directives.</source>
        <target state="translated">前置處理器指示詞中不允許原始字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">因為類型 '{0}' 有重新抽象成員 (來自基底介面)，所以無法內嵌。請考慮將 [內嵌 Interop 類型] 屬性設為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 只有在屬性或索引子同時具有 get 和 set 存取子時，才能在存取子上使用 'readonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordAmbigCtor">
        <source>The primary constructor conflicts with the synthesized copy constructor.</source>
        <target state="translated">主要建構函式與合成的複製建構函式相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordStructConstructorCallsDefaultConstructor">
        <source>A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</source>
        <target state="translated">在 'struct' 中宣告、具有參數清單的建構函式，必須有呼叫主要建構函式或已明確宣告建構函式的 'this' 初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">不能將 '{1}' 參考指派至 '{0}'，因為 '{1}' 的逸出範圍比 '{0}' 還要窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignReturnOnly">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">無法將 '{1}' 參考指派至 '{0}'，因為 '{1}' 只能透過 return 陳述式逸出目前的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignValEscapeWider">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">無法參考指派 '{1}' 給 '{0}'，因為 '{1}' 具有比 '{0}' 更寬的值逸出範圍，允許透過 '{0}' 的值指派，其逸出範圍比 '{1}' 更窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldCannotReferToRefStruct">
        <source>A ref field cannot refer to a ref struct.</source>
        <target state="translated">ref 欄位不能參考 ref 結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldInNonRefStruct">
        <source>A ref field can only be declared in a ref struct.</source>
        <target state="translated">ref 欄位只能在 ref 結構中宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalAcrossAwait">
        <source>A 'ref' local cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">無法保留 'await' 或 'yield' 界限之間的區域 'ref '。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref variable.</source>
        <target state="translated">參考指派的左側必須為 ref 變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadOnlyWrongOrdering">
        <source>'readonly' modifier must be specified after 'ref'.</source>
        <target state="translated">'readonly' 修飾元必須在 'ref' 之後指定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">唯讀類型的主要建構函式參數不能做為 ref 或 out 值 (類型的 init-only setter 或變數初始設定式中除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">唯讀類型的主要建構函式參數 '{0}' 的成員不能做為 ref 或 out 值 (類型的 init-only setter 或變數初始設定式中除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter">
        <source>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">無法透過 ref 參數藉傳址方式傳回參數 '{0}'; 只能在 return 陳述式中傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter2">
        <source>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">無法透過 ref 參數藉傳址方式傳回參數成員 '{0}'; 只能在 return 陳述式中傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnPrimaryConstructorParameter">
        <source>Cannot return primary constructor parameter '{0}' by reference.</source>
        <target state="translated">無法依參考傳回主要建構函式參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be returned by writable reference</source>
        <target state="translated">唯讀類型的主要建構函式參數無法由可寫入的參考傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference</source>
        <target state="translated">唯讀類型的主要建構函式參數 '{0}' 的成員無法由可寫入的參考傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter">
        <source>Cannot return a parameter by reference '{0}' because it is scoped to the current method</source>
        <target state="translated">無法藉傳址方式 '{0}' 傳回參數，因為它的範圍是目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</source>
        <target state="translated">無法藉傳址方式傳回參數 '{0}' 的成員，因為它的範圍是目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningPropertiesCannotBeRequired">
        <source>Ref returning properties cannot be required.</source>
        <target state="translated">無法要求 Ref 傳回屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructConstraintAlreadySpecified">
        <source>'ref struct' is already specified.</source>
        <target state="translated">已指定了 'ref struct'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' for ref struct '{2}'.</source>
        <target state="translated">'{0}' 無法為 ref struct '{2}' 實作介面成員'{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RelationalPatternWithNaN">
        <source>Relational patterns may not be used for a floating-point NaN.</source>
        <target state="translated">浮點 NaN 不可使用關聯性模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeHidden">
        <source>Required member '{0}' cannot be hidden by '{1}'.</source>
        <target state="translated">'{1}' 無法隱藏必要成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
        <source>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</source>
        <target state="translated">必要成員 '{0}' 可見度不能較低，或 setter 的可見程度低於包含的類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSet">
        <source>Required member '{0}' must be set in the object initializer or attribute constructor.</source>
        <target state="translated">必須在物件初始設定式或屬性建構函式中設定必要的成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSettable">
        <source>Required member '{0}' must be settable.</source>
        <target state="translated">必要的成員 '{0}' 必須可設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersBaseTypeInvalid">
        <source>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</source>
        <target state="translated">基底類型 '{0}' 所需的成員清單格式錯誤，無法解譯。若要使用此建構函式，請套用 'SetsRequiredMembers' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersInvalid">
        <source>The required members list for '{0}' is malformed and cannot be interpreted.</source>
        <target state="translated">'{0}' 的必要成員清單格式錯誤，無法解譯。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersMustBeAssignedValue">
        <source>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</source>
        <target state="translated">必要的成員 '{0}' 必須指派值，它無法使用巢狀成員或集合初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNameDisallowed">
        <source>Types and aliases cannot be named 'required'.</source>
        <target state="translated">類型和別名不能命名為 'required'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportByRefLikeGenerics">
        <source>Target runtime doesn't support by-ref-like generics.</source>
        <target state="translated">目標執行階段不支援泛型之類 by-ref-。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
        <source>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 在覆寫中，目標執行階段不支援 Covariant 類型。類型必須是 '{2}'，才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
        <source>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 在覆寫中，目標執行階段不支援 Covariant 傳回型別。傳回型別必須是 '{2}'，才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportInlineArrayTypes">
        <source>Target runtime doesn't support inline array types.</source>
        <target state="translated">目標執行階段不支援內嵌陣列類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">目標執行階段不支援介面成員的 'protected'、'protected internal' 或 'private protected' 存取權。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportRefFields">
        <source>Target runtime doesn't support ref fields.</source>
        <target state="translated">目標執行時間不支援 ref 欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
        <source>Target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">目標執行階段不支援介面中的靜態抽象成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">因為目標執行階段不支援介面中靜態抽象成員，所以 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
        <source>The target runtime doesn't support extensible or runtime-environment default calling conventions.</source>
        <target state="translated">目標執行階段不支援可延伸或執行階段環境的預設呼叫慣例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedDiscard">
        <source>The 'scoped' modifier cannot be used with discard.</source>
        <target state="translated">'scoped' 修飾元不能與捨棄一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">參數 '{0}' 的 'scoped' 修飾元不符合覆寫或實作的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfPartial">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match partial definition.</source>
        <target state="translated">參數 '{0}' 的 'scoped' 修飾元與部分定義不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">參數 '{0}' 的 'scoped' 修飾元不符合目標 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedRefAndRefStructOnly">
        <source>The 'scoped' modifier can be used for refs and ref struct values only.</source>
        <target state="translated">'scoped' 修飾元只能用於 refs 和 ref 結構值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedTypeNameDisallowed">
        <source>Types and aliases cannot be named 'scoped'.</source>
        <target state="translated">類型和別名不能命名為 'scoped'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
        <source>Required members are not allowed on the top level of a script or submission.</source>
        <target state="translated">指令碼或提交的頂層不允許必要的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedAPIInRecord">
        <source>'{0}' cannot be sealed because containing record is not sealed.</source>
        <target state="translated">因為未密封內含的記錄，所以無法密封 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignatureMismatchInRecord">
        <source>Record member '{0}' must return '{1}'.</source>
        <target state="translated">記錄成員 '{0}' 必須傳回 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramDisallowsMainType">
        <source>Cannot specify /main if there is a compilation unit with top-level statements.</source>
        <target state="translated">如果有編譯單位包含最上層陳述式，就無法指定 /main。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramIsEmpty">
        <source>At least one top-level statement must be non-empty.</source>
        <target state="translated">至少一個最上層陳述式必須是非空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
        <source>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</source>
        <target state="translated">在此內容中，無法使用最上層陳述式中宣告的區域變數或區域函式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
        <source>Only one compilation unit can have top-level statements.</source>
        <target state="translated">只能有一個編譯單位包含最上層陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramNotAnExecutable">
        <source>Program using top-level statements must be an executable.</source>
        <target state="translated">使用最上層陳述式的程式必須是可執行檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">單一元素解構模式需要一些其他語法才能使其明確。建議在右括弧 ')' 後新增捨棄指示項 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpreadMissingMember">
        <source>Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">擴展運算子 '..' 無法在類型 '{0}' 的變數上運作，因為 '{0}' 不包含 '{1}' 的公用執行個體或延伸模組定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAPIInRecord">
        <source>Record member '{0}' may not be static.</source>
        <target state="translated">記錄成員 '{0}' 不可以是靜態。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureThis">
        <source>A static anonymous function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">靜態匿名函式不可包含對 'this' 或 'base' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureVariable">
        <source>A static anonymous function cannot contain a reference to '{0}'.</source>
        <target state="translated">靜態匿名函式不可包含對 '{0}' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">靜態區域函式不可包含對 'this' 或 'base' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">靜態區域函式不可包含對 '{0}' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">靜態成員 '{0}' 不能標記為 'readonly'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">已指定 stdin 引數 '-'，但尚未從標準輸入資料流重新導向輸入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StringMustStartWithQuoteCharacter">
        <source>String must start with quote character: "</source>
        <target state="translated">字串的開頭必須是引號字元: "</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructHasInitializersAndNoDeclaredConstructor">
        <source>A 'struct' with field initializers must include an explicitly declared constructor.</source>
        <target state="translated">具有欄位初始設定式的 'struct' 必須包含明確宣告的建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCyclePrimaryConstructorParameter">
        <source>Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">類型 '{1}' 的結構主要建構函式參數 '{0}' 在結構配置中導致循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</source>
        <target state="translated">無法使用此樣式。switch 運算式的上一個 arm 已處理了此樣式，或其無法比對。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</source>
        <target state="translated">無法使用此 switch 案例。switch 運算式的上一個 arm 已處理了此樣式，或其無法比對。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">找不到 switch 運算式的最佳類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">switch 主導的運算式前後必須有括弧。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SymbolDefinedInAssembly">
        <source>'{0}' is defined in assembly '{1}'.</source>
        <target state="translated">'{0}' 於組件 '{1}' 中定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCloseBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</source>
        <target state="translated">差補原始字串常值開頭沒有足夠的 '$' 字元數，因此無法允許這麼多連續的右大括弧做為內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyOpenBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</source>
        <target state="translated">差補原始字串常值開頭沒有足夠的 '$' 字元，因此無法允許這麼多連續的左大括弧做為內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyQuotesForRawString">
        <source>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</source>
        <target state="translated">原始字串常值開頭沒有足夠的引號字元，因此無法允許這麼多連續的引號字元做為內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TopLevelStatementAfterNamespaceOrType">
        <source>Top-level statements must precede namespace and type declarations.</source>
        <target state="translated">最上層陳述式必須在命名空間和型別宣告之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">未預期的字元順序 '...'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">名稱 '{0}' 無法識別元組元素 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">作為 == 或 != 運算子之運算元使用的元組類型，必須具有相符的基數。但此運算子在左側的元組類型為基數 {0}，在右側則為 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConstraintsMustBeUniqueAndFirst">
        <source>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</source>
        <target state="translated">無法合併或複製 'class'、'struct'、'unmanaged'、'notnull' 以及 'default' 條件約束，而且必須先在條件約束清單中指定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeIsNotAnInterpolatedStringHandlerType">
        <source>'{0}' is not an interpolated string handler type.</source>
        <target state="translated">'{0}' 不是差補字串處理常式類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMustBePublic">
        <source>Type '{0}' must be public to be used as a calling convention.</source>
        <target state="translated">類型 '{0}' 必須是公用，才能用為呼叫慣例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先完全指派自動實作屬性 '{0}'。請考慮更新至語言版本 '{1}' 以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先完全指派欄位 '{0}'。請考慮更新至語言版本 '{1}' 以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedParameterList">
        <source>Unexpected parameter list.</source>
        <target state="translated">未預期的參數清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}' 使用 'UnmanagedCallersOnly' 屬性化，因此無法直接呼叫。取得此方法的函式指標。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}' 使用 'UnmanagedCallersOnly' 屬性化，因此無法轉換為委派類型。取得此方法的函式指標。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedRefSafetyRulesAttributeVersion">
        <source>'{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.</source>
        <target state="translated">'{0}' 是在具有無法辨識的 RefSafetyRulesAttribute 版本的模組中定義，預期為 '11'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeInterfaceImplementation">
        <source>UnscopedRefAttribute cannot be applied to an interface implementation because implemented member '{0}' doesn't have this attribute.</source>
        <target state="translated">UnscopedRefAttribute 無法套用至介面實作，因為實作的成員 '{0}' 不具這項屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedMemberTarget">
        <source>UnscopedRefAttribute can only be applied to struct or virtual interface instance methods and properties, and cannot be applied to constructors or init-only members.</source>
        <target state="translated">UnscopedRefAttribute 只能套用至結構或虛擬執行個體方法和屬性，而無法套用至建構函式或只為 init 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedTarget">
        <source>UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.</source>
        <target state="translated">UnscopedRefAttribute 無法套用到此參數，因為預設是不限範圍。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedScoped">
        <source>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</source>
        <target state="translated">UnscopedRefAttribute 無法套用至具有 'scoped' 修飾元之參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCompilerFeature">
        <source>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</source>
        <target state="translated">'{0}' 需要編譯器功能 '{1}'，此版本的 C# 編譯器不支援此功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRef">
        <source>Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member</source>
        <target state="translated">無法在執行個體成員內使用 ref、out 或 in 主要建立建構函式參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefAny">
        <source>Cannot use primary constructor parameter of type '{0}' inside an instance member</source>
        <target state="translated">無法使用執行個體成員內類型 '{0}' 的主要建構函式參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefLike">
        <source>Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member</source>
        <target state="translated">無法使用執行個體成員內具有類似參考類型的主要建立函式參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForListPattern">
        <source>List patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">類型 '{0}' 的值不可使用清單模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForSlicePattern">
        <source>Slice patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">類型 '{0}' 的值不可使用切片模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedRawString">
        <source>Unterminated raw string literal.</source>
        <target state="translated">未結束的原始字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">使用可能未指派的欄位 '{0}'。請考慮更新語言版本 '{1}' 以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">使用可能未指派的自動實作屬性 '{0}'。請考慮更新語言版本 '{1}' 以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">在指派 'this' 物件的所有欄位之前，無法使用該物件。請考慮更新語言版本 '{0}'，以自動預設未指派的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongArityAsyncReturn">
        <source>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</source>
        <target state="translated">應存在類似泛型工作的傳回型別，但在 'AsyncMethodBuilder' 屬性中找到的類型 '{0}' 不適用。它必須是 arity one 的未綁定泛型型別，並且其包含類型 (如果有) 必須是非泛型。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing">
        <source>The using directive for '{0}' appeared previously as global using</source>
        <target state="translated">'{0}' 的 using 指示詞先前顯示為全域 using</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing_Title">
        <source>The using directive appeared previously as global using</source>
        <target state="translated">Using 指示詞先前顯示為全域 using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ArrayAccess">
        <source>array access</source>
        <target state="translated">陣列存取</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AsyncMethodBuilderOverride">
        <source>async method builder override</source>
        <target state="translated">非同步方法建立器覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAllowsRefStructConstraint">
        <source>allows ref struct constraint</source>
        <target state="translated">允許參考結構限制式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoDefaultStructs">
        <source>auto default struct fields</source>
        <target state="translated">自動預設結構欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCheckedUserDefinedOperators">
        <source>checked user-defined operators</source>
        <target state="translated">已檢查使用者定義的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressions">
        <source>collection expressions</source>
        <target state="translated">集合運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCovariantReturnsForOverrides">
        <source>covariant returns</source>
        <target state="translated">Covariant 傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDiscards">
        <source>discards</source>
        <target state="translated">Discard</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDisposalPattern">
        <source>pattern-based disposal</source>
        <target state="translated">模式型處置</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPropertyPatterns">
        <source>extended property patterns</source>
        <target state="translated">擴充屬性模式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFieldKeyword">
        <source>field keyword</source>
        <target state="new">field keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileScopedNamespace">
        <source>file-scoped namespace</source>
        <target state="translated">以檔案為範圍的命名空間</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileTypes">
        <source>file types</source>
        <target state="translated">檔案類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenericAttributes">
        <source>generic attributes</source>
        <target state="translated">一般屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalUsing">
        <source>global using directive</source>
        <target state="translated">全域 using 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitIndexerInitializer">
        <source>implicit indexer initializer</source>
        <target state="translated">隱含索引子初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitObjectCreation">
        <source>target-typed object creation</source>
        <target state="translated">建立具目標類型的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImprovedInterpolatedStrings">
        <source>interpolated string handlers</source>
        <target state="translated">差補字串處理常式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInferredDelegateType">
        <source>inferred delegate type</source>
        <target state="translated">推斷委派類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInlineArrays">
        <source>inline arrays</source>
        <target state="translated">內嵌陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInstanceMemberInNameof">
        <source>instance member in 'nameof'</source>
        <target state="translated">'nameof' 中的執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaAttributes">
        <source>lambda attributes</source>
        <target state="translated">Lambda 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaOptionalParameters">
        <source>lambda optional parameters</source>
        <target state="translated">Lambda 選用參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaParamsArray">
        <source>lambda params array</source>
        <target state="translated">Lambda 參數陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaReturnType">
        <source>lambda return type</source>
        <target state="translated">lambda 傳回型別</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureListPattern">
        <source>list pattern</source>
        <target state="translated">清單模式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLockObject">
        <source>Lock object</source>
        <target state="translated">鎖定物件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNewLinesInInterpolations">
        <source>newlines in interpolations</source>
        <target state="translated">插補中的新行</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParameterlessStructConstructors">
        <source>parameterless struct constructors</source>
        <target state="translated">無參數結構建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParamsCollections">
        <source>params collections</source>
        <target state="translated">參數集合</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePositionalFieldsInRecords">
        <source>positional fields in records</source>
        <target state="translated">記錄中的位置欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrimaryConstructors">
        <source>primary constructors</source>
        <target state="translated">主要建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRawStringLiterals">
        <source>raw string literals</source>
        <target state="translated">原始字串常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecordStructs">
        <source>record structs</source>
        <target state="translated">記錄結構</target>
        <note>'record structs' is not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFields">
        <source>ref fields</source>
        <target state="translated">ref 欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReadonlyParameters">
        <source>ref readonly parameters</source>
        <target state="translated">ref readonly 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructInterfaces">
        <source>ref struct interfaces</source>
        <target state="translated">ref struct 介面</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefUnsafeInIteratorAsync">
        <source>ref and unsafe in async and iterator methods</source>
        <target state="translated">非同步和迭代器方法中的 ref 和 unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelaxedShiftOperator">
        <source>relaxed shift operator</source>
        <target state="translated">寬鬆移位 (Shift) 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRequiredMembers">
        <source>required members</source>
        <target state="translated">必要成員</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSealedToStringInRecord">
        <source>sealed ToString in record</source>
        <target state="translated">記錄中有密封的 ToString</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStringEscapeCharacter">
        <source>string escape character</source>
        <target state="translated">字串逸出字元</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStructFieldInitializers">
        <source>struct field initializers</source>
        <target state="translated">結構欄位初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnsignedRightShift">
        <source>unsigned right shift</source>
        <target state="translated">未簽署右移位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUtf8StringLiterals">
        <source>UTF-8 string literals</source>
        <target state="translated">UTF-8 字串常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingTypeAlias">
        <source>using type alias</source>
        <target state="translated">使用類型別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnAnonymousTypes">
        <source>with on anonymous types</source>
        <target state="translated">在匿名型別上</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAbstractMembersInInterfaces">
        <source>static abstract members in interfaces</source>
        <target state="translated">介面中的靜態抽象成員</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnStructs">
        <source>with on structs</source>
        <target state="translated">在結構上</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSpanCharConstantPattern">
        <source>pattern matching ReadOnly/Span&lt;char&gt; on constant string</source>
        <target state="translated">常數字串上的模式比對 ReadOnly/Span&lt;char&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Missing">
        <source>&lt;missing&gt;</source>
        <target state="translated">&lt;missing&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverloadResolutionPriority">
        <source>overload resolution priority</source>
        <target state="new">overload resolution priority</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PointerElementAccess">
        <source>pointer element access</source>
        <target state="translated">指標元素存取</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ARRAY">
        <source>array</source>
        <target state="translated">陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_DYNAMIC">
        <source>dynamic</source>
        <target state="translated">動態</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FUNCTION_POINTER">
        <source>function pointer</source>
        <target state="translated">函式指標</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_POINTER">
        <source>pointer</source>
        <target state="translated">指標</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_IdentifierConflictWithContextualKeyword">
        <source>'{0}' is a contextual keyword in property accessors starting in language version {1}. Use '@{0}' instead.</source>
        <target state="translated">'{0}' 是從語言版本 {1} 開始之屬性存取子中的內容相關關鍵字。請改用 '@{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_IdentifierConflictWithContextualKeyword_Title">
        <source>Identifier is a contextual keyword, with a specific meaning, in a later language version.</source>
        <target state="translated">識別碼是在較新語言版本中具有特定意義的內容相關關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas">
        <source>Compiling requires binding the lambda expression at least {0} times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">編譯至少需要繫結 Lambda 運算式 {0} 次。請考慮在宣告 Lambda 運算式時，指定明確的參數類型；若包含了泛型方法呼叫，請考慮使用明確的類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas_Title">
        <source>Compiling requires binding the lambda expression many times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">編譯需要多次繫結 Lambda 運算式。請考慮在宣告 Lambda 運算式時，指定明確的參數類型；若包含了泛型方法呼叫，請考慮使用明確的類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISpreadOperationIsNotCSharpSpread">
        <source>{0} is not a valid C# spread operation</source>
        <target state="translated">{0} 不是有效的 C# spread 作業</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">'&amp;' 運算子不應該用於非同步方法中的參數或區域變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync_Title">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">'&amp;' 運算子不應該用於非同步方法中的參數或區域變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">包含類型 '{1}' 的組件 '{0}' 參考了 .NET Framework，此情形不受支援。</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">載入的組件參考了 .NET Framework，此情形不受支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler">
        <source>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="translated">分析程式組件 '{0}' 參考編譯器的版本 '{1}' ，比目前執行的版本 '{2}' 還要新。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler_Title">
        <source>The analyzer assembly references a newer version of the compiler than the currently running version.</source>
        <target state="translated">分析程式組件參考的編譯器版本比目前執行的版本新。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn">
        <source>Argument {0} should be passed with the 'in' keyword</source>
        <target state="translated">引數 {0} 應該以 'in' 的關鍵字傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn_Title">
        <source>Argument should be passed with the 'in' keyword</source>
        <target state="translated">引數應該以 'in' 的關鍵字傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn">
        <source>Argument {0} should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">引數 {0} 應該以 'ref' 或 'in' 的關鍵字傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn_Title">
        <source>Argument should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">引數應該以 'ref' 或 'in' 的關鍵字傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">無法在此內容中使用類型 '{0}'，因為它無法在中繼資料中表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed_Title">
        <source>Type cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">無法在此內容中使用類型，因為它無法在中繼資料中表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef">
        <source>The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">對應至 'in' 參數之引數 {0} 的 'ref' 修飾元相當於 'in'。請考慮改為使用 'in'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef_Title">
        <source>The 'ref' modifier for an argument corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">對應至 'in' 參數之引數的 'ref' 修飾元相當於 'in'。請考慮改為使用 'in'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">必須指定屬性參數 'SizeConst'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired_Title">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">必須指定屬性參數 'SizeConst'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing">
        <source>This combination of arguments to '{0}' may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">對 '{0}' 使用此引數組合，會在其宣告範圍外公開參數 '{1}' 所參考的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing_Title">
        <source>This combination of arguments may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">此引數組合會在其宣告範圍外公開參數所參考的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果。它套用了不正確的參數名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
        <source>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</source>
        <target state="translated">CallerArgumentExpressionAttribute 套用了不正確的參數名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果，因為它是自我參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
        <source>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</source>
        <target state="translated">套用到參數的 CallerArgumentExpressionAttribute 將沒有效果，因為它是自我參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果，因為它套用了不允許選擇性引數的內容中所使用之成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerArgumentExpressionAttribute 將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果，CallerFilePathAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute 將沒有效果; CallerFilePathAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果，CallerLineNumberAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute 將沒有效果; CallerLineNumberAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerArgumentExpressionAttribute 將沒有效果，CallerMemberNameAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute 將沒有效果; CallerMemberNameAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">參數 '{0}' 會擷取為封閉類型的狀態，其值也可用來初始化欄位、屬性或事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">參數會擷取為封閉類型的狀態，其值也可用來初始化欄位、屬性或事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">參數 '{0}' 會擷取至包含類型的狀態，且其值也會傳遞給基礎建構函式。值也可能由基礎類別擷取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">參數會擷取至包含類型的狀態，且其值也會傳遞給基礎建構函式。值也可能由基礎類別擷取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">類型 '{0}' 的集合運算式可能會產生未預期的堆積配置。請考慮明確地建立陣列，然後轉換為 '{0}' 以使配置明確化。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">集合運算式可能會產生未預期的堆積配置。請考慮明確地建立陣列，然後轉換為最後類型以使配置明確化。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">類型 '{0}' 的集合運算式可能會因使用了 '..' 擴張而產生未預期的堆積配置。請考慮明確地建立陣列，然後轉換為 '{0}' 以使配置明確化。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations due to use of '..' spreads. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">集合運算式可能會因使用了 '..' 擴張而產生未預期的堆積配置。請考慮明確地建立陣列，然後轉換為最後類型以使配置明確化。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow">
        <source>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">作業在執行階段可能會溢位 '{0}' (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow_Title">
        <source>The operation may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">作業在執行階段可能會溢位 (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">型別 'System.Threading.Lock' 轉換為不同型別的值，在 'lock' 陳述式中可能會使用非預期的監視器型鎖定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock_Title">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">型別 'System.Threading.Lock' 轉換為不同型別的值，在 'lock' 陳述式中可能會使用非預期的監視器型鎖定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers">
        <source>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</source>
        <target state="translated">因為同一個函式的指標可能截然不同，所以比較函式指標可能會產生非預期的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers_Title">
        <source>Do not compare function pointer values</source>
        <target state="translated">不要比較函式指標值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference">
        <source>Analyzer reference '{0}' specified multiple times</source>
        <target state="translated">已指定多次分析器參考 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference_Title">
        <source>Analyzer reference specified multiple times</source>
        <target state="translated">已指定多次分析器參考</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall">
        <source>Use of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">在此內容中使用 '{0}' 的結果，可能會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2">
        <source>Use of member of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">此內容中使用 '{0}' 的結果成員，可能會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2_Title">
        <source>Use of member of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用結果的成員，因為它會將參數參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall_Title">
        <source>Use of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">在此內容中使用結果，可能會將參數參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</source>
        <target state="translated">此內容中類型 '{0}' 的 stackalloc 運算式結果可能會公開在包含方法之外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc_Title">
        <source>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</source>
        <target state="translated">此內容中此類型的 stackalloc 運算式結果可能會公開在包含方法之外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable">
        <source>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">在此內容中使用變數 '{0}'，可能會將參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable_Title">
        <source>Use of variable in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">在此內容中使用變數，可能會將參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">內嵌陣列轉換運算子不會用於從宣告類型的運算式進行轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed_Title">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">內嵌陣列轉換運算子不會用於從宣告類型的運算式進行轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">內嵌陣列索引子不會用於元素存取運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed_Title">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">內嵌陣列索引子不會用於元素存取運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">作為無效類型參數或具有作為無效類型參數之元素類型的内嵌陣列類型，都不支援「内嵌陣列」語言功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage_Title">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">作為無效類型參數或具有作為無效類型參數之元素類型的内嵌陣列類型，都不支援「内嵌陣列」語言功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">內嵌陣列 'Slice' 方法不會用於元素存取運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed_Title">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">內嵌陣列 'Slice' 方法不會用於元素存取運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.</source>
        <target state="translated">參數 '{0}' 的參考種類修飾元不符合隱藏成員中的對應參數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in hidden member.</source>
        <target state="translated">參數的參考種類修飾元不符合隱藏成員中的對應參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch">
        <source>Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.</source>
        <target state="translated">正在使用攔截器 '{1}' 攔截對 '{0}' 的呼叫，但簽章不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch_Title">
        <source>Signatures of interceptable and interceptor methods do not match.</source>
        <target state="translated">可攔截與攔截器方法的簽章不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">InterpolatedStringHandlerArgument 在套用至 Lambda 參數時沒有效果，將於呼叫網站忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">InterpolatedStringHandlerArgument 在套用至 Lambda 參數時沒有效果，將於呼叫網站忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName">
        <source>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">類型名稱 '{0}' 只包含小寫的 ASCII 字元。此類名稱可能保留供此語言使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName_Title">
        <source>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">類型名稱只包含小寫的 ASCII 字元。此類名稱可能保留供此語言使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</source>
        <target state="translated">這會取得 Managed 類型 ('{0}') 的位址、大小，或宣告指向它的指標</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr_Title">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type</source>
        <target state="translated">這會取得 Managed 類型的位址、大小，或宣告指向它的指標</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel">
        <source>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">將方法群組 '{0}' 轉換成非委派類型 '{1}'。原本希望叫用該方法嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel_Title">
        <source>Converting method group to non-delegate type</source>
        <target state="translated">將方法群組轉換為非委派類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ref 條件運算子的分支參考具有不相容宣告範圍的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary_Title">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ref 條件運算子的分支參考具有不相容宣告範圍的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.</source>
        <target state="translated">參數 '{0}' 類型中參考類型的可為 Null 性與攔截的方法 '{1}' 不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor_Title">
        <source>Nullability of reference types in type of parameter doesn't match interceptable method.</source>
        <target state="translated">參數類型中參考類型的可為 Null 性與攔截的方法不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor">
        <source>Nullability of reference types in return type doesn't match interceptable method '{0}'.</source>
        <target state="translated">傳回類型中參考類型的可為 Null 性與攔截的方法 '{0}'.不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor_Title">
        <source>Nullability of reference types in return type doesn't match interceptable method.</source>
        <target state="translated">傳回類型中參考類型的可為 Null 性與攔截的方法不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired">
        <source>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">除非包含的類型已過時或所有建構函式已過時，否則必要成員 '{0}' 的屬性不應為 'ObsoleteAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired_Title">
        <source>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">除非包含的類型已過時或所有建構函式已過時，否則不應要求具有 'ObsoleteAttribute' 屬性的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch">
        <source>Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.</source>
        <target state="translated">參數 {0} 在 Lambda 中的預設值為 '{1:10}'，但在目標委派類型中為 '{2:10}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch_Title">
        <source>The default parameter value does not match in the target delegate type.</source>
        <target state="translated">目標委派類型中的預設參數值不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.</source>
        <target state="translated">參數 '{0}' 的參考種類修飾元不符合已覆寫或已實作成員中的對應參數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in overridden or implemented member.</source>
        <target state="translated">參數的參考種類修飾元不符合已覆寫或已實作成員中的對應參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull">
        <source>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</source>
        <target state="translated">因為參數 '{1}' 不是 null，所以參數 '{0}' 在結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull_Title">
        <source>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</source>
        <target state="translated">因為 NotNullIfNotNull 所參考的參數不是 null，所以參數在結束時必須有非 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
        <source>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.</source>
        <target state="translated">參數 {0} 發生在參數清單中 {1} 之後，但卻用為差補字串處理常式轉換的引數。這會要求呼叫者在呼叫網站使用具名引數重新排列參數。請考慮將差補字串處理常式參數置於所有相關的引數後面。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
        <source>Parameter to interpolated string handler conversion occurs after handler parameter</source>
        <target state="translated">差補字串處理常式轉換的參數會在處理常式參數後發生</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly">
        <source>Parameter {0} has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">參數 {0} 在 Lambda 中具有參數修飾元，但不在目標委派類型中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly_Title">
        <source>Parameter has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">參數在 Lambda 中具有參數修飾元，但不在目標委派類型中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialPropertySignatureDifference">
        <source>Partial property declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">部分屬性宣告 '{0}' 和 '{1}' 有簽章差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialPropertySignatureDifference_Title">
        <source>Partial property declarations have signature differences.</source>
        <target state="translated">部分屬性宣告有簽章差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase">
        <source>Primary constructor parameter '{0}' is shadowed by a member from base.</source>
        <target state="translated">主要建構函式參數 '{0}' 會伴隨著來自基底的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase_Title">
        <source>Primary constructor parameter is shadowed by a member from base</source>
        <target state="translated">主要建構函式參數會伴隨著來自基底的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode">
        <source>'{0}' defines 'Equals' but not 'GetHashCode'</source>
        <target state="translated">'{0}' 會定義 'Equals' 而非 'GetHashCode'</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode_Title">
        <source>Record defines 'Equals' but not 'GetHashCode'.</source>
        <target state="translated">記錄會定義 'Equals' 而非 'GetHashCode'。</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
        <source>Mixed declarations and expressions in deconstruction</source>
        <target state="translated">解構中的混合宣告與運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference">
        <source>Partial method declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">部分方法宣告 '{0}' 和 '{1}' 有簽章差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference_Title">
        <source>Partial method declarations have signature differences.</source>
        <target state="translated">部分方法宣告有簽章差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">類型與別名不應命名為 'record'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed_Title">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">類型與別名不應命名為 'record'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">此參考指派 '{1}' 至 '{0}'，但 '{1}' 的逸出範圍比 '{0}' 還要窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower_Title">
        <source>This ref-assigns a value that has a narrower escape scope than the target.</source>
        <target state="translated">此參考指派的值比目標的逸出範圍更窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">此參考指派 '{1}' 至 '{0}'，但 '{1}' 只能透過 return 陳述式逸出目前的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly_Title">
        <source>This ref-assigns a value that can only escape the current method through a return statement.</source>
        <target state="translated">此參考指派的值只能透過 return 陳述式逸出目前的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">此參考指派 '{1}' 給 '{0}' 但 '{1}' 具有比 '{0}' 更寬的值逸出範圍，允許透過 '{0}' 的值指派，其逸出範圍比 '{1}' 更窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider_Title">
        <source>This ref-assigns a value that has a wider value escape scope than the target allowing assignment through the target of values with narrower escapes scopes.</source>
        <target state="translated">此參考指派的值比目標的逸出範圍更寬，允許透過目標的值指派，其逸出範圍更窄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable">
        <source>Argument {0} should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">引數 {0} 應為變數，因為它會傳遞至 'ref readonly' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable_Title">
        <source>Argument should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">引數應為變數，因為它會傳遞至 'ref readonly' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue">
        <source>A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">已為 'ref readonly' 參數指定預設值 '{0}'，但 'ref readonly' 應只用於參考。請考慮將參數宣告為 'in'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue_Title">
        <source>A default value is specified for 'ref readonly' parameter, but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">已為 'ref readonly' 參數指定預設值，但 'ref readonly' 應只用於參考。請考慮將參數宣告為 'in'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal">
        <source>This returns local '{0}' by reference but it is not a ref local</source>
        <target state="translated">這會藉傳址方式傳回本機 '{0}'，但其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2">
        <source>This returns a member of local '{0}' by reference but it is not a ref local</source>
        <target state="translated">這會藉傳址方式傳回本機 '{0}' 的成員，但其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2_Title">
        <source>This returns a member of local by reference but it is not a ref local</source>
        <target state="translated">這會藉傳址方式傳回本機的成員，但其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal_Title">
        <source>This returns local by reference but it is not a ref local</source>
        <target state="translated">這會藉傳址方式傳回本機，但其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal">
        <source>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">藉傳址方式傳回本機 '{0}'，但已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2">
        <source>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">藉傳址方式傳回 '{0}' 的成員，但已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2_Title">
        <source>A member is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">藉傳址方式傳回成員，但已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal_Title">
        <source>Local is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">藉傳址方式傳回本機，但已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter">
        <source>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">這會透過 ref 參數藉傳址 '{0}' 傳回參數; 但是只能在 return 陳述式中安全地傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2">
        <source>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">這會透過 ref 參數藉傳址方式傳回參數 '{0}' 的成員; 但是只能在 return 陳述式中安全地傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2_Title">
        <source>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">這會透過 ref 參數藉傳址方式傳回參數的成員; 但是只能在 return 陳述式中安全地傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter_Title">
        <source>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">這會透過 ref 參數藉傳址方式傳回參數; 但是只能在 return 陳述式中安全地傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter">
        <source>This returns a parameter by reference '{0}' but it is not a ref parameter</source>
        <target state="translated">這會藉傳址方式 '{0}' 傳回參數，但其非 ref 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2">
        <source>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</source>
        <target state="translated">這會藉傳址方式傳回參數 '{0}' 的成員，其不是 ref 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2_Title">
        <source>This returns by reference a member of parameter that is not a ref or out parameter</source>
        <target state="translated">這會藉傳址方式傳回參數的成員，其不是 ref 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter_Title">
        <source>This returns a parameter by reference but it is not a ref parameter</source>
        <target state="translated">這會藉傳址方式傳回參數，但其非 ref 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter">
        <source>This returns a parameter by reference '{0}' but it is scoped to the current method</source>
        <target state="translated">這會藉傳址 '{0}' 傳回參數，但範圍限於目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2">
        <source>This returns by reference a member of parameter '{0}' that is scoped to the current method</source>
        <target state="translated">這會藉傳址方式傳回參數 '{0}' 的成員，其範圍是目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2_Title">
        <source>This returns by reference a member of parameter that is scoped to the current method</source>
        <target state="translated">這會藉傳址方式傳回參數的成員，其範圍是目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter_Title">
        <source>This returns a parameter by reference but it is scoped to the current method</source>
        <target state="translated">這會藉傳址方式傳回參數，但範圍限於目前的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">結構成員藉傳址方式傳回 'this' 或其他執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis_Title">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">結構成員藉傳址方式傳回 'this' 或其他執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull">
        <source>Return value must be non-null because parameter '{0}' is non-null.</source>
        <target state="translated">因為參數 '{0}' 不是 null，所以傳回值必須非 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull_Title">
        <source>Return value must be non-null because parameter is non-null.</source>
        <target state="translated">因為參數不是 null，所以傳回值必須非 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">參數 '{0}' 的 'scoped' 修飾元不符合覆寫或實作的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
        <source>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</source>
        <target state="translated">參數的 'scoped' 修飾元不符合覆寫或實作的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">參數 '{0}' 的 'scoped' 修飾元不符合目標 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget_Title">
        <source>The 'scoped' modifier of parameter doesn't match target.</source>
        <target state="translated">參數的 'scoped' 修飾元不符合目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</source>
        <target state="translated">遇到未命名的列舉值時，switch 運算式不會處理其輸入類型的某些值 (未徹底處理)。例如，未涵蓋模式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</source>
        <target state="translated">遇到未命名的列舉值時，switch 運算式不會處理其輸入類型的某些值 (未徹底處理)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SyncAndAsyncEntryPoints">
        <source>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</source>
        <target state="translated">因為找到同步進入點 '{1}'，所以方法 '{0}' 無法作為進入點。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotFound">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">類型 '{0}' 未定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentList">
        <source>Unexpected argument list.</source>
        <target state="translated">未預期的引數清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedOrMissingConstructorInitializerInRecord">
        <source>A constructor declared in a type with parameter list must have 'this' constructor initializer.</source>
        <target state="translated">在類型中宣告、具有參數清單的建構函式，必須具有 'this' 建構函式初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVarianceStaticMember">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</source>
        <target state="translated">變異數無效: 除非使用語言版本 '{4}' 或更高版本，否則型別參數 '{1}' 在 '{0}' 上須為 {3} 有效。'{1}' 是 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">'{0}': 不可在指定條件約束類型的同時，又指定 'unmanaged' 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
        <source>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</source>
        <target state="translated">使用 'UnmanagedCallersOnly' 屬性化的方法不能具有泛型型別參數，而且不能在泛型型別中宣告。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyRequiresStatic">
        <source>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</source>
        <target state="translated">'UnmanagedCallersOnly' 僅適用於一般靜態非抽象方法、非虛擬方法或靜態區域函式。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 及任何巢狀層級的所有欄位必須是不可為 null 的值類型，如此才能在泛型型別或方法 '{0}' 中將其用為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCallingConvention">
        <source>The calling convention of '{0}' is not supported by the language.</source>
        <target state="translated">語言不支援 '{0}' 的呼叫慣例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForRelationalPattern">
        <source>Relational patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">類型 '{0}' 的值不可使用關聯性模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">不可直接在 switch 區段內使用 using 變數 (建議使用大括弧)。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">不允許模式的語法 'var' 參考類型，但 '{0}' 在此處的範圍中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">無法在有 'in' 或 'out' 型別參數的介面中宣告列舉、類別和結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongFuncPtrCallingConvention">
        <source>Calling convention of '{0}' is not compatible with '{1}'.</source>
        <target state="translated">'{0}' 的呼叫慣例與 '{1}' 不相容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">需要 '{1}' 子模式才能比對元組類型 '{0}'，但此處為 '{2}' 子模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">檔案名稱 '{0}' 是空的、包含了無效字元、指定了磁碟機但不是絕對路徑，或太長了</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AddressOfMethodGroup">
        <source>&amp;method group</source>
        <target state="translated">方法群組(&amp;M)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0 or higher) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.
-skipanalyzers[+|-]           Skip execution of diagnostic analyzers.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
-generatedfilesout:&lt;dir&gt;      Place files generated during compilation in the
                              specified directory.
-reportivts[+|-]                    Output information on all IVTs granted to this
                              assembly by all dependencies, and annotate foreign assembly
                              accessibility errors with what assembly they came from.
</source>
        <target state="translated">
                            Visual C# 編譯器選項

                      - OUTPUT FILES -
-out:&lt;file&gt;                   指定輸出檔案名稱 (預設: 
                             具有主要類別或第一個檔案的檔案基礎名稱)
-target:exe                   建置主控台可執行檔 (預設) (簡短
                             形式: -t:exe)
-target:winexe                建置 Windows 可執行檔 (簡短形式:
                             -t:winexe)
-target:library               建置程式庫 (簡短形式: -t:library)
-target:module                建置可以新增至其他
                             組件的模組 (簡短形式: -t:module)
-target:appcontainerexe       建置 Appcontainer 可執行檔 (簡短形式:
                             -t:appcontainerexe)
-target:winmdobj              建置由 WinMDExp 取用
                             的 Windows 執行階段中繼檔案 (簡短形式: -t:winmdobj)
-doc:&lt;file&gt;                   要產生的 XML 文件檔案
-refout:&lt;file&gt;                要產生的參考組件輸出
-platform:&lt;string&gt;             限制此程式碼可在哪些平台上執行: x86、
                             Itanium、x64、arm、arm64、anycpu32bitpreferred 或
                             anycpu。預設為 anycpu。

                      - INPUT FILES -
-recurse:&lt;wildcard&gt;               根據萬用字元
                             規格
                             包含目前目錄和子目錄中的所有檔案
-reference:&lt;alias&gt;=&lt;file&gt;     從指定的組件
                             檔使用指定的別名來參考中繼資料 (簡短形式: -r)
-reference:&lt;file list&gt;        從指定的組件檔
                             來參考中繼資料 (簡短形式: -r)
-addmodule:&lt;file list&gt;        將指定的模組連結至此組件中
-link:&lt;file list&gt;             從指定的 Interop
                             組件檔來內嵌中繼資料 (簡短形式: -l)
-analyzer:&lt;file list&gt;         從此組件執行分析器
                             (簡短形式: -a)
-additionalfile:&lt;file list&gt;   不會直接影響程式碼
                             產生但可由分析器用來產生錯誤或警告
                             的其他檔案。
-embed                        在 PDB 中内嵌所有來源檔案。
-embed:&lt;file list&gt;            在 PDB 中内嵌特定檔案。

                      - RESOURCES -
-win32res:&lt;file&gt;              指定 Win32 資源檔 (.res)
-win32icon:&lt;file&gt;             使用此圖示來進行輸出
-win32manifest:&lt;file&gt;         指定 Win32 資訊清單檔 (.xml)
-nowin32manifest              不要包含預設的 Win32 資訊清單
-resource:&lt;resinfo&gt;           嵌入指定的資源 (簡短形式: -res)
-linkresource:&lt;resinfo&gt;       將指定的資源連結到此組件
                             (簡短形式: -linkres) 其中 resinfo 格式
                             為 &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                      - CODE GENERATION -
-debug[+|-]                   發出偵錯資訊
-debug:{full|pdbonly|portable|embedded}
                             指定偵錯類型 ('full' 為預設，
                             'portable' 是跨平台格式，
                             'embedded' 是內嵌至
                             目標 .dll 或 .exe 中的跨平台格式)
-optimize[+|-]                啟用最佳化 (簡短形式: -o)
-deterministic                產生具決定性組件
                             (包括模組版本 GUID 和時間戳記)
-refonly                      產生參考組件，以取代主要輸出
strument:TestCoverage      產生檢測要收集
                             涵蓋範圍資訊的組件
-sourcelink:&lt;file&gt;            要內嵌至 PDB 中的來源連結資訊。

                      - ERRORS AND WARNINGS -
-warnaserror[+|-]             將所有警告回報為錯誤
-warnaserror[+|-]:&lt;warn list&gt; 將特定的警告回報為錯誤
                             (針對所有可為 Null 的警告使用 "nullable")
-warn:&lt;n&gt;                     設定警告層級 (0 或更高) (簡短形式: -w)
-nowarn:&lt;warn list&gt;           停用特定的警告訊息
                             (針對所有可為 Null 的警告使用 "nullable")
-ruleset:&lt;file&gt;               指定會停用特定
                             診斷的規則集檔案。
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                             指定用來記錄所有編譯器和分析器
                             診斷的檔案。
                             sarif_version:{1|2|2.1} 預設為1. 2 和 2.1，
                             都表示 SARIF 版本 2.1.0。
-reportanalyzer               回報其他分析器資訊，例如
                             執行時間。
-skipanalyzers[+|-]           略過診斷分析器的執行。

                      - LANGUAGE -
-checked[+|-]                 產生溢位檢查
-unsafe[+|-]                  允許 'unsafe' 程式碼
-define:&lt;symbol list&gt;         定義條件式編譯符號 (簡短
                             形式: -d)
-langversion:?              顯示語言版本的允許值
-langversion:&lt;string&gt;         指定語言版本，例如
                             `latest` (最新版本，包括次要版本)，
                             'default' (與 'latest' 相同)，
                             `latestmajor` (最新版本，排除次要版本)，
                             'preview' (最新版本，包括不支援預覽中的功能)，
                             或特定版本，例如 `6` 或 `7.1`
-nullable[+|-]                指定可為 Null 內容選項啟用|停用。
-nullable:{enable|disable|warnings|annotations}
                             指定可為 Null 內容選項啟用|停用|警告|註釋。

                      - SECURITY -
-delaysign[+|-]               只使用強式名稱金鑰的公開
                             部分對組件進行延遲簽屬
-publicsign[+|-]              只使用強式名稱金鑰的公開
                             部分對組件進行公開簽屬
-keyfile:&lt;file&gt;               指定強式名稱金鑰檔案
-keycontainer:&lt;string&gt;        指定強式名稱金鑰容器
-highentropyva[+|-]           啟用高熵 ASLR

                      - MISCELLANEOUS -
@&lt;file&gt;                       讀取回應檔以取得更多選項
-help                         顯示此使用方式訊息 (簡短形式 form: -?)
-nologo                       隱藏編譯器著作權訊息
-noconfig                     不要自動包括 CSC.RSP 檔案
-parallel[+|-]                同時建置。
-version                      顯示編譯器版本號碼並結束。

                      - ADVANCED -
-baseaddress:&lt;address&gt;        要建置程式庫的基底位址
-checksumalgorithm:&lt;alg&gt;      指定計算儲存在 PDB 中
                             來源檔案總和檢查碼的演算法。支援的值為: 
                             SHA1 或 SHA256 (預設)。
-codepage:&lt;n&gt;                 指定開啟來源
                             檔案時所要使用的字碼頁
-utf8output                   輸出編譯器訊息 (以 UTF-8 編碼)
-main:&lt;type&gt;                  指定包含進入點的類型
                             (略過所有其他可能的進入點) (簡短
                             形式: -m)
-fullpaths                    編譯器會產生完整路徑
-filealign:&lt;n&gt;                指定用於輸出檔案
                             區段的對齊
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                             指定編譯器的來源路徑名稱輸出的對應
                             。
-pdb:&lt;file&gt;                   指定偵錯資訊檔案名稱 (預設:
                             具有 .pdb 副檔名的輸出檔案名稱)
-errorendlocation             輸出每個錯誤
                             行與資料行的結束位置
-preferreduilang              指定喜好的輸出語言名稱。
-nosdkpath                    停用搜尋標準程式庫組件的預設 SDK 路徑。
-nostdlib[+|-]                不參考標準程式庫 (mscorlib.dll)
-subsystemversion:&lt;string&gt;    指定此組件的子系統版本
-lib:&lt;file list&gt;              指定要在其中搜尋的其他目錄以作為
                             參考
-errorreport:&lt;string&gt;         指定如何處理內部編譯器錯誤:
                             提示、傳送、佇列或無。預設為
                             佇列。
-appconfig:&lt;file&gt;             指定包含組件繫結設定的
                             應用程式設定檔
-moduleassemblyname:&lt;string&gt;  此模組將成為其一部分
                             的組件名稱
-modulename:&lt;string&gt;          指定來源模組的名稱
-generatedfilesout:&lt;dir&gt;      將編譯期間產生的檔案放在
                             指定的目錄。
-reportivts[+|-]                    輸出有關所有相依項授與至此
                             組件的所有 IVT 的資訊，並使用它們來自的組件
                             標註外部組件的可存取性錯誤。
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">預設介面實作</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">可處置</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">插入的逐字替代字串</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAndPattern">
        <source>and pattern</source>
        <target state="translated">and 樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">非同步 using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">聯合指派</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureConstantInterpolatedStrings">
        <source>constant interpolated strings</source>
        <target state="translated">常數差補字串</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultTypeParameterConstraint">
        <source>default type parameter constraints</source>
        <target state="translated">預設型別參數條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">委派泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">列舉泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">成員初始設定式及查詢中之運算式變數的宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPartialMethods">
        <source>extended partial methods</source>
        <target state="translated">擴充部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">可延伸 fixed 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetAsyncEnumerator">
        <source>extension GetAsyncEnumerator</source>
        <target state="translated">延伸模組 GetAsyncEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetEnumerator">
        <source>extension GetEnumerator</source>
        <target state="translated">延伸模組 GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="translated">外部區域函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFunctionPointers">
        <source>function pointers</source>
        <target state="translated">函式指標</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">索引運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">對可移動的固定緩衝區編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInitOnlySetters">
        <source>init-only setters</source>
        <target state="translated">僅供初始化 Setter</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="translated">區域函式屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">lambda 捨棄參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureMemberNotNull">
        <source>MemberNotNull attribute</source>
        <target state="translated">MemberNotNull 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleInitializers">
        <source>module initializers</source>
        <target state="translated">模組初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">巢狀函式中的名稱鏡像處理</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNativeInt">
        <source>native-sized integers</source>
        <target state="translated">原生大小整數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">巢狀運算式中的 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">notnull 泛型型別限制式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotPattern">
        <source>not pattern</source>
        <target state="translated">not 樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPointerConstantPattern">
        <source>null pointer constant pattern</source>
        <target state="translated">Null 指標常數模式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">可為 Null 的參考型別</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">在屬性存取子上淘汰</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOrPattern">
        <source>or pattern</source>
        <target state="translated">or 樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParenthesizedPattern">
        <source>parenthesized pattern</source>
        <target state="translated">括弧樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">警告動作 enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">範圍運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">唯讀成員</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecords">
        <source>records</source>
        <target state="translated">記錄</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">遞迴模式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">參考條件運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">參考 for 迴圈變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">參考 foreach 反覆運算變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">參考重新指派</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelationalPattern">
        <source>relational pattern</source>
        <target state="translated">關聯性樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">stackalloc 初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAnonymousFunction">
        <source>static anonymous function</source>
        <target state="translated">靜態匿名函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">靜態區域函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;切換運算式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTargetTypedConditional">
        <source>target-typed conditional expression</source>
        <target state="translated">目標型別條件運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">元組相等</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypePattern">
        <source>type pattern</source>
        <target state="translated">類型樣式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">Null 聯合運算子中的非限制式型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">非受控建構的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">Unmanaged 泛型類型條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">using 宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
        <source>variance safety for static interface members</source>
        <target state="translated">靜態介面成員的變異數安全性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">適用於覆寫和明確介面實作方法的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Parameter">
        <source>parameter</source>
        <target state="translated">參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Return">
        <source>return</source>
        <target state="translated">傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;throw 運算式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(與之前錯誤相關符號的位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(與之前警告相關符號的位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TopLevelStatements">
        <source>top-level statements</source>
        <target state="translated">最上層陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> 無法納入格式錯誤的 XML 檔 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> 無法插入某些或所有 include 的 XML </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Include 標籤無效 </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> 找不到與下列 include 標籤相符的項目 </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">遺漏檔案屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">遺漏路徑屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;全域命名空間&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">泛型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">匿名方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">模組做為屬性目標規範</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">命名空間別名限定詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">固定大小緩衝區</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">靜態類別</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">唯讀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">部分類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">非同步函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">布林類型的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">方法群組</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">匿名方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">Lambda 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">集合</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">屬性的存取修飾詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">迭代器</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">預設運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">預設常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">可為 Null 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">模式比對</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">運算式主體屬性存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">運算式主體建構函式及解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">Throw 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">隱含類型陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">隱含類型區域變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">匿名類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">自動實作的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">自動實作的唯讀屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">物件初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">集合初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">類型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">命名空間</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">元素</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">事件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">使用別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">foreach 反覆運算變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">固定變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">使用變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">contravariant</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">以 Contravariant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">Covariant</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">以 Covariant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">非 Variant 方式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">動態</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">具名引數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">選擇性參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">例外狀況篩選條件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">類型變異數</target>
        <note />
      </trans-unit>
      <trans-unit id="NotSameNumberParameterTypesAndRefKinds">
        <source>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</source>
        <target state="translated">指定的 {0} 參數類型和 {1} 參數參考種類。這些陣列的長度必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutIsNotValidForReturn">
        <source>'RefKind.Out' is not a valid ref kind for a return type.</source>
        <target state="translated">'RefKind.Out' 對傳回型別而言，不是有效的參考類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">SyntaxTree 不屬於編譯的一部份</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">因為 SyntaxTree 不屬於編譯的一部份，所以無法將其移除</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">名稱 '_' 參考常數而非捨棄模式。請使用 'var _' 來捨棄值，或使用 '@_' 來依該名稱參考常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">不可對 case 常數使用 '_'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked">
        <source>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">常數值 '{0}' 在執行階段可能會使 '{1}' 溢位 (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked_Title">
        <source>Constant value may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">常數值在執行階段可能會溢位 (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">正在將 Null 常值或可能的 Null 值轉換為不可為 Null 的型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">正在將 Null 常值或可能的 Null 值轉換為不可為 Null 的型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">可能的 Null 值不能用於標有 [NotNull] 或 [DisallowNull] 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">可能的 Null 值不能用於標有 [NotNull] 或 [DisallowNull] 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">方法 '{0}' 缺少 `[DoesNotReturn]` 註釋，與實作或覆寫的成員不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">方法缺少 `[DoesNotReturn]` 註釋，與實作或覆寫的成員不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">'{0}' 已列在類型 '{1}' 上的介面清單中，並具有不同的參考類型可 NULL 性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">介面已列在介面清單中，並具有不同的參考類型可 NULL 性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">產生器 '{0}' 無法產生來源。其不會提供給輸出，並可能導致編譯錯誤。例外狀況的類型為 '{1}'，訊息為 '{2}'。
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">產生器無法產生來源。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">產生器 '{0}' 無法初始化。其不會提供給輸出，並可能導致編譯錯誤。例外狀況的類型為 '{1}'，訊息為 '{2}'。
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">產生器無法初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定的運算式永遠符合提供的常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定的運算式永遠符合提供的常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">指定的運算式一律不比對提供的樣式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern_Title">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">指定的運算式一律不比對提供的樣式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定的運算式永遠不符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定的運算式永遠不符合提供的模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">從 'readonly' 成員呼叫非 readonly 成員 '{0}' 會產生 '{1}' 的隱含複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">從 'readonly' 成員呼叫非 readonly 成員會產生隱含複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways">
        <source>An expression of type '{0}' always matches the provided pattern.</source>
        <target state="translated">類型為 '{0}' 的運算式必須比對提供的樣式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways_Title">
        <source>The input always matches the provided pattern.</source>
        <target state="translated">輸入必須比對提供的樣式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">名稱 '_' 參考類型 '{0}'，而非捨棄模式。請為類型使用 '@_'，或使用 'var _' 捨棄。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">請勿使用 '_' 參考 is-type 運算式中的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull">
        <source>Member '{0}' must have a non-null value when exiting.</source>
        <target state="translated">成員 '{0}' 在結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember">
        <source>Member '{0}' cannot be used in this attribute.</source>
        <target state="translated">成員 '{0}' 不可用於此屬性中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember_Title">
        <source>Member cannot be used in this attribute.</source>
        <target state="translated">成員不可用於此屬性中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen">
        <source>Member '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">成員 '{0}' 在以 '{1}' 結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen_Title">
        <source>Member must have a non-null value when exiting in some condition.</source>
        <target state="translated">成員在某些條件下結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull_Title">
        <source>Member must have a non-null value when exiting.</source>
        <target state="translated">成員在結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">可為 Null 的參考型別註釋應只用於 '#nullable' 註釋內容中的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">因為可為 null 之參考型別的註釋應只於 '#nullable' 註釋內容的程式碼中使用。自動產生的的程式碼需要來源中的明確 '#nullable' 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">因為可為 null 之參考型別的註釋應只於 '#nullable' 註釋內容的程式碼中使用。自動產生的的程式碼需要來源中的明確 '#nullable' 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">可為 Null 的參考型別註釋應只用於 '#nullable' 註釋內容中的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">無法將 null 常值轉換成不可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">無法將 null 常值轉換成不可為 Null 的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">'{1}' 中的參數 '{0}' 可能有 Null 參考引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">可能有 Null 參考引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">可能有 Null 參考指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">可能有 Null 參考指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">物件或集合初始設定式意味會解除參考可能的 null 成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">物件或集合初始設定式意味會解除參考可能為 null 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">可能 null 參考的取值 (dereference)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">可能 null 參考的取值 (dereference)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">可能有 Null 參考傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">可能有 Null 參考傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以無法針對 '{3}' 內類型 '{1}' 的參數 '{2}' 使用類型 '{0}' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以無法將類型 '{0}' 的引數用作 '{3}' 中參數 '{2}' 的類型 '{1}' 輸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以引數無法用作參數的輸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">因為參考型別的可 NULL 性有所差異，所以引數無法用於參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">型別 '{0}' 的值中參考型別可 Null 性與目標型別 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">值中參考型別的可 Null 性與目標型別不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">方法 '{1}' 的型別參數 '{0}' 條件約束可 Null 性與介面方法 '{3}' 的型別參數 '{2}' 條件約束不符合。請考慮改用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">方法的型別參數條件約束與介面方法的型別參數條件約束不符合。請考慮改用隱含的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' 的部分方法宣告在類型參數 '{1}' 的限制式中，有不一致的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">部分方法宣告在類型參數的限制式中，有不一致的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明確介面指定名稱中參考類型可 NULL 性與類型所實作的介面不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明確介面指定名稱中參考類型可 NULL 性與類型所實作的介面不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。基底類型所實作之介面中的參考類型可 NULL 性不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">類型未實作介面成員。基底類型所實作之介面中的參考類型可 NULL 性不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">'{1}' 的 '{0}' 參數類型中，參考型別是否可為 Null 的情況，與目標委派 '{2}' 不相符 (可能的原因是屬性可為 Null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">參數類型中參考型別是否可為 Null 的情況，與目標委派不相符 (可能的原因是屬性可為 Null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">參數 '{1}' 之 '{0}' 型別中參考型別的可 Null 性與隱含實作的成員 '{2}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">參數 '{0}' 型別中參考型別的可 Null 性與部分方法宣告不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">參數型別中參考型別的可 Null 性與部分方法宣告不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別 '{0}' 中參考型別是否可為 Null 的情況，與目標委派 '{1}' 不相符 (可能的原因是屬性可為 Null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別中參考型別是否可為 Null 的情況，與目標委派不相符 (可能的原因是屬性可為 Null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與實作的成員 '{0}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">傳回型別 '{0}' 中參考型別的可 Null 性與隱含實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與部分方法宣告不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">傳回型別中參考型別的可 Null 性與部分方法宣告不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">型別中參考型別的可 Null 性與實作的成員 '{0}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">型別中參考型別的可 Null 性與實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' 的型別中參考型別的可 Null 性與隱含實作的成員 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">型別中參考型別的可 Null 性與隱含實作的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型別中參考型別的可 Null 性與覆寫的成員不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">型別 '{3}' 無法作為型別參數 '{2}' 用於泛型型別或方法 '{0}' 中。型別引數 '{3}' 的可 Null 性與條件約束型別 '{1}' 不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與條件約束型別不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">型別 '{2}' 無法作為型別參數 '{1}' 用於泛型型別或方法 '{0}' 中。型別引數 '{2}' 的可 Null 性與 'notnull' 限制式不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與 'notnull' 限制式不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">型別 '{2}' 無法作為型別參數 '{1}' 用於泛型型別或方法 '{0}' 中。型別引數 '{2}' 的可 Null 性與 'class' 條件約束不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">型別無法作為型別參數用於泛型型別或方法中。型別引數的可 Null 性與 'class' 條件約束不符合。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">可為 Null 的實值型別可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">可為 Null 的實值型別可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">在程式控制權脫離目前的方法之前，必須指派 out 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned_Title">
        <source>An out parameter must be assigned to before control leaves the method</source>
        <target state="translated">在控制權離開方法之前，必須指派 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">參數 '{0}' 在以 '{1}' 結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting in some condition.</source>
        <target state="translated">參數在某些條件下結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting.</source>
        <target state="translated">參數 '{0}' 在結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting.</source>
        <target state="translated">參數在結束時必須具有非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': 靜態類型不可用做為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass_Title">
        <source>Static types cannot be used as parameters</source>
        <target state="translated">靜態類型不可用作參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion">
        <source>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</source>
        <target state="translated">因為受限於優先順序，所以無法在此使用運算子 '{0}'。請使用括弧消除歧義。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion_Title">
        <source>Operator cannot be used here due to precedence.</source>
        <target state="translated">因為受限於優先順序，所以無法在此使用運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</source>
        <target state="translated">因為 '{2}' 並非公用執行個體或延伸模組方法，所以 '{0}' 未實作 '{1}' 模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance_Title">
        <source>Type does not implement the collection pattern; member is is not a public instance or extension method.</source>
        <target state="translated">型別未實作集合模式; 成員非公用執行個體或延伸模組方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': 靜態類型不可用做為傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass_Title">
        <source>Static types cannot be used as return types</source>
        <target state="translated">靜態類型不可用作傳回型別</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">標記 [DoesNotReturn] 的方法不應傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">標記 [DoesNotReturn] 的方法不應傳回。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">is' 或 'as' 運算子的第二個運算元不可為靜態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs_Title">
        <source>The second operand of an 'is' or 'as' operator may not be a static type</source>
        <target state="translated">'is' 或 'as' 運算子的第二個運算元不可為靜態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">switch 運算式未處理其輸入類型的所有可能值 (未徹底處理)。例如，未涵蓋模式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">switch 運算式未處理部分 null 輸入 (未徹底處理)。例如，未涵蓋模式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Switch 運算式未處理某些 Null 輸入 (其並不詳盡)。例如，未涵蓋模式 '{0}'。但具有 'when' 子句的模式可能可以成功與這個值相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Switch 運算式未處理某些 null 輸入。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Switch 運算式未處理某些 null 輸入。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Switch 運算式不會處理其輸入類型所有可能的值 (其並不詳盡)。例如，未涵蓋模式 '{0}'。但具有 'when' 子句的模式可能可以成功與這個值相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 運算式未處理其輸入類型可能的值 (並非全部)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 運算式未處理其輸入類型可能的值 (並非全部)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.</source>
        <target state="translated">參數 '{0}' 的參考種類修飾元不符合目標中的對應參數 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in target.</source>
        <target state="translated">參數的參考種類修飾元不符合目標中的對應參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">擲回值可能為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">擲回值可能為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">參數類型 '{0}' 中參考型別是否可為 NULL 的情況，與實作的成員 '{1}' 不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">參數類型中參考型別是否可為 NULL 的情況，與實作的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">'{1}' 的 '{0}' 參數類型中，參考型別是否可為 NULL 的情況，與隱含實作的成員 '{2}' 不相符 (可能的原因是屬性可為 NULL)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">參數類型中參考型別是否可為 NULL 的情況，與隱含實作的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">參數類型 '{0}' 是否可為 NULL 的情況，與覆寫的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">參數類型是否可為 NULL 的情況，與覆寫的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別中參考型別是否可為 NULL 的情況，與實作的成員 '{0}' 不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別中參考型別是否可為 NULL 的情況，與實作的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別 '{0}' 中參考型別是否可為 NULL 的情況，與隱含實作的成員 '{1}' 不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別中參考型別是否可為 NULL 的情況，與隱含實作的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別是否可為 NULL 的情況，與覆寫的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">傳回型別是否可為 NULL 的情況，與覆寫的成員不相符 (可能的原因是屬性可為 NULL )。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">因為元組 == 或 != 運算子的另一端指定了不同的名稱或未指定名稱，所以會忽略元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">因為元組 == 或 != 運算子的另一端指定了不同的名稱或未指定名稱，所以會忽略元組元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">類型參數 '{0}' 與外部方法 '{1}' 的類型參數，名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">類型參數與外部方法的類型參數，類型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion">
        <source>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派自動實作屬性 '{0}' 之前會先將控制項傳回呼叫者，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion_Title">
        <source>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派自動實作屬性之前會先將控制項傳回呼叫者，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先完全指派自動實作屬性 '{0}'。請考慮更新至語言版本 '{1}' 以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
        <source>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先完全指派自動實作屬性。請考慮更新至語言版本以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion">
        <source>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派欄位 '{0}' 之前會先將控制項傳回呼叫者，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion_Title">
        <source>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派欄位之前會先將控制項傳回呼叫者，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先完全指派欄位 '{0}'。請考慮更新至語言版本 '{1}' 以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion_Title">
        <source>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</source>
        <target state="translated">在控制項傳回呼叫者之前，必須先在建構函式中完全指派結構的欄位。請考慮更新至語言版本以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Unboxing 可能 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Unboxing 可能 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">套用到參數 '{0}' 的 EnumeratorCancellationAttribute 不會有任何作用。屬性只有在會傳回 IAsyncEnumerable 的非同步迭代器方法中，在類型 CancellationToken 的參數上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">EnumeratorCancellationAttribute 不會有任何作用。屬性只有在會傳回 IAsyncEnumerable 的非同步迭代器方法中，在類型 CancellationToken 的參數上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同步迭代器 '{0}' 有一或多個類型 'CancellationToken' 的參數，但因為沒有任何參數有裝飾 'EnumeratorCancellation' 屬性，所以將不會取用來自已產生 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消權杖參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同步迭代器成員有一或多個類型 'CancellationToken' 的參數，但因為沒有任何參數有裝飾 'EnumeratorCancellation' 屬性，所以將不會取用來自已產生 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消權杖參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring the {0} as nullable.</source>
        <target state="translated">退出建構函式時，不可為 Null 的 {0} '{1}' 必須包含非 Null 值。請考慮新增 'required' 修飾元，或將 {0} 宣告為可以為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.</source>
        <target state="translated">退出建構函式時，不可為 Null 的欄位必須包含非 Null 值。請考慮新增 'required' 修飾元，或將欄位宣告為可以為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter">
        <source>Parameter '{0}' is unread.</source>
        <target state="translated">參數 '{0}' 未讀取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter_Title">
        <source>Parameter is unread.</source>
        <target state="translated">參數未讀取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter">
        <source>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">參數 '{0}' 未讀取。是否忘記使用該參數來初始化該名稱的屬性?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter_Title">
        <source>Parameter is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">參數未讀取。是否忘記使用該參數來初始化該名稱的屬性?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">使用未指派的區域變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">使用可能未指派的欄位 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion">
        <source>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派之前會先讀取欄位 '{0}'，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion_Title">
        <source>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派之前會先讀取欄位，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">使用可能未指派的欄位 '{0}'。請考慮更新語言版本 '{1}' 以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion_Title">
        <source>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</source>
        <target state="translated">使用可能未指派的欄位。請考慮更新語言版本以自動預設欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField_Title">
        <source>Use of possibly unassigned field</source>
        <target state="translated">使用可能未指派的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">使用未指派的 out 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut_Title">
        <source>Use of unassigned out parameter</source>
        <target state="translated">使用未指派的 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">可能使用了未指派的自動實作屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion">
        <source>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派之前會先讀取自動實作屬性 '{0}'，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion_Title">
        <source>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">在明確指派之前會先讀取自動實作屬性，導致先前隱含的指派為 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">使用可能未指派的自動實作屬性 '{0}'。請考慮更新語言版本 '{1}' 以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion_Title">
        <source>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</source>
        <target state="translated">使用可能未指派的自動實作屬性。請考慮更新語言版本以自動預設屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty_Title">
        <source>Use of possibly unassigned auto-implemented property</source>
        <target state="translated">使用可能未指派的自動實作屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField">
        <source>Ref field '{0}' should be ref-assigned before use.</source>
        <target state="translated">Ref 欄位 '{0}' 應在使用前重新指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField_Title">
        <source>Ref field should be ref-assigned before use.</source>
        <target state="translated">Ref 欄位應在使用前重新指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">在指派 'this' 物件的所有欄位之前，會先讀取該物件，導致先前對未明確指派的欄位進行隱含的 'default' 指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion_Title">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">在指派 'this' 物件的所有欄位之前，會先讀取該物件，導致先前對未明確指派的欄位進行隱含的 'default' 指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">在指派 'this' 物件的所有欄位之前，無法使用該物件。請考慮更新語言版本 '{0}'，以自動預設未指派的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion_Title">
        <source>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</source>
        <target state="translated">在指派 'this' 物件的所有欄位之前，無法在建構函式中使用。請考慮更新語言版本，以自動預設未指派的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation_Title">
        <source>Use of unassigned local variable</source>
        <target state="translated">使用未指派的區域變數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}' 僅供評估之用。後續更新時可能會有所變更或移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">類型僅供評估之用。後續更新時可能會有所變更或移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">此位置不可使用字元 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">註解中使用的語法錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">實體參考中發現無效的字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">必須以 '&gt;' 或 '/&gt;' 做為結束標籤 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">必須是識別項。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Unicode 字元無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">此位置不可使用空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">屬性值中不可使用字元 '&lt;'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">屬性與屬性值之間少了等號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">參考未定義的實體 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">必須是字串常值，但未找到左引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">遺漏字串常值的右引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">字串常值前後不可使用非 ASCII 引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">此位置不可出現結束標籤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">結束標籤 '{0}' 與起始標籤 '{1}' 不對稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">必須是元素 '{0}' 的結束標籤。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">遺漏了必要的空格。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">此位置處找到未預期的字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">常值字串 ']]&gt;' 不可用在元素內容中。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">'{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">找不到中繼資料檔 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">不支援中繼資料參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">無法開啟中繼資料檔'{0}' -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">類型 '{0}' 定義在未參考的組件中。您必須加入組件 '{1}' 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">類型 '{0}' 定義在未加入的模組中。您必須加入模組 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">無法寫入輸出檔 '{0}' -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">程式已定義了一個以上的進入點。請以 /main 進行編譯，以指定包含進入點的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">運算子 '{0}' 不可套用至類型為 '{1}' 和 '{2}' 的運算元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">除以常數零</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">無法套用有 [] 的索引至類型為 '{0}' 的運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">[] 內的索引數目錯誤; 必須是 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">運算子 '{0}' 不可套用至類型為 '{1}' 的運算元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">關鍵字 'this' 在靜態屬性、靜態方法或靜態欄位初始設定式中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">關鍵字 'this' 在目前內容中無法使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'{0}' 的進入點簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">方法的進入點簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">無法將類型 '{0}' 隱含轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">無法將類型 '{0}' 轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">常數值 '{0}' 不可轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">運算子 '{0}' 在類型為 '{1}' 和 '{2}' 的運算元上模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">運算子 '{0}' 在類型為 '{1}' 的運算元上模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">out 參數不能有 In 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">無法將 null 轉換成 '{0}'，因為它是不可為 null 的實值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">無法透過參考轉換、boxing 轉換、unboxing 轉換、wrapping 轉換或 null 類型轉換，來將類型 '{0}' 轉換成 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">寫入偵錯資訊時發生未預期的錯誤 -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比方法 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比方法 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">不一致的存取範圍: 欄位類型 '{1}' 比欄位 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">不一致的存取範圍: 屬性類型 '{1}' 比屬性 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">不一致的存取範圍: 索引子傳回類型 '{1}' 比索引子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比索引子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比運算子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比運算子 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">不一致的存取範圍: 傳回類型 '{1}' 比委派 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">不一致的存取範圍: 參數類型 '{1}' 比委派 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">不一致的存取範圍: 基底類別 '{1}' 比類別 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">不一致的存取範圍: 基底介面 '{1}' 比介面 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': 事件屬性必須同時要有 add 和 remove 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'{0}': 事件必須為委派類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">事件 '{0}' 從未使用過</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">從未使用過事件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'{0}': 介面中的執行個體事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">事件 '{0}' 只可出現在 += 或 -= 的左側 (除非從類型 '{1}' 中使用)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">事件的明確介面實作必須使用存取子語法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'{0}': 無法覆寫; '{1}' 不是事件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">add 或 remove 存取子必須具有主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'{0}': 抽象事件不可有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">組件名稱 '{0}' 已保留，不可用做為互動工作階段中的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">列舉程式名稱 '{0}' 已保留，且無法使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">as 運算子必須搭配參考類型或可為 Null 的類型一起使用 ('{0}' 是不可為 Null 的實值類型)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">字尾 'l' 很容易與數字 '1' 混淆 -- 請使用 'L' 以避免困擾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">字尾 'l' 很容易與數字 '1' 混淆</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">事件 '{0}' 只可出現在 += 或 -= 的左側</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">非泛型宣告中不可使用條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">類型參數宣告必須是識別項，而非類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">類型 '{1}' 已保留了一個具有相同參數類型且名為 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">參數名稱 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">命名空間 '{1}' 已包含 '{0}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">類型 '{0}' 已包含 '{1}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">名稱 '{0}' 不存在於目前的內容中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">名稱 '{0}' 不存在於目前的內容中 (是否遺漏了組件 '{1}' 的參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'{0}' 是 '{1}' 與 '{2}' 之間模稜兩可的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">'{0}' 的 using 指示詞之前曾出現於此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">Using 指示詞先前出現在此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">修飾元 '{0}' 對此項目無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">有一個以上的保護修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'{0}' 會隱藏繼承的成員 '{1}'。若本意即為要隱藏，請使用 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">成員隱藏所繼承的成員; 遺漏 new 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">宣告的變數名稱與基底類型中的變數相同，但未使用 new 關鍵字。此警告是為了通知您應使用 new; 宣告變數的方式就如同宣告中使用了 new。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">成員 '{0}' 並未隱藏可存取的成員。不需要 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">成員未隱藏所繼承的成員; 不需要 new 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">'{0}' 常數值的運算發生循環定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">類型 '{1}' 已定義了一個具有相同參數類型且名為 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member cannot be marked as '{0}'</source>
        <target state="translated">靜態成員不能標記為 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">標記為 override 的成員 '{0}'，不可標記為 new 或 virtual</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'{0}' 會隱藏繼承的成員 '{1}'。若要讓目前的成員覆寫該實作，請加入 override 關鍵字; 否則請加入 new 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">成員隱藏所繼承的成員; 遺漏 override 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'{0}': 未找到任何合適的方法可覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields, methods or statements</source>
        <target state="translated">命名空間不能直接包含如欄位、方法或陳述式等成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'{0}' 是 {1}，但卻當成 {2} 使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'{0}' 是 {1}，其在指定內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">需要有物件參考，才可使用非靜態欄位、方法或屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">以下方法或屬性之間的呼叫模稜兩可: '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'{0}' 由於其保護層級之故，所以無法存取</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">'{0}' 沒有任何多載符合委派 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">需要可轉換成 '{0}' 之類型的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">因為 '{0}' 傳回了 void，所以 return 關鍵字之後不可接著物件運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">已經在此範圍內定義名為 '{0}' 的區域變數或函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">指派的左側必須是變數、屬性或索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'{0}': 靜態建構函式不能使用參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">指派至 '{0}' 的運算式必須為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'{0}' 為類型 '{1}'。非字串之參考類型的 const 欄位，只能以 null 初始設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">無法在此範圍宣告名為 '{0}' 的區域變數或參數，因為該名稱已用於封入區域變數範圍，以定義區域變數或參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">using namespace' 指示詞只能套用至命名空間; '{0}' 是類型而非命名空間。請考慮改用 'using static' 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">using static' 指示詞只能套用至類型; '{0}' 是命名空間而非類型。請考慮改用 'using namespace' 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">using static' 指示詞不能用來宣告別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">沒有可中斷或繼續的封閉式迴圈</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">標籤 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">類型 '{0}' 未定義任何建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract type or interface '{0}'</source>
        <target state="translated">無法建立抽象類型或介面 '{0}' 的執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">需要為 const 欄位提供值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base type dependency involving '{0}' and '{1}'</source>
        <target state="translated">循環基底類型相依性包括 '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">委派 '{0}' 沒有有效的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">必須是方法名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">必須是常數值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">Switch 運算式或 case 標籤必須是 bool、char、string、integral、enum 或 C# 6 及舊版中對應的可為 Null 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">必須是整數類型的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">switch 陳述式包含多個標籤值為 '{0}' 的情況</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">goto case 只有在 switch 陳述式中有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">屬性或索引子 '{0}' 無法用在此內容中，因為它缺少 get 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">類型 catch 或 throw 必須衍生自 System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">沒有引數的 throw 陳述式不可用於 catch 子句之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">控制項不可脫離 finally 子句的主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">標籤 '{0}' 所包含的範圍內以相同的名稱遮蔽了另一個標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">goto 陳述式的範圍內沒有這種標籤 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">之前的 catch 子句已取得所有屬於此類型或超級類型 ('{0}') 的例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">篩選條件運算式是常數 'true'，請考慮移除此篩選條件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">篩選條件運算式是常數 'true'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'{0}': 不是所有程式碼路徑都有傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">偵測到執行不到的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">偵測到執行不到的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">程式控制權無法從一個 case 標籤 ('{0}') 繼續到另一個</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">未參考此標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">未參考此標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">使用未指派的區域變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">已宣告變數 '{0}'，但從未使用過它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">已宣告變數，但從未使用過它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">欄位 '{0}' 從未使用過</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">從未使用過欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">使用可能未指派的欄位 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">可能使用了未指派的自動實作屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">無法判斷條件運算式的類型，因為 '{0}' 和 '{1}' 會互相隱含轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">無法確認條件運算式的類型，因為 '{0}' 和 '{1}' 之間沒有隱含轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">base' 參考需要基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">在此內容中使用關鍵字 'base' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">成員 '{0}' 無法以執行個體參考進行存取; 請改用類型名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">在程式控制權脫離目前的方法之前，必須指派 out 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">陣序規範無效: 必須是 ',' 或 ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'{0}' 不可同時為外部並宣告主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'{0}' 不可同時為外部並具有建構函式初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'{0}' 不可同時為外部與抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">屬性建構函式參數 '{0}' 的類型為 '{1}'，但是該類型不是有效的屬性參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">屬性引數必須是常數運算式、typeof 運算式或屬性參數類型的陣列建立運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">屬性建構函式參數 '{0}' 為選擇性參數，但並未指定預設參數值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">指定的運算式一律會是提供的 ('{0}') 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'is' 運算式的指定運算式一律會是提供的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">指定的運算式絕不是提供的 ('{0}') 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'is' 運算式的指定運算式絕不是提供的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'{0}' 不是 lock 陳述式所需的參考類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">在此內容中使用 null 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">在此內容中使用預設常值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">__arglist 建構函式只有在變數引數方法中才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">必須對指標套用 * 或 -&gt; 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">只能使用一個值對指標編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">若將 '{0}' 用作為 ref 或 out 值或取得其位址，皆可能會導致執行階段例外狀況，因為其為傳址封送類別的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">若將傳址封送類別的欄位用作為 ref 或 out 值或取得其位址，皆可能會導致執行階段例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">不可指定為靜態唯讀欄位 (除非在靜態建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">無法將靜態唯讀欄位用作為 ref 或 out 值 (除非在靜態建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">無法指派為屬性或索引子 '{0}' -- 其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">只有指派、呼叫、遞增、遞減以及新的物件運算式，可以用做為陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">foreach 要求 '{1}' 的傳回類型 '{0}' 必須要有適合的公用 MoveNext 方法以及公用 Current 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">只可使用 65534 個區域變數，包括由編譯器所產生的區域變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">無法呼叫抽象基底成員: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A non ref-returning property or indexer may not be used as an out or ref value</source>
        <target state="translated">非參考傳回屬性或索引子不可以 out 或 ref 值形式使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">無法取得 Managed 類型 ('{0}') 的位址、大小，也無法宣告指向它的指標</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">在 fixed 陳述式中宣告的區域變數類型必須為指標類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">在 fixed 或 using 陳述式宣告中，必須提供初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">無法取得指定運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">您只能取得 fixed 陳述式初始設定式中 unfixed 運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">您不能使用 fixed 陳述式來取得原本就是 fixed 運算式的位址</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">指標和固定大小緩衝區只能使用於 unsafe 內容中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">運算子 True 或 False 的傳回類型必須為 bool</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">運算子 '{0}' 需要也同時定義對稱的運算子 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">為了可以當成最少運算 (Short Circuit) 運算子使用，使用者定義的邏輯運算子 ('{0}') 必須具有相同的傳回類型與參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">為了讓 '{0}' 可以當成最少運算 (short circuit) 的運算子使用，其宣告類型 '{1}' 必須定義運算子 true 和運算子 false</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">已指派變數 '{0}'，但是從未使用過它的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">已指派變數，但從未使用過其值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">檢查模式下，作業於編譯時期溢位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">常數值 '{0}' 不可轉換成 '{1}' (請使用 'unchecked' 語法覆寫)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">具有 vararg 的方法不可為泛型、泛型類型或是具有 params 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">__arglist 運算式只可出現於呼叫或 new 運算式中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">只有在編譯時指定了 /unsafe，才會出現 unsafe 程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">'{0}' 與 '{1}' 之間模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">在 foreach 陳述式中同時需要類型與識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a parameter list</source>
        <target state="translated">params 參數必須是參數清單中的最後一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">'{0}' 沒有預先定義的大小，因此 sizeof 只能用於 unsafe 內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">命名空間 '{1}' 中沒有類型或命名空間名稱 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">欄位初始設定式無法參考非靜態欄位、方法或屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'因為 '{0}' 不是 override，所以無法密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'{0}': 無法覆寫繼承的成員 '{1}'，因為其已密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">在 Void 指標上未定義有問題的作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其為覆寫方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">is' 或 'as' 在指標類型上都無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">無法直接呼叫解構函式與 object.Finalize。請考慮呼叫 IDisposable.Dispose (若有的話)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">找不到類型或命名空間名稱 '{0}' (是否遺漏了 using 指示詞或組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">stackalloc 無法使用負值大小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">無法以負值大小建立陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">請勿覆寫 object.Finalize，請改為提供解構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base type Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">請勿直接呼叫您的基底類型 Finalize 方法。其會從您的解構函式自動呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">正在以負值索引檢索陣列 (陣列索引一律從 0 開始)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">對具有負索引的陣列編製索引</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">可能誤用了參考比較; 若要進行數值比較，請將左側轉型為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">可能誤用參考比較; 左端需要轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">可能誤用了參考比較; 若要進行數值比較，請將右側轉型為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">可能誤用參考比較; 右端需要轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">fixed 陳述式指派的右側，不可為 cast 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">在 catch 或 finally 區塊中不可使用 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a parameter list</source>
        <target state="translated">__arglist 參數必須是參數清單的最後一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">類型 '{0}' 的宣告中遺漏 partial 修飾元; 還存在此類型的其他部分宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</source>
        <target state="translated">'{0}' 中有一部分宣告必須全是類別、全是記錄類別、全是結構、全是記錄結構，或全是介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">'{0}' 的部分宣告出現相 衝突的存取範圍修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">'{0}' 的部分宣告不得指定不同的基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">'{0}' 的部分宣告必須要有相同順序的相同類型參數名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' 的部分宣告對類型參數 '{1}' 有不一致的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">無法將類型 '{0}' 隱含轉換成 '{1}'。已存在明確轉換 (是否漏了轉型?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', or a method or property return type.</source>
        <target state="translated">'partial' 修飾元只能直接出現在 'class'、'record'、'struct'、'interface' 或方法或屬性傳回型別之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base type dependency.</source>
        <target state="translated">匯入的類型 '{0}' 無效。其包含循環基底類型相依性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">使用未指派的 out 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">變數宣告中不可指定陣列大小 (請嘗試使用 'new' 運算式進行初始設定)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">無法在此內容中使用屬性或索引子 '{0}'，因為無法存取 get 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">無法在此內容中使用屬性或索引子 '{0}'，因為無法存取 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">'{0}' 存取子的存取範圍修飾元，必須比屬性或索引子 '{1}' 更嚴格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">不可同時對屬性或索引子 '{0}' 的兩個存取子，指定存取範圍修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 存取子上的存取範圍修飾元，只有在屬性或索引子同時有 get 和 set 存取子時，才可使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'，因為 '{2}' 並非公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'{0}' 未實作 '{1}' 模式，因為 '{2}' 與 '{3}' 之間模稜兩可。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">類型未實作集合模式; 成員模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'{0}' 未實作 '{1}' 模式。'{2}' 的簽章錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">類型未實作集合模式; 成員的簽章錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">'{0}' 已授與 Friend 存取權限，但輸出組件 ('{1}') 的公開金鑰，與授與之組件中 InternalsVisibleTo 屬性所指定的公開金鑰不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">'{0}' 已授與 Friend 存取權限，但輸出組件的強式名稱簽署狀態不符合授與組件的強式名稱簽署狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">在部分結構 '{0}' 的多重宣告中，欄位之間沒有已定義的順序。若要指定順序，所有執行個體欄位都必須在同一個宣告中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">在多個局部結構宣告中，欄位之間未定義順序</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">類型 '{0}' 不可宣告為 const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">無法建立變數類型 '{0}' 的執行個體，因為其無 new() 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">使用泛型 {1} '{0}' 時需要 {2} 個類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">類型 '{0}' 不可用做類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} '{0}' 不可搭配類型引數一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">非泛型 {1} '{0}' 不可搭配類型引數一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'{2}' 必須是具有公用無參數建構函式的非抽象類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的隱含參考轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。可為 Null 的類型 '{3}' 無法滿足 '{1}' 的條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。可為 Null 的類型 '{3}' 無法滿足 '{1}' 的條件約束。可為 Null 的類型無法滿足任何介面條件約束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的 Boxing 轉換或類型參數轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">類型 '{3}' 不可用做為泛型類型或方法 '{0}' 中的類型參數 '{2}'。沒有從 '{3}' 到 '{1}' 的 Boxing 轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">參數名稱 '{0}' 與自動產生的參數名稱衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">全域命名空間中找不到類型或命名空間名稱 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last restrictive constraint specified</source>
        <target state="translated">new() 限制式必須是最後一個指定的限制式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'{0}': 進入點不可為泛型，也不可為泛型類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">進入點不可為泛型，也不可為泛型類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">無法將 null 轉換成類型參數 '{0}'，因為其可能是不可為 null 的實值類型。請考慮改用 'default({0})'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">類型參數 '{1}' 出現重複的條件約束 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">類別類型條件約束 '{0}' 必須在所有其他條件約束之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'{1} {0}' 的傳回類型錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">'{0}' 與委派 '{1}' 之間的參考不符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">已為類型參數 '{0}' 指定了條件約束子句。類型參數的所有條件約束，都必須在單一 where 子句中指定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">方法 '{0}' 的類型引數不可從使用方式推斷。請嘗試明確地指定類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'{0}': 參數、區域變數或區域函式的名稱不得與方法類型參數相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">類型參數 '{0}' 不可與 'as' 運算子一起使用，因為它沒有類別類型條件約束或 'class' 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">已指派欄位 '{0}'，但從未使用過其值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">已指派欄位，但從未使用過其值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">'{0}' 屬性只有在非明確介面成員宣告的索引子上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'{0}': 屬性引數不可使用類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'{0}': 不能在建立變數類型的執行個體時，提供引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract type cannot be sealed or static</source>
        <target state="translated">'{0}': 抽象類型不可為密封或靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">cref 屬性中有模稜兩可的參考: '{0}'。已假設為 '{1}'，但也可能符合其他多載，包括 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">cref 屬性中的參考模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'{0}': volatile 欄位的參考不會視為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">volatile 欄位的參考不會視為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">通常不應該將 volatile 欄位用作為 ref 或 out 值，因為不會將它視為 volatile。但有例外狀況，例如呼叫連鎖 API 時。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">因為 '{1}' 具有 ComImport 屬性，所以 '{0}' 必須為 extern 或 abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'{0}': 具有 ComImport 屬性的類別不可指定基底類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">方法 '{1}' 之類型參數 '{0}' 的條件約束，必須符合介面方法 '{3}' 之類型參數 '{2}' 的條件約束。請考慮改用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">方法 '{0}' 的特徵標記中元組元素必須與介面方法 '{1}' 的元組元素名稱相符 (包括在傳回類型)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">類型名稱 '{0}' 不存在於類型 '{1}' 中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">無法將方法群組 '{0}' 轉換成非委派類型 '{1}'。原本希望叫用該方法嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">/reference 選項中未指定外部別名 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">別名 '{0}' 不能搭配 '::' 一起使用，因為別名會參考類型。請改用 '.'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">找不到別名 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">類型 '{1}' 同時存在於 '{0}' 和 '{2}' 中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">'{0}' 中的命名空間 '{1}' 與 '{2}' 中的類型 '{3}' 相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">'{0}' 中的命名空間 '{1}' 與 '{2}' 中匯入的類型 '{3}' 相衝突。請使用 '{0}' 中定義的命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">命名空間與所匯入的類型衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">'{0}' 中的類型 '{1}' 與 '{2}' 中匯入的類型 '{3}' 相衝突。請使用 '{0}' 中定義的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">類型與所匯入的類型衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">'{0}' 中的類型 '{1}' 與 '{2}' 中匯入的命名空間 '{3}' 相衝突。請使用 '{0}' 中定義的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">類型與所匯入的命名空間衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">'{0}' 中的類型 '{1}' 與 '{2}' 中的命名空間 '{3}' 相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">外部別名宣告必須位於命名空間中所有其他定義的元素之前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">最好不要定義名為 'global' 的別名，因為 'global::' 一定會去參考全域命名空間，而不會去參考別名</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">最好不要定義名為 'global' 的別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a type cannot be both static and sealed</source>
        <target state="translated">'{0}': 類型不可同時為靜態及密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'{0}': 抽象屬性不可有私用存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">語法錯誤; 應為值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">無法修改 Unboxing 轉換的結果</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Foreach 無法在 '{0}' 上運作。原本是要叫用 '{0}' 嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">++ 或 -- 運算子的傳回類型，必須符合此參數類型或衍生自此參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'{0}': 不可在指定條件約束類型的同時，又指定 'class' 或 'struct' 條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">new()' 條件約束不能和 'struct' 條件約束一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 必須是參考類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">類型 '{2}' 必須是不可為 null 的實值類型，才可在泛型類型或方法 '{0}' 中用做為參數 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">循環條件約束相依性包括 '{0}' 和 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">類型參數 '{0}' 繼承了衝突的條件約束 '{1}' 和 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">類型參數 '{1}' 有 'struct' 條件約束，因此 '{1}' 不可做為 '{0}' 的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">從 '{2}' 轉換成 '{3}' 時，使用者定義的轉換 '{0}' 與 '{1}' 模稜兩可</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">運算式的結果一律會是類型 '{0}' 的 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">運算式的結果一律是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">無法藉傳址方式傳回「這個」。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.</source>
        <target state="translated">無法使用屬性 constructor '{0}'，因為它有 'in' 或 'ref readonly' 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">覆寫及明確介面實作方法的條件約束，繼承自基底方法，所以無法直接指定，但 'class' 或 'struct' 限制式除外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">繼承的成員 '{0}' 和 '{1}'，在類型 '{2}' 中有相同的簽章，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">運算十進位常數運算式失敗</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">與類型 '{0}' 的 null 進行比較，一律會產生 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">與 struct 類型的 null 進行比較，一律會產生 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">引進可能會妨礙解構函式引動過程的 'Finalize' 方法。是否想要宣告解構函式?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">採用 'Finalize' 方法可能會妨礙解構函式的引動過程</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">如果用以建立類別的方法，其簽章是公用虛擬 void Finalize，則會發生此警告。

如果這類類別用做基底類別，而且衍生類別定義解構函式，則解構函式會覆寫基底類別 Finalize 方法，而非 Finalize。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'{0}' 不應有 params 參數，因為 '{1}' 沒有此參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">goto case' 值未隱含轉換成類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">goto case' 值未隱含轉換成參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">方法 '{0}' 無法實作類型 '{2}' 的介面存取子 '{1}'。請使用明確介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">運算式的結果一律會是 '{0}'，因為類型 '{1}' 的值絕對不會等於類型 '{2}' 的 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">運算式的結果一律會相同，因為此類型的值絕對不會等於 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">運算式的結果一律會是 '{0}'，因為類型 '{1}' 的值絕對不會等於類型 '{2}' 的 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">運算式的結果一律會相同，因為此類型的值絕對不會等於 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">明確介面實作 '{0}' 符合多個介面成員。實際選擇的介面成員，與實作相關。請考慮改用非明確實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">明確介面實作符合多個介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'因為 '{0}' 已標記為抽象，所以它無法宣告主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'{0}' 並未標記成 abstract、extern 或 partial，所以必須宣告主體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'{0}' 不可同時為抽象與密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">抽象 {0} '{1}' 不可標記為虛擬</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">常數 '{0}' 不可標記為 static</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'{0}': 因為 '{1}' 不是函式，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'{0}': 無法覆寫繼承的成員 '{1}'，因為其未標記為 virtual、abstract 或 override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'{0}': 覆寫 '{1}' 繼承的成員 '{2}' 時，無法變更存取修飾詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'{0}': 在覆寫繼承的成員 '{1}' 時無法變更元組元素名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 傳回類型必須是 '{2}' 才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'{0}': 無法衍生自密封類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract type '{1}'</source>
        <target state="translated">'{0}' 為抽象，但包含在非抽象類型 '{1}' 中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'{0}': 靜態建構函式不可有明確的 'this' 或 'base' 建構函式呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'{0}': 靜態建構函式中不可使用存取修飾詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">建構函式 '{0}' 不可呼叫其本身</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">建構函式 '{0}' 不可透過其他建構函式呼叫自己</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">'{0}' 沒有基底類別且無法呼叫基底建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">未定義或匯入預先定義的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">未定義或匯入預先定義的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">在多個參考組件中宣告了預先定義的類型 '{0}': '{1}' 與 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'{0}': 結構無法呼叫基底類別建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">類型為 '{1}' 的結構成員 '{0}'，在結構配置中造成循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">介面不能包含執行個體欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">介面不能包含執行個體建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">介面清單中的類型 '{0}' 不是介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'{0}' 已列於介面清單中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' 已列於元組元素名稱不同的類型 '{2}' 介面清單中，名稱為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">繼承的介面 '{1}' 造成 '{0}' 介面階層架構中出現循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'{0}' 會隱藏繼承的抽象成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'{0}' 未實作繼承的抽象成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">類別 System.Object 不能有基底類別或實作介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'在明確介面宣告中的 '{0}' 不是介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">在明確介面宣告中，無法在可實作的介面成員間找到 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'{0}': 包含類型未實作介面 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</source>
        <target state="translated">'{0}': 明確的介面宣告只能在類別、記錄、結構或介面中宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'{0}': 成員名稱不可與其封入類型名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'{0}': 就其類型而言，此列舉值過大</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'{0}': 因為 '{1}' 不是屬性，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'{0}': 因為 '{1}' 沒有可覆寫的 get 存取子，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'{0}': 因為 '{1}' 沒有可覆寫的 set 存取子，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'{0}': 屬性或索引子不可有 void 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'{0}': 屬性或索引子至少必須要有一個存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed type '{1}'</source>
        <target state="translated">'{0}' 是密封類型 '{1}' 中新的虛擬成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'{0}' 加入了在介面成員 '{1}' 中找不到的存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">明確介面實作 '{0}' 遺失存取子 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'{0}': 介面之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base type are not allowed</source>
        <target state="translated">'{0}': 與基底類型之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived type are not allowed</source>
        <target state="translated">'{0}': 與衍生類型之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot convert a type to itself</source>
        <target state="translated">使用者定義的運算子無法將類型轉換成本身</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">使用者定義的轉換必須轉換為封入類型或從封入類型轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">類型 '{0}' 中出現重複的使用者定義之轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">使用者定義的運算子 '{0}' 必須宣告為 static 和 public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">++ 或 -- 運算子的參數類型必須是包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">一元運算子的參數必須為包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">二元運算子的一個參數必須為包含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type</source>
        <target state="translated">多載移位 (Shift) 運算子的第一個運算元的類型必須和包含類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">列舉不能包含明確的無參數建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}': 因為此語言不支援 '{1}'，所以無法覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'此語言不支援 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'{0}': 無法明確呼叫運算子或存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'{0}': 不可透過運算式參考類型; 請嘗試改用 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of type</source>
        <target state="translated">解構函式的名稱必須符合類型的名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">只有類別類型可以包含解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">命名空間 '{1}' 包含與別名 '{0}' 相衝突的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">別名 '{0}' 與 {1} 定義相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其為建構函式、解構函式、運算子、Lambda 運算式或明確介面實作</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">Conditional 屬性在 '{0}' 上無效，因為其傳回類型不是 void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">'{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">'{1}' 中的 '{0}' 屬性重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">Conditional 屬性不能用在介面成員上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">使用者定義的運算子無法傳回 void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'{0}': 動態類型之間不可進行使用者定義的轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">'{0}' 屬性的引數值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">參數對於指定的 Unmanaged 類型無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">必須指定屬性參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">必須指定屬性參數 '{0}' 或 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Unmanaged 類型 '{0}' 對欄位無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Unmanaged 類型 '{0}' 只對欄位有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在此宣告類型上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">浮點常數的值超出類型 '{0}' 的範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">指定 Guid 屬性時必須同時指定 ComImport 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">具名屬性引數 '{0}' 的值無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">DllImport 屬性必須指定在標記為 'static' 和 'extern' 的方法上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">無法更新 '{0}'; 缺少屬性 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="translated">DllImport 屬性無法套用至泛型方法，或包含在泛型方法或類型中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">欄位或屬性不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">欄位或自動實作屬性的類型不可為 '{0}'，除非它是 ref struct 的執行個體成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">陣列元素不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'{0}' 已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">類型或成員已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'{0}' 不是屬性類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'{0}' 不是有效的具名屬性引數。具名屬性引數必須為欄位，且不可為 readonly、static 或 const，也不可以是 public 且非 static 的 read-write 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' 已經過時: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">類型或成員已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' 已經過時: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">索引子不能有 void 的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'{0}': 虛擬或抽象成員不可為私用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">只可使用陣列初始設定式運算式，指派給陣列類型。請嘗試改用 new 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">陣列初始設定式只可用於變數或欄位初始設定式中。請嘗試改用 new 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">'{0}': 標記有 StructLayout(LayoutKind.Explicit) 之類型的執行個體欄位，必須要有 FieldOffset 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">方法、運算子或存取子 '{0}' 已標記為外部，但其上沒有屬性。請考慮加入 DllImport 屬性來指定外部實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">方法、運算子或存取子標記為外部，而且其上沒有屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed type</source>
        <target state="translated">'{0}': 在密封類型中宣告了新的 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed type</source>
        <target state="translated">在密封類型中宣告了新的 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Conditional 成員 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">ref 和 out 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">'{0}' 屬性的引數必須是有效的識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 屬性僅能置於標記為 StructLayout(LayoutKind.Explicit) 類型的成員上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">static 或 const 欄位不能有 FieldOffset 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">屬性 '{0}' 只有在衍生自 System.Attribute 的類別上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">可能誤用了空白的陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">可能誤用了空白的陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'{0}' 有重複的具名屬性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'{0}' 不可衍生自特殊類別 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">無法在包含索引子的類型上指定 DefaultMember 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'此語言不支援類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">從未指派欄位 '{0}'，會持續使用其預設值 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">從未指派欄位，會持續使用其預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">陣列宣告子無效: 若要宣告 Managed 陣列，陣序規範必須位於變數識別項之前。若要宣告固定大小緩衝區欄位，請在欄位類型之前使用 fixed 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">與整數常數比較無意義，因為此常數位於類型 '{0}' 的範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">與整數常數比較無意義; 此常數位於類型的範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">無法套用屬性類別 '{0}'，因為其抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'{0}' 不是有效的具名屬性引數，因為其不是有效的屬性參數類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">遺漏編譯器必要成員 '{0}.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' 對此宣告而言，不是有效的屬性位置。對此宣告有效的屬性位置是 '{1}'。將會忽略此區塊中的所有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">不是此宣告的有效屬性位置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' 不是可辨認的屬性位置。此宣告的有效屬性位置為 '{1}'。將會忽略此區塊中的所有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">不是可辨識的屬性位置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' 會覆寫 Object.Equals(object o)，但是不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">類型會覆寫 Object.Equals(object o)，但不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'{0}' 定義了運算子 == 或運算子 !=，但不會覆寫 Object.Equals(object o)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">類型會定義運算子 == 或運算子 !=，但不會覆寫 Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' 定義了運算子 == 或運算子 !=，但不會覆寫 Object.GetHashCode()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">類型會定義運算子 == 或運算子 !=，但不會覆寫 Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">無法在 ref 參數上僅指定 Out 屬性，卻不指定 In 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'{0}' 無法定義多載的 {1}，後者僅在參數修飾元 '{2}' 和 '{3}' 有所不同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">不可將類型 double 的常值，隱含轉換成類型 '{1}'; 請使用 '{0}' 後置詞來建立此類型的常值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">條件運算式中的指派一直是常數; 這表示您要使用 == 代替 = ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">條件運算式中的指派一律是常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'{0}': 在結構中宣告了新的 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">兩個索引子具有不同的名稱; 類型中每個索引子上都必須使用同名的 IndexerName 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">擁有 ComImport 屬性的類別無法有使用者定義的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">欄位不能有 void 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">成員 '{0}' 會覆寫過時的成員 '{1}'。請將 Obsolete 屬性加入 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">成員會覆寫過時成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">無法從 C# 使用 System.Void -- 請使用 typeof(void) 取得 void 類型物件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">用於 sign-extend 運算元的 Bitwise-or 運算子; 請先考慮轉換為較小的不帶正負號類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">用於 sign-extended 運算元上的 Bitwise-or 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">編譯器會隱含地擴大，而且 sign-extended 變數，然後在位元 OR 運算中使用結果值。這可能會導致非預期的行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'{0}': Volatile 欄位不可為類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'{0}': 欄位不可同時為 volatile 和 readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">修飾元 'abstract' 在欄位上無效。請嘗試改用屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}' 不可實作 '{1}'，因為此語言不支援它</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'{0}' 明確方法實作無法實作 '{1}'，因為其為存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'{0}' 介面標記為 'CoClassAttribute'，而非標記為 'ComImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">介面標記為 'CoClassAttribute'，而非標記為 'ComImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Conditional 成員 '{0}' 不可有 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">存取子 '{0}' 無法為類型 '{2}' 實作介面成員 '{1}'。請使用明確的介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">命名空間別名限定詞 '::' 一定會解析為類型或命名空間，所以不能用在這裡。請考慮用 '.' 替代。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">無法從 '{0}' 衍生，因為其為類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">類型參數 '{0}' 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">類型參數 '{0}' 與外部類型 '{1}' 的類型參數名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">類型參數與外部類型的類型參數名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">類型參數 '{0}' 與包含類型或方法的名稱相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'{0}' 不可同時實作 '{1}' 和 '{2}'，因為它們可能會整合某些類型參數的替代</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">'{1}' 未定義類型參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'{0}' 不是有效的條件約束。用做為條件約束的類型，必須是介面、非密封類別或類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">條件約束不可為特殊類別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">不一致的存取範圍: 條件約束類型 '{1}' 比 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">無法在 '{0}' 中進行非虛擬的成員查詢，因為其為型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">條件約束類型無效。用做為條件約束的類型，必須是介面、非密封類別或類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'{0}': 不可在靜態類別中宣告執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'{1}': 不可衍生自靜態類別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">靜態類別不能有執行個體建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">靜態類別不能包含解構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">無法建立靜態類別 '{0}' 的執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">靜態類別 '{0}' 不可衍生自類型 '{1}'。靜態類別必須衍生自 object。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'{0}': 靜態類別無法實作介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'{0}': 靜態類別不可包含使用者定義的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">無法轉換成靜態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'{0}': 靜態類別不可用做為條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'{0}': 靜態類型不可用做為類型引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'{0}': 陣列元素不可為靜態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'{0}': 不可在靜態類別中宣告索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': 靜態類型不可用做為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': 靜態類型不可用做為傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">無法宣告靜態類型 '{0}' 的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">最內層 catch 子句中巢狀 finally 子句不允許沒有引數的 throw 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}' 不是有效的格式規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">可能對引數 '{0}' 進行了不正確的指派，而其為 using 或 lock 陳述式的引數。此區域變數的原始值，將會發生 Dispose 呼叫或解除鎖定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">可能不正確地指派給其為 using 或 lock 陳述式引數的本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">類型 '{0}' 定義於此組件中，但已為其指定類型轉送子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">無法轉送類型 '{0}'，因為其為 '{1}' 的巢狀類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">組件 '{1}' 中類型 '{0}' 的類型轉送子造成循環</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">只有在建置 'module' 的目標類型時，才可指定 /moduleassemblyname 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">組件參考 '{0}' 無效，無法解析</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">指定做為 TypeForwardedTo 屬性引數的類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</source>
        <target state="translated">'{0}' 未實作執行個體介面成員 '{1}'。因為 '{2}' 為靜態，所以無法實作介面成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作介面成員，因為其並非公用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法實作 '{1}'，因為其沒有符合的傳回類型 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'{0}' 與 TypeForwardedToAttribute 重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">查詢主體必須以 select 或 group 子句結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">必須是內容關鍵字 'on'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">必須是內容關鍵字 'equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">必須是內容關鍵字 'by'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">匿名類型成員宣告子無效。匿名類型成員必須以成員指派、簡單名稱或成員存取加以宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">初始設定式成員宣告子無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Lambda 參數用法不一致; 參數類型必須全部為明確類型或全部為隱含類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberNotExplicit">
        <source>A partial member may not explicitly implement an interface member</source>
        <target state="translated">部分成員不可明確地實作介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">兩個部分方法宣告必須都是擴充方法，或者都不是擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">部分方法不可有多重定義宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">部分方法不能有多重實作的宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">找不到用以實作部分方法 '{0}' 宣告的定義宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' 的部分方法宣告對型別參數 '{1}' 有不一致的條件約束</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">無法從方法 '{0}' 建立委派，因為它是無實作宣告的部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberStaticDifference">
        <source>Both partial member declarations must be static or neither may be static</source>
        <target state="translated">兩個部分成員宣告都必須是靜態，或者都不是靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">在運算式樹狀結構中，不可使用只具有定義宣告或已移除條件式方法的部分方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">過時的成員 '{0}' 會覆寫非過時的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">過時成員會覆寫非過時成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">'{0}' 的完整名稱對於偵錯資訊而言太長。在編譯時請勿使用 '/debug' 選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">偵錯資訊的完整名稱太長</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">無法將 {0} 指派給隱含類型變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">隱含類型變數必須經過初始設定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">隱含類型變數不可有多重宣告子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">無法使用陣列初始設定式來初始設定隱含類型變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">隱含類型區域變數不可為 fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">隱含類型變數不可為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">建構函式 '{0}' 標記為外部</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">建構函式標記為外部</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">內容關鍵字 'var' 只可出現在區域變數宣告或指令碼中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">找不到隱含類型陣列的最佳類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">無法將 '{0}' 指派給匿名型別屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">運算式樹狀結構不可包含基底存取</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">運算式樹狀結構不可包含指派運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">匿名類型不可具有多個同名的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">具有陳述式主體的 Lambda 運算式，不可轉換成運算式樹狀架構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">如果運算式樹狀結構的類型引數 '{0}' 不是委派類型，就無法將 Lambda 轉換成運算式樹狀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">在常數運算式中不可使用匿名類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">is' 或 'as' 運算子的第一個運算元，不可為 Lambda 運算式、匿名方法或方法群組。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">as' 運算子的第一運算元不得為不含自然對數的元組常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">運算式樹狀結構不可包含多維陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">遺失引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">在宣告區域變數 '{0}' 之前，無法使用此變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">無法推斷 '{0}' 的類型，因為其初始設定式會直接或間接參考定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">在宣告區域變數 '{0}' 之前，無法使用此變數。區域變數的宣告會隱藏欄位 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含左側為 null 或預設常值的聯合運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">必須是識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">必須是 ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">語法錯誤，必須是 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">'{0}' 修飾元重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">屬性存取子已定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">必須是 byte、sbyte、short、ushort、int、uint、long 或 ulong 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">逸出序列無法辨認</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">常數中包含新行字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">空的字元常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">字元常值中有太多字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">必須是 get 或 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">必須是物件、字串或類別類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">必須是具名屬性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Catch 子句無法接在 try 陳述式的一般 catch 字句之後</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">應有關鍵字 'this' 或 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">必須是可多載的一元運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">必須是可多載的二元運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">整數常數太大</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">必須是類型或命名空間定義，或檔案結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">必須是成員定義、陳述式或檔案結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">內嵌的陳述式不能為宣告或標記陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">必須是前置處理器指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">必須是單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">必須是 )</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">必須是 #endif 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">未預期的前置處理器指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#error: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">#warning 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">必須是類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">於檔案第一個語彙基元後無法定義或取消定義前置處理器符號</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">無法在檔案的第一個語彙基元後使用 #r</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">找到檔案結尾，必須是 '*/'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">偵測到合併衝突標記</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">使用 refonly 時，請勿使用 refout。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">使用 /refout 或 /refonly 時無法編譯網路模組。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">必須是可多載的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">必須是 #endregion 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">未結束的字串常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">前置處理器指示詞必須出現為行中第一個非空白字元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">必須是識別項; '{1}' 為關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">必須是 { 或 ;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">無法在 for、using、fixed 或宣告陳述式中使用一個以上的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">必須是 add 或 remove 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">未預期的字元 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">未預期的語彙基元 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'{0}': 靜態類別不可包含 Protected 成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">上一個 catch 子句已經攔截所有的例外狀況。所有擲回的非例外狀況都將包裝在 System.Runtime.CompilerServices.RuntimeWrappedException 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">前一個 catch 子句已提取所有例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">如果 catch() 區塊未在 catch (System.Exception e) 區塊後面指定例外狀況類型，則會導致此警告。此警告會建議 catch() 區塊將不會擷取任何例外狀況。

如果 AssemblyInfo.cs 檔案中的 RuntimeCompatibilityAttribute 設定為 false，則 catch (System.Exception e) 區塊後面的 catch() 區塊可以擷取非 CLS 例外狀況: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]。如果此屬性未明確地設定為 false，則所有擲回的非 CLS 例外狀況都會包裝為例外狀況，而 catch (System.Exception e) 區塊會加以擷取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">遞增或遞減運算子的運算元必須是變數、屬性或索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，也找不到可接受類型 '{0}' 第一個引數的可存取擴充方法 '{1}' (是否遺漏 using 指示詞或組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，也找不到擴充方法 '{1}' 可接受類型 '{0}' 的第一個引數 (是否遺漏 '{2}' 的 using 指示詞?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">方法 '{0}' 具有參數修飾元 'this'，但其不在第一個參數上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> 參數修飾元 '{0}' 不可搭配 '{1}' 使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">擴充方法的第一個參數不可為類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">擴充方法中，參數陣列不可用於 'this' 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">擴充方法必須為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">擴充方法必須在非泛型靜態類別中定義</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">參數只能有一個 '{0}' 修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">擴充方法必須定義在最上層靜態類別中; {0} 為巢狀類別</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">無法定義新的擴充方法，因為找不到編譯器的必要類型 '{0}'。是否遺漏了 System.Core.dll 的參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.ExtensionAttribute'。請改用 'this' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.DynamicAttribute'。請改用 'dynamic' 關鍵字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">建構函式呼叫必須以動態方式分派，但因為其為建構函式初始設定式的一部分，所以無法動態分派。請考慮將動態引數轉型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">實值類型 '{1}' 上定義的擴充方法 '{0}'，無法用以建立委派</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">方法 '{0}' 沒有任何多載使用 {1} 個引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">引數 {0}: 無法從 '{1}' 轉換成 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">無法開啟原始程式檔 '{0}' -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">建立模組時無法連結資源檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">在此組件中已使用了資源識別項 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">每個連結資源與模組，都必須要有不重複的檔案名稱。在此組件中指定了一次以上的檔案名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">參考檔 '{0}' 不是組件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">ref 或 out 值必須是可指派的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">關鍵字 'base' 在靜態方法中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">在目前的內容中無法使用關鍵字 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">必須是 }</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">必須是 {</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'必須是 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">前置處理器運算式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, record, struct, or interface member declaration</source>
        <target state="translated">類別、記錄、結構或介面成員宣告中的語彙基元 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">方法必須要有傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">基底類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">空的 switch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">空的 switch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">必須是 catch 或 finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">運算式詞彙 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires an argument list or (), [], or {} after type</source>
        <target state="translated">new 運算式在類型後需要有引數清單或是 ()、[] 或 {}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">在命名空間中定義的元素無法明確宣告為 private、protected、protected internal 或 private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">必須是 ; 或 = (無法在宣告中指定建構函式引數)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">using 子句必須位於所有其他命名空間中所定義的元素之前 (外部別名宣告除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">多載二元運算子 '{0}' 接受兩個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">多載一元運算子 '{0}' 接受一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">參數類型 'void' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">using 別名 '{0}' 之前曾出現於此命名空間中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">無法經由類型 '{1}' 的限定詞，來存取保護的成員 '{0}'; 限定詞必須是類型 '{2}' (或從其衍生的類型)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'{0}' 因為已是組件，所以無法加入此組件中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">此語言不支援屬性、索引子或事件 '{0}'; 請嘗試直接呼叫存取子方法 '{1}' 或 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">此語言不支援屬性、索引子或事件 '{0}'; 請嘗試直接呼叫存取子方法 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">在此內容中不可使用關鍵字 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">索引子至少要有一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">陣列類型規範 [] 必須出現在參數名稱之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">宣告無效; 請改用 '{0} operator &lt;dest-type&gt; (...'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">找不到為 Main 方法所指定的 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</source>
        <target state="translated">為 Main 方法指定的 '{0}' 必須為非泛型類別、記錄、結構或介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">'{0}' 沒有適合的靜態 Main 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">無法為 Main 方法使用 '{0}'，因為其為匯入物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">沒有來源的輸出必須有指定的 /out 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">指定的選項衝突: Win32 資源檔; Win32 資訊清單</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">指定的選項衝突: Win32 資源檔; Win32 圖示</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">讀取資源 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">寫入 XML 文件檔案時發生錯誤: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">XML 註解有格式錯誤的 XML -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">XML 註解有格式錯誤的 XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">XML 註解中的 '{0}' 有重複的 param 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">XML 註解中有重複的 param 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">XML 註解中的 '{0}' 有 param 標籤，但沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">XML 註解具有 param 標籤，但是沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">'{1}' 上的 XML 註解中的 '{0}' 有 paramref 標籤，但沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">XML 註解具有 paramref 標籤，但是沒有該名稱的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">參數 '{0}' 在 '{1}' 的 XML 註解中沒有相符的 param 標籤 (但其他參數有)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">在 XML 註解中，參數沒有相符的 param 標籤 (但其他參數則相反)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">XML 註解有無法解析的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">XML 註解有無法解析的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">stackalloc 運算式在類型之後需要有 []</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">為 #line 指示詞指定的行號遺漏或無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">必須是檔案名稱、單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">必須是以引號括住的檔案名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">#r 只可用於指令碼中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">因為 '{0}' 不包含 '{1}' 的公用執行個體或延伸模組定義，所以 foreach 陳述式無法在型別 '{0}' 的變數上運作</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">XML 註解 cref 屬性中參數 {0} 的類型無效: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的參數類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的傳回類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 註解 cref 屬性中的傳回類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">讀取 Win32 資源時發生錯誤 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">XML 註解有句法不正確的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">XML 註解有句法不正確的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">成員修飾元 '{0}' 必須在成員類型與名稱之前</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">建立陣列必須有陣列大小或陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 註解沒有放置在有效的語言項目前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 註解沒有放置在有效的語言項目前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">無法納入檔案 '{0}' 的 XML 片段 '{1}' -- {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">無法包含 XML 片段</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">XML include 元素無效 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">無效的 XML include 項目</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">遺漏公用可見類型或成員 '{0}' 的 XML 註解</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">遺漏公用可見類型或成員的 XML 註解</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">已指定 /doc 編譯器選項，但是一個或多個建構沒有註解。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Include 註解檔中的 XML 格式錯誤 -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Include 註解檔中的 XML 格式錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">委派 '{0}' 不接受 {1} 個引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">方法或存取子區塊後的分號無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>The return type of a method, delegate, or function pointer cannot be '{0}'</source>
        <target state="translated">方法、委派或函式指標的傳回型別不得為 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">使用者取消了編譯</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">無法製作類型 '{0}' 之變數的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">無法指派給 '{0}'，因為其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">無法將 '{0}' 用作為 ref 或 out 值，因其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">C# 類型上不可使用 RequiredAttribute 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">修飾元不能置於事件存取子宣告中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">params 參數不可宣告為 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">無法修改 '{0}' 的傳回值，因為其非變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">找不到介面 '{1}' 的 Managed coclass 包裝函式類別 '{0}' (是否遺漏了組件參考?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</source>
        <target state="translated">'{0}' 在 '{1}' 和 '{2}' 之間不明確。使用 '@{0}' 或明確包含 'Attribute' 尾碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">傳遞引數 {0} 時不可包含 '{1}' 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">選項 '{0}' 會覆寫原始程式檔或加入的模組中所指定之屬性 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">選項會覆寫原始程式檔或加入的模組中所指定的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">如果來源中所找到的組件屬性 AssemblyKeyFileAttribute 或 AssemblyKeyNameAttribute，與 [專案屬性] 中所指定的 /keyfile 或 /keycontainer 命令列選項或金鑰檔案名稱或金鑰容器衝突，則會發生此警告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">/langversion 的選項 '{0}' 無效。請使用 '/langversion:?' 來列出支援的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">無法以 '{0}' 建立委派，因為其或其所覆寫的方法具有 Conditional 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">無法建立暫存檔 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">傳遞引數 {0} 時必須包含 '{1}' 關鍵字</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">在匿名方法或 Lambda 運算式內不可使用 yield 陳述式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">無法從迭代器傳回值。請使用 yield return 陳述式傳回值，或使用 yield break 結束反覆運算。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">迭代器不能有 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">'{0}' 的主體不可是迭代區塊，因為 '{1}' 不是 Iterator 介面類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">finally 子句的主體中不可使用 yield</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">在具有 catch 子句的 try 區塊主體中不可使用 yield 產生值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">yield return 之後應接著運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">無法在匿名方法、Lambda 運算式、查詢運算式或區域函式中使用 ref、out 或 in 參數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">無法在 catch 子句主體中使用 yield 產生值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">程式控制權不能從匿名方法或 Lambda 運算式的主體離開</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">無法辨認的 #pragma 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">無法辨認的 #pragma 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">應為 'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">#pragma 警告後應有 'disable' 或 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">無法還原警告 'CS{0}'，因為其已全域停用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">無法還原警告，因為已全域予以停用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">迭代器的參數清單中不可有 __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have pointer type parameters</source>
        <target state="translated">迭代器不能具有指標型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">介面 '{1}' 的 Managed coclass 包裝函式類別簽章 '{0}'，不是有效的類別名稱簽章</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">foreach 陳述式不可用在類型 '{0}' 的變數上，因為其會實作 '{1}' 的多個具現化; 請嘗試轉型為特定的介面具現化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">固定大小緩衝區欄位在欄位名稱後面必須有陣列大小規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">固定大小緩衝區欄位必須是結構的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">並非所有程式碼路徑都會在類型為 '{1}' 的 {0} 中傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">'{0}' 功能不包括在標準化 ISO C# 語言規格中，在其他編譯器上可能無法接受</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">功能不包括在標準化 ISO C# 語言規格中，在其他編譯器上可能無法接受</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">逐字規範 "@" 之後應接著關鍵字、識別項或字串</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">無法將唯讀欄位用作為 ref 或 out 值 (除非在建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">無法將唯讀欄位 '{0}' 的成員用作為 ref 或 out 值使用 (除非在建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</source>
        <target state="translated">無法指派給唯讀欄位 (除非位於建構函式內; 或位於已定義此欄位的類型中，僅供初始化的 Setter 內; 或位於變數初始設定式內)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">唯讀欄位 '{0}' 的成員不可修改 (除非在建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' 無法用為 ref 或 out 值，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' 的成員不可用為 ref 或 out 值，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">無法指派給 {0} '{1}'，或將其用在 ref 指派的右邊，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">無法指派給 {0} '{1}' 的成員，或將其用在 ref 指派的右邊，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">無法以可寫入傳址方式傳回 {0} '{1}'，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">無法以可寫入傳址方式傳回 {0} '{1}' 的成員，因為它是唯讀變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">無法指派為靜態唯讀欄位 '{0}' 的欄位 (除非在靜態建構函式或變數初始設定式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">無法將靜態唯讀欄位 '{0}' 的欄位用作為 ref 或 out 值 (除非在靜態建構函式中)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">無法修改 '{0}' 的成員，因為其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">無法將 '{0}' 的欄位用作為 ref 或 out 值，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">無法指派給 '{0}'，因為其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">無法將 '{0}' 用作為 ref 或 out 值，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}。請參閱錯誤 CS{1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">警告會覆寫錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">編譯器將錯誤覆寫為警告時會發出此警告。如需此問題的相關資訊，請搜尋提及的錯誤碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">無法將 {0} 轉換成類型 '{1}'，因為其非委派類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">因為參數類型與委派參數類型不符，所以無法將 {0} 轉換為類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">無法將 {0} 轉換成想要的委派類型，因為區塊中的某些傳回類型，無法隱含轉換成委派傳回類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than '{1}'</source>
        <target state="translated">因為此為非同步方法，所以傳回運算式的類型必須是 '{0}' 而非 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">無法將非同步 {0} 轉換成委派類型 '{1}'。非同步 {0} 可能會傳回 void、Task 或 Task&lt;T&gt;，而這些都無法轉換成 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">固定大小緩衝區類型必須是下列其中一項: bool、byte、short、int、long、char、sbyte、ushort、uint、ulong、float 或 double</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">長度為 {0} 且類型為 '{1}' 的固定大小緩衝區太大</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">固定大小緩衝區的長度必須大於零</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">您不能使用包含在 unfixed 運算式中的固定大小緩衝區。請嘗試使用 fixed 陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">屬性 '{0}' 在屬性或事件存取子上無效。其只有在 '{1}' 宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">在 '{1}' 中指定了的搜尋路徑 '{0}' 無效 -- '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">指定的搜尋路徑無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">__arglist 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">params 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">命名空間宣告不能有修飾元或屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">/platform 的 '{0}' 選項無效; 必須是 anycpu、x86、Itanium、arm、arm64 或 x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.</source>
        <target state="translated">結構內部的匿名方法、Lambda 運算式及查詢運算式，皆無法存取 'this' 的執行個體成員。請考慮將 'this' 複製到匿名方法、Lambda 運算式、查詢運算式或本機函式外部的區域變數，並改用該區域變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'.</source>
        <target state="needs-review-translation">'{0}': using 陳述式中使用的類型必須可以隱含轉換為 'System.IDisposable'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">參數 {0} 必須以 '{1}' 關鍵字宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">參數 {0} 不可以 '{1}' 關鍵字宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">參數 {0} 宣告為類型 '{1}{2}'，但應該是 '{3}{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">/reference' 的外部別名無效; '{0}' 不是有效的識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">參考別名選項無效: '{0}=' -- 遺漏檔案名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">您不能重新定義全域外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">類型 '{0}' 的參考表示它定義在此組件中，但是在原始檔或任何加入的模組中都未定義它</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">類型 '{0}' 的參考表示它定義在 '{1}' 中，但找不到</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">預先定義的類型 '{0}' 在全域別名的多個組件中都有定義; 請使用 '{1}' 中的定義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">預先定義的類型定義在全域別名的多個組件中</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">如果在兩個組件中找到預先定義的系統類型 (例如 System.Int32)，則會發生此錯誤。可能發生此狀況的其中一種原因是參考兩個不同位置的 mscorlib 或 System.Runtime.dll，例如嘗試並排執行兩個版本的 .NET Framework。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">無法取得區域變數 '{0}' 或其成員的位址，這些也無法用於匿名方法或 Lambda 運算式內部</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">原始程式檔已超過 PDB 所能顯示的上限 16,707,565 行; 偵錯資訊可能會不正確</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">原始程式檔已超過 PDB 所能顯示的上限 16,707,565 行; 偵錯資訊可能會不正確</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">無法將沒有參數清單的匿名方法區塊，轉換成委派類型 '{0}'，因為其有一或多個 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">屬性 '{0}' 只有在方法或屬性類別上才有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">存取 '{0}' 上的成員可能會造成執行階段例外狀況，因為其為傳址封送類別的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">存取傳址封送類別之欄位上的成員，可能會導致執行階段例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">如果嘗試在類別衍生自 MarshalByRefObject 的成員上呼叫方法、屬性或索引子，而且成員是實值類型，則會發生此警告。繼承自 MarshalByRefObject 的物件通常是要透過參考跨應用程式定義域進行封送處理。如果任何程式碼曾經嘗試跨應用程式定義域直接存取這類物件的 value-type 成員，則會發生執行階段例外狀況。若要解決此警告，請先將成員複製至區域變數，並對該變數呼叫此方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">'{0}' 不是有效的警告編號</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">不是有效的警告號碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">傳遞給 #pragma 警告前置處理器指示詞的號碼不是有效的警告號碼。請驗證號碼代表警告，而不是錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">數字無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">對前置處理器指示詞指定了無效的檔名。檔名太長或者不是有效的檔名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">針對前置處理器指示詞所指定的檔名無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">#pragma checksum 語法無效; 應該是 #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">#pragma 總和檢查碼語法無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">必須是單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">#pragma 指示詞後面必須有單行註解或行結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">為 '{0}' 指定了不同的總和檢查碼值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">指定不同的 #pragma 總和檢查碼值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">組件參考 '{0}' 無效，無法解析</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">組件參考無效，無法進行解析</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">此警告指出未正確地指定屬性 (例如 InternalsVisibleToAttribute)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">假設 '{1}' 所使用的組件參考 '{0}' 符合 '{3}' 的識別 '{2}'，您可能會需要提供執行階段原則</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">假設組件參考符合識別</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">兩個組件的版次和 (或) 版本號碼不同。若要進行統一，您必須在應用程式的 .config 檔案中指定指示詞，而且您必須提供組件的正確強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">假設 '{1}' 所使用的組件參考 '{0}' 符合 '{3}' 的識別 '{2}'，您可能會需要提供執行階段原則</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">假設組件參考符合識別</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">兩個組件的版次和 (或) 版本號碼不同。若要進行統一，您必須在應用程式的 .config 檔案中指定指示詞，而且您必須提供組件的正確強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">已匯入具有相同識別的多個組件: '{0}' 和 '{1}'。請移除其中一個重複的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">匯入了具有相同簡單名稱 '{0}' 的組件。請嘗試移除其中一個參考 (例如 '{1}')，或簽署它們以啟用並存。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">識別為 '{1}' 的組件 '{0}' 會使用 '{2}'，而後者的版本高於識別為 '{4}' 的參考組件 '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">固定大小緩衝區只能透過區域變數或欄位存取</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">XML 註解中的 '{0}' 有重複的 typeparam 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">XML 註解中有重複的 typeparam 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">XML 註解中的 '{0}' 有 typeparam 標籤，但沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">XML 註解具有 typeparam 標籤，但是沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">'{1}' 上的 XML 註解中的 '{0}' 有 typeparamref 標籤，但沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">XML 註解具有 typeparamref 標籤，但是沒有該名稱的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">類型參數 '{0}' 在 '{1}' 的 XML 註解中沒有相符的 typeparam 標籤 (但是其他類型參數有)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">在 XML 註解中，類型參數沒有相符的 typeparam 標籤 (但其他類型參數則相反)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 類型必須是 '{2}' 才符合覆寫的成員 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">請勿使用 'System.Runtime.CompilerServices.FixedBuffer' 屬性。請改用 'fixed' 欄位修飾元。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">對同一個變數進行指派; 您是否想要指派別的東西?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">對相同變數進行的指派</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">對同一個變數進行比較; 您是否想要比較別的東西?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">對相同變數進行的比較</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">開啟 Win32 資源檔 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">運算式一律會造成 System.NullReferenceException，因為 '{0}' 的預設值為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">運算式一律會造成 System.NullReferenceException，因為類型的預設值為 null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">類別 '{0}' 不可有多重基底類別: '{1}' 和 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">基底類別 '{0}' 必須在所有介面之前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">XML 註解具有參考類型參數的 cref 屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">XML 註解具有參考類型參數的 cref 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Friend 組件參考 '{0}' 無效。InternalsVisibleTo 宣告不可指定版本、文化特性、公開金鑰語彙基元或處理器架構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Friend 組件參考 '{0}' 無效。以強式名稱簽署的組件，在其 InternalsVisibleTo 宣告中必須指定公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">無法將委派繫結至 '{0}'，因為其為 'System.Nullable&lt;T&gt;' 的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'{0}' 未包含使用 {1} 個引數的建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">組件和模組屬性必須位於檔案中所有定義的其他項目之前 (using 子句與外部別名宣告除外)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">必須是運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">/subsystemversion 的版本 {0} 無效。ARM 或 AppContainerExe 的版本必須是 6.02 (含) 以上的版本，其他則必須是 4.00 (含) 以上的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">內嵌 Interop 方法 '{0}' 包含主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be zero or greater</source>
        <target state="translated">警告層級必須大於或等於零</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">/debug 的選項 '{0}' 無效; 必須為 'portable'、'embedded'、'full' 或 'pdbonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">選項 '{0}' 無效; 資源可見度必須是 'public' 或 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">DefaultParameterValue 屬性的引數類型和參數類型必須相符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">類型 '{0}' 的引數不適用於 DefaultParameterValue 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">成員 '{0}' 的初始設定重複</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">成員 '{0}' 無法進行初始設定，它不是欄位或屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">無法在物件初始設定式中指派靜態欄位或屬性 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">類型為 '{1}' 的唯讀欄位 '{0}' 之成員，無法以物件初始設定式進行指派，因為其為實值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">類型 '{1}' 且屬性為 '{0}' 的成員，無法以物件初始設定式進行指派，因為其為實值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">建立物件時不能使用 Unsafe 類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">項目初始設定式不可為空白</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">最符合 '{0}' 的多載方法，沒有正確的初始設定式元素簽章。可初始化的 Add 必須是可存取的執行個體方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">無法使用集合初始設定式來初始設定類型 '{0}'，因為其未實作 'System.Collections.IEnumerable'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">讀取 Win32 資訊清單檔 '{0}' 時發生錯誤 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">因為模組的 /win32manifest 僅適用於組件，因此將予以忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">因為模組的 /win32manifest 僅適用於組件，因此將予以忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'{0}' 未包含 '{1}' 的定義，且最佳擴充方法多載 '{2}' 需要類型 '{3}' 的接收器</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">已宣告範圍變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">範圍變數 '{0}' 與之前的 '{0}' 宣告相衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">無法指派 {0} 至範圍變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。請考慮明確地指定範圍變數 '{2}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。是否遺漏了必要的組件參考或 'System.Linq' 的 using 指示詞?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">找不到來源類型 '{0}' 的查詢模式實作。找不到 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名稱 '{0}' 不在 'equals' 左側的範圍內。請考慮交換 'equals' 任一側的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名稱 '{0}' 不在 'equals' 右側的範圍內。請考慮交換 'equals' 任一側的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">無法將範圍變數 '{0}' 以 out 或 ref 參數的方式傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">為來源類型 '{0}' 找到多個查詢模式實作。模稜兩可的 '{1}' 呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 子句中的其中一個運算式類型不正確。呼叫 '{1}' 時發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 子句中的運算式類型不正確。呼叫 '{1}' 時發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">在具來源類型為 '{1}' 的查詢運算式內的後續 from 子句中，不可使用類型 '{0}' 的運算式。呼叫 '{2}' 時，發生類型推斷失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">運算式樹狀結構不可包含 unsafe 指標作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">運算式樹狀結構不可包含匿名方法運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">匿名方法運算式無法轉換成運算式樹狀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">無法指派為範圍變數 '{0}' -- 其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">範圍變數 '{0}' 不可與方法類型參數同名</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">無法在範圍變數宣告中使用內容關鍵字 'var'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">集合初始設定式最符合的多載 Add 方法 '{0}'，有一些無效的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含具有變數引數的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含方法群組</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">無法使用集合初始設定式項目最符合的多載方法 '{0}'。集合初始設定式 'Add' 方法不能具有 ref 或 out 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">非可叫用成員 '{0}' 不能用做為方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">成員 '{0}' 會實作類型 '{2}' 的介面成員 '{1}'。在執行階段發現多個相符的介面成員。實作將會視所呼叫的方法而定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">成員會在執行階段實作具有多個相符項的介面成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">當兩介面方法的差異只在於特定參數的標記方式是 ref 還是 out 時，便可能產生此警告。因為在執行階段所呼叫方法既不明顯，也沒辦法預先確認，所以最好變更程式碼來避免此警告。

雖然 C# 會區分 out 與 ref，但是 CLR 會將它們視為相同。決定實作介面的方法時，CLR 只會選擇其中一個。

請為編譯器提供呼叫方法的區分方式。例如，您可以為它們指定不同的名稱，或在其上提供其他參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</source>
        <target state="translated">成員 '{1}' 會覆寫 '{0}'。在執行階段有多個覆寫候選項。呼叫的方法視實作而定。請使用較新的執行階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">成員會在執行階段覆寫具有多個覆寫候選項的基底成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">物件與集合初始設定式運算式不可套用到委派建立運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'{0}' 為類型 '{1}'。常數宣告中指定的類型，必須為 sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、string、列舉類型或參考類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">找不到原始程式檔 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">已指定多次原始程式檔 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">已指定多次原始程式檔</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">遺漏 '{0}' 選項的檔案規格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">命令列語法錯誤: 遺漏 '{1}' 選項的 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">選項無法辨認: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">未指定任何原始程式檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">未指定任何原始程式檔</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">必須是指令碼 (.csx 檔)，但未指定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">開啟回應檔 '{0}' 時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">無法開啟 '{0}' 進行寫入 -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">映像基底編號 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'{0}' 是二進位檔案而非文字檔</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">字碼頁 '{0}' 無效或未安裝</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">不支援演算法 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">在建置模組或程式庫時不能指定 /main</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">/target: 的目標類型無效。必須指定 'exe'、'winexe'、'library' 或 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">因為在回應檔中已指定 /noconfig 選項，所以將會忽略該選項</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">因為在回應檔中已指定 /noconfig 選項，所以將會忽略該選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">無效的檔案區段記憶體對齊 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">無效的輸出名稱: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">無效的偵錯資訊格式: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'不再支援 'id#' 語法。請改用 '$id'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; '{0}' 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">無法建立短的檔名 '{0}'，因為已有長檔名的名稱和該短檔名相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">宣告外部別名的 /reference 選項只能有一個檔名。若要指定多個別名或檔名，請用多個 /reference 選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">命令列語法錯誤: 遺漏 '{0}' 選項的 ':&lt;number&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">/pdb 選項需要同時使用 /debug 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含引數上省略 ref 的 COM 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">命令列語法錯誤: 選項 '{1}' 的 Guid 格式 '{0}' 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">命令列語法錯誤: 遺漏選項 '{1}' 的 Guid</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">具有變數引數的方法不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">具有變數引數的方法不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">引數類型 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">引數類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">'{0}' 的傳回類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">傳回類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">'{0}' 的類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">公用、保護或保護內部變數的類型必須符合 Common Language Specification (CLS) 規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">只有大小寫不相同的識別項 '{0}'，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">只有大小寫不同的識別項，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">只有 ref/out 或陣列陣序差異的多載方法 '{0}'，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">只有 ref/out 或陣列陣序差異的多載方法，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">只有未命名陣列類型有差異的多載方法 '{0}'，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">只有未命名陣列類型有差異的多載方法，不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">如果您的多載方法採用不規則陣列，而且方法簽章之間的唯一差異是陣列的項目類型，則會發生此錯誤。若要避免此錯誤，請考慮使用矩形陣列，而非不規則陣列; 請使用其他參數來釐清函式呼叫; 請重新命名一個或多個多載方法; 或者，如果不需要符合 CLS 規範，請移除 CLSCompliantAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">識別項 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">識別項不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}': 基底類型 '{1}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">基底類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">在標記為符合 CLS 規範的組件中，基底類型標記為不需要符合 Common Language Specification (CLS) 規範。移除指定組件符合 CLS 規範的屬性，或移除指出類型不符合 CLS 規範的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'{0}': 符合 CLS 規範的介面內，所有成員都必須符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">符合 CLS 規範的介面內，所有成員都必須符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'{0}': 只有符合 CLS 規範的成員，才可為抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">只有符合 CLS 規範的成員，才可為抽象</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">您必須在組件 (而非模組) 上指定 CLSCompliant 屬性，以啟用 CLS 合規性檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">您必須在組件 (而非模組) 上指定 CLSCompliant 屬性，以啟用 CLS 合規性檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">新增的模組必須以 CLSCompliant 屬性標記，才能與這個組件相符</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">新增的模組必須以 CLSCompliant 屬性標記，才能與這個組件相符</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'因為組件沒有 CLSCompliant 屬性，所以 '{0}' 不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">因為組件沒有 CLSCompliant 屬性，所以類型或成員不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'{0}' 沒有僅使用符合 CLS 規範之類型的可存取建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">類型沒有僅使用符合 CLS 規範之類型的可存取建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">以陣列做為屬性引數不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">以陣列做為屬性引數不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">在模組上指定的 CLSCompliant 屬性不能與組件上的 CLSCompliant 屬性不同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">在模組上指定的 CLSCompliant 屬性不能與組件上的 CLSCompliant 屬性不同</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'因為 '{0}' 是不符合 CLS 規範之類型 '{1}' 的成員，所以不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">因為類型是不符合 CLS 規範之類型的成員，所以不可標記為符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">將不會在 '{0}' 上執行 CLS 合規性檢查，因為從此組件之外無法看到它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">將不會執行 CLS 合規性檢查，因為這個組件不是外部可見的</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'{0}' 不需要 CLSCompliant 屬性，因為組件並沒有 CLSCompliant 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">因為組件沒有 CLSCompliant 屬性，所以類型或成員不需要 CLSCompliant 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 屬性套用在參數上沒有意義，請改為置於方法上。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">CLSCompliant 屬性在套用至參數時沒有任何意義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 屬性套用至傳回類型沒有意義，請改為置於方法上。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">CLSCompliant 屬性在套用至傳回類型時沒有任何意義</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">條件約束類型 '{0}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">條件約束類型不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">符合 CLS 規範的欄位 '{0}' 不可為 Volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">符合 CLS 規範的欄位不可為 volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}' 不符合 CLS 規範，因為基底介面 '{1}' 不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">類型不符合 CLS 規範，因為基底介面不符合 CLS 規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">'await' 要求類型 {0} 必須要有適合的 GetAwaiter 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">無法等候 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">'await' 要求 '{1}.GetAwaiter()' 的傳回類型 '{0}' 必須是適合的 IsCompleted、OnCompleted 和 GetResult 成員，且實作 INotifyCompletion 或 ICriticalNotifyCompletion。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">'await' 要求類型 '{0}' 必須要有適合的 GetAwaiter 方法。是否遺漏了 'System' 的 using 指示詞?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">無法等候 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'await' 不能當做非同步方法或 Lambda 運算式中的識別項使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'{0}' 未實作 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression</source>
        <target state="translated">因為 '{0}' 是個會傳回 '{1}' 的非同步方法，所以傳回關鍵字之後不可接著物件運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">非同步方法的傳回類型必須為 void、Task、Task&lt;T&gt;、task-like 類型、IAsyncEnumerable&lt;T&gt; 或 IAsyncEnumerator&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">無法傳回類型 'void' 的運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">非同步方法的參數清單中不可出現 __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>Instance of type '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">無法保留 'await' 或 'yield' 界限之間的執行個體類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have pointer type parameters</source>
        <target state="translated">非同步方法不能具有指標型別參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">非同步方法不可出現 ref、in 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">await' 運算子只有在包含於以 'async' 修飾元標記的方法或 Lambda 運算式中時，才可使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">await' 運算子只可用在非同步 {0} 中。請考慮以 'async' 修飾元標記此 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">await' 運算子只可用在非同步方法中。請考慮以 'async' 修飾元標記此方法，並將其傳回類型變更為 'Task&lt;{0}&gt;'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">await' 運算子只可用於非同步方法中。請考慮以 'async' 修飾元標記此方法，並將其傳回類型變更為 'Task'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">無法在 finally 子句的主體中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">無法在 catch 子句中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">無法在 catch 子句的篩選條件運算式中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">無法在 lock 陳述式的主體中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">await' 運算子不可用於靜態指令碼變數初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">無法在不安全的內容中等候</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">async' 修飾元只可用於具有主體的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">安全屬性 '{0}' 無法套用至非同步方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">具有 'SecurityCritical' 或 'SecuritySafeCritical' 屬性的介面、類別或結構中，不可使用非同步方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">await' 運算子只能用在初始 'from' 子句的第一個集合運算式或 'join' 子句的集合運算式中的查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">這個非同步方法缺少 'await' 運算子，因此將以同步方式執行。請考慮使用 'await' 運算子等候未封鎖的應用程式開發介面呼叫，或使用 'await Task.Run(...)' 在背景執行緒上執行 CPU-bound 工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">Async 方法缺乏 'await' 運算子，將同步執行</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">因為未等候此呼叫，所以在呼叫完成之前會繼續執行目前的方法。請考慮將 'await' 運算子套用至呼叫的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">因為未等待此呼叫，所以在完成呼叫之前會繼續執行目前方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">目前方法會呼叫傳回 Task 或 Task&lt;TResult&gt; 的 async 方法，而且不會將 await 運算子套用至結果。呼叫 async 方法會啟動非同步工作。不過，因為未套用 await 運算子，所以程式會繼續進行，而不會等待工作完成。在大多數情況下，該行為不會是您預期的行為。通常，calling 方法的其他層面取決於呼叫結果，或者至少必須先 called 方法，您才能從包含該呼叫的方法傳回。

另一個同樣重要的問題是，在 called async 方法中所引發的例外狀況會發生什麼情況。傳回 Task 或 Task&lt;TResult&gt; 之方法中所引發的例外狀況，會儲存在傳回的工作中。如果您不等待工作或明確地檢查例外狀況，則會遺失例外狀況。如果您等待工作，則會重新擲出其例外狀況。

最佳做法是一律等待呼叫。

只有在確定不想要等待非同步呼叫完成，且 called 方法不會引發任何例外狀況時，才應該考慮隱藏警告。在該情況下，將呼叫的工作結果指派給變數，即可隱藏警告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'MethodImplOptions.Synchronized' 無法套用至非同步方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerLineNumberAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerFilePathAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">無法套用 CallerMemberNameAttribute，因為沒有從類型 '{0}' 標準轉換成類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute 只能套用至具有預設值的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerLineNumberAttribute 將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute 將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerFilePathAttribute 將沒有作用，因為它套用到不允許選擇性引數的內容中所使用的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerFilePathAttribute 將沒有作用，因為它套用到不允許選擇性引數的內容中所使用的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">程式未包含適合進入點的靜態 'Main' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">必須是長度為 '{0}' 的陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">必須是巢狀的陣列初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">變異數修飾元無效。只有介面及委派類型參數才可指定為變異數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">未預期的別名用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">未預期的泛型名稱用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">未預期的未繫結泛型名稱用法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">運算式與陳述式只可出現在方法主體中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">陣列存取不能有具名引數規範</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">尚未實作語言功能 ('{0}')。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">預設值在此內容中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">開啟圖示檔 {0} 時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">開啟 Win32 資訊清單檔案 {0} 時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">建置 Win32 資源時發生錯誤 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">選擇性參數必須出現在所有必要參數之後</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">無法繼承具有指定之類型參數的介面 '{0}'，因為其會讓方法 '{1}' 包含只有在 ref 和 out 上有所差異的多載</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">'{0}' 的部分宣告必須具有相同順序的相同類型參數名稱與變異數修飾元</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">變異數無效: 類型參數 '{1}' 必須是在 '{0}' 上有效的 {3}。'{1}' 是 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'{0}': 無法衍生自動態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'{0}': 無法實作動態介面 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">條件約束不可為動態類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">條件約束不可為動態類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">找不到編譯動態運算式所需的一或多種類型。您是否遺漏了參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">名稱 '{0}' 超過中繼資料內所允許的長度上限。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">屬性在此內容中無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'extern alias' 在此內容中無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">使用 '{0}' 測試與 '{1}' 的相容性，基本上和測試與 '{2}' 的相容性是一樣的，而且對所有非 null 值都會成功</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">使用 'is' 測試與 'dynamic' 的相容性，基本上與測試與 'Object' 的相容性相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">無法在頂層指令碼中使用 'yield'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">無法在指令碼中宣告命名空間</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">此內容中不可使用組件與模組屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">委派 '{0}' 沒有叫用方法，或是叫用方法包含了不支援的傳回類型或參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global code; ignoring '{0}' entry point.</source>
        <target state="translated">程式的進入點是全域程式碼; 將略過 '{0}' 進入點。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global code; ignoring entry point</source>
        <target state="translated">程式的進入點是全域程式碼; 將忽略進入點</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">不一致的存取範圍: 事件類型 '{1}' 比事件 '{0}' 的存取範圍小</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">必須在所有固定引數皆已指定之後，具名引數規格才可出現。請使用語言版本 {0} 或更高的版本，以允許非後置的具名引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">必須在所有固定引數皆已在動態引動過程中指定之後，具名引數規格才可出現。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">最符合 '{0}' 的多載，沒有名稱為 '{1}' 的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">委派 '{0}' 沒有名稱為 '{1}' 的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">不可指定多次具名引數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">具名引數 '{0}' 會指定已指定其位置引數的參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">具名引數 '{0}' 未用在正確的位置，但後面接著未命名引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">不能連同 DefaultParameterAttribute 或 OptionalAttribute 一起指定預設參數值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">'{0}' 的預設參數值必須是編譯時期的常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">ref 或 out 參數不能有預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">無法指定 'this' 參數的預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter collection</source>
        <target state="translated">無法指定參數收集的預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">類型 '{0}' 的值不可用做為預設參數，因為沒有標準轉換至類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">類型 '{0}' 的值不可用做為可為 Null 之參數 '{1}' 的預設參數，因為 '{0}' 不是簡單類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'{0}' 為類型 '{1}'。非字串之參考類型的預設參數值，只能以 null 初始設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">為參數 '{0}' 指定的預設值將沒有作用，因為它套用到了不允許選擇性引數的內容中所使用之成員</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">指定的預設值將沒有效果，因為它所套用到的成員是用在不允許選擇性引數的內容</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">使用檔案 '{0}' 的公開金鑰簽署輸出時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">使用容器 '{0}' 的公開金鑰簽署輸出時發生錯誤 -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">typeof 運算子不能用於動態類型上</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">運算式樹狀結構不可包含動態作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">非同步 Lambda 運算式不可轉換成運算式樹狀結構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">無法定義利用 'dynamic' 的類別或成員，因為找不到編譯器的必要類型 '{0}'。是否遺漏了參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">無法傳遞 Null 做為 Friend 組件名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">金鑰檔案 '{0}' 遺漏簽署所需的私密金鑰</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">公開簽章已指定且需要公開金鑰，但並未指定任何公開金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">對 netmodule 不支援公開簽署。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">指定了延遲簽署且需要公開金鑰，但未指定任何公開金鑰</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">指定了延遲簽署且需要公開金鑰，但未指定任何公開金鑰</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">指定的版本字串 '{0}' 不符合所需的格式 - major[.minor[.build[.revision]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">指定的版本字串 '{0}' 包含萬用字元，但這與確定性不相容。請移除版本字串中的萬用字元，或停用此編譯的確定性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">指定的版本字串 '{0}' 不符合所需的格式: major.minor.build.revision (不含萬用字元)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定的版本字串 '{0}' 不符合建議的格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定的版本字串不符合建議的格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">可執行檔不可為附屬組件; 文化特性需保留為空白</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</source>
        <target state="translated">未提供任何可對應到 '{1}' 之必要參數 '{0}' 的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">命令列參數 '{0}' 尚未獲實作，已忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">尚未實作命令列參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">無法發出模組 '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">無法在匿名方法、Lambda 運算式或查詢運算式中，使用固定的區域變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">運算式樹狀結構不可包含具名引數規格</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">運算式樹狀結構不可包含使用選擇性引數的呼叫或引動過程</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">運算式樹狀結構不可包含具備索引的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">索引屬性 '{0}' 有必須提供的非選擇性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">索引屬性 '{0}' 的所有引數都必須是選擇性引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">類型 '{0}' 的執行個體不可用於巢狀函式、查詢運算式、迭代區塊或非同步方法中</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">安全屬性的第一個引數必須是有效的 SecurityAction</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">安全屬性 '{0}' 出現無效的 SecurityAction 值 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">SecurityAction 值 '{0}' 對套用至組件的安全屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">SecurityAction 值 '{0}' 對套用至類型或方法的安全屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">SecurityAction 值 '{0}' 對 PrincipalPermission 屬性無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">運算式樹狀結構不可包含 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">無法解析為 PermissionSet 屬性的具名引數 '{1}' 所指定之檔案路徑 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">讀取為 PermissionSet 屬性的具名引數 '{1}' 所定之檔案 '{0}' 時，發生錯誤: '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">全域命名空間中找不到類型名稱 '{0}'。此類型已轉送到組件 '{1}'，請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">命名空間 '{1}' 中找不到類型名稱 '{0}'。此類型已轉送到組件 '{2}'，請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">找不到類型名稱 '{0}'。此類型已經轉送給組件 '{1}'。請考慮加入該組件的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">組件 '{0}' 和 '{1}' 參考相同的中繼資料，但只有一個是連結的參考 (使用 /link 選項指定); 請考慮移除其中一個參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">集合初始設定式項目最符合的多載 Add 方法已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">集合初始設定式項目最符合的多載 Add 方法已經過時</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">集合初始設定式元素最符合的多載 Add 方法 '{0}' 已經過時。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">安全屬性 '{0}' 在此宣告類型上無效。安全屬性只有在組件、類型和方法宣告上才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">無法將類型 '{0}' 的運算式用做為動態分派作業的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">無法將 Lambda 運算式用做為動態分派作業的引數，但卻未先將其轉型為委派或運算式樹狀結構類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">無法將方法群組用做為動態分派作業的引數。原本希望叫用此方法嗎?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">方法 '{0}' 的呼叫必須以動態方式分派，但因為它是基底存取運算式的一部分，所以無法動態分派。請考慮將動態引數轉型，或排除基底存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">不允許透過來源類型 'dynamic' 或使用類型 'dynamic' 之聯結序列的查詢運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">索引子存取必須以動態方式分派，但因為其為基底存取運算式的一部分，所以無法動態分派。請考慮將動態引數轉型，或排除基底存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">以動態方式將呼叫分派至方法 '{0}' 可能會在執行階段失敗，因為有一個或多個適用的多載為條件式方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">以動態分派的呼叫可能會在執行階段失敗，因為一個或多個適用的多載是條件式方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">'{0}' 沒有名稱為 '{1}' 的適用方法，但似乎有使用該名稱的擴充方法。擴充方法不可以動態方式分派。請考慮將動態引數轉型，或不要利用擴充方法語法來呼叫擴充方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為 CallerFilePathAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果; CallerFilePathAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerMemberNameAttribute 將沒有作用，因為 CallerLineNumberAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerMemberNameAttribute 將沒有效果; CallerLineNumberAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">套用到參數 '{0}' 的 CallerFilePathAttribute 將沒有作用，因為 CallerLineNumberAttribute 會覆寫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerFilePathAttribute 將沒有效果; CallerLineNumberAttribute 會覆寫它</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">運算式必須可隱含轉換成布林值，或是其類型 '{0}' 必須定義運算子 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'{0}' 不可實作 '{1}'，因為 '{2}' 是 Windows 執行階段事件，而 '{3}' 是一般 .NET 事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">於配置的 {0} 執行個體的所有參考都超出範圍之前，在該執行個體上呼叫 System.IDisposable.Dispose()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">在所配置執行個體的所有參考超出範圍之前，對其呼叫 System.IDisposable.Dispose()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">配置的 {0} 執行個體並非沿著所有例外狀況路徑處置。請在其所有參考都超出範圍之前，呼叫 System.IDisposable.Dispose()。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">所配置的執行個體未沿著所有例外路徑處置</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">可以多次處置物件 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">可以多次處置物件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">無法內嵌 Interop 類型 '{0}'。請改用適當的介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌類型 '{0}'，因為其為巢狀類型。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌類型 '{0}'，因為它有泛型引數。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">內嵌 Interop 結構 '{0}' 只可包含公用執行個體欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Windows 執行階段事件不可以 out 或 ref 參數形式傳遞。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">來源介面 '{0}' 遺漏了內嵌事件 '{2}' 所需的方法 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">介面 '{0}' 的來源介面無效，但內嵌事件 '{1}' 需要該介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">無法內嵌 Interop 類型 '{0}'，因為其遺漏必要的 '{1}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">無法從組件 '{0}' 內嵌 Interop 類型，因為其遺漏了 '{1}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">無法從組件 '{0}' 內嵌 Interop 類型，因為其遺漏了 '{1}' 屬性或 '{2}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">無法內嵌組件 '{1}' 和 '{2}' 中都有的 Interop 類型 '{0}'。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">從組件 '{1}' 內嵌 Interop 類型 '{0}'，會造成目前組件中的名稱衝相突。請考慮將 [內嵌 Interop 類型] 屬性設定為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">已建立內嵌 Interop 組件 '{0}' 的參考，因為該組件的間接參考已由組件 '{1}' 所建立。請考慮變更其中任一組件的 [內嵌 Interop 類型] 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">已建立內嵌 Interop 組件的參考，因為參考間接組件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">您已使用 /link 新增組件參考 (內嵌 Interop 類型屬性設定為 True)。這會指示編譯器內嵌該組件中的 Interop 類型資訊。不過，編譯器無法內嵌該組件中的 Interop 類型資訊，因為您已參考的另一個組件也會使用 /reference 來參考該組件 (內嵌 Interop 類型屬性設定為 False)。

若要內嵌兩個組件的 Interop 類型資訊，請針對每一個組件參考使用 /link (內嵌 Interop 類型屬性設定為 True)。

若要移除警告，您可以改用 /reference (內嵌 Interop 類型屬性設定為 False)。在此情況下，主要 Interop 組件 (PIA) 會提供 Interop 類型資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">因為組件 '{1}' 的類型 '{0}' 具有屬於內嵌 Interop 類型的泛型類型引數，所以不可跨組件的界限使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">找不到符合內嵌 Interop 類型 '{0}' 的 Interop 類型。是否遺漏了組件參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">儲存在 '{1}' 中的模組名稱 '{0}'，必須符合其檔案名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">模組名稱 {0} 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">無效的 '{0}' 值: '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath 必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">將會忽略模組 '{1}' 中的屬性 '{0}'，改用出現在來源中的執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">因來源中出現的執行個體，將會忽略屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">原始程式檔中所提供的屬性 '{0}'，與選項 '{1}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">固定緩衝區只能有一個維度。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">參考組件 '{0}' 沒有強式名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">參考的組件沒有強式名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">AssemblySignatureKeyAttribute 中指定的簽章公開金鑰無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">從模組 '{1}' 匯出的類型 '{0}' 與此組件的主要模組中所宣告之類型相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">從模組 '{1}' 匯出的類型 '{0}' 與從模組 '{3}' 匯出的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">轉送的類型 '{0}' 與此組件主要模組中所宣告的類型相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">轉送到組件 '{1}' 的類型 '{0}' 與轉送到組件 '{3}' 的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">轉送到組件 '{1}' 的類型 '{0}' 與從模組 '{3}' 匯出的類型 '{2}' 相衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">參考組件 '{0}' 有不同的文化特性設定 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">參考的組件具有不同文化特性設定</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">無從驗證的組件不可有處理器專屬的模組 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">組件與模組 '{0}' 的目標處理器不可不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">參考組件 '{0}' 以不同的處理器為目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">參考的組件以不同的處理器為目標</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">建立雜湊時密碼編譯失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">遺漏 '{0}' netmodule 的參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">模組 '{0}' 已定義在此組件中。每個模組都必須要有不重複的檔案名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">無法讀取組態檔 '{0}' -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">無法繼續，因為編輯包含內嵌類型的參考: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">在目前偵錯工作階段期間加入的成員 '{0}'，只能從其宣告組件中 '{1}' 存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">不得同時指定編輯選項 '{0}' 與 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">連結的 netmodule 中繼資料必須提供完整的 PE 影像: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred 只可與 /t:exe、/t:winexe 和 /t:appcontainerexe 一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;路徑清單&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;文字&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">null 散佈運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">運算式主體方法</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">運算式主體屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">運算式主體索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">Auto 屬性初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;命名空間&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">Byref 本機與傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">唯讀參考</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">編譯 (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">語法節點不在語法樹狀結構內</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必須提供位置，才可提供最基本的類型限定性條件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必須提供 SyntaxTreeSemanticModel，才可提供最基本的類型限定性條件。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">無法從 {1} 編譯來參考類型為 '{0}' 的編譯</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">語法樹狀結構已存在</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">提交只能包含指令碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">提交最多可以有一個語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">樹狀結構必須要有包含 SyntaxKind.CompilationUnit 的根節點</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">類型引數不可為 null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">類型引數的數目錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">名稱 {0} 發生名稱衝突</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions 的選項組合無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">項目: 不可為空白</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier 或 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier 來建立識別項語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 來建立字元常值語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 來建立數值常值語彙基元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">此方法只可用以建立語彙基元 - {0} 不是語彙基元種類。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">泛型參數為定義，但其必須是參考 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">為可能包含多重變數宣告子的宣告節點，呼叫了 GetDeclarationName。</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">位置不在有完整範圍 {0} 的語法樹狀結構內</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">語言名稱 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">語言名稱無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">透明識別項成員存取 '{1}' 的欄位 '{0}' 失敗。目前正在查詢的資料是否會實作查詢模式?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">此參數有多個相異的預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">此欄位有多個相異的常數值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">在 cref 屬性中，泛型類型的巢狀類型必須符合規定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">在 cref 屬性中，泛型類型的巢狀類型必須符合規定</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">不是 C# 符號。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">不必要的 using 指示詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">未使用的外部別名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">項目不可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">LIB 環境變數</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">/LIB 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH 選項</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">目錄不存在</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">路徑太長或無效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">找不到 RuntimeMetadataVersion 的值。找不到任何包含 System.Object 的組件，也未透過選項指定 RuntimeMetadataVersion 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">找不到 RuntimeMetadataVersion 的值</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">必須是 {0} SemanticModel。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">Lambda 運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">C# 1 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">C# 2 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">C# 3 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">C# 4 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">C# 5 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">C# 6 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.0 中未提供功能 '{0}'。請使用語言版本 {1} 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'「實驗」</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">位置必須在語法樹狀結構的範圍內。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">要推測的語法節點，不可屬於目前編譯的語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">不支援鏈結理論式語意模型。應從非理論式 ParentModel 建立理論式模型。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Microsoft (R) Visual C# 編譯器</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} 版 {1} </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">支援的語言版本:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'{0}': 具有 ComImport 屬性的類別不可指定欄位初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">區域變數名稱 '{0}' 對 PDB 而言太長。請考慮將其縮短，或在編譯時不要使用 /debug。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">PDB 的本機名稱太長</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">轉換成 void 傳回委派的匿名函式，不可傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a '{0}' returning delegate cannot return a value</source>
        <target state="translated">轉換成 '{0}' 傳回委派的非同步 Lambda 運算式，不可傳回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">不可從 {1} 建立分析器 {0} 的執行個體: {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">無法建立分析器執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">組件 {0} 不包含任何分析器。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">組件不包含任何分析器</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">無法載入分析器組件 {0} : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">無法載入分析器組件</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">因為 ReflectionTypeLoadException 之故，所以略過分析器組件 {0} 中的某些類型: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">讀取規則集檔案 {0} 時發生錯誤 - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">讀取 '{0}' 的偵錯資訊時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">作業導致了堆疊溢位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">必須是識別項或數值常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">必須是識別項或數值常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties can have initializers.</source>
        <target state="translated">只有自動實作的屬性可以有初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">自動實作的屬性必須要有 get 存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">自動實作的屬性必須覆寫已覆寫屬性的所有存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">沒有明確建構函式的結構，不可包含有初始設定式的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">無法在不編碼的情況下，對原始程式文字發出偵錯資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">不可同時提供區塊主體與運算式主體。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">控制項的位置不可位於最後一個 case 標籤 ('{0}') 的參數之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">Nameof 運算子中不可使用類型引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含 null 散佈運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">運算式樹狀架構 Lambda 不可包含字典初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">運算式 Lambda 中的集合初始設定式不支援擴充功能 Add 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">nameof 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">字典初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">以 '{' 開頭的插入運算式遺漏結束分隔符號 '}' </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">差補字串中不能使用單行註解。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">運算式太長或太複雜，造成編譯困難</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">運算式沒有名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">nameof 的引數中不可使用子運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">別名限定的名稱不是運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">方法群組上不可使用類型參數做為 'nameof' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">必須是 SearchCriteria。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">組件文化特性字串可能不包含內嵌的 NUL 字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">使用靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">內插字串</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">等待於 catch 區塊與 finally 區塊中</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">二進位常值</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">數字分隔符號</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">區域函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">在差補字串中，必須將 '{0}' 字元逸出 (重複兩次)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">在差補字串中，只能以重複兩次 ('{0}{0}') 的方式，將 '{0}' 字元逸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">格式規範的尾端不可以是空白字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">空白的格式規範。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">參考組件 '{0}' 中有錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">必須是運算式或宣告陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">擴充方法群組不允許做為 'nameof' 的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">對齊值 {0} 的範圍大於 {1}，而且可能會導致大型格式化字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">未使用的外部別名</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">不必要的 using 指示詞</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">跳過載入分析器組件中因 ReflectionTypeLoadException 而失敗的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">對齊值的範圍可能會導致大型格式化字串</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">從串連產生的字串常數長度超過 System.Int32.MaxValue。請嘗試將字串分割為多個常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">元組必須包含至少兩個項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">偵錯進入點必須是目前編譯中所宣告方法的定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load 只允許用於指令碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">無法在檔案中第一個語彙基元後使用 #load</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">找不到檔案。</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">SyntaxTree 從 #load 指示詞所產生，無法直接移除或取代。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">不支援原始程式檔參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">pathmap 選項格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">無效的實際常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">無法藉傳址方式傳回自動實作屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">藉傳址方式傳回的屬性必須有 get 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">藉傳址方式傳回的屬性不能有 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">'{0}' 必須符合覆寫成員 '{1}' 的藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">藉傳址傳回只能用於藉傳址方式傳回的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">傳值傳回只能用於以傳值方式傳回的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">傳回運算式的類型必須是類型 '{0}'，因為此方法藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。因為 '{2}' 沒有相符的藉傳址方式傳回，所以無法實作 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">'{0}' 的主體不可是迭代區塊，因為 '{0}' 是藉傳址方式傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">無法將藉傳址方式傳回的 Lambda 運算式轉換為運算式樹狀架構</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">運算式樹狀架構 Lambda 不能包含呼叫藉傳址方式傳回的方法、屬性或索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">因為參考可能不會傳遞或傳回運算式，所以無法於此內容中使用運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因為已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">無法藉傳址方式傳回 '{0}' 的成員，因為已將其初始化為無法藉傳址方式傳回的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因其為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">無法藉傳址方式傳回範圍變數 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">無法藉傳址方式傳回 '{0}'，因其為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回唯讀欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回靜態的唯讀欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回唯讀欄位 '{0}' 的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">無法以可寫入傳址方式傳回靜態唯讀欄位 '{0}' 的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref parameter</source>
        <target state="translated">無法藉傳址 '{0}' 傳回參數，因為其非 ref 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">無法藉傳址方式傳回參數 '{0}' 的成員，因為它不是 ref 或 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">無法藉傳址方式傳回本機 '{0}'，因為其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">無法藉傳址方式傳回本機 '{0}' 的成員，因為其非參考本機</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">結構成員無法藉傳址方式傳回 'this' 或其他執行個體成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用運算式，因為它會在其宣告範圍外間接公開變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用 '{0}' 的結果，因為它會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">無法在此內容中使用 '{0}' 結果的成員，因為它會將參數 '{1}' 參考的變數公開在其宣告範圍外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">不允許對 '{0}' 使用此引數組合，因為它會在其宣告範圍外公開參數 '{1}' 所參考的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ref 條件運算子的分支不能參考具有不相容宣告範圍的變數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">無法在此內容中使用類型 '{0}' 的 stackalloc 運算式結果，因為它會公開在包含方法之外</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">無法使用參考將傳值變數初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">無法使用值將傳址變數初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">運算式的類型必須是類型 '{0}'，因為其藉傳址方式指派</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">傳址變數的宣告必須具有初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">無法在匿名方法、Lambda 運算式或查詢運算式中使用參考本機 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">對 '{0}' 之呼叫所傳回的參考無法在 'await' 或 'yield' 界限間保留。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'包含 ref 條件運算子的運算式無法使用 'await'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">這兩個條件運算子的值都必須是 ref 值，或兩個都不是 ref 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">運算式類型必須是 '{0}'，才符合替代的 ref 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">運算式樹狀目錄不可包含區域函式的參考</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">無法將具有動態類型的引數傳遞給本機函式 '{1}' 的 params 參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">提交時就應該建立語法樹狀結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">程式所使用的使用者字串加起來長度超過允許限制。請嘗試減少使用字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</source>
        <target state="translated">在樣式中使用可為 Null 的類型 '{0}' 不合法。請改用基礎類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">寫入輸出檔案時發生錯誤: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">元組元素名稱不得重複。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">只有位置 {1} 允許元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">任何位置都不允許元組元素名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">在組件 '{2}' 的類型 '{1}' 上找不到成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">元組</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">使用 {1} out 參數及 void 傳回型別找不到適合類型 '{0}' 的解構執行個體或擴充方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">需要具有右邊類型的運算式，才能解構指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">switch 運算式必須是值; 但找到的是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">類型為 '{1}' 的模式無法處理類型為 '{0}' 的運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">如有指定公用簽章，屬性 '{0}' 將予忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">如有指定公用簽章，屬性將予忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">選項 '{0}' 必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">具有 {0} 元素的 Tuple 無法轉換為類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">out 變數宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">不允許在相同引數清單中參考隱含型別 out 變數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">無法推斷隱含型別 out 變數 '{0}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">無法推斷隱含型別解構變數 '{0}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">無法推斷隱含型別捨棄的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">無法將 '{0}' 項目的元組解構為 '{1}' 變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">無法解構動態物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">解構必須包含至少兩個變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">因為目標類型 '{1}' 指定了不同的名稱或未指定名稱，所以會忽略元組項目名稱 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">因為指派目標指定了不同的名稱或未指定名稱，所以會忽略元組項目名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">預先定義的類型 '{0}' 必須為結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'new' 不得搭配元組類型使用。請改用元組常值運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">解構 `var (...)` 表單不允許 'var' 的特定類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">因為找不到編譯器所需的類型 '{0}'，所以無法定義利用元組的類別或成員。是否遺漏參考?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">無法明確參考 'System.Runtime.CompilerServices.TupleElementNamesAttribute'。請使用元組語法定義元組名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">運算式樹狀架構不得包含 out 引數變數宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">運算式樹狀架構不可包含 discard。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">運算式樹狀架構不得包含 'is' 模式比對運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">運算式樹狀架構不得包含元組常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">運算式樹狀架構不得包含元組轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">只有在發出 PDB 時才支援 /sourcelink 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">只有在發出 PDB 時才支援 /embed 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">檢測設備種類無效: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">已保留作為左值的語法 'var (...)'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">需要 { 或 ; 或 =&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">此內容不允許 throw 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">此內容中不允許宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Foreach 迴圈必須宣告其反覆運算變數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">解構左側不允許元組元素名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">若要轉換負值，必須以括號括住該值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">運算式樹狀架構不可包含 throw 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">組件名稱 {0} 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">若要讓 '{0}' 類型作為 '{1}' 類型的 AsyncMethodBuilder，其 Task 屬性應傳回 '{1}' 類型，而非 '{2}' 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">組件 '{1}' 中的模組 '{0}' 正在將類型 '{2}' 轉送給多個組件: '{3}' 及 '{4}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">在模式中使用類型 'dynamic' 不合法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的文件模式不受支援或無效: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">提供的原始程式碼類型不受支援或無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的語言版本不受支援或無效: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前置處理符號的名稱無效; '{0}' 不是有效的識別碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.1 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">C# 7.2 無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">指定的語言版本 '{0}' 不可以零作為開頭</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">可能未指派 'void' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">'{0}' 僅供評估之用，可能會在未來更新中變更或移除。抑制此診斷以繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">類型僅供評估之用，可能會在未來更新中變更或移除。抑制此診斷以繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">編譯器版本: '{0}'。語言版本: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">非同步主要</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">元組項目名稱 '{0}' 從推斷而來。請使用語言版本 {1} 或更新版本，依推斷名稱存取項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">元組不可包含 'void' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">不得同步傳回進入點的 void 或 int</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">在 C# {2} 中，類型為 '{1}' 的模式無法處理類型為 '{0}' 的運算式。請使用語言版本 {3} 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">區域函式 '{0}' 已宣告，但從未使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">區域函式已宣告但從未使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="translated">區域函式 '{0}' 必須宣告主體，原因是其未標記為 'static extern'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">無法從組件 '{2}' 讀取方法 '{0}' 的偵錯資訊 (權杖 0x{1:X8})</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} 不是有效的 C# 轉換運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">無法將具有動態類型的引數傳遞到具有推斷類型引數的一般區域函式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">前置數字分隔符號</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">請勿使用 '{0}'。此保留供編譯器使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">類型名稱 '{0}' 保留供編譯器使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">擴充方法 '{0}' 的第一個 'in' 或 'ref readonly' 參數必須是具體 (非泛型) 數值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">唯讀結構的執行個體欄位必須為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">使用唯讀結構的自動實作執行個體屬性必須為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">唯讀結構中不允許欄位型的事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">ref 擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">類型 '{0}' 的 stackalloc 運算式不可能轉換成類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">ref' 擴充方法 '{0}' 的第一個參數，必須是限制為結構的實值型別或泛型型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">in 參數不能有 Out 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} 不是有效的 C# 複合指派作業</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">篩選條件運算式是常數 'false'，請考慮移除 catch 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">篩選條件運算式是常數 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">篩選條件運算式是常數 'false'，請考慮移除 try-catch 區塊</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">篩選條件運算式是常數 'false'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">__arglist 不能有 void 類型的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">因為內插補點的結尾是 ':'，所以無法直接在字串內插補點使用條件式運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">請勿在屬性 (property) 上使用 'System.Runtime.CompilerServices.FixedBuffer' 屬性 (attribute)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">在 C# 7.3 中無法使用 '{0}' 功能。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">語言版本 {0} 不支援自動屬性 (property) 上以欄位為目標的屬性 (attribute)。請使用語言版本 {1} 或更高的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">此語言版本不支援自動屬性 (property) 上以欄位為目標的屬性 (attribute)。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">非同步資料流</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="needs-review-translation">'{0}': 在非同步 using 陳述式中使用的類型，必須可隱含地轉換為 'System.IAsyncDisposable' 或實作合適的 'DisposeAsync' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">非同步的 foreach 需要 '{1}' 的傳回型別 '{0}'，必須要有合適的公用 'MoveNextAsync' 方法和公用 'Current' 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">因為它實作 '{1}' 的多個具現化，所以非同步的 foreach 陳述式無法在型別 '{0}' 的變數上作業; 請嘗試轉換至特定的介面具現化</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</source>
        <target state="translated">在介面中宣告的轉換、等式或不等式運算子必須為抽象或虛擬</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">目標執行階段不支援預設介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">因為目標執行階段不支援預設介面實作，所以 '{0}' 無法在類型 '{2}' 中實作介面成員 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</source>
        <target state="translated">'{0}' 未實作介面成員 '{1}'。'{2}' 無法在 C# {3} 中隱含地實作非公用成員。請使用語言版本 '{4}' 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">介面成員 '{0}' 沒有最具體的實作。'{1}' 和 '{2}' 都不是最具體的。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>