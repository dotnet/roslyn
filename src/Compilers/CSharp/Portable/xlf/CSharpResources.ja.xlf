<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CallingConventionTypeIsInvalid">
        <source>Cannot use '{0}' as a calling convention modifier.</source>
        <target state="translated">呼び出し規則修飾子として '{0}' を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallingConventionTypesRequireUnmanaged">
        <source>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</source>
        <target state="translated">'{1}' が 'SignatureCallingConvention.Unmanaged' でない限り、'{0}' を渡すことは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">別の構築済みジェネリック型から、構築済みジェネリック型を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">非ジェネリック型から、構築済みジェネリック型を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractConversionNotInvolvingContainedType">
        <source>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</source>
        <target state="translated">インターフェイス内のユーザー定義の変換では、それを囲む型に制約されたそれを囲む型の型パラメーターとの間で変換する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">'{0}': 抽象イベントはイベント アクセサーの構文を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfMethodGroupInExpressionTree">
        <source>'&amp;' on method groups cannot be used in expression trees</source>
        <target state="translated">メソッド グループの '&amp;' を式ツリーで使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfToNonFunctionPointer">
        <source>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</source>
        <target state="translated">&amp;method グループ '{0}' を関数以外のポインター型 '{1}' に変換することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">挿入される逐語的文字列で '$@' の代わりに '@$' を使用するには、言語バージョン '{0}' 以上をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</source>
        <target state="translated">'{1}' および '{2}' のオペランドの演算子 '{0}' があいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">演算子 '{0}' は、参照型として認識されていない型パラメーターであるため、型 '{1}' の 'default' およびオペランドに適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver">
        <source>Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.</source>
        <target state="translated">識別子 '{0}' は、このコンテキストの型 '{1}' とパラメーター '{2}' の間であいまいです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">オブジェクト作成では Null 許容参照型を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseRefLike">
        <source>Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">匿名メソッド、ラムダ式、クエリ式、またはローカル関数内で ref に似た型を持つパラメーター '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterCaptured">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member</source>
        <target state="translated">構造体内の匿名メソッド、ラムダ式、クエリ式、ローカル関数は、インスタンス メンバー内でも使用されるプライマリ コンストラクター パラメーターにアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterInMember">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter</source>
        <target state="translated">構造体のインスタンス メンバー内の匿名メソッド、ラムダ式、クエリ式、ローカル関数は、プライマリ コンストラクター パラメーターにアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">'System.Runtime.CompilerServices.ITuple' を使用してパターン マッチングを行う場合、要素名を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">as 式で Null 許容参照型 '{0}?' を使用することはできません。代わりに基になる型 '{0}' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーターを割り当てることはできません (型または変数初期化子の init 専用セッターを除く)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーター '{0}' のメンバーは変更できません (型または変数初期化子の init 専用セッターを除く)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</source>
        <target state="translated">init 専用プロパティまたはインデクサー '{0}' を割り当てることができるのは、オブジェクト初期化子の中か、インスタンス コンストラクターまたは 'init' アクセサーの 'this' か 'base' 上のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">型 '{0}' は、メタデータで表現できないため、このコンテキストでは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrTypeArgCannotBeTypeVar">
        <source>'{0}': an attribute type argument cannot use type parameters</source>
        <target state="translated">'{0}': 属性の型引数では型パラメーターを使用することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">属性 '{0}' はイベント アクセサーでは無効です。'{1}' 宣言でのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesRequireParenthesizedLambdaExpression">
        <source>Attributes on lambda expressions require a parenthesized parameter list.</source>
        <target state="translated">ラムダ式での属性には、かっこで囲まれたパラメーター リストが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">'set' アクセサーがあるため、自動実装プロパティ '{0}' を 'readonly' とマークすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">自動実装の 'set' アクセサー '{0}' を 'readonly' とマークすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</source>
        <target state="translated">'{0}' は '{1}' の適切なパブリック インスタンスまたは拡張機能の定義を含んでいないため、型 '{0}' の変数に対して非同期 foreach ステートメントを使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">'{0}' は '{1}' のパブリック インスタンスまたは拡張機能の定義を含んでいないため、型 '{0}' の変数に対して非同期 foreach ステートメントを使用することはできません。'await foreach' ではなく 'foreach' ですか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">バイナリ演算子のパラメーターの 1 つは、それを含む型であるか、それに制約された型パラメーターである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractEqualityOperatorSignature">
        <source>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</source>
        <target state="translated">インターフェイス '{0}' で宣言されている等値演算子または非等値演算子のパラメーターの 1 つは、'{0}' に制限された '{0}' の型パラメーターである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecRetType">
        <source>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</source>
        <target state="translated">++ または -- 演算子の戻り値の型は、パラメーター型と一致するか、パラメーター型から派生しているか、またはパラメーター型が異なる型パラメーターでない限りそれに制約された含んでいる型の型パラメーターである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">++ または -- 演算子のパラメーター型は、それを含む型であるか、それに制約された型パラメーターである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</source>
        <target state="translated">オーバーロードされたシフト演算子の最初のオペランドは、それを含む型またはそれに制約された型パラメーターと同じ型である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractStaticMemberAccess">
        <source>A static virtual or abstract interface member can be accessed only on a type parameter.</source>
        <target state="translated">静的な仮想または抽象インターフェイス メンバーには、型パラメーターでのみアクセスできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">単項演算子のパラメーターは、それを含む型であるか、それに制約された型パラメーターである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRefLangVersion">
        <source>Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.</source>
        <target state="translated">言語バージョン {1} では、引数 {0} を 'ref' キーワード (keyword)と共に渡すことはできません。'ref' 引数を 'in' パラメーターに渡すには、{2} 以上の言語バージョンにアップグレードしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryReadOnlySpanConcatenation">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</source>
        <target state="translated">演算子 '{0}' は、UTF-8 バイト表現ではない型 '{1}' および '{2}' のオペランドには適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
        <source>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerArgumentExpressionAttribute は、既定値を含むパラメーターにのみ適用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCaseInSwitchArm">
        <source>A switch expression arm does not begin with a 'case' keyword.</source>
        <target state="translated">switch 式の arm が 'case' キーワードで始まりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">非同期 foreach では動的な型のコレクションを使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFieldTypeInRecord">
        <source>The type '{0}' may not be used for a field of a record.</source>
        <target state="translated">レコードのフィールドに対して型 '{0}' を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerArgCount">
        <source>Function pointer '{0}' does not take {1} arguments</source>
        <target state="translated">関数ポインター '{0}' には {1} 個の引数を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerParamModifier">
        <source>'{0}' cannot be used as a modifier on a function pointer parameter.</source>
        <target state="translated">関数ポインター パラメーターでは、'{0}' を修飾子として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInheritanceFromRecord">
        <source>Only records may inherit from records.</source>
        <target state="translated">レコードから継承できるのはレコードだけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInitAccessor">
        <source>The 'init' accessor is not valid on static members</source>
        <target state="translated">静的メンバー上で 'init' アクセサーは有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">/nullable のオプション '{0}' が無効です。'disable'、'enable'、'warnings'、'annotations' のいずれかにする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableReferenceTypeInUsingAlias">
        <source>Using alias cannot be a nullable reference type.</source>
        <target state="translated">Using エイリアスを NULL 許容参照型にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">NULL 許容参照型では typeof 演算子を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefaultOrNew">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">演算子 '{0}' はオペランド '{1}' に適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">パターン マッチには使用できないオペランドです。値が必要ですが、'{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordBase">
        <source>Records may only inherit from object or another record</source>
        <target state="translated">レコードの継承元にできるのは、object か別のレコードだけです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordMemberForPositionalParameter">
        <source>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</source>
        <target state="translated">レコード メンバー '{0}' は、位置指定パラメーター '{2}' に一致させるための型 '{1}' の読み取り可能なインスタンス プロパティまたはフィールドである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefUsing">
        <source>A using statement resource of type '{0}' cannot be used in async methods or async lambda expressions.</source>
        <target state="translated">型 '{0}' の using ステートメント リソースは、非同期メソッドまたは非同期ラムダ式では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefInUsingAlias">
        <source>Using alias cannot be a 'ref' type.</source>
        <target state="translated">using エイリアスを 'ref' 型にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticAfterUnsafe">
        <source>'static' modifier must precede 'unsafe' modifier.</source>
        <target state="translated">'static' 修飾子は 'unsafe' 修飾子の前に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">コマンドライン構文エラー: '{0}' は、'{1}' オプションの有効な値ではありません。値は '{2}' の形式にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnsafeInUsingDirective">
        <source>Only a 'using static' or 'using alias' can be 'unsafe'.</source>
        <target state="translated">'unsafe' に設定できるのは、'using static' または 'using エイリアス' のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingStaticType">
        <source>'{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.</source>
        <target state="translated">'{0}' 型は 'using static' では無効です。使用できるのは、クラス、構造体、インターフェイス、列挙型、デリゲート、名前空間のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BuilderAttributeDisallowed">
        <source>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</source>
        <target state="translated">AsyncMethodBuilder 属性は、明示的な戻り値の型のない匿名メソッドでは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeConvertedToUtf8">
        <source>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</source>
        <target state="translated">入力文字列を同等の UTF-8 バイト表現に変換できません。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'{0}' は null 許容にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotClone">
        <source>The receiver type '{0}' is not a valid record type and is not a struct type.</source>
        <target state="translated">レシーバーの種類 '{0}' は有効なレコード型でも構造体型でもありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertAddressOfToDelegate">
        <source>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</source>
        <target state="translated">メソッド グループ '{0}' をデリゲート型 '{1}' に変換することはできません。(&amp;M)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferDelegateType">
        <source>The delegate type could not be inferred.</source>
        <target state="translated">デリゲート型を推論できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotMatchOnINumberBase">
        <source>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specifc numeric type.</source>
        <target state="translated">'INumberBase&lt;T&gt;' を継承または拡張しているため、'{0}' で数値定数またはリレーショナル パターンを使用することはできません。指定された数値型に絞り込むために、型パターンを使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
        <source>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</source>
        <target state="translated">'マネージド' 呼び出し規則をアンマネージド呼び出し規則指定子と組み合わせることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseFunctionPointerAsFixedLocal">
        <source>The type of a local declared in a fixed statement cannot be a function pointer type.</source>
        <target state="translated">fixed ステートメントで宣言されたローカルの型を関数ポインター型にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
        <source>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">'UnmanagedCallersOnly' という属性を持つメソッドでは、'{0}' を{1}の型として使用することはできません。</target>
        <note>1 is the localized word for 'parameter' or 'return'. UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_CannotUseReducedExtensionMethodInAddressOf">
        <source>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</source>
        <target state="translated">レシーバーが '&amp;' 演算子の対象となっている拡張メソッドを使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseRefInUnmanagedCallersOnly">
        <source>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">"UnmanagedCallersOnly" の属性が設定されたメソッドのシグネチャでは、"ref"、"in"、または "out" を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
        <source>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</source>
        <target state="translated">InterpolatedStringHandlerArgumentAttribute 引数は、属性が使用されているパラメーターを参照できません。</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_CantChangeInitOnlyOnOverride">
        <source>'{0}' must match by init-only of overridden member '{1}'</source>
        <target state="translated">'{0}' は、オーバーライドされたメンバー '{1}' と同じく、初期化専用である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturnType">
        <source>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</source>
        <target state="translated">戻り値の型がデリゲート戻り値の型と一致しないため、{0} を型 '{1}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">__arglist では、'in' や 'out' で引数を渡すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
        <source>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</source>
        <target state="translated">このコンストラクターは、その属性を持つコンストラクターにチェーンされるため、'SetsRequiredMembers' を追加する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOperatorNeedsMatch">
        <source>The operator '{0}' requires a matching non-checked version of the operator to also be defined</source>
        <target state="translated">演算子 '{0}' を定義するには、チェックされていないバージョンの合致する演算子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloneDisallowedInRecord">
        <source>Members named 'Clone' are disallowed in records.</source>
        <target state="translated">'Clone' という名前のメンバーはレコードでは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotStatic">
        <source>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</source>
        <target state="translated">'{0}' は、静的インターフェイス メンバー '{1}' を実装していません。'{2}' は静的ではないため、インターフェイス メンバーを実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</source>
        <target state="translated">'{0}' は、インターフェイス メンバー '{1}' を実装していません。'{2}' は '{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidMethodName">
        <source>The CollectionBuilderAttribute method name is invalid.</source>
        <target state="translated">CollectionBuilderAttribute メソッド名が無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidType">
        <source>The CollectionBuilderAttribute builder type must be a non-generic class or struct.</source>
        <target state="translated">CollectionBuilderAttribute ビルダー型は、非ジェネリック クラスまたは構造体である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeMethodNotFound">
        <source>Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan&lt;{1}&gt;' and return type '{2}'.</source>
        <target state="translated">必要なシグネチャを持つアクセス可能な '{0}' メソッドが見つかりませんでした:'ReadOnlySpan&lt;{1}&gt;' 型の単一パラメーターを持つ静的メソッドと戻り値の型 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderNoElementType">
        <source>'{0}' has a CollectionBuilderAttribute but no element type.</source>
        <target state="translated">'{0}' に CollectionBuilderAttribute がありますが、要素型がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionEscape">
        <source>A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</source>
        <target state="new">A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionImmutableArray">
        <source>This version of '{0}' cannot be used with collection expressions.</source>
        <target state="translated">このバージョンの '{0}' は、コレクション式では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionNoTargetType">
        <source>There is no target type for the collection expression.</source>
        <target state="new">There is no target type for the collection expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetNoElementType">
        <source>Collection expression target '{0}' has no element type.</source>
        <target state="new">Collection expression target '{0}' has no element type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetTypeNotConstructible">
        <source>Cannot initialize type '{0}' with a collection expression because the type is not constructible.</source>
        <target state="new">Cannot initialize type '{0}' with a collection expression because the type is not constructible.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">型パラメーター '{1}' は 'unmanaged' 制約を含むので、'{0}' の制約として '{1}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="translated">ローカル関数 '{0}' は、条件付き属性を使用するには、'static' である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">型 '{0}' の式を型 '{1}' のパターンで処理することはできません。オープン型と定数パターンを一致させるには、言語バージョン '{2}' 以上をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantValueOfTypeExpected">
        <source>A constant value of type '{0}' is expected</source>
        <target state="translated">型 '{0}' の定数値が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorMustInvokeBaseCopyConstructor">
        <source>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</source>
        <target state="translated">レコード内のコピー コンストラクターは、ベースのコピー コンストラクターまたはパラメーターなしのオブジェクト コンストラクター (レコードがオブジェクトから継承している場合) を呼び出す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorWrongAccessibility">
        <source>A copy constructor '{0}' must be public or protected because the record is not sealed.</source>
        <target state="translated">コピー コンストラクター '{0}' は、レコードが sealed ではないため、public または protected にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">名前 '{0}' は対応する 'Deconstruct' パラメーター '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructVariableCannotBeByRef">
        <source>A deconstruction variable cannot be declared as a ref local</source>
        <target state="translated">分解変数を ref ローカルと宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultConstraintOverrideOnly">
        <source>The 'default' constraint is valid on override and explicit interface implementation methods only.</source>
        <target state="translated">'default' 制約は、オーバーライドおよび明示的なインターフェイスの実装メソッドでのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">型 '{0}' には非抽象メンバーがあるため、この型を埋め込むことはできません。'相互運用型の埋め込み' プロパティを false に設定することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">既定のリテラルのターゲット型がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">既定のリテラル 'default' はパターンとして無効です。必要に応じて別のリテラル (例: '0' または 'null') をご使用ください。すべてと一致させるには、破棄パターン '_' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeneathPatternCombinator">
        <source>A variable may not be declared within a 'not' or 'or' pattern.</source>
        <target state="translated">'not' または 'or' パターンの中で変数を宣言することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">この破棄パターンは switch ステートメントの case ラベルとして許可されていません。破棄パターンに 'case var _:' を使用するか、'_' という定数に'case @_:' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseEqualityContract">
        <source>'{0}' does not override expected property from '{1}'.</source>
        <target state="translated">'{0}' は、'{1}' からの想定されるプロパティをオーバーライドしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseMethod">
        <source>'{0}' does not override expected method from '{1}'.</source>
        <target state="translated">'{0}' は、'{1}' からの想定されるメソッドをオーバーライドしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideMethodFromObject">
        <source>'{0}' does not override expected method from 'object'.</source>
        <target state="translated">'{0}' は、'object' からの想定されるメソッドをオーバーライドしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupReturnTypeMod">
        <source>A return type can only have one '{0}' modifier.</source>
        <target state="translated">戻り値の型には '{0}' 修飾子を 1 つだけ指定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">'{0}' が複数回、明示的に実装されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterceptor">
        <source>The indicated call is intercepted multiple times.</source>
        <target state="translated">指定された呼び出しは複数回インターセプトされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithDifferencesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</source>
        <target state="translated">'{0}' は、型 '{2}' のインターフェイス リストに '{1}' として既に指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">Null 抑制演算子 ('!') が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">プロパティまたはインデクサー '{0}' の両方のアクセサーで 'readonly' 修飾子を指定することはできません。代わりに、プロパティ自体に 'readonly' 修飾子を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">'else' でステートメントを開始することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EntryPointCannotBeUnmanagedCallersOnly">
        <source>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">アプリケーションのエントリ ポイントに 'UnmanagedCallersOnly' 属性を設定することはできません。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_EqualityContractRequiresGetter">
        <source>Record equality contract property '{0}' must have a get accessor.</source>
        <target state="translated">レコードの等値コントラクト プロパティ '{0}' には get アクセサーが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeVariable">
        <source>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">参照される変数が宣言のスコープ外に公開される可能性があるため、このコンテキストで変数 '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInterpolatedString">
        <source>Expected interpolated string</source>
        <target state="translated">補間された文字列 (期待値)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplementationOfOperatorsMustBeStatic">
        <source>Explicit implementation of a user-defined operator '{0}' must be declared static</source>
        <target state="translated">ユーザー定義演算子 '{0}' の明示的な実装は静的として宣言する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">'System.Runtime.CompilerServices.NullableAttribute' の明示的な適用は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMismatchInitOnly">
        <source>Accessors '{0}' and '{1}' should both be init-only or neither</source>
        <target state="translated">アクセサー '{0}' と '{1}' は、両方 init 専用か、両方そうでないかのいずれかでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitRequiredMember">
        <source>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</source>
        <target state="translated">'System.Runtime.CompilerServices.RequiredMemberAttribute' を使用しないでください。代わりに、必須フィールドとプロパティに 'required' キーワードを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitScopedRef">
        <source>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</source>
        <target state="translated">'System.Runtime.CompilerServices.ScopedRefAttribute' を使用しないでください。キーワード 'scoped' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">指定された式を fixed ステートメントで使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">式ツリーに null 合体代入を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">式ツリーに ref 構造体または制限がある型 '{0}' の値を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
        <source>An expression tree may not contain an access of static virtual or abstract interface member</source>
        <target state="translated">式ツリーに静的仮想または抽象インターフェイス メンバーへのアクセス権を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsCollectionExpression">
        <source>An expression tree may not contain a collection expression.</source>
        <target state="new">An expression tree may not contain a collection expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="translated">式ツリーに、from-end インデックス ('^') 式を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInlineArrayOperation">
        <source>An expression tree may not contain an inline array access or conversion</source>
        <target state="translated">式ツリーにインライン配列アクセスまたは変換を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
        <source>An expression tree may not contain an interpolated string handler conversion.</source>
        <target state="translated">式ツリーには、補間された文字列ハンドラー変換を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternImplicitIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="translated">式ツリーに、System.Index または System.Range インデクサー アクセスのパターンを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="translated">式ツリーに範囲 ('..') 式を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">式ツリーに switch 式を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">式ツリーにタプルの == または != 演算子を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsUtf8StringLiterals">
        <source>An expression tree may not contain UTF-8 string conversion or literal.</source>
        <target state="translated">式ツリーに UTF-8 文字列変換またはリテラルを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsWithExpression">
        <source>An expression tree may not contain a with-expression.</source>
        <target state="translated">式ツリーは、with 式を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'{0}': extern イベントは初期化子を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">機能 '{0}' は現在、プレビュー段階であり、*サポートされていません*。プレビュー機能を使用するには、'preview' 言語バージョンを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">機能 '{0}' は試験段階であり、サポートされていません。有効にするには '/features:{1}' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion10">
        <source>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 10.0 では使用できません。言語バージョン {1} 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion11">
        <source>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 11.0 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion12">
        <source>Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</source>
        <target state="new">Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 8.0 では使用できません。言語バージョン {1} 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 8.0 では使用できません。言語バージョン {1} 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion9">
        <source>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 9.0 では使用できません。言語バージョン {1} 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">フィールドに類似したイベント '{0}' を 'readonly' にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileLocalDuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}' in this file.</source>
        <target state="translated">名前空間 '{1}' は、このファイルの '{0}' の定義を既に含んでいます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FilePathCannotBeConvertedToUtf8">
        <source>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</source>
        <target state="translated">ファイル ローカル型 '{0}' は、含んでいるファイル パスを同等の UTF-8 バイト表現に変換できないため使用できません。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedAndNormalNamespace">
        <source>Source file can not contain both file-scoped and normal namespace declarations.</source>
        <target state="translated">ソース ファイルには、ファイルスコープと通常の名前空間の両方の宣言を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedNamespaceNotBeforeAllMembers">
        <source>File-scoped namespace must precede all other members in a file.</source>
        <target state="translated">ファイルスコープの名前空間は、ファイル内の他のすべてのメンバーの前に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeBase">
        <source>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</source>
        <target state="translated">ファイル ローカル型 '{0}' は、ファイル ローカル型 '{1}' 以外の基本データ型として使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeDisallowedInSignature">
        <source>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</source>
        <target state="translated">ファイル ローカル型 '{0}' は、ファイル ローカル型 '{1}' 以外のメンバーの署名として使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNameDisallowed">
        <source>Types and aliases cannot be named 'file'.</source>
        <target state="translated">型とエイリアスに 'file' という名前を付けることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNested">
        <source>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</source>
        <target state="translated">ファイル ローカル型 '{0}' は、最上位レベルの型で定義する必要があります。'{0}' は入れ子にされた型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNoExplicitAccessibility">
        <source>File-local type '{0}' cannot use accessibility modifiers.</source>
        <target state="translated">ファイル ローカル型 '{0}' はアクセシビリティ修飾子を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNonUniquePath">
        <source>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</source>
        <target state="translated">ファイル ローカル型 '{0}' は、一意のパスを持つファイル内で宣言する必要があります。パス '{1}'は複数のファイルで使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedFieldMustNotBeRef">
        <source>A fixed field must not be a ref field.</source>
        <target state="translated">固定フィールドを ref フィールドにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">'{0}' は '{1}' のパブリック インスタンスまたは拡張機能の定義を含んでいないため、型 '{0}' の変数に対して foreach ステートメントを使用することはできません。'foreach' ではなく 'await foreach' ですか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrMethMustBeStatic">
        <source>Cannot create a function pointer for '{0}' because it is not a static method</source>
        <target state="translated">'{0}' は静的メソッドではないため、関数ポインターを作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrRefMismatch">
        <source>Ref mismatch between '{0}' and function pointer '{1}'</source>
        <target state="translated">'{0}' と関数ポインター '{1}' で参照が一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointerTypesInAttributeNotSupported">
        <source>Using a function pointer type in this context is not supported.</source>
        <target state="translated">このコンテキストでの関数ポインター型の使用はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointersCannotBeCalledWithNamedArguments">
        <source>A function pointer cannot be called with named arguments.</source>
        <target state="translated">関数ポインターを名前付き引数で呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
        <source>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</source>
        <target state="translated">インターフェイス '{0}' は型引数として使用できません。静的メンバー '{1}' は、インターフェイスに最も限定的な実装がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingInNamespace">
        <source>A global using directive cannot be used in a namespace declaration.</source>
        <target state="translated">グローバル using ディレクティブを名前空間宣言で使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingOutOfOrder">
        <source>A global using directive must precede all non-global using directives.</source>
        <target state="translated">グローバル using ディレクティブは、すべての非グローバル using ディレクティブの前に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingStaticFileType">
        <source>File-local type '{0}' cannot be used in a 'global using static' directive.</source>
        <target state="translated">ファイル ローカル型 '{0}' は、'global using static' ディレクティブでは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">goto は同じブロック内の using 宣言より前の位置にはジャンプできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">goto は using 宣言より後の位置にはジャンプできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HiddenPositionalMember">
        <source>The positional member '{0}' found corresponding to this parameter is hidden.</source>
        <target state="translated">このパラメーターに対応する位置にあるメンバー '{0}' が非表示になっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAtSequence">
        <source>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</source>
        <target state="translated">'@' 文字のシーケンスは使用できません。逐語的文字列または識別子に使用できる '@' 文字は 1 つだけです。生文字列には何も含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">このコンテキストでは抑制演算子が許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitConversionOperatorCantBeChecked">
        <source>An 'implicit' user-defined conversion operator cannot be declared checked</source>
        <target state="translated">'implicit' ユーザー定義変換演算子はチェック済みと宣言できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</source>
        <target state="translated">'{0}' は、インターフェイス メンバー '{1}' を実装していません。'{2}' はアクセスできないメンバーを暗黙的に実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">暗黙的なインデックス インデクサーの呼び出しでは、引数に名前を付けることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationIllegalTargetType">
        <source>The type '{0}' may not be used as the target type of new()</source>
        <target state="translated">型 '{0}' は new() のターゲット型として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNoTargetType">
        <source>There is no target type for '{0}'</source>
        <target state="translated">'{0}' のターゲット型がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNotValid">
        <source>Use of new() is not valid in this context</source>
        <target state="translated">new() はこのコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">暗黙的な範囲インデクサーの呼び出しでは、引数に名前を付けることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedDefaultParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have a default value.</source>
        <target state="translated">暗黙的に型指定されたラムダパラメーター '{0}' に既定値を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">'in' 修飾子を持つ引数を、動的ディスパッチされる式で使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritingFromRecordWithSealedToString">
        <source>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</source>
        <target state="translated">シールされた ' Object. ToString ' を含むレコードからの継承は、C# {0} ではサポートされていません。' {1} ' 以上の言語バージョンを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitCannotBeReadonly">
        <source>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</source>
        <target state="translated">'init' アクセサーを 'readonly' としてマークできません。代わりに '{0}' を readonly としてマークします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayBadIndex">
        <source>Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.</source>
        <target state="translated">インライン配列型の要素にアクセスできるのは、暗黙的に 'int'、'System.Index'、または 'System.Range' に変換できる 1 つの引数を使用する場合のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToReadOnlySpanNotSupported">
        <source>Cannot convert expression to '{0}' because it may not be passed or returned by reference</source>
        <target state="translated">式は参照渡しによって渡したり返したりできないため、式を '{0}' に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToSpanNotSupported">
        <source>Cannot convert expression to '{0}' because it is not an assignable variable</source>
        <target state="translated">式は割り当て可能な変数ではないため、'{0}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayForEachNotSupported">
        <source>foreach statement on an inline array of type '{0}' is not supported</source>
        <target state="translated">型 '{0}' のインライン配列の foreach ステートメントはサポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayIndexOutOfRange">
        <source>Index is outside the bounds of the inline array</source>
        <target state="translated">インデックスがインライン配列の範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayUnsupportedElementFieldModifier">
        <source>Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.</source>
        <target state="translated">インライン配列要素フィールドは、必須、読み取り専用、揮発性、または固定サイズ バッファーとして宣言できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstancePropertyInitializerInInterface">
        <source>Instance properties in interfaces cannot have initializers.</source>
        <target state="translated">インターフェイス内のインスタンス プロパティは初期化子を持つことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptableMethodMustBeOrdinary">
        <source>Cannot intercept '{0}' because it is not an invocation of an ordinary member method.</source>
        <target state="translated">通常のメンバー メソッドの呼び出しではないため、'{0}' をインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorArityNotCompatible">
        <source>Method '{0}' must be non-generic or have arity {1} to match '{2}'.</source>
        <target state="translated">メソッド '{0}' は非ジェネリックであるか、'{2}' と一致するアリティ {1} を持っている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotBeGeneric">
        <source>Method '{0}' must be non-generic to match '{1}'.</source>
        <target state="translated">'{1}' に一致するには、メソッド '{0}' は非ジェネリックである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotInterceptNameof">
        <source>A nameof operator cannot be intercepted.</source>
        <target state="translated">nameof 演算子はインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotUseUnmanagedCallersOnly">
        <source>An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.</source>
        <target state="translated">インターセプターに 'UnmanagedCallersOnlyAttribute' を設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCharacterOutOfRange">
        <source>The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.</source>
        <target state="translated">与えられた行の長さは '{0}' 文字で、指定された文字数 '{1}' に達していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorContainingTypeCannotBeGeneric">
        <source>Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</source>
        <target state="new">Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorFilePathCannotBeNull">
        <source>Interceptor cannot have a 'null' file path.</source>
        <target state="translated">インターセプターに 'null' ファイル パスを指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorGlobalNamespace">
        <source>An interceptor cannot be declared in the global namespace.</source>
        <target state="translated">グローバル名前空間でインターセプターを宣言することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineCharacterMustBePositive">
        <source>Line and character numbers provided to InterceptsLocationAttribute must be positive.</source>
        <target state="translated">InterceptsLocationAttribute に指定する行番号と文字番号は正の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineOutOfRange">
        <source>The given file has '{0}' lines, which is fewer than the provided line number '{1}'.</source>
        <target state="translated">与えられたファイルは '{0}' 行しかなく、指定された行数 '{1}' を下回っています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMethodMustBeOrdinary">
        <source>An interceptor method must be an ordinary member method.</source>
        <target state="translated">インターセプター メソッドは通常のメンバー メソッドである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustHaveMatchingThisParameter">
        <source>Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.</source>
        <target state="translated">インターセプターには、'{1}' で '{0}' パラメーターと一致する 'this' パラメーターが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustNotHaveThisParameter">
        <source>Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.</source>
        <target state="translated">'{0}' に 'this' パラメーターがないため、インターセプターに 'this' パラメーターを指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustReferToStartOfTokenPosition">
        <source>The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?</source>
        <target state="translated">指定された行番号と文字番号は、トークン '{0}' の先頭を参照していません。行 '{1}' と文字 '{2}' を使用するつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNameNotInvoked">
        <source>Possible method name '{0}' cannot be intercepted because it is not being invoked.</source>
        <target state="translated">考えられるメソッド名 '{0}' は呼び出されていないため、インターセプトすることができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNonUniquePath">
        <source>Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.</source>
        <target state="translated">コンパイル内の複数のファイルにこのパスがあるため、パス '{0}' を持つファイル内の呼び出しをインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNotAccessible">
        <source>Cannot intercept call with '{0}' because it is not accessible within '{1}'.</source>
        <target state="translated">'{1}' 内ではアクセスできないため、'{0}' を使用して呼び出しをインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilation">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'.</source>
        <target state="translated">インターセプトできません。コンパイルにパス '{0}' のファイルが含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithCandidate">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?</source>
        <target state="translated">インターセプトできません。コンパイルにパス '{0}' のファイルが含まれていません。パス '{1}' を使うつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithUnmappedCandidate">
        <source>Cannot intercept: Path '{0}' is unmapped. Expected mapped path '{1}'.</source>
        <target state="translated">インターセプトできません。パス '{0}' がマップされていません。マップされたパス '{1}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPositionBadToken">
        <source>The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.</source>
        <target state="translated">指定された行番号と文字番号は、インターセプト可能なメソッド名ではなく、トークン '{0}' を参照しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorScopedMismatch">
        <source>Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.</source>
        <target state="translated">'scoped' 修飾子または '[UnscopedRef]' 属性の違いにより、'{1}' を使用して '{0}' への呼び出しをインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorSignatureMismatch">
        <source>Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.</source>
        <target state="translated">署名が一致しないため、インターセプター '{1}' でメソッド '{0}' をインターセプトできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorsFeatureNotEnabled">
        <source>The 'interceptors' experimental feature is not enabled in this namespace. Add '{0}' to your project.</source>
        <target state="translated">'インターセプター' の実験的な機能は、この名前空間では有効になっていません。プロジェクトに '{0}' を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
        <source>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">'UnmanagedCallersOnly' メソッド '{0}' は、インターフェイス メンバー '{1}' を型 '{2}' で実装できません</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">'{0}' は、__arglist パラメーターが指定されているため、型 '{2}' のインターフェイス メンバー '{1}' を実装できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">C# コンパイラで内部エラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
        <source>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</source>
        <target state="translated">パラメーター '{0}' に適用された InterpolatedStringHandlerArgumentAttribute の形式が正しくないため、解釈できません。'{1}' のインスタンスを手動で構築してください。</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
        <source>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</source>
        <target state="translated">パラメーター '{0}' は、パラメーター '{1}' で補間された文字列ハンドラーの変換への引数ですが、対応する引数は、補間された文字列式の後に指定されています。引数を並べ替えて、'{0}' を '{1}' の前に移動します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
        <source>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</source>
        <target state="translated">パラメーター '{0}' は明示的に指定されていませんが、パラメーター '{1}' で補間された文字列ハンドラーの変換への引数として使用されています。'{1}' の前に '{0}' の値を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
        <source>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</source>
        <target state="translated">補間された文字列ハンドラー構築で動的を使用することはできません。'{0}' のインスタンスを手動で構築してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnInconsistent">
        <source>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</source>
        <target state="translated">補間された文字列ハンドラー メソッド '{0}' の戻り値の型が一致しません。'{1}' を返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnMalformed">
        <source>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</source>
        <target state="translated">補間された文字列ハンドラー メソッド '{0}' の形式が正しくありません。'void' または 'bool' を返すことはありません。</target>
        <note>void and bool are keywords</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
        <source>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</source>
        <target state="translated">インデックス付けされているインスタンスを参照する補間された文字列ハンドラーの変換は、インデクサー メンバー初期化子では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExperimentalDiagID">
        <source>The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</source>
        <target state="new">The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFuncPointerReturnTypeModifier">
        <source>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</source>
        <target state="translated">'{0}' は有効な関数ポインターの戻り値の型修飾子ではありません。有効な修飾子は 'ref ' および 'ref readonly' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFunctionPointerCallingConvention">
        <source>'{0}' is not a valid calling convention specifier for a function pointer.</source>
        <target state="translated">'{0}' は関数ポインターの有効な呼び出し規則指定子ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">無効なハッシュ アルゴリズム名: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayFields">
        <source>Inline array struct must declare one and only one instance field.</source>
        <target state="translated">インライン配列構造体では、インスタンス フィールドを 1 つだけ宣言する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLayout">
        <source>Inline array struct must not have explicit layout.</source>
        <target state="translated">インライン配列構造体に明示的なレイアウトを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLength">
        <source>Inline array length must be greater than 0.</source>
        <target state="translated">インライン配列の長さは、0 より大きくなければいけません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not a valid parameter name from '{1}'.</source>
        <target state="translated">'{0}' は、'{1}' からの有効なパラメーター名ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierForLanguageVersion">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">C# {1} では、修飾子 '{0}' はこの項目に対して有効ではありません。'{2}' 以上の言語バージョンをご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameInSubpattern">
        <source>Identifier or a simple member access expected.</source>
        <target state="translated">識別子または単純なメンバー アクセスが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">無効なオブジェクト作成</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPrimaryConstructorParameterReference">
        <source>Cannot use primary constructor parameter '{0}' in this context.</source>
        <target state="translated">このコンテキストでは、プライマリ コンストラクター パラメーター '{0}' を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">プロパティまたはインデクサー '{0}' とそのアクセサーの両方で 'readonly' 修飾子を指定することはできません。いずれかを削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">"無効な次元指定子です: ']' を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUnmanagedCallersOnlyCallConv">
        <source>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</source>
        <target state="translated">'{0}' は 'UnmanagedCallersOnly' の有効な呼び出し規則の種類ではありません。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InvalidWithReceiverType">
        <source>The receiver of a `with` expression must have a non-void type.</source>
        <target state="translated">'with' 式のレシーバーは、void でない型でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">is-type 式で Null 許容参照型 '{0}?' を使用することはできません。代わりに基になる型 '{0}' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">型 '{0}' の式は指定されたパターンと絶対に一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">反復子ブロックを伴うメソッド '{0}' が '{1}' を返すには 'async' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaExplicitReturnTypeVar">
        <source>The contextual keyword 'var' cannot be used as an explicit lambda return type</source>
        <target state="translated">コンテキスト キーワード "var" を明示的なラムダ戻り値の型として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaWithAttributesToExpressionTree">
        <source>A lambda expression with attributes cannot be converted to an expression tree</source>
        <target state="translated">属性を含むラムダ式は、式ツリーに変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">機能 '{3}' は C# {4} では使用できないため、'{0}' は型 '{2}' のインターフェイス メンバー '{1}' を実装できません。'{5}' 以上の言語バージョンをご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContainsDifferentWhitespace">
        <source>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</source>
        <target state="translated">行に、生文字列リテラルの終了行とは異なる空白が含まれています: '{0}'と'{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineDoesNotStartWithSameWhitespace">
        <source>Line does not start with the same whitespace as the closing line of the raw string literal.</source>
        <target state="translated">行の先頭が生文字列リテラルの終了行と同じ空白ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveEndLessThanStart">
        <source>The #line directive end position must be greater than or equal to the start position</source>
        <target state="translated">#line ディレクティブの終了位置は、開始位置と同じかそれ以上でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveInvalidValue">
        <source>The #line directive value is missing or out of range</source>
        <target state="translated">#line ディレクティブの値が見つからないか、範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveRequiresSpace">
        <source>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</source>
        <target state="translated">#line span ディレクティブには、最初のかっこの前、文字オフセットの前、ファイル名の前にスペースが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ListPatternRequiresLength">
        <source>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</source>
        <target state="translated">リスト パターンは、型 '{0}' の値には使用できません。適切な 'Length' または 'Count' プロパティが見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethFuncPtrMismatch">
        <source>No overload for '{0}' matches function pointer '{1}'</source>
        <target state="translated">関数ポインター '{1}' に一致する '{0}' のオーバーロードはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedRecord">
        <source>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</source>
        <target state="translated">予期しないキーワード 'record' です。'record struct' または 'record class' のつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedSlicePattern">
        <source>Slice patterns may only be used once and directly inside a list pattern.</source>
        <target state="translated">スライス パターンは、1 回限り、リスト パターン内で直接使用される可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedUnchecked">
        <source>Unexpected keyword 'unchecked'</source>
        <target state="translated">予期しないキーワード 'unchecked'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddressOf">
        <source>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</source>
        <target state="translated">メソッド グループを関数ポインターに変換できません ('&amp;' が抜けていないか確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">パターンがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
        <source>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">モジュール初期化子に 'UnmanagedCallersOnly' 属性を設定することはできません。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
        <source>Module initializer method '{0}' must not be generic and must not be contained in a generic type</source>
        <target state="translated">モジュール初期化子メソッド '{0}' をジェネリックにすることはできず、ジェネリック型に含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
        <source>Module initializer method '{0}' must be accessible at the module level</source>
        <target state="translated">モジュール初期化子メソッド '{0}' はモジュール レベルでアクセス可能である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeOrdinary">
        <source>A module initializer must be an ordinary member method</source>
        <target state="translated">モジュール初期化子は通常のメンバー メソッドでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
        <source>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</source>
        <target state="translated">モジュール初期化子メソッド '{0}' は、static でなければならず、仮想であってはならず、パラメーターを持ってはならず、'void' を返す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">複数のアナライザー構成ファイルを同じディレクトリに入れることはできません ('{0}')。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">属性 [EnumeratorCancellation] を複数のパラメーターで使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleFileScopedNamespace">
        <source>Source file can only contain one file-scoped namespace declaration.</source>
        <target state="translated">ソース ファイルには、ファイルスコープ付きの名前空間の宣言を 1 つだけ含めることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleRecordParameterLists">
        <source>Only a single partial type declaration may have a parameter list</source>
        <target state="translated">単一の部分型宣言のみがパラメーター リストを持つことができます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForInlineArray">
        <source>An inline array access may not have a named argument specifier</source>
        <target state="translated">インライン配列のアクセスには名前付き引数の指定子を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">new()' 制約は 'unmanaged' 制約と一緒には使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintCannotHaveRequiredMembers">
        <source>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</source>
        <target state="translated">'{2}'に必要なメンバーがあるため、'{2}' は、ジェネリック型またはメソッド '{0}'のパラメーター '{1}' の 'new()' 制約を満たすことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
        <source>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</source>
        <target state="translated">非逐語的な補間された文字列内の改行は、C# {0} ではサポートされていません。{1} またはそれ以上の言語バージョンを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">'{0}': 非同期 using ステートメントで使用される型は、暗黙的に 'System.IAsyncDisposable' に変換可能であるか、適切な 'DisposeAsync' メソッドを実装する必要があります。'await using' ではなく 'using' ですか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">'{0}': using ステートメントで使用される型は、暗黙的に 'System.IDisposable' への変換が可能でなければなりません。'using' ではなく 'await using' ですか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerArgumentExpressionParam">
        <source>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">型 '{0}' を型 '{1}' に変換する標準変換が存在しないため、CallerArgumentExpressionAttribute を適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCopyConstructorInBaseType">
        <source>No accessible copy constructor found in base type '{0}'.</source>
        <target state="translated">基本型 '{0}' にアクセス可能なコピー コンストラクターが見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDelegateConstraint">
        <source>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</source>
        <target state="translated">キーワード 'delegate' は制約として使用できません。'System.Delegate' のつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEnumConstraint">
        <source>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</source>
        <target state="translated">キーワード 'enum' は制約として使用できません。'struct, System.Enum' のつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvTargetTypedConditional">
        <source>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</source>
        <target state="translated">'{1}' と '{2}' の間に共通の型が見つからないため、言語バージョン {0} で条件式が無効です。ターゲットにより型指定された変換を使用するには、言語バージョン {3} 以上にアップグレードしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="translated">出力ディレクトリを特定できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPrivateAPIInRecord">
        <source>Record member '{0}' must be private.</source>
        <target state="translated">レコード メンバー '{0}' は private でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonProtectedAPIInRecord">
        <source>Record member '{0}' must be protected.</source>
        <target state="translated">レコード メンバー '{0}' は protected でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicAPIInRecord">
        <source>Record member '{0}' must be public.</source>
        <target state="translated">レコード メンバー '{0}' は public でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicParameterlessStructConstructor">
        <source>The parameterless struct constructor must be 'public'.</source>
        <target state="translated">パラメーターなしの構造体コンストラクターは 'パブリック' でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughCloseBracesForRawString">
        <source>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</source>
        <target state="translated">補間は、生文字列リテラルの開始文字である '$' の数と同じ数の終わり波かっこで終わる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughQuotesForRawString">
        <source>Not enough quotes for raw string literal.</source>
        <target state="translated">生文字列リテラルに十分な数の引用符がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not an instance method, the receiver cannot be an interpolated string handler argument.</source>
        <target state="translated">'{0}' はインスタンス メソッドではありません。レシーバーを、補間された文字列ハンドラー引数にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableAPIInRecord">
        <source>'{0}' must allow overriding because the containing record is not sealed.</source>
        <target state="translated">'{0}' ではオーバーライドを許可する必要があります。これが含まれているレコードが sealed ではないためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullInvalidInterpolatedStringHandlerArgumentName">
        <source>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</source>
        <target state="translated">null は有効なパラメーター名ではありません。インスタンス メソッドのレシーバーへのアクセスを取得するには、パラメーター名として空の文字列を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">'enable'、'disable'、'restore' のいずれかが必要でした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">'warnings'、'annotations'、またはディレクティブの終わりが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">'{0}' 値が無効です: C# {2} に対する '{1}'。言語バージョン '{3}' 以上をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">言語バージョン '{0}' 以上を使用していない限り、null 許容の型パラメーターは値の型または null 非許容の参照型であることがわかっている必要があります。言語バージョンを変更するか、'class'、'struct'、または型制約を追加することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedTypeArgument">
        <source>Omitting the type argument is not allowed in the current context</source>
        <target state="translated">型引数を省略することは、現在のコンテキストでは許可されません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantBeChecked">
        <source>User-defined operator '{0}' cannot be declared checked</source>
        <target state="translated">ユーザー定義演算子 '{0}' はチェック済みと宣言できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefReadonlyParam">
        <source>A ref readonly parameter cannot have the Out attribute.</source>
        <target state="translated">ref 読み取り専用パラメーターに Out 属性を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">out 変数を ref ローカルと宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideDefaultConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</source>
        <target state="translated">メソッド '{0}' は、型パラメーター '{1}' に対して 'default' 制約を指定していますが、オーバーライドされた、または明示的に実装されたメソッド '{3}' の対応する型パラメーター '{2}' は、参照型または値の型に制約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideMustHaveRequired">
        <source>'{0}' must be required because it overrides required member '{1}'</source>
        <target state="translated">必要なメンバー'{1}'をオーバーライドするため、'{0}' が必須です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">メソッド '{0}' は、型パラメーター '{1}' に対して 'class' 制約を指定していますが、オーバーライドされた、または明示的に実装されたメソッド '{3}' の対応する型パラメーター '{2}' は参照型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">メソッド '{0}' は、型パラメーター '{1}' に対して 'struct' 制約を指定していますが、オーバーライドされた、または明示的に実装されたメソッド '{3}' の対応する型パラメーター '{2}' は NULL 非許容の値型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNullCheckingNotSupported">
        <source>The 'parameter null-checking' feature is not supported.</source>
        <target state="translated">'parameter null-checking' 機能はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodAccessibilityDifference">
        <source>Both partial method declarations must have identical accessibility modifiers.</source>
        <target state="translated">両方の部分メソッド宣言には、同じアクセシビリティ修飾子を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtendedModDifference">
        <source>Both partial method declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</source>
        <target state="translated">両方の部分メソッド宣言には、'virtual'、'override'、'sealed'、'new' 修飾子の同じ組み合わせを指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReadOnlyDifference">
        <source>Both partial method declarations must be readonly or neither may be readonly</source>
        <target state="translated">部分メソッド宣言は、両方とも readonly であるか、両方とも readonly でないかのいずれかである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodRefReturnDifference">
        <source>Partial method declarations must have matching ref return values.</source>
        <target state="translated">部分メソッドの宣言には、一致する ref 戻り値が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReturnTypeDifference">
        <source>Both partial method declarations must have the same return type.</source>
        <target state="translated">部分メソッドの両方の宣言には、同じ戻り値の型を指定しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
        <source>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</source>
        <target state="translated">部分メソッド '{0}' にはアクセシビリティ修飾子が指定されているため、実装部分が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithExtendedModMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</source>
        <target state="translated">部分メソッド '{0}' には、'virtual'、'override'、'sealed'、'new'、または 'extern' 修飾子が指定されているため、アクセシビリティ修飾子が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</source>
        <target state="translated">部分メソッド '{0}' には、void 以外の戻り値の型が指定されているため、アクセシビリティ修飾子が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithOutParamMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</source>
        <target state="translated">部分メソッド '{0}' には、'out' パラメーターが指定されているため、アクセシビリティ修飾子が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternSpanCharCannotBeStringNull">
        <source>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</source>
        <target state="translated">文字列 'null' 定数は、'{0}' のパターンとしてサポートされていません。代わりに空の文字列を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">ポインター型でパターン マッチングを使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">非同期反復子メソッドの本体には 'yield' ステートメントを含める必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">非同期反復子メソッドの本体には 'yield' ステートメントを含める必要があります。メソッド宣言から 'async' を削除するか、'yield' ステートメントを追加することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">プロパティ サブパターンには、一致させるプロパティまたはフィールドへの参照が必要です。例: '{{ Name: {0} }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringDelimiterOnOwnLine">
        <source>Raw string literal delimiter must be on its own line.</source>
        <target state="translated">生文字列リテラルの区切り記号は、独自の行に置かれる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringInVerbatimInterpolatedStrings">
        <source>Multi-line raw string literals are only allowed in verbatim interpolated strings.</source>
        <target state="translated">複数行の生文字列リテラルは、逐語的に補間された文字列でのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringMustContainContent">
        <source>Multi-line raw string literals must contain at least one line of content.</source>
        <target state="translated">複数行の生文字列リテラルには、少なくとも 1 行のコンテンツが含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringNotInDirectives">
        <source>Raw string literals are not allowed in preprocessor directives.</source>
        <target state="translated">プリプロセッサ ディレクティブでは、生文字列リテラルは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">型 '{0}' には基底インターフェイスからのメンバーの再抽象化があるため、この型を埋め込むことはできません。'相互運用型の埋め込み' プロパティを false に設定することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 'readonly' は、プロパティまたはインデクサーが get および set の両方のアクセサーを含む場合にのみ、アクセサーで使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordAmbigCtor">
        <source>The primary constructor conflicts with the synthesized copy constructor.</source>
        <target state="translated">プライマリ コンストラクターが、合成されたコピー コンストラクターと競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordStructConstructorCallsDefaultConstructor">
        <source>A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</source>
        <target state="translated">パラメーター リストを使用して 'struct' で宣言されたコンストラクターには、プライマリ コンストラクターまたは明示的に宣言されたコンストラクターを呼び出す 'this' 初期化子が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">'{1}' を '{0}' に ref 割り当てすることはできません。'{1}' のエスケープ スコープが '{0}' より狭いためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignReturnOnly">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">'{1}' は return ステートメントを介してのみ現在のメソッドをエスケープできるため、'{1}' を '{0}' に ref 割り当てすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignValEscapeWider">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">'{1}' を '{0}' に参照割り当てできません。'{1}' には '{0}' よりも広い値エスケープ スコープがあり、'{0}' を使用して '{1}' より狭いエスケープ スコープを持つ値の割り当てが許可されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldCannotReferToRefStruct">
        <source>A ref field cannot refer to a ref struct.</source>
        <target state="translated">ref フィールドは ref 構造体を参照できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldInNonRefStruct">
        <source>A ref field can only be declared in a ref struct.</source>
        <target state="translated">ref フィールドは ref 構造体でのみ宣言できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref variable.</source>
        <target state="translated">ref 代入の左辺は ref 変数である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadOnlyWrongOrdering">
        <source>'readonly' modifier must be specified after 'ref'.</source>
        <target state="translated">'readonly' 修飾子は 'ref' の後に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーターは、ref または out 値として使用できません (型または変数初期化子の init 専用セッターを除く)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーター '{0}' のメンバーを ref または out 値として使用することはできません (型または変数初期化子の init 専用セッターを除く)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter">
        <source>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">ref パラメーター経由で参照渡し '{0}' でパラメーターを返すことはできません。返すことができるのは return ステートメント内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter2">
        <source>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">ref パラメーター経由で '{0}' パラメーターのメンバーを参照渡しで返すことはできません。return ステートメントでのみ返すことができます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnPrimaryConstructorParameter">
        <source>Cannot return primary constructor parameter '{0}' by reference.</source>
        <target state="translated">参照渡しでプライマリ コンストラクター パラメーター '{0}' を返すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be returned by writable reference</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーターを書き込み可能な参照で返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference</source>
        <target state="translated">読み取り専用型のプライマリ コンストラクター パラメーター '{0}' のメンバーを書き込み可能な参照で返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter">
        <source>Cannot return a parameter by reference '{0}' because it is scoped to the current method</source>
        <target state="translated">現在のメソッドに範囲指定されているため、参照渡し '{0}' でパラメーターを返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</source>
        <target state="translated">現在のメソッドに範囲指定されているため、パラメーター '{0}' のメンバーを参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningPropertiesCannotBeRequired">
        <source>Ref returning properties cannot be required.</source>
        <target state="translated">プロパティを返す参照は必要ありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RelationalPatternWithNaN">
        <source>Relational patterns may not be used for a floating-point NaN.</source>
        <target state="translated">リレーショナル パターンは、浮動小数点の NaN に使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeHidden">
        <source>Required member '{0}' cannot be hidden by '{1}'.</source>
        <target state="translated">必要なメンバー '{0}' を '{1}' で非表示にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
        <source>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</source>
        <target state="translated">必要なメンバー '{0}' の表示を減らす、また含まれる型の '{1}' より小さいセッターの表示を設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSet">
        <source>Required member '{0}' must be set in the object initializer or attribute constructor.</source>
        <target state="translated">必要なメンバー '{0}' は、オブジェクト初期化子または属性コンストラクターに設定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSettable">
        <source>Required member '{0}' must be settable.</source>
        <target state="translated">必要なメンバー '{0}' は設定可能である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersBaseTypeInvalid">
        <source>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</source>
        <target state="translated">基本データ型 '{0}' に必要なメンバーの一覧の形式が正しくないため、解釈できません。このコンストラクターを使用するには、'SetsRequiredMembers' 属性を適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersInvalid">
        <source>The required members list for '{0}' is malformed and cannot be interpreted.</source>
        <target state="translated">'{0}' に必要なメンバーの一覧の形式が正しくないため、解釈できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersMustBeAssignedValue">
        <source>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</source>
        <target state="translated">必要なメンバー '{0}' に値を割り当てる必要があります。入れ子になったメンバーまたはコレクション初期化子を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNameDisallowed">
        <source>Types and aliases cannot be named 'required'.</source>
        <target state="translated">型とエイリアスに 'required' という名前を付けることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
        <source>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': ターゲットのランタイムはオーバーライドで covariant 型をサポートしていません。型は、オーバーライドされるメンバー '{1}' と一致する '{2}' にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
        <source>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': ターゲットのランタイムはオーバーライドで戻り値の型 covariant をサポートしていません。戻り値の型は、オーバーライドされるメンバー '{1}' と一致する '{2}' にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportInlineArrayTypes">
        <source>Target runtime doesn't support inline array types.</source>
        <target state="translated">ターゲットのランタイムはインライン配列型をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">ターゲット ランタイムは、インターフェイスのメンバーに対して 'protected'、'protected internal'、'private protected' アクセシビリティをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportRefFields">
        <source>Target runtime doesn't support ref fields.</source>
        <target state="translated">対象のランタイムは ref フィールドをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
        <source>Target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">ターゲット ランタイムでは、インターフェイスの静的な抽象メンバーをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">ターゲットのランタイムは、インターフェイス内の静的な抽象メンバーをサポートしていないため、'{0}' は型 '{2}' のインターフェイス メンバー '{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
        <source>The target runtime doesn't support extensible or runtime-environment default calling conventions.</source>
        <target state="translated">ターゲット ランタイムは、拡張可能またはランタイム環境の既定の呼び出し規則をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedDiscard">
        <source>The 'scoped' modifier cannot be used with discard.</source>
        <target state="translated">'scoped' 修飾子を discard と共に使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">パラメーター '{0}' の 'scoped' 修飾子が、オーバーライドされたメンバーまたは実装されたメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfPartial">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">パラメーター '{0}' の 'scoped' 修飾子が部分メソッド宣言と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">パラメーター '{0}' の 'scoped' 修飾子がターゲット '{1}'と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedRefAndRefStructOnly">
        <source>The 'scoped' modifier can be used for refs and ref struct values only.</source>
        <target state="translated">'scoped' 修飾子は refs および ref 構造体の値にのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedTypeNameDisallowed">
        <source>Types and aliases cannot be named 'scoped'.</source>
        <target state="translated">型とエイリアスに 'scoped' という名前を付けることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
        <source>Required members are not allowed on the top level of a script or submission.</source>
        <target state="translated">必要なメンバーは、スクリプトまたは送信の最上位レベルでは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedAPIInRecord">
        <source>'{0}' cannot be sealed because containing record is not sealed.</source>
        <target state="translated">'{0}' を sealed にすることはできません。これが含まれているレコードが sealed ではないためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignatureMismatchInRecord">
        <source>Record member '{0}' must return '{1}'.</source>
        <target state="translated">レコード メンバー '{0}' は '{1}' を返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramDisallowsMainType">
        <source>Cannot specify /main if there is a compilation unit with top-level statements.</source>
        <target state="translated">トップレベルのステートメントを含むコンパイル ユニットがある場合、/main を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramIsEmpty">
        <source>At least one top-level statement must be non-empty.</source>
        <target state="translated">少なくとも 1 つの最上位のステートメントを空以外にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
        <source>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</source>
        <target state="translated">このコンテキストでは、トップレベルのステートメントで宣言されたローカル変数またはローカル関数 '{0}' を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
        <source>Only one compilation unit can have top-level statements.</source>
        <target state="translated">トップレベルのステートメントを持つことができるのは、1 つのコンパイル ユニットのみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramNotAnExecutable">
        <source>Program using top-level statements must be an executable.</source>
        <target state="translated">トップレベルのステートメントを使用するプログラムは、実行可能ファイルである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">単一要素の分解パターンには、あいまいさを排除するための他の構文が必要です。破棄指定子 '_' を閉じかっこ ')' の後に追加することをお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpreadMissingMember">
        <source>Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="new">Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAPIInRecord">
        <source>Record member '{0}' may not be static.</source>
        <target state="translated">レコード メンバー '{0}' を static にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureThis">
        <source>A static anonymous function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">静的な匿名関数に 'this' または 'base' への参照を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureVariable">
        <source>A static anonymous function cannot contain a reference to '{0}'.</source>
        <target state="translated">静的な匿名関数に '{0}' への参照を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">静的なローカル関数に 'this' または 'base' への参照を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">静的なローカル関数に '{0}' への参照を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">静的メンバー '{0}' を 'readonly' とマークすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">stdin 引数 '-' が指定されていますが、入力が標準入力ストリームからリダイレクトされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StringMustStartWithQuoteCharacter">
        <source>String must start with quote character: "</source>
        <target state="translated">文字列の先頭は引用符文字である必要があります: "</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructHasInitializersAndNoDeclaredConstructor">
        <source>A 'struct' with field initializers must include an explicitly declared constructor.</source>
        <target state="translated">フィールド初期化子を持つ 'struct' には、明示的に宣言されたコンストラクターを含める必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCyclePrimaryConstructorParameter">
        <source>Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">型 '{1}' の構造体のプライマリ コンストラクター パラメーター '{0}' により、構造体レイアウトで循環が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</source>
        <target state="translated">このパターンには到達できません。これは、switch 式の以前のアームによって既に処理されたか、一致させることができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</source>
        <target state="translated">switch ケースに到達できません。以前のケースで既に処理されたか、一致させることができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">switch 式に最適な型が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">switch を制御する式の周囲にはかっこが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SymbolDefinedInAssembly">
        <source>'{0}' is defined in assembly '{1}'.</source>
        <target state="translated">'{0}' はアセンブリ '{1}' で定義されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCloseBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</source>
        <target state="translated">補間された生文字列リテラルの先頭に十分な数の '$' 文字がないため、連続する終わり波かっこをコンテンツとして使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyOpenBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</source>
        <target state="translated">補間された生文字列リテラルの先頭に十分な数の '$' 文字がないため、連続した始め波かっこをコンテンツとして使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyQuotesForRawString">
        <source>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</source>
        <target state="translated">生文字列リテラルの先頭に十分な数の引用符文字がないため、連続した引用符文字をコンテンツとして使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TopLevelStatementAfterNamespaceOrType">
        <source>Top-level statements must precede namespace and type declarations.</source>
        <target state="translated">トップレベルのステートメントは、名前空間および型の宣言の前にある必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">予期しない文字シーケンス '...'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">名前 '{0}' はタプル要素 '{1}' を識別しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">演算子 == または != のオペランドとして使用するタプルの型は、カーディナリティが一致している必要があります。しかし、この演算子は、左辺のタプルの型のカーディナリティが {0} で、右辺が {1} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConstraintsMustBeUniqueAndFirst">
        <source>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</source>
        <target state="translated">'class'、'struct'、'unmanaged'、'notnull'、'default' の制約を組み合わせたり、複製したりすることはできません。これらは制約リストの最初に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeIsNotAnInterpolatedStringHandlerType">
        <source>'{0}' is not an interpolated string handler type.</source>
        <target state="translated">'{0}' は、補間された文字列ハンドラー型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMustBePublic">
        <source>Type '{0}' must be public to be used as a calling convention.</source>
        <target state="translated">呼び出し規則として使用する型 '{0}' はパブリックでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">コントロールを呼び出し元に返す前に、自動実装プロパティ '{0}' を完全に割り当てる必要があります。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">コントロールを呼び出し元に返す前に、フィールド '{0}' を完全に割り当てる必要があります。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedParameterList">
        <source>Unexpected parameter list.</source>
        <target state="translated">予期しないパラメーター リストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}' は 'UnmanagedCallersOnly' 属性が設定されているため、直接呼び出すことはできません。このメソッドへの関数ポインターを取得してください。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}' は 'UnmanagedCallersOnly' 属性が設定されているため、デリゲート型に変換できません。このメソッドへの関数ポインターを取得してください。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedRefSafetyRulesAttributeVersion">
        <source>'{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.</source>
        <target state="translated">'{0}' は、認識されない RefSafetyRulesAttribute バージョンを持つモジュールで定義され、'11' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeInterfaceImplementation">
        <source>UnscopedRefAttribute cannot be applied to an interface implementation.</source>
        <target state="translated">UnscopedRefAttribute をインターフェイスの実装に適用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedMemberTarget">
        <source>UnscopedRefAttribute can only be applied to struct instance methods and properties, and cannot be applied to constructors or init-only members.</source>
        <target state="translated">UnscopedRefAttribute は構造体インスタンスのメソッドとプロパティにのみ適用でき、コンストラクターまたは init のみのメンバーには適用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedTarget">
        <source>UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.</source>
        <target state="translated">UnscopedRefAttribute は、既定では範囲外であるため、このパラメーターに適用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedScoped">
        <source>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</source>
        <target state="translated">UnscopedRefAttribute は、'scoped' 修飾子を持つパラメーターには適用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCompilerFeature">
        <source>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</source>
        <target state="translated">'{0}' にはコンパイラ機能 '{1}' が必要ですが、このバージョンのC## コンパイラではサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRef">
        <source>Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member</source>
        <target state="translated">インスタンス メンバー内のプライマリ コンストラクター パラメーター '{0}' では ref、out、in を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefAny">
        <source>Cannot use primary constructor parameter of type '{0}' inside an instance member</source>
        <target state="translated">インスタンス メンバー内に ref に似た型を持つプライマリ コンストラクター パラメーター '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefLike">
        <source>Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member</source>
        <target state="translated">インスタンス メンバー内に ref に似た型を持つプライマリ コンストラクター パラメーター '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForListPattern">
        <source>List patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">リスト パターンは、'{0}' 型の値に使用されない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForSlicePattern">
        <source>Slice patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">スライス パターンは、'{0}' 型の値に使用されない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedRawString">
        <source>Unterminated raw string literal.</source>
        <target state="translated">生文字列リテラルが終了していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">割り当てられていない可能性のあるフィールド '{0}' を使用しています。フィールドを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティ '{0}' を使用しています。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">すべてのフィールドが割り当てられる前に、'this' オブジェクトを使用することはできません。割り当てられていないフィールドを自動既定値にするため '{0}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongArityAsyncReturn">
        <source>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</source>
        <target state="translated">汎用タスクのような戻り値の型が必要ですが、'AsyncMethodBuilder' 属性で見つかった型 '{0}' が適切ではありませんでした。アリティの非バインド ジェネリック型である必要があり、それを含む型 (存在する場合) は非ジェネリックでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing">
        <source>The using directive for '{0}' appeared previously as global using</source>
        <target state="translated">'{0}' の using ディレクティブは、以前に global using として使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing_Title">
        <source>The using directive appeared previously as global using</source>
        <target state="translated">using ディレクティブは、以前に global using として使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ArrayAccess">
        <source>array access</source>
        <target state="translated">配列アクセス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AsyncMethodBuilderOverride">
        <source>async method builder override</source>
        <target state="translated">非同期メソッド ビルダーのオーバーライド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoDefaultStructs">
        <source>auto default struct fields</source>
        <target state="translated">自動既定の構造体フィールド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCheckedUserDefinedOperators">
        <source>checked user-defined operators</source>
        <target state="translated">チェックされたユーザー定義演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressions">
        <source>collection expressions</source>
        <target state="new">collection expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCovariantReturnsForOverrides">
        <source>covariant returns</source>
        <target state="translated">covariant の戻り値</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDiscards">
        <source>discards</source>
        <target state="translated">ディスカード</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDisposalPattern">
        <source>pattern-based disposal</source>
        <target state="translated">パターン ベースの廃棄</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPropertyPatterns">
        <source>extended property patterns</source>
        <target state="translated">拡張プロパティ パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileScopedNamespace">
        <source>file-scoped namespace</source>
        <target state="translated">ファイルスコープの名前空間</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileTypes">
        <source>file types</source>
        <target state="translated">ファイルの種類</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenericAttributes">
        <source>generic attributes</source>
        <target state="translated">汎用属性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalUsing">
        <source>global using directive</source>
        <target state="translated">グローバル using ディレクティブ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitObjectCreation">
        <source>target-typed object creation</source>
        <target state="translated">target-typed オブジェクトの作成</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImprovedInterpolatedStrings">
        <source>interpolated string handlers</source>
        <target state="translated">補間された文字列ハンドラー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInferredDelegateType">
        <source>inferred delegate type</source>
        <target state="translated">推論されたデリゲート型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInlineArrays">
        <source>inline arrays</source>
        <target state="translated">インライン配列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInstanceMemberInNameof">
        <source>instance member in 'nameof'</source>
        <target state="translated">'nameof' のインスタンス メンバー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaAttributes">
        <source>lambda attributes</source>
        <target state="translated">ラムダ属性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaOptionalParameters">
        <source>lambda optional parameters</source>
        <target state="translated">ラムダの省略可能なパラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaParamsArray">
        <source>lambda params array</source>
        <target state="translated">ラムダ パラメーター配列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaReturnType">
        <source>lambda return type</source>
        <target state="translated">ラムダ戻り値の型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureListPattern">
        <source>list pattern</source>
        <target state="translated">リスト パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNewLinesInInterpolations">
        <source>newlines in interpolations</source>
        <target state="translated">補間における改行</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParameterlessStructConstructors">
        <source>parameterless struct constructors</source>
        <target state="translated">パラメーターのない構造体コンストラクター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePositionalFieldsInRecords">
        <source>positional fields in records</source>
        <target state="translated">レコード内の位置指定フィールド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrimaryConstructors">
        <source>primary constructors</source>
        <target state="translated">プライマリ コンストラクター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRawStringLiterals">
        <source>raw string literals</source>
        <target state="translated">生文字列リテラル</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecordStructs">
        <source>record structs</source>
        <target state="translated">レコード構造体</target>
        <note>'record structs' is not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFields">
        <source>ref fields</source>
        <target state="translated">ref フィールド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReadonlyParameters">
        <source>ref readonly parameters</source>
        <target state="translated">ref 読み取り専用パラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelaxedShiftOperator">
        <source>relaxed shift operator</source>
        <target state="translated">緩和されたシフト演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRequiredMembers">
        <source>required members</source>
        <target state="translated">必要なメンバー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSealedToStringInRecord">
        <source>sealed ToString in record</source>
        <target state="translated">レコードでシールされた ToString</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStructFieldInitializers">
        <source>struct field initializers</source>
        <target state="translated">構造体フィールド初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnsignedRightShift">
        <source>unsigned right shift</source>
        <target state="translated">符号なし右シフト</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUtf8StringLiterals">
        <source>UTF-8 string literals</source>
        <target state="translated">UTF-8 文字列リテラル</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingTypeAlias">
        <source>using type alias</source>
        <target state="translated">using 型のエイリアス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnAnonymousTypes">
        <source>with on anonymous types</source>
        <target state="translated">匿名型の場合</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAbstractMembersInInterfaces">
        <source>static abstract members in interfaces</source>
        <target state="translated">インターフェイスの静的な要約メンバー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnStructs">
        <source>with on structs</source>
        <target state="translated">構造体の場合</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSpanCharConstantPattern">
        <source>pattern matching ReadOnly/Span&lt;char&gt; on constant string</source>
        <target state="translated">定数文字列の ReadOnly/Span&lt;char&gt; に一致するパターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ImplicitIndexerInitializer">
        <source>implicit indexer initializer</source>
        <target state="translated">暗黙的なインデクサー初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Missing">
        <source>&lt;missing&gt;</source>
        <target state="translated">&lt;missing&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PointerElementAccess">
        <source>pointer element access</source>
        <target state="translated">ポインター要素アクセス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ARRAY">
        <source>array</source>
        <target state="translated">配列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_DYNAMIC">
        <source>dynamic</source>
        <target state="translated">ダイナミック</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FUNCTION_POINTER">
        <source>function pointer</source>
        <target state="translated">関数ポインター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_POINTER">
        <source>pointer</source>
        <target state="translated">ポインター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_StringEscapeCharacter">
        <source>string escape character</source>
        <target state="translated">文字列エスケープ文字</target>
        <note />
      </trans-unit>
      <trans-unit id="ISpreadOperationIsNotCSharpSpread">
        <source>{0} is not a valid C# spread operation</source>
        <target state="translated">{0} は有効な C# 分散演算ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">'&amp;' 演算子は、非同期メソッドのパラメーターまたはローカル変数では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync_Title">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">'&amp;' 演算子は、非同期メソッドのパラメーターまたはローカル変数では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">型 '{1}' を含むアセンブリ '{0}' が .NET Framework を参照しています。これはサポートされていません。</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">読み込まれたアセンブリが .NET Framework を参照しています。これはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler">
        <source>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="translated">アナライザー アセンブリ '{0}' は、コンパイラのバージョン '{1}' を参照しています。これは、現在実行中のバージョン '{2}' よりも新しいバージョンです。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler_Title">
        <source>The analyzer assembly references a newer version of the compiler than the currently running version.</source>
        <target state="translated">アナライザー アセンブリが参照しるコンパイラのバージョンは、現在実行中のバージョンよりも新しいです。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn">
        <source>Argument {0} should be passed with the 'in' keyword</source>
        <target state="new">Argument {0} should be passed with the 'in' keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn_Title">
        <source>Argument should be passed with the 'in' keyword</source>
        <target state="new">Argument should be passed with the 'in' keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn">
        <source>Argument {0} should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">引数 {0} は 'ref' または 'in' キーワード (keyword)と共に渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn_Title">
        <source>Argument should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">引数は 'ref' または 'in' キーワード (keyword)で渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">型 '{0}' は、メタデータで表現できないため、このコンテキストでは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttrDependentTypeNotAllowed_Title">
        <source>Type cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">型は、メタデータで表現できないため、このコンテキストで使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef">
        <source>The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">'in' パラメーターに対応する引数 {0} の 'ref' 修飾子が 'in' と同じです。代わりに 'in' を使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef_Title">
        <source>The 'ref' modifier for an argument corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">'in' パラメーターに対応する引数の 'ref' 修飾子は 'in' と同じです。代わりに 'in' を使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="new">Attribute parameter 'SizeConst' must be specified.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired_Title">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="new">Attribute parameter 'SizeConst' must be specified.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing">
        <source>This combination of arguments to '{0}' may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">'{0}' に対するこの引数の組み合わせは、パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallArgMixing_Title">
        <source>This combination of arguments may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">この引数の組み合わせは、パラメーターによって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は、無効なパラメーター名で適用されているため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
        <source>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</source>
        <target state="translated">CallerArgumentExpressionAttribute が無効なパラメーター名で適用されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は自己参照であるため、無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
        <source>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</source>
        <target state="translated">パラメーターに適用された CallerArgumentExpressionAttribute は自己参照であるため、無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は、省略可能な引数を許可しないコンテキストで使用されるメンバーに適用されるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerArgumentExpressionAttribute は、オプションの引数を許可していないコンテキストで使用されるメンバーに適用されるため、無効になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は、CallerFilePathAttribute によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute は、、CallerFilePathAttribute によってオーバーライドされるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は、CallerLineNumberAttribute によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute は、、CallerLineNumberAttribute によってオーバーライドされるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerArgumentExpressionAttribute は、CallerMemberNameAttribute によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute は効果がなく、CallerMemberNameAttribute によってオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">パラメーター '{0}' は外側の型の状態にキャプチャされ、その値はフィールド、プロパティ、またはイベントの初期化にも使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">パラメーターは外側の型の状態にキャプチャされ、その値はフィールド、プロパティ、またはイベントの初期化にも使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">パラメーター '{0}' は外側の型の状態にキャプチャされ、その値も基底コンストラクターに渡されます。この値は、基底クラスでもキャプチャされる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">パラメーターは外側の型の状態にキャプチャされ、その値も基底コンストラクターに渡されます。この値は、基底クラスでもキャプチャされる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">'{0}' 型のコレクション式では、予期しないヒープ割り当てが発生する可能性があります。配列を明示的に作成してから、'{0}' に変換して割り当てを明示的にすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">コレクション式で予期しないヒープ割り当てが発生する可能性があります。配列を明示的に作成してから、最後の型に変換して割り当てを明示的にすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">型 '{0}' のコレクション式では、'..' 拡散が使用されているため、予期しないヒープ割り当てが発生する可能性があります。配列を明示的に作成してから、'{0}' に変換して割り当てを明示的にすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations due to use of '..' spreads. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">'..' 拡散が使用されているため、コレクション式で予期しないヒープ割り当てが発生する可能性があります。配列を明示的に作成してから、最後の型に変換して割り当てを明示的にすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow">
        <source>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">実行時に操作がオーバーフロー '{0}' する可能性があります (オーバーライドするには 'unchecked' 構文を使用してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow_Title">
        <source>The operation may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">実行時に操作がオーバーフローする可能性があります (オーバーライドするには 'unchecked' 構文を使用してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers">
        <source>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</source>
        <target state="translated">同じ関数へのポインターがそれぞれ異なっている可能性があるため、関数ポインターの比較によって予期しない結果が生成されるおそれがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers_Title">
        <source>Do not compare function pointer values</source>
        <target state="translated">関数ポインター値を比較しない</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference">
        <source>Analyzer reference '{0}' specified multiple times</source>
        <target state="translated">複数回指定されたアナライザー参照 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference_Title">
        <source>Analyzer reference specified multiple times</source>
        <target state="translated">複数回指定されたアナライザー参照</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall">
        <source>Use of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">このコンテキストで '{0}' の結果を使用すると、パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2">
        <source>Use of member of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">このコンテキストで '{0}' の結果のメンバーを使用すると、パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall2_Title">
        <source>Use of member of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">このコンテキストで結果のメンバーを使用すると、パラメーターによって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeCall_Title">
        <source>Use of result in this context may expose variables referenced by parameter outside of their declaration scope</source>
        <target state="translated">このコンテキストで結果を使用すると、パラメーターによって参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</source>
        <target state="translated">このコンテキストにおけるこの種類 '{0}' の stackalloc 式の結果は、それを含んでいるメソッドの外部に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc_Title">
        <source>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</source>
        <target state="translated">このコンテキストにおけるこの種類の stackalloc 式の結果は、それを含んでいるメソッドの外部に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable">
        <source>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">このコンテキストでの変数 '{0}' の使用は、参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable_Title">
        <source>Use of variable in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">このコンテキストでの変数の使用は、参照される変数が宣言のスコープ外に公開される可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">インライン配列変換演算子は、宣言する型の式からの変換には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed_Title">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">インライン配列変換演算子は、宣言する型の式からの変換には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">インライン配列インデクサーは要素アクセス式には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed_Title">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">インライン配列インデクサーは要素アクセス式には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="new">'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage_Title">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="new">'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">インライン配列 'Slice' メソッドは要素アクセス式には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed_Title">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">インライン配列 'Slice' メソッドは要素アクセス式には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.</source>
        <target state="translated">パラメーター '{0}' の参照の種類修飾子が、非表示のメンバーの対応するパラメーター '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in hidden member.</source>
        <target state="translated">パラメーターの参照の種類の修飾子が、非表示のメンバーの対応するパラメーターと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch">
        <source>Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.</source>
        <target state="translated">インターセプター '{1}' を使用して'{0}' への呼び出しをインターセプトしていますが、署名が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch_Title">
        <source>Signatures of interceptable and interceptor methods do not match.</source>
        <target state="translated">インターセプター可能なメソッドとインターセプター メソッドの署名が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">ラムダ パラメーターに適用しても InterpolatedStringHandlerArgument は効果がありません。呼び出しサイトでは無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">ラムダ パラメーターに適用しても InterpolatedStringHandlerArgument は効果がありません。呼び出しサイトでは無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName">
        <source>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">型名 '{0}' には、小文字の ASCII 文字のみが含まれています。このような名前は、プログラミング言語用に予約されている可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName_Title">
        <source>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">型名には、小文字の ASCII 文字のみが含まれています。このような名前は、プログラミング言語用に予約されている可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</source>
        <target state="translated">これは、マネージ型 ('{0}') のアドレスの取得、サイズの取得、またはそのマネージ型へのポインターの宣言を行います</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr_Title">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type</source>
        <target state="translated">これは、マネージ型のアドレスの取得、サイズの取得、またはそのマネージ型へのポインターの宣言を行います</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel">
        <source>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">メソッド グループ '{0}' を非デリゲート型 '{1}' に変換中です。このメソッドを呼び出すつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel_Title">
        <source>Converting method group to non-delegate type</source>
        <target state="translated">メソッド グループを非デリゲート型に変換しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">ref 条件演算子のブランチでは、互換性のない宣言スコープを持つ変数を参照します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary_Title">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">ref 条件演算子のブランチでは、互換性のない宣言スコープを持つ変数を参照します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.</source>
        <target state="translated">パラメーター '{0}' の型における参照型の Null 許容性が、インターセプト可能なメソッド '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor_Title">
        <source>Nullability of reference types in type of parameter doesn't match interceptable method.</source>
        <target state="translated">パラメーターの型における参照型の Null 許容性が、インターセプト可能なメソッドと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor">
        <source>Nullability of reference types in return type doesn't match interceptable method '{0}'.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、インターセプト可能なメソッド '{0}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor_Title">
        <source>Nullability of reference types in return type doesn't match interceptable method.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、インターセプト可能なメソッドと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired">
        <source>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">必要なメンバー '{0}' は、包含する型が古い形式であるか、すべてのコンストラクターが古い形式でない限り、属性 'ObsoleteAttribute' が必要ありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired_Title">
        <source>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">'ObsoleteAttribute' 属性を持つメンバーは、包含する型が古い形式であるか、すべてのコンストラクターが古い形式でない限り、必要ありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch">
        <source>Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.</source>
        <target state="translated">パラメーター {0} のラムダでの既定値は '{1:10}' だが、ターゲットデリゲート型では '{2:10}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch_Title">
        <source>The default parameter value does not match in the target delegate type.</source>
        <target state="translated">既定のパラメーター値がターゲット デリゲート型と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.</source>
        <target state="translated">パラメーター '{0}' の参照の種類修飾子が、オーバーライドされたメンバーまたは実装されるメンバーの対応するパラメーター '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in overridden or implemented member.</source>
        <target state="translated">パラメーターの参照の種類修飾子が、オーバーライドされたメンバーまたは実装されたメンバーの対応するパラメーターと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull">
        <source>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</source>
        <target state="translated">パラメーター '{1}' が null 以外であるため、パラメーター '{0}' には、終了時に null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull_Title">
        <source>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</source>
        <target state="translated">NotNullIfNotNull によって参照されているパラメーターが null 以外であるため、パラメーターには終了時に null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
        <source>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.</source>
        <target state="translated">パラメーター リスト内の '{1}' の後にパラメーター '{0}' が発生しますが、補間された文字列ハンドラーの変換の引数として使用されます。呼び出し元が呼び出しサイトで名前付き引数を使用してパラメーターを並べ替える必要があります。関係するすべての引数の後に、補間された文字列ハンドラーのパラメーターを指定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
        <source>Parameter to interpolated string handler conversion occurs after handler parameter</source>
        <target state="translated">パラメーターから補間された文字列ハンドラーへの変換は、ハンドラー パラメーターの後に発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly">
        <source>Parameter {0} has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">パラメーター {0} にラムダの params 修飾子がありますが、ターゲット デリゲート型にはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly_Title">
        <source>Parameter has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">パラメーターにラムダの params 修飾子がありますが、ターゲット デリゲート型にはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase">
        <source>Primary constructor parameter '{0}' is shadowed by a member from base.</source>
        <target state="translated">プライマリ コンストラクター パラメーター '{0}' は、ベースのメンバーによってシャドウされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase_Title">
        <source>Primary constructor parameter is shadowed by a member from base</source>
        <target state="translated">プライマリ コンストラクター パラメーターがベースのメンバーによってシャドウされています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode">
        <source>'{0}' defines 'Equals' but not 'GetHashCode'</source>
        <target state="translated">'{0}' では 'Equals' が定義されていますが、'GetHashCode' は定義されていません</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode_Title">
        <source>Record defines 'Equals' but not 'GetHashCode'.</source>
        <target state="translated">レコードでは 'Equals' が定義されていますが、'GetHashCode' は定義されていません。</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
        <source>Mixed declarations and expressions in deconstruction</source>
        <target state="translated">分解で宣言と式が混在しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference">
        <source>Partial method declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">部分メソッドの宣言 '{0}' と '{1}' には、シグネチャの違いがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference_Title">
        <source>Partial method declarations have signature differences.</source>
        <target state="translated">部分メソッドの宣言には、シグネチャの違いがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">型およびエイリアスに 'record' という名前を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed_Title">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">型およびエイリアスに 'record' という名前を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">これは、'{1}' を '{0}' に ref 割り当てしますが、'{1}' には '{0}' より狭いエスケープ スコープがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower_Title">
        <source>This ref-assigns a value that has a narrower escape scope than the target.</source>
        <target state="translated">これは、ターゲットより狭いエスケープ スコープを持つ値を ref 割り当てします。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">これは '{1}' を '{0}' に ref 割り当てしますが、'{1}' は return ステートメントを介してのみ現在のメソッドをエスケープできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly_Title">
        <source>This ref-assigns a value that can only escape the current method through a return statement.</source>
        <target state="translated">これは、return ステートメントを介してのみ現在のメソッドをエスケープできる値を ref 割り当てします。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escapes scopes than '{1}'.</source>
        <target state="translated">この参照は '{1}' に '{0}' を割り当てますが、'{1}' の値のエスケープ スコープは、'{0}' よりも狭いエスケープ スコープを持つ値の'{0}' を介した割り当てを許可する '{1}' よりも広い値のエスケープ スコープを持っています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider_Title">
        <source>This ref-assigns a value that has a wider value escape scope than the target allowing assignment through the target of values with narrower escapes scopes.</source>
        <target state="translated">この参照により、ターゲットよりも広い値エスケープ スコープを持つ値が割り当てられ、より狭いエスケープ スコープを持つ値のターゲットを介して割り当てることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable">
        <source>Argument {0} should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">引数 {0} は 'ref readonly' パラメーターに渡されるため、変数である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable_Title">
        <source>Argument should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">引数は 'ref readonly' パラメーターに渡されるため、変数である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue">
        <source>A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">'ref readonly' パラメーター '{0}' に既定値が指定されていますが、'ref readonly' は参照にのみ使用する必要があります。パラメーターを 'in' として宣言することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue_Title">
        <source>A default value is specified for 'ref readonly' parameter, but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">'ref readonly' パラメーターに既定値が指定されていますが、'ref readonly' は参照にのみ使用する必要があります。パラメーターを 'in' として宣言することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal">
        <source>This returns local '{0}' by reference but it is not a ref local</source>
        <target state="translated">これは、ローカル変数 '{0}' を参照渡しで返しますが、ref ローカル変数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2">
        <source>This returns a member of local '{0}' by reference but it is not a ref local</source>
        <target state="translated">これは、ローカル '{0}' のメンバーを参照渡しで返しますが、ref ローカル変数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2_Title">
        <source>This returns a member of local by reference but it is not a ref local</source>
        <target state="translated">これは、ローカルのメンバーを参照渡しで返しますが、ref ローカル変数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal_Title">
        <source>This returns local by reference but it is not a ref local</source>
        <target state="translated">これは、ローカル変数を参照渡しで返しますが、ref ローカル変数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal">
        <source>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">ローカル変数 '{0}' は参照渡しで返されますが、参照渡しで返せない値に初期化されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2">
        <source>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">'{0}' のメンバーは参照渡しで返されますが、参照渡しで返せない値に初期化されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2_Title">
        <source>A member is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">メンバーは参照渡しで返されますが、参照渡しで返せない値に初期化されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal_Title">
        <source>Local is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">ローカル変数は参照渡しで返されますが、参照渡しで返せない値に初期化されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter">
        <source>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">これは、ref パラメーター経由で参照渡し '{0}' でパラメーターを返しますが、安全に返すことができるのは return ステートメント内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2">
        <source>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">これは、ref パラメーター経由でパラメーター '{0}' のメンバーを参照渡しで返しますが、安全に返すことができるのは return ステートメント内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2_Title">
        <source>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">これは、ref パラメーター経由でパラメーターのメンバーを参照渡しで返しますが、安全に返すことができるのは return ステートメント内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter_Title">
        <source>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">これは、ref パラメーター経由で参照渡しでパラメーターを返しますが、安全に返すことができるのは return ステートメント内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter">
        <source>This returns a parameter by reference '{0}' but it is not a ref parameter</source>
        <target state="translated">これは、参照返し '{0}' でパラメーターを返しますが、ref パラメーターではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2">
        <source>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</source>
        <target state="translated">これは、ref パラメーターでも out パラメーターでもないパラメーター '{0}' のメンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2_Title">
        <source>This returns by reference a member of parameter that is not a ref or out parameter</source>
        <target state="translated">これは、ref パラメーターでも out パラメーターでもないパラメーターのメンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter_Title">
        <source>This returns a parameter by reference but it is not a ref parameter</source>
        <target state="translated">これは、参照返しでパラメーターを返しますが、ref パラメーターではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter">
        <source>This returns a parameter by reference '{0}' but it is scoped to the current method</source>
        <target state="translated">これは参照渡し '{0}' でパラメーターを返しますが、現在のメソッドに範囲設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2">
        <source>This returns by reference a member of parameter '{0}' that is scoped to the current method</source>
        <target state="translated">これは、現在のメソッドに範囲指定されているパラメーター '{0}' のメンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2_Title">
        <source>This returns by reference a member of parameter that is scoped to the current method</source>
        <target state="translated">これは、現在のメソッドに範囲指定されているパラメーターのメンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter_Title">
        <source>This returns a parameter by reference but it is scoped to the current method</source>
        <target state="translated">これは参照渡しでパラメーターを返しますが、現在のメソッドに範囲設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">構造体メンバーは 'this' または他のインスタンス メンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis_Title">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">構造体メンバーは 'this' または他のインスタンス メンバーを参照渡しで返します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull">
        <source>Return value must be non-null because parameter '{0}' is non-null.</source>
        <target state="translated">パラメーター '{0}' が null 以外であるため、戻り値は null 以外でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull_Title">
        <source>Return value must be non-null because parameter is non-null.</source>
        <target state="translated">パラメーターが null 以外であるため、戻り値は null 以外でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">パラメーター '{0}' の 'scoped' 修飾子が、オーバーライドされたメンバーまたは実装されたメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
        <source>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</source>
        <target state="translated">パラメーターの 'scoped' 修飾子が、オーバーライドされたメンバーまたは実装されたメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">パラメーター '{0}' の 'scoped' 修飾子がターゲット '{1}'と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget_Title">
        <source>The 'scoped' modifier of parameter doesn't match target.</source>
        <target state="translated">パラメーターの 'scoped' 修飾子がターゲットと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</source>
        <target state="translated">switch 式では、名前なしの列挙値を含む入力の種類の一部の値が処理されません (すべてが網羅されているわけではありません)。たとえば、パターン '{0}' がカバーされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</source>
        <target state="translated">switch 式では、名前なしの列挙値を含む入力の種類の一部の値が処理されない (すべてを網羅していない)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SyncAndAsyncEntryPoints">
        <source>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</source>
        <target state="translated">同期エントリ ポイント '{1}' が検出されたため、メソッド '{0}' はエントリ ポイントとして使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotFound">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">型 '{0}' は定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentList">
        <source>Unexpected argument list.</source>
        <target state="translated">予期しない引数リストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedOrMissingConstructorInitializerInRecord">
        <source>A constructor declared in a type with parameter list must have 'this' constructor initializer.</source>
        <target state="translated">パラメーター リストを持つ型で宣言されたコンストラクターには、'this' コンストラクター初期化子が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVarianceStaticMember">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</source>
        <target state="translated">無効な変性: 言語バージョン '{4}' 以上が使用されていない限り、型パラメーター '{1}' は '{0}' で {3} が有効である必要があります。'{1}' は {2} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">'{0}': 制約クラスと 'unmanaged' 制約の両方を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
        <source>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</source>
        <target state="translated">'UnmanagedCallersOnly' という属性を持つメソッドは、ジェネリック型パラメーターを持つことができません。また、ジェネリック型で宣言することはできません。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyRequiresStatic">
        <source>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</source>
        <target state="translated">'UnmanagedCallersOnly' は、通常の静的な非抽象的、仮想でないメソッドまたは静的なローカル関数にのみ適用できます。</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">型 '{2}' と、入れ子になっているあらゆるレベルのすべてのフィールドは、ジェネリック型またはメソッド '{0}' のパラメーター '{1}' として使用するために、Null 非許容の値型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCallingConvention">
        <source>The calling convention of '{0}' is not supported by the language.</source>
        <target state="translated">'{0}' の呼び出し規則は、この言語ではサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForRelationalPattern">
        <source>Relational patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">リレーショナル パターンは、'{0}' 型の値に使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">using 変数を switch セクションで直接使用することはできません (波かっこの使用をご検討ください)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">型を参照するためにパターンに構文 'var' を使用することは許可されていませんが、ここでは '{0}' がスコープ内にあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">'in' または 'out' の型パラメーターを持つインターフェイス内では、列挙体、クラス、および構造体を宣言することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongFuncPtrCallingConvention">
        <source>Calling convention of '{0}' is not compatible with '{1}'.</source>
        <target state="translated">'{0}' の呼び出し規則は '{1}' と互換性がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">タプル型 '{0}' のマッチングには '{1}' サブパターンが必要ですが、'{2}' サブパターンが指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">ファイル名 '{0}' は、空である、無効な文字を含んでいる、絶対パスが指定されていないドライブ指定がある、または長すぎるかのいずれかです</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AddressOfMethodGroup">
        <source>&amp;method group</source>
        <target state="translated">メソッド グループ(&amp;M)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0 or higher) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.
-skipanalyzers[+|-]           Skip execution of diagnostic analyzers.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
-generatedfilesout:&lt;dir&gt;      Place files generated during compilation in the
                              specified directory.
-reportivts[+|-]                    Output information on all IVTs granted to this
                              assembly by all dependencies, and annotate foreign assembly
                              accessibility errors with what assembly they came from.
</source>
        <target state="translated">
                            Visual C# Compiler のオプション

                      - 出力ファイル -
-out:&lt;file&gt;                   出力ファイル名を指定します (既定値: main クラスを含むファイルの
                             ベース名また最初のファイル)
-target:exe                   コンソール アプリケーションをビルドします (既定) (短い
                             形式: -t:exe)
-target:winexe                Windows 実行可能ファイルをビルドします (短い形式:
                             -t:winexe)
-target:library               ライブラリをビルドします (短い形式: -t:library)
-target:module                別のアセンブリに追加できるモジュールを
                             ビルドします (短い形式: -t:module)
-target:appcontainerexe       Appcontainer 実行可能ファイルをビルドします (短い形式:
                             -t:appcontainerexe)
-target:winmdobj              WinMDExp が使用する、Windows ランタイムの
                             中間ファイルをビルドします (短い形式: -t:winmdobj)
-doc:&lt;file&gt;                   生成する XML ドキュメント ファイルです
-refout:&lt;file&gt;                    生成する参照アセンブリ出力です
-platform:&lt;string&gt;                このコードを実行できるプラットフォームを限定します。x86、
                             Itanium、x64、arm、arm64、anycpu32bitpreferred、
                             anycpu のいずれかです。既定値は anycpu です。

                      - 入力ファイル -
-recurse:&lt;wildcard&gt;               ワイルドカードの仕様に従って、
                             現在のディレクトリとサブディレクトリ内のすべてのファイルを
                             含めます
-reference:&lt;alias&gt;=&lt;file&gt;     指定されたエイリアスを使用して、指定されたアセンブリ ファイルからの
                             メタデータを参照します (短い形式: -r)
-reference:&lt;file list&gt;        指定されたアセンブリ ファイルからのメタデータを
                             参照します (短い形式: -r)
-addmodule:&lt;file list&gt;        指定されたモジュールをこのアセンブリにリンクします
-link:&lt;file list&gt;             指定された相互運用アセンブリからのメタデータを
                             埋め込みます (短い形式: -l)
-analyzer:&lt;file list&gt;         このアセンブリからアナライザーを実行します
                             (短い形式: -a)
-additionalfile:&lt;file list&gt;   コードの生成に直接影響しないものの、エラーまたは警告を
                             生成するためにアナライザーが使用する可能性がある
                             追加ファイルです。
-embed                        PDB ファイル内にすべてのソース ファイルを埋め込みます。
-embed:&lt;file list&gt;            PDB に特定のファイルを埋め込みます。

                      - リソース -
-win32res:&lt;file&gt;              Win32 リソース ファイル (.res) を指定します
-win32icon:&lt;file&gt;             出力にこのアイコンを使用します
-win32manifest:&lt;file&gt;         Win32 マニフェスト ファイル (.xml) を指定します
-nowin32manifest              既定の Win32 マニフェストを含めません
-resource:&lt;resinfo&gt;           指定されたリソースを埋め込みます (短い形式: -res)
-linkresource:&lt;resinfo&gt;       このアセンブリに指定されたリソースをリンクします
                             (短い形式: -linkres) resinfo の形式: 
                             &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                      - コード生成 -
-debug[+|-]                       デバッグ情報を出力します
-debug:{full|pdbonly|portable|embedded}
                             デバッグの種類を指定します ('full' は既定、
                             'portable' はクロスプラットフォーム形式、
                             'embedded' はターゲットの .dll または .exe に埋め込まれる
                             クロスプラットフォーム形式です)
-optimize[+|-]                最適化を有効にします (短い形式: -o)
-deterministic                   決定論的アセンブリを生成します
                             (モジュール バージョン GUID とタイムスタンプを含む)
-refonly                          メイン出力の代わりに参照アセンブリを生成します
-instrument:TestCoverage          カバレッジ情報を収集するようにインストルメント化されたアセンブリを
                             生成します
-sourcelink:&lt;file&gt;                PDB に埋め込むソース リンク情報。

                      - エラーと警告 -
-warnaserror[+|-]                 すべての警告をエラーとして報告します
-warnaserror[+|-]:&lt;warn list&gt; 特定の警告をエラーとして報告します
                             (すべての NULL 値の許容に関する警告に対して "nullable" を使用します)
-warn:&lt;n&gt;                     警告レベル (0 以上) を設定します (短い形式: -w)
-nowarn:&lt;warn list&gt;           特定の警告メッセージを無効にします
                             (すべての NULL 値の許容に関する警告に対して "nullable" を使用します)
-ruleset:&lt;file&gt;               特定の診断を無効にするルールセット ファイルを
                             指定します。
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                             すべてのコンパイラとアナライザーの診断をログに記録するファイルを
                             指定します。
                             sarif_version:{1|2|2.1} 既定値は 1 です。2 と 2.1 は
                             両方とも SARIF バージョン 2.1.0 を意味します。
-reportanalyzer               実行時間などの追加のアナライザー情報を
                             報告します。
-skipanalyzers[+|-]               診断アナライザーの実行をスキップします。

                      - 言語 -
-checked[+|-]                 オーバーフロー チェックを生成します
-unsafe[+|-]                  'unsafe' コードの使用を許可します
-define:&lt;symbol list&gt;             条件付きコンパイル シンボルを定義します (短い
                             形式: -d)
-langversion:?              言語バージョンに指定できる値を表示します
-langversion:&lt;string&gt;             次のような言語バージョンを指定します。
                             'latest' (マイナー バージョンを含む最新バージョン)、
                             'default' ('latest' と同じ)、
                             'latestmajor' (マイナー バージョンを含まない最新バージョン)、
                             'preview' (サポートされていないプレビューの機能を含む最新バージョン)、
                             '6' や '7.1' などの特定のバージョン
-nullable[+|-]                Null 許容コンテキスト オプションの有効または無効を指定します。
-nullable:{enable|disable|warnings|annotations}
                             Null 許容コンテキスト オプションの enable|disable|warnings|annotations を指定します。

                      - セキュリティ -
-delaysign[+|-]                   厳密な名前キーの公開部分のみを使用して
                             アセンブリに遅延署名します
-publicsign[+|-]                  厳密な名前キーの公開部分のみを使用して
                             アセンブリに公開署名します
-keyfile:&lt;file&gt;                   厳密な名前のキー ファイルを指定します
-keycontainer:&lt;string&gt;            厳密な名前のキー コンテナーを指定します
-highentropyva[+|-]               高エントロピ ASLR を有効にします

                      - その他 -
@&lt;file&gt;                       その他のオプションを、応答ファイルから読み取ります
-help                       この使用法メッセージを表示します (短い形式: -?)
-nologo                       コンパイラの著作権メッセージを表示しません
-noconfig                     CSC.RSP ファイルを自動的に含めません
-parallel[+|-]                同時にビルドします。
-version                      コンパイラのバージョン番号を表示して終了します。

                      - 詳細設定 -
-baseaddress:&lt;address&gt;        ビルドするライブラリのベース アドレス
-checksumalgorithm:&lt;alg&gt;      PDB に格納されているソース ファイル チェックサムを計算するための
                             アルゴリズムを指定します。サポートされている値:
                             SHA1 または SHA256 (既定値)。
-codepage:&lt;n&gt;                 ソース ファイルを開くときに使用するコードページを
                             指定します
-utf8output                   UTF-8 エンコードでコンパイラのメッセージを出力します
-main:&lt;type&gt;                  エントリ ポイントを含む型を指定します
                             (他のすべてのエントリ ポイントを無視します) (短い
                             形式: -m)
-fullpaths                    コンパイラは完全修飾パスを生成します
-filealign:&lt;n&gt;                出力ファイルのセクションに使用する配置を
                             指定します
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                             コンパイラが出力するソース パス名のマッピングを
                             指定します。
-pdb:&lt;file&gt;                   デバッグ情報のファイル名を指定します (既定値:
                             出力ファイル名と .pdb 拡張子)
-errorendlocation             各エラーの終了位置の出力行と
                             出力列です
-preferreduilang                  優先する出力言語名を指定します。
-nosdkpath                    標準ライブラリ アセンブリの既定の SDK パスの検索を無効にします。
-nostdlib[+|-]                標準ライブラリ (mscorlib.dll) を参照しません
-subsystemversion:&lt;string&gt;    このアセンブリのサブシステム バージョンを指定します
-lib:&lt;file list&gt;              参照を検索する追加のディレクトリを
                             指定します
-errorreport:&lt;string&gt;         内部コンパイラ エラーを処理する方法を指定します。
                             prompt、send、queue、none のいずれかです。既定値は 
                             queue です。
-appconfig:&lt;file&gt;             アセンブリ バインド設定を含むアプリケーション
                             構成ファイルを指定します
-moduleassemblyname:&lt;string&gt;  このモジュールが属することになるアセンブリの
                             名前です
-modulename:&lt;string&gt;          ソース モジュールの名前を指定します
-generatedfilesout:&lt;dir&gt;      コンパイル中に生成されたファイルを指定したディレクトリに
                             配置します。
-reportivts[+|-]                  すべての依存関係によってこのアセンブリに
                             付与されたすべての IVT に関する情報を出力し、外部アセンブリの
                             アクセシビリティ エラーに、発生元のアセンブリに関する注釈をつけます。
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">既定のインターフェイスの実装</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">破棄可能</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">代替的な挿入逐語的文字列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAndPattern">
        <source>and pattern</source>
        <target state="translated">and パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">非同期 using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">合体代入</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureConstantInterpolatedStrings">
        <source>constant interpolated strings</source>
        <target state="translated">定数の補間された文字列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultTypeParameterConstraint">
        <source>default type parameter constraints</source>
        <target state="translated">既定の型パラメーターの制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">delegate ジェネリック型の制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">enum ジェネリック型の制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">メンバー初期化子とクエリ内の式変数の宣言</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPartialMethods">
        <source>extended partial methods</source>
        <target state="translated">拡張部分メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">拡張可能な fixed ステートメント</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetAsyncEnumerator">
        <source>extension GetAsyncEnumerator</source>
        <target state="translated">拡張機能 GetAsyncEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetEnumerator">
        <source>extension GetEnumerator</source>
        <target state="translated">拡張機能 GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="translated">extern ローカル関数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFunctionPointers">
        <source>function pointers</source>
        <target state="translated">関数ポインター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">インデックス演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">移動可能な固定バッファーのインデックス化</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInitOnlySetters">
        <source>init-only setters</source>
        <target state="translated">init 専用セッター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="translated">ローカル関数の属性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">ラムダ ディスカード パラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureMemberNotNull">
        <source>MemberNotNull attribute</source>
        <target state="translated">MemberNotNull 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleInitializers">
        <source>module initializers</source>
        <target state="translated">モジュールの初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">入れ子になった関数での名前シャドウイング</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNativeInt">
        <source>native-sized integers</source>
        <target state="translated">ネイティブサイズの整数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">入れ子になった式の stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">notnull ジェネリック型の制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotPattern">
        <source>not pattern</source>
        <target state="translated">not パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPointerConstantPattern">
        <source>null pointer constant pattern</source>
        <target state="translated">null ポインター定数パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">Null 許容参照型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">プロパティ アクセサーで廃止</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOrPattern">
        <source>or pattern</source>
        <target state="translated">or パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParenthesizedPattern">
        <source>parenthesized pattern</source>
        <target state="translated">かっこで囲まれたパターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">警告アクション enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">範囲演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">読み取り専用メンバー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecords">
        <source>records</source>
        <target state="translated">レコード</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">再帰的パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">ref 条件式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">ref for ループ変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">ref foreach 繰り返し変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">ref 再代入</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelationalPattern">
        <source>relational pattern</source>
        <target state="translated">リレーショナル パターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">stackalloc 初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAnonymousFunction">
        <source>static anonymous function</source>
        <target state="translated">静的匿名関数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">静的ローカル関数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;switch 式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTargetTypedConditional">
        <source>target-typed conditional expression</source>
        <target state="translated">ターゲットにより型指定された条件式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">タプルの等値性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypePattern">
        <source>type pattern</source>
        <target state="translated">種類のパターン</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">Null 合体演算子の中の非制約型パラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">アンマネージド構築型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">unmanaged ジェネリック型の制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">using 宣言</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
        <source>variance safety for static interface members</source>
        <target state="translated">静的インターフェイス メンバーの変性の安全性</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">オーバーライドおよび明示的なインターフェイスの実装メソッドの制約</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Parameter">
        <source>parameter</source>
        <target state="translated">パラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Return">
        <source>return</source>
        <target state="translated">戻り値</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;スロー式&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(以前のエラーに関連するシンボルの位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(以前のエラーに関連する警告の位置)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TopLevelStatements">
        <source>top-level statements</source>
        <target state="translated">トップレベルのステートメント</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> XML ファイル "{0}" の形式が正しくないため、含めることができません </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> 含められている XML のいくつか、またはすべてを挿入できませんでした </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> インクルード タグが無効です </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> 次のインクルード タグで一致する要素が見つかりませんでした </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">ファイル属性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">パス属性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;グローバル名前空間&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">ジェネリック</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">匿名メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">属性ターゲット指定子としてのモジュール</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">名前空間のエイリアス修飾子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">固定サイズ バッファー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">静的クラス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">読み取り専用の構造体</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">partial 型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">非同期関数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">ブール型の switch</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">メソッド グループ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">匿名メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">ラムダ式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">(コレクション)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">プロパティのアクセス修飾子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">extern エイリアス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">反復子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">既定の演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">既定のリテラル</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">Null 許容型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">パターン マッチング</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">式本体のプロパティ アクセサー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">式本体のコンストラクターとデストラクター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">スロー式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">暗黙的に型指定された配列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">暗黙的に型指定されたローカル変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">匿名型</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">自動的に実装されたプロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">読み取り専用の自動実装プロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">オブジェクト初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">コレクション初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">クエリ式</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">拡張メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">部分メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">種類</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">名前空間</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">フィールド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">プロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">要素</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">ラベル</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">イベント</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">型パラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">using エイリアス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">extern エイリアス</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">コンストラクター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">foreach 繰り返し変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">固定変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">using 変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">反変</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">反変</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">共変</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">共変</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">不変</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">ダイナミック</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">名前付き引数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">省略可能なパラメーター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">例外フィルター</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">型変性</target>
        <note />
      </trans-unit>
      <trans-unit id="NotSameNumberParameterTypesAndRefKinds">
        <source>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</source>
        <target state="translated">指定されたパラメーター型 {0} と {1} パラメーター参照の種類。これらの配列は同じ長さである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutIsNotValidForReturn">
        <source>'RefKind.Out' is not a valid ref kind for a return type.</source>
        <target state="translated">'RefKind.Out' は、戻り値の型に対して有効な参照の種類ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">SyntaxTree はコンパイルの一部ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">SyntaxTree はコンパイルの一部ではないため削除できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">名前 '_' は、破棄パターンではなく定数を参照しています。値を破棄する場合には 'var _' を、そのような名前の定数を参照する場合には '@_' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">case 定数に '_' を使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked">
        <source>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">定数値 '{0}' は実行時に '{1}' をオーバーフローする可能性があります (オーバーライドするには 'unchecked' 構文を使用してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked_Title">
        <source>Constant value may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">実行時に定数値がオーバーフローする可能性があります (オーバーライドするには 'unchecked' 構文を使用してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Null リテラルまたは Null の可能性がある値を Null 非許容型に変換しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Null リテラルまたは Null の可能性がある値を Null 非許容型に変換しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">[NotNull] または [DisallowNull] としてマークされた型に対して、Null の可能性がある値を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">[NotNull] または [DisallowNull] としてマークされた型に対して、Null の可能性がある値を使用することはできない</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">メソッド '{0}' には、実装された、またはオーバーライドされたメンバーと一致する '[DoesNotReturn]' 注釈がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">メソッドには、実装された、またはオーバーライドされたメンバーと一致する '[DoesNotReturn]' 注釈がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">'{0}' は既に型 '{1}' のインターフェイス リストに存在しますが、参照型の Null 許容性が異なっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">インターフェイスは既にインターフェイス リストに存在しますが、参照型の Null 許容性が異なっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">ジェネレーター '{0}' でソースを生成できませんでした。出力には寄与しません。結果として、コンパイル エラーが発生する可能性があります。例外の型: '{1}'。メッセージ: '{2}'。
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">ジェネレーターはソースを生成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">ジェネレーター '{0}' を初期化できませんでした。出力には寄与しません。結果として、コンパイル エラーが発生する可能性があります。例外の型: '{1}'。メッセージ: '{2}'。
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">ジェネレーターを初期化できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定された式は指定された定数と必ず一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">指定された式は指定された定数と必ず一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">指定された式は指定されたパターンと常に一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern_Title">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">指定された式は指定されたパターンと常に一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定された式は指定されたパターンと絶対に一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">指定された式は指定されたパターンと絶対に一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">'readonly' メンバーから readonly 以外のメンバー '{0}' を呼び出すと、'{1}' の暗黙のコピーが生成されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">'readonly' メンバーから readonly 以外のメンバーを呼び出すと、暗黙のコピーが生成されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways">
        <source>An expression of type '{0}' always matches the provided pattern.</source>
        <target state="translated">型 '{0}' の式は指定されたパターンと常に一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways_Title">
        <source>The input always matches the provided pattern.</source>
        <target state="translated">入力は、指定されたパターンと常に一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">名前 '_' は、破棄パターンではなく型 '{0}' を参照しています。型の場合は '@_' を、破棄する場合は 'var _' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">is 型の式の中で型を参照するために '_' を使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull">
        <source>Member '{0}' must have a non-null value when exiting.</source>
        <target state="translated">終了時にメンバー '{0}' には null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember">
        <source>Member '{0}' cannot be used in this attribute.</source>
        <target state="translated">メンバー '{0}' をこの属性で使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember_Title">
        <source>Member cannot be used in this attribute.</source>
        <target state="translated">メンバーをこの属性で使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen">
        <source>Member '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">'{1}' で終了する場合、メンバー '{0}' には null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen_Title">
        <source>Member must have a non-null value when exiting in some condition.</source>
        <target state="translated">一部の条件で終了するとき、メンバーには null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull_Title">
        <source>Member must have a non-null value when exiting.</source>
        <target state="translated">終了時にメンバーには null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">'#nullable' 注釈コンテキスト内のコードでのみ、Null 許容参照型の注釈を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Null 許容参照型の注釈は、'#nullable' 注釈のコンテキスト内のコードでのみ使用する必要があります。自動生成されたコードには、ソースに明示的な '#nullable' ディレクティブが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Null 許容参照型の注釈は、'#nullable' 注釈のコンテキスト内のコードでのみ使用する必要があります。自動生成されたコードには、ソースに明示的な '#nullable' ディレクティブが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">'#nullable' 注釈コンテキスト内のコードでのみ、Null 許容参照型の注釈を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">null リテラルを null 非許容参照型に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">null リテラルを null 非許容参照型に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">'{1}' 内のパラメーター '{0}' に Null 参照引数がある可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">Null 参照引数の可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">Null 参照代入の可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">Null 参照代入の可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">オブジェクトまたはコレクション初期化子が、null の可能性があるメンバー '{0}' を暗黙的に逆参照しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">オブジェクトまたはコレクション初期化子が、null の可能性があるメンバーを暗黙的に逆参照しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">null 参照の可能性があるものの逆参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">null 参照の可能性があるものの逆参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">Null 参照戻り値である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">Null 参照戻り値である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">型 '{0}' の引数は、参照型の NULL 値の許容の違いにより、'{3}' の型 '{1}' のパラメーター '{2}' には使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">型 '{0}' の引数は、参照型の NULL 値の許容の違いにより、'{3}' のパラメーター '{2}' に対して型 '{1}' の出力として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">参照型の NULL 値の許容の違いにより、引数をパラメーターの出力として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">参照型の NULL 値の許容の違いにより、パラメーターに引数を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">'{0}' 型の値における参照型の Null 許容性が、対象の型 '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">値における参照型の Null 許容性が、対象の型と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">メソッド '{1}' の型パラメーター '{0}' に対する制約の Null 許容性が、インターフェイス メソッド '{3}' の型パラメーター '{2}' に対する制約と一致しません。明示的なインターフェイスの実装を使用することをお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">型パラメーターの制約の Null 許容性が、暗黙的に実装されたインターフェイス メソッドの型パラメーターの制約と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' の部分メソッド宣言には、型パラメーター '{1}' の制約に NULL 値の許容の矛盾があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">部分メソッド宣言には、型パラメーターの制約に NULL 値の許容の矛盾があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明示的なインターフェイス指定子内の参照型の Null 許容性が、型によって実装されているインターフェイスと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">明示的なインターフェイス指定子内の参照型の Null 許容性が、型によって実装されているインターフェイスと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">'{0}' はインターフェイス メンバー '{1}' を実装しません。基本型で実装されているインターフェイス内の参照型の Null 許容性が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">型はインターフェイス メンバーを実装しません。基本型で実装されているインターフェイス内の参照型の Null 許容性が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">'{1}' のパラメーター '{0}' の型における参照型の NULL 値の許容が、ターゲット デリゲート '{2}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">パラメーターの型における参照型の NULL 値の許容が、ターゲット デリゲートと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">パラメーター '{0}' の型における参照型の Null 許容性が、実装されるメンバー '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">パラメーターの型における参照型の Null 許容性が、実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">'{1}' のパラメーター '{0}' の型における参照型の Null 許容性が、暗黙的に実装されるメンバー '{2}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">パラメーターの型における参照型の Null 許容性が、暗黙的に実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">パラメーター '{0}' の型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">パラメーターの型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">パラメーター '{0}' の型における参照型の Null 許容性が、部分メソッド宣言と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">パラメーターの型における参照型の Null 許容性が、部分メソッド宣言と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">'{0}' の戻り値の型における参照型の NULL 値の許容が、ターゲット デリゲート '{1}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型における参照型の NULL 値の許容が、ターゲット デリゲートと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、実装されるメンバー '{0}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' の戻り値の型における参照型の Null 許容性が、暗黙的に実装されるメンバー '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、暗黙的に実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">戻り値の型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">戻り値の型における参照型の Null 値の許容が、部分メソッド宣言と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">戻り値の型における参照型の Null 値の許容が、部分メソッド宣言と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">型における参照型の Null 許容性が、実装されるメンバー '{0}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">型における参照型の Null 許容性が、実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' の型における参照型の Null 許容性が、暗黙的に実装されるメンバー '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">型における参照型の Null 許容性が、暗黙的に実装されるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">型における参照型の Null 許容性が、オーバーライドされるメンバーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">型 '{3}' を、ジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用することはできません。型引数 '{3}' の Null 許容性が制約型 '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">この型を、ジェネリック型またはメソッド内で型パラメーターとして使用することはできません。型引数の Null 許容性が制約型と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">型 '{2}' を、ジェネリック型またはメソッド '{0}' 内で型パラメーター '{1}' として使用することはできません。型引数 '{2}' の Null 許容性が 'notnull' 制約と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">この型を、ジェネリック型またはメソッド内で型パラメーターとして使用することはできません。型引数の Null 許容性が 'notnull' 制約と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">型 '{2}' を、ジェネリック型またはメソッド '{0}' 内で型パラメーター '{1}' として使用することはできません。型引数 '{2}' の Null 許容性が 'class' 制約と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">この型を、ジェネリック型またはメソッド内で型パラメーターとして使用することはできません。型引数の Null 許容性が 'class' 制約と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Null 許容値型は Null になる場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Null 許容値型は Null になる場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">out パラメーター '{0}' はコントロールが現在のメソッドを抜ける前に割り当てられる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned_Title">
        <source>An out parameter must be assigned to before control leaves the method</source>
        <target state="translated">out パラメーターは、制御がメソッドを抜ける前に割り当てる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">'{1}' で終了する場合、パラメーター '{0}' には null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting in some condition.</source>
        <target state="translated">一部の条件で終了するとき、パラメーターには null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting.</source>
        <target state="translated">終了時にパラメーター '{0}' には null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting.</source>
        <target state="translated">終了時にパラメーターには null 以外の値が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': スタティック型はパラメーターとして使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass_Title">
        <source>Static types cannot be used as parameters</source>
        <target state="translated">スタティック型をパラメーターとして使用することはできない</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion">
        <source>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</source>
        <target state="translated">優先順位の理由から、こちらで演算子 '{0}' は使用できません。かっこを使用して明確にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion_Title">
        <source>Operator cannot be used here due to precedence.</source>
        <target state="translated">優先順位の理由から、こちらで演算子は使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</source>
        <target state="translated">'{0}' は、パターン '{1}' を実装しません。'{2}' は、パブリック インスタンスまたは拡張メソッドではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance_Title">
        <source>Type does not implement the collection pattern; member is is not a public instance or extension method.</source>
        <target state="translated">型は、コレクション パターンを実装しません。メンバーはパブリック インスタンスまたは拡張メソッドではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': スタティック型を戻り値の型として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass_Title">
        <source>Static types cannot be used as return types</source>
        <target state="translated">スタティック型を戻り値の型として使用することはできない</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">[DoesNotReturn] とマークされたメソッドを返すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">[DoesNotReturn] とマークされたメソッドの返却禁止。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">is' または 'as' 演算子の 2 番目のオペランドはスタティック型 '{0}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs_Title">
        <source>The second operand of an 'is' or 'as' operator may not be a static type</source>
        <target state="translated">'is' または 'as' 演算子の 2 番目のオペランドは static 型にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">この switch 式では入力型の可能な値がすべて扱われるわけではありません (すべてが網羅されているわけではありません)。たとえば、パターン '{0}' がカバーされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">この switch 式では一部の null 入力が処理されません (すべてが網羅されているわけではありません)。たとえば、パターン '{0}' がカバーされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">一部の null 入力が switch 式で処理されません (すべてが網羅されてはいません)。たとえば、パターン '{0}' がカバーされていません。ただし、'when' 句を含むパターンがこの値と一致する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">switch 式が一部の null 入力を処理しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">switch 式が一部の null 入力を処理しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">入力型の可能な値の一部が switch 式で処理されません (すべてが網羅されてはいません)。たとえば、パターン '{0}' がカバーされていません。ただし、'when' 句を含むパターンがこの値と一致する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 式が入力の種類で可能なすべての値を処理していません (すべてを網羅していません)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 式が入力の種類で可能なすべての値を処理していません (すべてを網羅していません)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.</source>
        <target state="translated">パラメーター '{0}' の参照の種類修飾子が、ターゲット内の対応するパラメーター '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in target.</source>
        <target state="translated">パラメーターの参照の種類修飾子が、ターゲット内の対応するパラメーターと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">スローされた値が null である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">スローされた値が null である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">パラメーター '{0}' の型における参照型の NULL 値の許容が、実装されるメンバー '{1}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">パラメーターの型における参照型の NULL 値の許容が、実装されるメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">'{1}' のパラメーター '{0}' の型における参照型の NULL 値の許容が、暗黙的に実装されるメンバー '{2}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">パラメーターの型における参照型の NULL 値の許容が、暗黙的に実装されるメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">パラメーター '{0}' の型の NULL 値の許容が、オーバーライドされたメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">パラメーターの型の NULL 値の許容が、オーバーライドされたメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型における参照型の NULL 値の許容が、実装されるメンバー '{0}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型における参照型の NULL 値の許容が、実装されるメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">'{0}' の戻り値の型における参照型の NULL 値の許容が、暗黙的に実装されるメンバー '{1}' と一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型における参照型の NULL 値の許容が、暗黙的に実装されるメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型の NULL 値の許容が、オーバーライドされたメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">戻り値の型の NULL 値の許容が、オーバーライドされたメンバーと一致しません。おそらく、NULL 値の許容の属性が原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">タプル要素名 '{0}' は、タプルの == または != 演算子の反対側に異なる名前が指定されたか名前が指定されていないため、無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">タプル要素名は、タプルの == または != 演算子の反対側に異なる名前が指定されたか名前が指定されていないため、無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">型パラメーター '{0}' は、外のメソッドからの型パラメーター '{1}' と同じ名前です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">型パラメーターの型は、外のメソッドからの型パラメーターと同じ型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion">
        <source>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">フィールド '{0}' が明示的に割り当てられる前に自動実装プロパティが呼び出し元に返され、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion_Title">
        <source>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">フィールドが明示的に割り当てられる前に自動実装プロパティが呼び出し元に返され、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">コントロールを呼び出し元に返す前に、自動実装プロパティ '{0}' を完全に割り当てる必要があります。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
        <source>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</source>
        <target state="translated">コントロールを呼び出し元に返す前に、自動実装プロパティを完全に割り当てる必要があります。プロパティを自動既定値にするため言語バージョンを更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion">
        <source>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">フィールド '{0}' が明示的に割り当てられる前にコントロールが呼び出し元に返され、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion_Title">
        <source>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">フィールドが明示的に割り当てられる前にコントロールが呼び出し元に返され、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">コントロールを呼び出し元に返す前に、フィールド '{0}' を完全に割り当てる必要があります。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion_Title">
        <source>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</source>
        <target state="translated">構造体のフィールドは、コントロールが呼び出し元に返される前にコンストラクターに完全に割り当てられている必要があります。言語バージョンを更新してフィールドを自動で既定にすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">null の可能性がある値をボックス化解除しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">null の可能性がある値をボックス化解除しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">パラメーター '{0}' に適用された EnumeratorCancellationAttribute は効果がありません。この属性は、IAsyncEnumerable を返す非同期反復子メソッドの CancellationToken 型のパラメーターに対してのみ効果があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">EnumeratorCancellationAttribute は効果がありません。この属性は、IAsyncEnumerable を返す非同期反復子メソッドの CancellationToken 型のパラメーターに対してのみ効果があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同期反復子 '{0}' には型 'CancellationToken' の 1 つ以上のパラメーターがありますが、'EnumeratorCancellation' 属性で修飾されているパラメーターはありません。そのため、生成された 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' からの取り消しトークン パラメーターは使用されません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">非同期反復子メンバーには型 'CancellationToken' の 1 つ以上のパラメーターがありますが、'EnumeratorCancellation' 属性で修飾されているパラメーターはありません。そのため、生成された 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' からの取り消しトークン パラメーターは使用されません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider declaring the {0} as nullable.</source>
        <target state="translated">null 非許容の {0} '{1}' には、コンストラクターの終了時に null 以外の値が入っていなければなりません。{0} を Null 許容として宣言することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.</source>
        <target state="translated">null 非許容のフィールドには、コンストラクターの終了時に null 以外の値が入っていなければなりません。Null 許容として宣言することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter">
        <source>Parameter '{0}' is unread.</source>
        <target state="translated">パラメーター '{0}' は未読です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter_Title">
        <source>Parameter is unread.</source>
        <target state="translated">パラメーターが未読です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter">
        <source>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">パラメーター '{0}' は未読です。この名前のプロパティを初期化するために使用していることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter_Title">
        <source>Parameter is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">パラメーターが未読のため、この名前のプロパティを初期化するために使用していることを確認する必要がある</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">未割り当てのローカル変数 '{0}' が使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">フィールド '{0}' は、割り当てられていない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion">
        <source>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">明示的に割り当てられる前にフィールド '{0}' が読み取られ、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion_Title">
        <source>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">明示的に割り当てられる前にフィールドが読み取られ、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">割り当てられていない可能性のあるフィールド '{0}' を使用しています。フィールドを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion_Title">
        <source>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</source>
        <target state="translated">割り当てられていない可能性のあるフィールドを使用しています。フィールドを自動既定値にするため言語バージョンを更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField_Title">
        <source>Use of possibly unassigned field</source>
        <target state="translated">割り当てられていない可能性のあるフィールドの使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">未割り当ての out パラメーター '{0}' が使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut_Title">
        <source>Use of unassigned out parameter</source>
        <target state="translated">割り当てられていない out パラメーターの使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティ '{0}' の使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion">
        <source>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">明示的に割り当てられる前に自動実装プロパティ '{0}' が読み取られ、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion_Title">
        <source>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">明示的に割り当てられる前に自動実装プロパティが読み取られ、先行する暗黙的な代入が 'default' になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティ '{0}' を使用しています。プロパティを自動既定値にするため '{1}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion_Title">
        <source>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティを使用しています。プロパティを自動既定値にするため言語バージョンを更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty_Title">
        <source>Use of possibly unassigned auto-implemented property</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティの使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField">
        <source>Ref field '{0}' should be ref-assigned before use.</source>
        <target state="translated">参照フィールド '{0}' は、使用する前に参照を割り当てる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField_Title">
        <source>Ref field should be ref-assigned before use.</source>
        <target state="translated">参照フィールドは、使用する前に参照を割り当てる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">'this' オブジェクトは、すべてのフィールドが割り当てられる前に読み取られます。これにより、明示的に割り当てられていないフィールドに対する 'default' の暗黙的な割り当てが先行しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion_Title">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">'this' オブジェクトは、すべてのフィールドが割り当てられる前に読み取られます。これにより、明示的に割り当てられていないフィールドに対する 'default' の暗黙的な割り当てが先行しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">すべてのフィールドが割り当てられる前に、'this' オブジェクトを使用することはできません。割り当てられていないフィールドを自動既定値にするため '{0}' 言語バージョンに更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion_Title">
        <source>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</source>
        <target state="translated">すべてのフィールドが割り当てられる前に、'this' オブジェクトをコンストラクターで使用することはできません。割り当てられていないフィールドを自動既定値にするため言語バージョンを更新することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation_Title">
        <source>Use of unassigned local variable</source>
        <target state="translated">割り当てられていないローカル変数の使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}' は、評価の目的でのみ提供されています。将来の更新で変更または削除されることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">型は評価の目的でのみ提供されています。将来の更新で変更または削除されることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">文字 '{0}' はこの位置では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">コメントで正しくない構文が使用されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">エンティティ参照内に無効な文字が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">タグ '{0}' を閉じるには、'&gt;' または '/&gt;' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">識別子が必要でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">無効な Unicode 文字です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">この位置では空白は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">属性値に文字 '&lt;' は使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">属性と属性値の間に等号がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">未定義のエンティティ '{0}' への参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">文字列リテラルが必要でしたが、始まりの引用符が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">文字列リテラルに終わりの引用符がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">ASCII 以外の引用符は、文字列リテラルを囲むために使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">この位置では、終了タグは不要でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">終了タグ '{0}' が開始タグ '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">要素 '{0}' に終了タグが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">必要な空白がありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">この位置には予期しない文字です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">リテラル文字列 ']]&gt;' は要素コンテンツでは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">'{0}' 属性が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">メタデータ ファイル '{0}' が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">メタデータ参照はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">メタデータ ファイル '{0}' を開けませんでした -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">型 '{0}' は、参照されていないアセンブリに定義されています。アセンブリ '{1}' に参照を追加する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">型 '{0}' は、追加されていないモジュールに定義されています。モジュール '{1}' を追加する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">出力ファイル '{0}' に書き込めませんでした -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">プログラムで複数のエントリ ポイントが定義されています。エントリ ポイントを含む型を指定するには、/main でコンパイルしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">演算子 '{0}' を '{1}' と '{2}' 型のオペランドに適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">定数 0 による除算です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">角かっこ [] 付きインデックスを '{0}' 型の式に適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">角かっこ [] 内のインデックス数が正しくありません。正しい数は {0} です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">演算子 '{0}' は '{1}' 型のオペランドに適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">キーワード 'this' は、静的プロパティ、静的メソッド、または静的フィールド初期化子では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">キーワード 'this' は現在のコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'{0}' で間違った認証が使われています。エントリ ポイントとして使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">メソッドに、エントリ ポイントになる不適切な署名があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">型 '{0}' を '{1}' に暗黙的に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">型 '{0}' を '{1}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">定数値 '{0}' を '{1}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">型 '{1}' および '{2}' のオペランドの演算子 '{0}' があいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">演算子 '{0}' は型 '{1}' のオペランドに対してあいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">out パラメーターに in 属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">Null 非許容の値型であるため、Null を '{0}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">参照の変換、ボックス変換、アンボックス変換、折り返しの変換、または null 型の変換で、型 '{0}' を '{1}' に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">デバッグ情報の書き込み中に予期しないエラーが発生しました -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。戻り値の型 '{1}' のアクセシビリティはメソッド '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。パラメーター型 '{1}' のアクセシビリティはメソッド '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。フィールド型 '{1}' のアクセシビリティはフィールド '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。プロパティ型 '{1}' のアクセシビリティはプロパティ '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。インデクサーの戻り値の型 '{1}' のアクセシビリティはインデクサー '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。パラメーター型 '{1}' のアクセシビリティはインデクサー '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。戻り値の型 '{1}' のアクセシビリティは演算子 '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。パラメーター型 '{1}' のアクセシビリティは演算子 '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。戻り値の型 '{1}' のアクセシビリティはデリゲート '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。パラメーター型 '{1}' のアクセシビリティはデリゲート '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。基底クラス '{1}' のアクセシビリティはクラス '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。基底インターフェイス '{1}' のアクセシビリティはインターフェイス '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': イベント プロパティには、add および remove アクセサーの両方を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'{0}': イベントはデリゲート型である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">イベント '{0}' は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">イベントは使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'{0}': インターフェイスのインスタンス イベントは初期化子を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">イベント '{0}' は、+= または -= の左側にのみ表示されます (型 '{1}' 内で使用する場合を除きます)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">イベントのインターフェイスを明示的に実装するには、イベント アクセサーの構文を使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'{0}': '{1}' はイベントではないためオーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">add または remove アクセサーには本体が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'{0}': 抽象イベントは初期化子を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">アセンブリ名 '{0}' は予約されており、対話形式のセッションで参照として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">列挙子名 '{0}' は予約されているため、使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">as 演算子は参照型または null 許容型で使用してください ('{0}' は null 非許容の値型です)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">l' と 数字の '1' との混同を避けるため、'L' を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">l' という接尾辞は、数字の '1' と混同されることがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">イベント '{0}' は += または -= の左側にのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">制約は非ジェネリック宣言では許可されません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">型パラメーターの宣言は型ではなく識別子でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">型 '{1}' は、'{0}' と呼ばれるメンバーを同じパラメーターの型で既に予約しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">パラメーター名 '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">名前空間 '{1}' は既に '{0}' の定義を含んでいます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">型 '{0}' は既に '{1}' の定義を含んでいます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">現在のコンテキストに '{0}' という名前は存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">現在のコンテキストに '{0}' という名前は存在しません (アセンブリ '{1}' に対する参照が指定されていることを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'{0}' は、'{1}' と '{2}' 間のあいまいな参照です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">'{0}' の using ディレクティブは、この名前空間で既に使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">使用中のディレクティブは、以前この名前空間に使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">修飾子 '{0}' がこの項目に対して有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">複数の保護修飾子があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'{0}' は継承されたメンバー '{1}' を非表示にします。非表示にする場合は、キーワード new を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">メンバーは継承されたメンバーを非表示にします。キーワード new がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">基本データ型の変数と同じ名前で宣言された変数がありましたが、キーワード new は使用されませんでした。この警告は、new を使用する必要があることを通知するものです。変数は、あたかも宣言で new が使用されたかのように宣言されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">メンバー '{0}' はアクセス可能なメンバーを非表示にしません。新しいキーワードは不要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">メンバーは継承されたメンバーを非表示にしません。new キーワードは不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">'{0}' の定数値の評価により、循環定義が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">型 '{1}' は、'{0}' と呼ばれるメンバーを同じパラメーターの型で既に定義しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member cannot be marked as '{0}'</source>
        <target state="translated">静的なメンバーを '{0}' とマークすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">override 型のメンバー '{0}' を、new または virtual にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'{0}' は継承されたメンバー '{1}' を非表示にします。現在のメンバーでその実装をオーバーライドするには、override キーワードを追加してください。オーバーライドしない場合は、new キーワードを追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">メンバーは継承されたメンバーを非表示にします。override キーワードがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'{0}': オーバーライドする適切なメソッドが見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields, methods or statements</source>
        <target state="translated">名前空間にフィールドやメソッド、またはステートメントのようなメンバーを直接含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'{0}' に '{1}' の定義がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'{0}' は {1} ですが、{2} のように使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'{0}' は {1} です。これは特定のコンテンツでは無効になります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">静的でないフィールド、メソッド、またはプロパティ '{0}' で、オブジェクト参照が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">次のメソッドまたはプロパティ間で呼び出しが不適切です: '{0}' と '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'{0}' はアクセスできない保護レベルになっています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">デリゲート '{1}' に一致する '{0}' のオーバーロードはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">'{0}' に変換可能な型のオブジェクトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">'{0}' は void 型を返すため、キーワード return の後にオブジェクト式を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">'{0}' という名前のローカル変数または関数はこのスコープで既に定義されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">代入式の左辺には変数、プロパティ、またはインデクサーを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'{0}': 静的コンストラクターにパラメーターがあってはなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">'{0}' に割り当てられた式は定数でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'{0}' の型は '{1}' です。文字列以外の参照型の const フィールドは null でのみ初期化できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">ローカルまたはパラメーター '{0}' は、その名前が外側のローカルのスコープでローカルやパラメーターの定義に使用されているため、このスコープでは宣言できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">using namespace' ディレクティブは名前空間に対してのみ適用できます。'{0}' は名前空間ではなく型です。代わりに 'using static' ディレクティブを使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">using static' ディレクティブは型に対してのみ適用できます。'{0}' は型ではなく名前空間です。代わりに 'using namespace' ディレクティブを使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">using static' ディレクティブはエイリアスの宣言には使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">break または continue に対応するループがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">ラベル '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">型 '{0}' のコンストラクターが定義されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract type or interface '{0}'</source>
        <target state="translated">抽象型またはインターフェイス '{0}' のインスタンスを作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">const フィールドに値を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base type dependency involving '{0}' and '{1}'</source>
        <target state="translated">'{0}' と '{1}' を含む、循環する基本データ型の依存関係です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">デリゲート '{0}' には有効なコンストラクターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">メソッド名が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">定数値が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">C# 6 以前のものにおいて、switch 式または case ラベルには、bool、char、string、integral、enum、または対応する null 許容型を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">整数型の値が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">switch ステートメントに、ラベル値が '{0}' の case が複数含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">goto は switch ステートメント内でのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">get アクセサーがないため、プロパティまたはインデクサー '{0}' をこのコンテキストで使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">キャッチ、または スローされた型は System.Exception から派生したものでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">引数なしの throw ステートメントは catch 句以外では使えません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">コントロールが finally 句の本体から出られません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">スコープ内に、ラベル '{0}' と同じ名前のラベルが存在しますが、無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">goto ステートメントのスコープに '{0}' というラベルはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">前の catch 句はこれ、またはスーパー型 ('{0}') の例外のすべてを既にキャッチしました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">フィルター式は定数 'true' です。フィルターの削除を検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">フィルター式は定数 'true' です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'{0}': 値を返さないコード パスがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">到達できないコードが検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">到達できないコードが検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">コントロールはひとつの case ラベル ('{0}') から別のラベルへ流れ落ちることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">このラベルは参照されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">このラベルは参照されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">未割り当てのローカル変数 '{0}' が使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">変数 '{0}' は宣言されていますが、使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">変数は宣言されていますが、使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">フィールド '{0}' は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">フィールドは使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">フィールド '{0}' は、割り当てられていない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">割り当てられていない可能性のある自動実装プロパティ '{0}' の使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">'{0}' と '{1}' が暗黙的に変換し合うため、条件式の型がわかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">'{0}' と '{1}' の間に暗黙的な変換がないため、条件式の型がわかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">base' 参照には基底クラスが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">キーワード 'base' の使用はこのコンテキストでは有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">インスタンス参照でメンバー '{0}' にアクセスできません。代わりに型名を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">out パラメーター '{0}' はコントロールが現在のメソッドを抜ける前に割り当てられる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">無効な次元指定子です: ',' または ']' を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'{0}' を extern にして、本体を宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'{0}' を extern にして、コンストラクター初期化子を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'{0}' に extern と abstract の両方を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">属性コンストラクターのパラメーター '{0}' には型 '{1}' がありますが、これは無効な属性パラメーター型です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">属性引数は、定数式、typeof 式、または属性パラメーター型の配列の作成式でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">属性コンストラクターのパラメーター '{0}' は省略可能ですが、既定のパラメーター値が指定されていませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">式は常に指定された型 ('{0}') です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'is' 式の指定された式は常に指定された型です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">式は指定された型 ('{0}') ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'is' 式の指定された式は指定された型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'{0}' は lock ステートメントによって要求された参照型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">null はこのコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">このコンテキストでの既定のリテラルの使用は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">__arglist 構文は可変個の引数メソッド内でのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">* または -&gt; 演算子はポインターに対して使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">ポインターのインデックスを複数指定しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">参照渡しのマーシャリングクラスのフィールドであるため、'{0}' を ref 値または out 値として使用したり、そのアドレスを取得したりすると、ランタイム例外が発生する可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">参照渡しのマーシャリングクラスのフィールドを ref 値または out 値として使用するか、そのフィールドのアドレスを取得すると、ランタイム例外が発生する可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">静的読み取り専用フィールドへの割り当てはできません (静的コンストラクターまたは変数初期化子では可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">静的な読み取り専用フィールドを ref 値または out 値として使用することはできません (静的コンストラクターでは可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">プロパティまたはインデクサー '{0}' は読み取り専用であるため、割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">代入、呼び出し、インクリメント、デクリメント、新しいオブジェクトの式のみがステートメントとして使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">foreach では、戻り値の型 '{1}' の '{0}' に適切なパブリック MoveNext メソッドおよびパブリック Current プロパティが含まれている必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">コンパイラが生成するものを含む 65534 のローカルのみが許可されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">抽象基本メンバーを呼び出すことはできません:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A non ref-returning property or indexer may not be used as an out or ref value</source>
        <target state="translated">参照を返さないプロパティまたはインデクサーを out 値または ref 値として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">マネージ型 ('{0}') のアドレスの取得、サイズの取得、またはそのマネージ型へのポインターの宣言が実行できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">fixed ステートメントで宣言されたローカルの型は、ポインター型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">fixed または using ステートメントの宣言の中に、初期化子を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">式のアドレスを取得できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">fixed ステートメントの初期化子内の fixed でない式のアドレスのみを取得できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">既に fixed が使用されている式のアドレスを取得するために、fixed ステートメントを使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">ポインターおよび固定サイズ バッファーは、unsafe コンテキストでのみ使用することができます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">演算子 true または false の戻り値の型はブール型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">演算子 '{0}' を定義するには、合致する演算子 '{1}' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">short circuit 演算子として適用するためには、ユーザー定義の論理演算子 ('{0}') が同じ戻り値の型とパラメーター型を持つ必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">'{0}' が short circuit 演算子として適用されるためには、宣言する型 '{1}' で true 演算子と false 演算子を定義する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">変数 '{0}' は割り当てられていますが、その値は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">変数は割り当てられていますが、その値は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">この操作はチェック モードでコンパイルしたときにオーバーフローします</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">定数値 '{0}' は '{1}' に変換できません (unchecked 構文を使ってオーバーライドしてください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">vararg を使用するメソッドは、ジェネリックにしたり、ジェネリック型に含めたりできません。また、params パラメーターを持つこともできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeArray">
        <source>The params parameter must be a single dimensional array</source>
        <target state="translated">params パラメーターは 1 次元配列でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">__arglist 式は呼び出し、または new 式の中でのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">アンセーフ コードは /unsafe でコンパイルした場合のみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">'{0}' と '{1}' 間があいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">foreach ステートメントには、型と識別子の両方が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a parameter list</source>
        <target state="translated">params パラメーターは、パラメーター リストの最後のパラメーターでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">'{0}' には定義済みのサイズが指定されていないため、sizeof は unsafe コンテキストでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">型または名前空間の名前 '{0}' が名前空間 '{1}' に存在しません (アセンブリ参照があることを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">フィールド初期化子は、静的でないフィールド、メソッド、またはプロパティ '{0}' を参照できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'override ではないため、'{0}' をシールすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'{0}': 継承されたメンバー '{1}' はシールされているため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">問題の操作は void ポインターで定義されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">条件付き属性はオーバーライド メソッドであるため、 '{0}' では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">is' と 'as' のどちらもポインター型では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">デストラクター と object.Finalize を直接呼び出すことはできません。使用可能であれば IDisposable.Dispose を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">型または名前空間の名前 '{0}' が見つかりませんでした (using ディレクティブまたはアセンブリ参照が指定されていることを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">stackalloc で負のサイズを使うことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">負のサイズで配列を作成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">object.Finalize をオーバーライドしないでください。代わりにデストラクターを提供してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base type Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">基本データ型の Finalize メソッドを直接呼び出さないでください。デストラクターから自動的に呼び出されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">負のインデックスで配列します。配列は常にゼロからの開始を示します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">負のインデックスで配列をインデックス付けしています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">予期しない参照比較です。比較値を取得するには型 '{0}' に左辺をキャストしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">予期しない参照比較です。左辺をキャストする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">予期しない参照比較です。比較値を取得するには型 '{0}' に右辺をキャストしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">予期しない参照比較です。右辺をキャストする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">fixed ステートメントの代入式の右辺はキャスト式ではない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">stackalloc は catch または finally ブロックで使用されない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a parameter list</source>
        <target state="translated">__arglist パラメーターは、パラメーター リストの最後のパラメーターでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">partial 修飾子が型 '{0}' にありません。この型の別の部分宣言が存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</source>
        <target state="translated">'{0}' の partial 宣言は、すべてのクラス、すべてのレコード クラス、すべての構造体、すべてのレコード構造体、すべてのインターフェイスのいずれかにする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">'{0}' の partial 宣言には競合するアクセシビリティ修飾子が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">'{0}' の partial 宣言では、異なる基底クラスを指定してはいけません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">'{0}' の partial 宣言では、同じ型パラメーター名を同じ順序で指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' の partial 宣言には、型パラメーター '{1}' に対して矛盾する制約が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">型 '{0}' を '{1}' に暗黙的に変換できません。明示的な変換が存在します (cast が不足していないかどうかを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', or a method return type.</source>
        <target state="translated">'partial' 修飾子は、'class'、'record'、'struct'、'interface'、またはメソッドの戻り値の型の直前にのみ指定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base type dependency.</source>
        <target state="translated">インポートされた型 '{0}' は無効です。これには循環する基本データ型の依存関係が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">未割り当ての out パラメーター '{0}' が使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">配列のサイズは変数宣言の中で指定できません ('new' を使用して初期化してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">get アクセサーにアクセスできないため、プロパティまたはインデクサー '{0}' はこのコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">set アクセサーにアクセスできないため、プロパティまたはインデクサー '{0}' はこのコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">'{0}' アクセサーのアクセシビリティ修飾子は、プロパティまたはインデクサー '{1}' よりも制限されていなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">アクセシビリティ修飾子は、プロパティまたはインデクサー '{0}' の両方のアクセサーに指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': アクセサーのアクセシビリティ修飾子は、プロパティまたはインデクサーが get アクセサーおよび set アクセサーの両方を含む場合にのみ、使用されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'{0}' はインターフェイス メンバー '{1}' を実装しません。'{2}' は public ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'{0}' は、パターン '{1}' を実装しません。'{2}' は、'{3}' で不適切です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">型は、コレクション パターンを実装しません。メンバーがあいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'{0}' は、パターン '{1}' を実装しません。'{2}' には正しくないシグネチャが含まれます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">型は、コレクション パターンを実装しません。メンバーには正しくないシグネチャが含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">フレンド アクセスのアクセス権は '{0}' によって付与されますが、出力アセンブリ ('{1}') の公開キーは、付与するアセンブリで InternalsVisibleTo 属性によって指定される公開キーと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">フレンド アクセスのアクセス権は '{0}' によって付与されますが、出力アセンブリにおける厳密な名前の署名の状態が付与するアセンブリと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">部分的な構造体 '{0}' の複数の宣言内にあるフィールド間に、定義された順序がありません。順序を指定するには、すべてのインスタンス フィールドが同じ宣言内になければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">部分的な構造体の複数の宣言内にあるフィールド間に定義された順序がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">型 '{0}' を const 宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">変数型 '{0}' のインスタンスは、new() 制約を含まないため、作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">ジェネリック {1} '{0}' を使用するには、{2} 型引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">型 '{0}' は型引数として使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} '{0}' は型引数と一緒には使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">非ジェネリック {1} '{0}' は型引数と一緒には使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'{2}' は、ジェネリック型またはメソッド '{0}' 内でパラメーター '{1}' として使用するために、パブリック パラメーターなしのコンストラクターを持つ非抽象型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">型 '{3}' はジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用できません。'{3}' から '{1}' への暗黙的な参照変換がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">型 '{3}' はジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用できません。Null 許容型 '{3}' は、'{1}' の制約を満たしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">型 '{3}' はジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用できません。Null 許容型 '{3}' は、'{1}' の制約を満たしていません。Null 許容型はインターフェイス制約を満たすことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">型 '{3}' はジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用できません。'{3}' から '{1}' へのボックス変換または型パラメーター変換がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">型 '{3}' はジェネリック型またはメソッド '{0}' 内で型パラメーター '{2}' として使用できません。'{3}' から '{1}' へのボックス変換がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">パラメーター名 '{0}' が自動生成されたパラメーター名と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">型名または名前空間名 '{0}' がグローバル名前空間に見つかりませんでした (アセンブリ参照が存在することを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last constraint specified</source>
        <target state="translated">new() 制約は最後に指定する制約でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'{0}': エントリ ポイントがジェネリックになったり、ジェネリック型の中に存在したりすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">エントリ ポイントがジェネリックになったり、ジェネリック型の中に存在したりすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">Null 非許容の値型である可能性があるため、Null を型パラメーター '{0}' に変換できません。'default({0})' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">型パラメーター '{1}' に対する制約 '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">クラス型制約 '{0}' は、他の制約の前に指定されなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'{1} {0}' には、不適切な戻り値の型が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">'{0}' とデリゲート '{1}' で参照が一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">制約句が、型パラメーター '{0}' に既に指定されています。型パラメーターの制約のすべてが、単一の WHERE 句で指定されなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">メソッド '{0}' の型引数を使い方から推論することはできません。型引数を明示的に指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'{0}': パラメーター、ローカル変数またはローカル関数は、メソッド型のパラメーターと同じ名前を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">型パラメーター '{0}' にはクラス型制約も 'class' 制約も含まれないため、'as' 演算子で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">フィールド '{0}' が割り当てられていますが、値は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">フィールドが割り当てられていますが、値は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">'{0}' 属性は、明示的なインターフェイス メンバー宣言ではないインデクサー上でのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'{0}': 属性の引数は型パラメーターを使用することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'{0}': 変数型のインスタンスを作成するときに、引数を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract type cannot be sealed or static</source>
        <target state="translated">'{0}': 抽象型を sealed または static に指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">'{0}' は cref 属性内のあいまいな参照です。'{1}' を仮定しますが、'{2}' を含む別のオーバーロードに一致した可能性もあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">Cref 属性の参照があいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'{0}': volatile フィールドへの参照は、volatile として扱われません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">volatile フィールドへの参照は、volatile として扱われません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">volatile フィールドは、通常は ref 値または out 値として使用しないでください。このフィールドは、volatile として扱われないためです。ただしこれには、インタロック API の呼び出しのときなど、例外もあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">'{1}' は ComImport 属性を含むため、'{0}' は extern または abstract にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'{0}': ComImport 属性を含むクラスは、基底クラスを指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">メソッド '{1}' の型パラメーター '{0}' に対する制約は、インターフェイス メソッド '{3}' の型パラメーター '{2}' に対する制約と一致しなければなりません。明示的なインターフェイスの実装を使用することをお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">メソッド '{0}' のシグネチャにあるタプル要素名は、インターフェイス メソッド '{1}' のタプル要素名と (戻り値の型を含めて) 一致している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">型名 '{0}' が型 '{1}' に存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">メソッド グループ '{0}' を非デリゲート型 '{1}' に変換することはできません。このメソッドを呼び出しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">extern エイリアス '{0}' は、/reference オプションで指定されませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">エイリアスが型を参照しているため、エイリアス '{0}' を '::' と使用できません。'.' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">エイリアス '{0}' が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">型 '{1}' が '{0}' と '{2}' の両方に存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">'{0}' の名前空間 '{1}' が '{2}' の型 '{3}' と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">'{0}' の名前空間 '{1}' は、'{2}' のインポートされた型 '{3}' と競合しています。'{0}' で定義された名前空間を使用しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">名前空間がインポートされた型と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">'{0}' の型 '{1}' は、'{2}' のインポートされた型 '{3}' と競合しています。'{0}' で定義された型を使用しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">型がインポートされた型と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">'{0}' の型 '{1}' は、'{2}' のインポートされた名前空間 '{3}' と競合しています。'{0}' で定義された型を使用しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">型がインポートされた名前空間と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">'{0}' の型 '{1}' が '{2}' の名前空間 '{3}' と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">extern エイリアス宣言は、名前空間で定義された他のすべての要素の前に指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">global::' はエイリアスではなく常にグローバル名前空間を参照するため、'global' という名前のエイリアスを定義することはお勧めしません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">global' という名前のエイリアスを定義することはお勧めしません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a type cannot be both static and sealed</source>
        <target state="translated">'{0}': 型に static と sealed の両方を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'{0}': 抽象プロパティにプライベート アクセサーは指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">構文エラーです。値が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">アンボックス変換の結果を変更できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Foreach は '{0}' 上で使用できません。'{0}' を呼び出しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">++ または -- 演算子の戻り値の型は、パラメーター型と一致するか、パラメーター型から派生する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'{0}': 制約クラスと 'class' または 'struct' 制約の両方を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">new()' 制約は 'struct' 制約と一緒には使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">型 '{2}' は、ジェネリック型のパラメーター '{1}'、またはメソッド '{0}' として使用するために、参照型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">型 '{2}' は、ジェネリック型のパラメーター '{1}'、またはメソッド '{0}' として使用するために、Null 非許容の値型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">'{0}' と '{1}' を含む、循環制約の依存関係です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">型パラメーター '{0}' は、競合する制約 '{1}' および '{2}' を継承します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">型パラメーター '{1}' は 'struct' 制約を含むので、'{0}' の制約として '{1}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">'{2}' から '{3}' へ変換するときの、あいまいなユーザー定義の変換 '{0}' および '{1}' です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">式の結果は常に型 '{0}' の 'null' になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">式の結果が常に 'null' です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">参照渡しで 'this' を返すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.</source>
        <target state="translated">'in' または 'ref readonly' パラメーターがあるため、属性のコンストラクター '{0}' を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">オーバーライドおよび明示的なインターフェイスの実装メソッドの制約は、基本メソッドから継承されるので、'class' または 'struct' 制約の場合を除いて直接指定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">継承したメンバー '{0}' と '{1}' に '{2}' 型の同じ署名があるためオーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">10 進数の定数式の評価に失敗しました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">型 '{0}' の null と比較すると、いつも 'false' を生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">構造体型の null と比較するといつも 'false' を生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">Finalize' メソッドを導入すると、デストラクターの呼び出しに影響する可能性があります。デストラクターを宣言しようとしましたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">Finalize' メソッドを導入すると、デストラクターの呼び出しに影響する可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">この警告は、シグネチャが public virtual void Finalize であるメソッドを持つクラスを作成したときに発生します。

このようなクラスが基本クラスとして使用され、派生クラスがデストラクターを定義している場合、デストラクターは Finalize ではなく、基本クラスの Finalize メソッドをオーバーライドします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'{1}' には params パラメーターがないため、'{0}' は params パラメーターを持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">goto case' 値は型 '{0}' に暗黙的に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">goto case' 値はスイッチ型に暗黙的に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">メソッド '{0}' は、型 '{2}' のインターフェイス アクセサー '{1}' を実装できません。明示的なインターフェイス実装を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">型 '{1}' の値が型 '{2}' の 'null' に等しくなることはないので、式の結果は常に '{0}' になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">この型の値が 'null' に等しくなることはないので、式の結果は常に同じです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">型 '{1}' の値が型 '{2}' の 'null' に等しくなることはないので、式の結果は常に '{0}' になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">この型の値が 'null' に等しくなることはないので、式の結果は常に同じです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">明示的なインターフェイスの実装 '{0}' に一致するインターフェイス メンバーが 2 つ以上あります。どのインターフェイスが実際選択されるかは実装に依存しています。代わりに、明示的ではない実装の使用をお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">明示的なインターフェイスの実装に一致するインターフェイス メンバーが複数あります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'{0}' は abstract に指定されているため本体を宣言できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'{0}' は abstract、extern、または partial に指定されていないため、本体を宣言する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'{0}' を abstract および sealed に同時に指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">抽象 {0} '{1}' を virtual に指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">定数 '{0}' を static に設定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'{0}': '{1}' は関数ではないためオーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'{0}': 継承されたメンバー '{1}' は virtual、abstract または override に設定されていないためオーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'{0}': '{1}' の継承メンバー '{2}' をオーバーライドするときに、アクセス修飾子を変更できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'{0}': 継承されたメンバー '{1}' を上書きするときにタプル要素名を変更することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': オーバーライドされたメンバー '{1}' に対応するために戻り値の型は '{2}' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'{0}': シール型 '{1}' から派生することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract type '{1}'</source>
        <target state="translated">'{0}' は抽象ですが、非抽象型の '{1}' に含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'{0}': 静的コンストラクターは、明示的な 'this' または 'base' コンストラクターの呼び出しを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'{0}': アクセス修飾子は静的コンストラクターでは許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">コンストラクター '{0}' で、それ自体を呼び出すことはできません:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">コンストラクター '{0}' で、それ自体を別のコンストラクターを通して呼び出すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">'{0}' には基底クラスがないため、基底コンストラクターを呼び出せません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">定義済みの型 '{0}' は定義、またはインポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">定義済みの型 '{0}' は定義、またはインポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">定義済みの型 '{0}' が複数の参照先アセンブリで宣言されています: '{1}' と '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'{0}': 構造体は、基底クラスのコンストラクターを呼び出すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">型 '{1}' の構造体メンバー '{0}' により、構造体レイアウトで循環参照が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">インターフェイスにインスタンス フィールドを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">インターフェイスにインスタンス コンストラクターを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">インターフェイス リストの型 '{0}' はインターフェイスではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'{0}' は既にインターフェイス リストに存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' は、型 '{2}' のインターフェイス リストに、異なるタプル要素名 '{1}' として既に指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">継承インターフェイス '{1}' により、'{0}' のインターフェイス階層内で循環参照が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'{0}' は継承抽象メンバー '{1}' を隠します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'{0}' は継承抽象メンバー '{1}' を実装しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'{0}' はインターフェイス メンバー '{1}' を実装しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">クラス System.Object は基底クラスを含んだり、インターフェイスを実装したりできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'明示的インターフェイス宣言の中の '{0}' はインターフェイスではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">明示的なインターフェイス宣言内の '{0}' が、実装可能なインターフェイスのメンバーの中に見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'{0}': 含む型は、インターフェイス '{1}' を実装しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</source>
        <target state="translated">'{0}': 明示的インターフェイス宣言はクラス、レコード、構造体、またはインターフェイスの中でのみ宣言できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'{0}': メンバー名をそれを囲む型の名前と同じにすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'{0}': 列挙子の値は、型に対して大きすぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'{0}': '{1}' はプロパティではないためオーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'{0}': '{1}' に、オーバーライド可能な get アクセサーがないため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'{0}': '{1}' に、オーバーライド可能な set アクセサーがないため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'{0}': プロパティまたはインデクサーに void 型を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'{0}': プロパティまたはインデクサーには少なくとも 1 つのアクセサーを指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed type '{1}'</source>
        <target state="translated">'{0}' は sealed 型 '{1}' の新しい仮想メンバーです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'{0}' はインターフェイス メンバー '{1}' にないアクセサーを追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">明示的なインターフェイスの実装 '{0}' にアクセサー '{1}' はありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'{0}': インターフェイスとの間におけるユーザー定義の変換は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base type are not allowed</source>
        <target state="translated">'{0}': 基本データ型との間におけるユーザー定義の変換は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived type are not allowed</source>
        <target state="translated">'{0}': 派生型との間におけるユーザー定義の変換は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot convert a type to itself</source>
        <target state="translated">ユーザー定義の演算子は、型をそれ自体に変換することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">ユーザー定義の変換では、それを囲む型に/から変換しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">型 '{0}' で重複するユーザー定義の変換です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">ユーザー定義の演算子 '{0}' は static および public として宣言されなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">++ または -- 演算子のパラメーターの型は、それを含む型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">単項演算子のパラメーターは、それを含む型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">バイナリ演算子のパラメーターの 1 つはそれを含む型でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type</source>
        <target state="translated">オーバーロードされた shift 演算子の最初のオペランドはそれを含む型と同じ型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">列挙型は明示的なパラメーターなしのコンス トラクターを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}': '{1}' はこの言語でサポートされていないため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'{0}' はこの言語でサポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'{0}': 演算子またはアクセサーを明示的に呼び出すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'{0}': 式から型を参照することはできません。'{1}' を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of type</source>
        <target state="translated">デストラクターの名前を型の名前と同じにしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">クラスのみがデストラクターを含むことができます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">名前空間 '{1}' は、エイリアス '{0}' と競合する定義を含んでいます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">エイリアス '{0}' は定義 {1} と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</source>
        <target state="translated">条件付き属性は、コンストラクター、デストラクター、演算子、ラムダ式、明示的インターフェイスのいずれかの実装であるため、'{0}' では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">戻り値の型が void でないため、条件付き属性は '{0}' では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">'{0}' 属性が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">'{0}' 属性が '{1}' で重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">インターフェイス メンバーに対して、条件付き属性は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">ユーザー定義の演算子は void を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'{0}': 動的な型との間でユーザー定義の変換を行うことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">'{0}' 属性の引数の値が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">パラメーターは指定されたアンマネージ型に対して無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">属性パラメーター '{0}' を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">属性パラメーター '{0}' または '{1}' を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">アンマネージ型 '{0}' はフィールドに対して無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">アンマネージ型 '{0}' はフィールドに対してのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">属性 '{0}' はこの宣言型では無効です。'{1}' 宣言でのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">浮動小数点定数が型 '{0}' の範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">Guid 属性は ComImport 属性を使って指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">名前付き属性の引数 '{0}' の値が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">static または extern に指定されているメソッドでは、DllImport 属性を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">'{0}' を更新できません。属性 '{1}' がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="translated">DllImport 属性は、ジェネリックであるメソッドに適用することも、ジェネリック メソッドまたは型に含めることもできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">フィールドまたはプロパティに型 '{0}' を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">フィールドまたは自動実装プロパティは、それが ref 構造体のインスタンス メンバーである場合を除いて、型 '{0}' にすることができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">配列要素を '{0}' 型にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'{0}' は古い形式です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">型またはメンバーが旧型式です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'{0}' は属性クラスではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'{0}' は有効な名前付き属性引数ではありません。名前付き属性引数は、読み取り専用、static、const、または公開され、静的でない読み書き可能なプロパティ以外のフィールドである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' は旧形式です ('{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">型またはメンバーが旧型式です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' は旧形式です ('{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">インデクサーに void 型を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'{0}': 仮想または抽象メンバーには、private を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">配列型を割り当てるには配列初期化子式だけを使用してください。new 式を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">配列初期化子は変数かフィールド初期化子の中でのみ使用できます。new 式を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">'{0}': StructLayout(LayoutKind.Explicit) でマークされた型のインスタンス フィールドには、FieldOffset 属性を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">メソッド、演算子、またはアクセサー '{0}' は external に設定されていて属性を持っていません。外部の実装を指定するには、DllImport 属性の追加を検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">メソッド、演算子、またはアクセサーは external に設定されていて属性を持っていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed type</source>
        <target state="translated">'{0}': 新規の protected メンバーが sealed 型で宣言されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed type</source>
        <target state="translated">新規の protected メンバーが sealed 型で宣言されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">条件付きメンバー '{0}' はインターフェイス メンバー '{1}' を型 '{2}' で実装できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">ref および out はこのコンテキストでは有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">属性 '{0}' に対する引数は、有効な識別子である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 属性は、StructLayout(LayoutKind.Explicit) でマークされた型のメンバーでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">FieldOffset 属性は、static または const フィールドで使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">属性 '{0}' は、System.Attribute から派生したクラスでのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">empty ステートメントが間違っている可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">empty ステートメントが間違っている可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'{0}' 属性引数の名前が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'{0}' は特殊クラス '{1}' から派生することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">インデクサーを含む型に対して DefaultMember 属性を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'{0}' はこの言語でサポートされていない型です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">フィールド '{0}' は割り当てられません。常に既定値 {1} を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">フィールドは割り当てられません。常に既定値を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">不適切な配列の宣言子: マネージ配列を宣言するには、次元指定子を変数の識別子の前に指定します。固定サイズ バッファー フィールドを宣言するには、フィールド型の前に fixed キーワードを使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">整数定数への比較ができません。定数が型 '{0}' の範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">整数定数への比較は無意味です。定数が型の範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">抽象であるため属性クラス '{0}' を適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'{0}' は有効な名前付き属性引数ではありません。属性パラメーター型が有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">コンパイラが必要とするメンバー '{0}.{1}' がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' は、この宣言の有効な属性ではありません。宣言の有効な属性の場所は '{1}' です。このブロックの属性はすべて無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">属性の場所はこの宣言に対して無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' は認識できる属性の場所ではありません。この宣言の属性の場所として使用できるのは '{1}' です。このブロック内の属性はすべて無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">認識できる属性の場所ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' は Object.Equals(object o) をオーバーライドしますが、Object.GetHashCode() をオーバーライドしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">型は Object.Equals(object o) をオーバーライドしますが、Object.GetHashCode() をオーバーライドしません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'{0}' は演算子 == または演算子 != を定義しますが、Object.Equals(object o) をオーバーライドしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">型は演算子 == または演算子 != を定義しますが、Object.Equals(object o) をオーバーライドしません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' は演算子 == または演算子 != を定義しますが、Object.GetHashCode() をオーバーライドしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">型は演算子 == または演算子 != を定義しますが、Object.GetHashCode() をオーバーライドしません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">ref パラメーターで Out 属性を指定するには、In 属性も指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'{0}' は、パラメーター修飾子 '{2}' と '{3}' だけが異なるオーバーロードされた {1} を定義できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">型 double のリテラルを暗黙的に型 '{1}' に変換することはできません。'{0}' サフィックスを使用して、この型のリテラルを作成してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">条件式の代入は常に定数です。== を使用するつもりで = を使用しましたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">条件式の代入は常に定数です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'{0}': 新規のプロテクト メンバーが構造体で宣言されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">2 つのインデクサーの名前が違います。1 つの型の中のそれぞれのインデクサーの IndexerName 属性は、同じでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">ComImport 属性を持つクラスはユーザー定義のコンストラクターを持てません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">フィールドは void 型を持てません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">メンバー '{0}' は古い形式のメンバー '{1}' をオーバーライドします。Obsolete 属性を '{0}' に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">メンバーは古い形式のメンバーをオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">System.Void は C# から使用できません。void 型オブジェクトを取得するには typeof(void) を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArray">
        <source>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">System.ParamArrayAttribute' を使用しないでください。代わりに 'params' キーワードを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">Bitwise-or 演算子が sign-extended オペランドで使用されています。まず、小さい符号なしの型をキャストしてみてください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">符号拡張されたオペランドでビットごとの or 演算子が使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">コンパイラは、変数を暗黙に拡張し、符号拡張してから、ビットごとの OR 演算の結果の値を使用しました。これにより、予期しない動作が発生することがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'{0}': volatile フィールドの型を '{1}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'{0}': フィールドに volatile と readonly の両方を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">修飾子 'abstract' はフィールドで有効ではありません。プロパティを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}' はこの言語でサポートされていないため、'{1}' で実装できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'{0}' 明示的なメソッドの実装で、アクセサーである '{1}' を実装することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'{0}' インターフェイスは、'CoClassAttribute' でマークされていますが、'ComImportAttribute' ではマークされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">インターフェイスは、'ComImportAttribute' ではなく、'CoClassAttribute' に設定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">条件付きメンバー '{0}' には out パラメーターを指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">アクセサー '{0}' は、インターフェイス メンバー '{1}' を型 '{2}' に対して実装できません。明示的なインターフェイスの実装を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">名前空間エイリアス修飾子 '::' は、常に型または名前空間を解決するので、ここでは無効です。'.' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">'{0}' は型パラメーターであるため、派生させることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">型パラメーター '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">型パラメーター '{0}' は、外の型からの型パラメーター '{1}' と同じ名前です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">型パラメーターの名前は、外の型からの型パラメーターと同じ名前です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">型のパラメーター '{0}' は、含む型またはメソッドと同じ名前を持っています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'型パラメーターの代用に対して統合している可能性があるため、'{0}' は '{1}' と '{2}' の両方を実装することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">'{1}' は、型のパラメーター '{0}' を定義しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'{0}' は有効な制約ではありません。制約として使用された型はインターフェイス、非シール クラス、または型パラメーターでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">制約は特殊クラス '{0}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。制約型 '{1}' のアクセシビリティは '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">'{0}' で非 virtual メンバー参照を実行できません。これは型パラメーターであるためです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">無効な制約型です。制約として使用された型はインターフェイス、非シール クラス、または型パラメーターでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'{0}': 静的クラスでインスタンスのメンバーを宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'{1}': 静的クラス '{0}' から派生することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">静的クラスにはコンストラクターを指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">静的クラスにデストラクターを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">静的クラス '{0}' のインスタンスを作成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">静的クラス '{0}' は型 '{1}' から派生することはできません。静的クラスはオブジェクトから派生する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'{0}': 静的クラスはインターフェイスを実装することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructInterfaceImpl">
        <source>'{0}': ref structs cannot implement interfaces</source>
        <target state="translated">'{0}': ref 構造体はインターフェイスを実装できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'{0}': 静的クラスにユーザー定義の演算子を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">スタティック型 '{0}' へ変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'{0}': 静的クラスは、制約として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'{0}': スタティック型を型引数として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'{0}': 配列要素をスタティック型にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'{0}': 静的クラスでインデクサーを宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': スタティック型はパラメーターとして使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': スタティック型を戻り値の型として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">スタティック型 '{0}' の変数を宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">引数のない throw ステートメントは、すぐ外側にある catch 句の中に入れ子にされた finally 句の中で使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}' は有効な形式指定子ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">using または lock ステートメントの引数であるローカルの '{0}' への代入が間違っている可能性があります。Dispose の呼び出しまたはロック解除がローカルの元の値で実行されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">using または lock ステートメントの引数であるローカルへの代入が正しくない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">型 '{0}' はこのアセンブリ内で定義されていますが、これには型フォワーダーが指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">型 '{0}' は、'{1}' の入れ子にされた型なので、転送できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">アセンブリ '{1}' にある '{0}' の型フォワーダーで循環が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">/moduleassemblyname オプションは 'module' のターゲット型をビルドするときのみ指定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">アセンブリ参照 '{0}' は無効であり、解決できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">無効な型が TypeForwardedTo 属性の引数として指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</source>
        <target state="translated">'{0}' は、インスタンス インターフェイス メンバー '{1}' を実装していません。'{2}' は静的であるため、インターフェイス メンバーを実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'{0}' は、インターフェイス メンバー '{1}' を実装していません。'{2}' は public ではないため、インターフェイス メンバーを実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'{0}' は、インターフェイス メンバー '{1}' を実装していません。'{2}' は一致する '{3}' の戻り値の型を持たないため、'{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'{0}' TypeForwardedToAttribute が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">クエリ本体の後には select 句または group 句が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">コンテキスト キーワード 'on' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">コンテキスト キーワード 'equals' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">コンテキスト キーワード 'by' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">匿名型のメンバー宣言子が無効です。メンバー代入、簡易名、またはメンバー アクセスを使用して、匿名型メンバーを宣言する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">初期化子のメンバー宣言子が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">ラムダ パラメーターの使用方法に一貫性がありません。パラメーター型はすべて明示的であるか、またはすべて暗黙的である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInvalidModifier">
        <source>A partial method cannot have the 'abstract' modifier</source>
        <target state="translated">部分メソッドに 'abstract' 修飾子を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyInPartialClass">
        <source>A partial method must be declared within a partial type</source>
        <target state="translated">部分メソッドは、部分型内で宣言される必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodNotExplicit">
        <source>A partial method may not explicitly implement an interface method</source>
        <target state="translated">部分メソッドは、インターフェイス メソッドを明示的に実装できないことがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">部分メソッド宣言は、両方とも拡張メソッドであるか、両方とも拡張メソッドでないかのいずれかである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">部分メソッドには、複数の定義宣言を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">部分メソッドでは、複数の実装宣言を含むことができない場合があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamsDifference">
        <source>Both partial method declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">部分メソッド宣言は、両方とも params パラメーターを使用するか、両方とも params パラメーターを使用しないかのいずれかである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">部分メソッド '{0}' の実装宣言に対する定義宣言が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentTupleNames">
        <source>Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">部分メソッド宣言 '{0}' および '{1}' は、どちらも同じタプル要素名を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">'{0}' の部分メソッド宣言には、型パラメーター '{1}' に対して矛盾する制約が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">メソッド '{0}' は実装宣言がない部分メソッドであるため、このメソッドからデリゲートを作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodStaticDifference">
        <source>Both partial method declarations must be static or neither may be static</source>
        <target state="translated">部分メソッド宣言は、両方とも static であるか、両方とも static でないかのいずれかである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodUnsafeDifference">
        <source>Both partial method declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">部分メソッド宣言は、両方とも unsafe であるか、両方とも unsafe でないかのいずれかである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">定義宣言だけを含む部分メソッドまたは削除された条件付きメソッドは、式ツリーで使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">旧形式のメンバー '{0}' は、旧形式でないメンバー '{1}' をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">旧形式のメンバーが、旧形式でないメンバーをオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">'{0}' の完全修飾名は、デバッグ情報に対して長すぎます。'/debug' オプションなしでコンパイルしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">完全修飾名が、デバッグ情報に対して長すぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">{0} を暗黙的に型指定された変数に割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">暗黙的に型指定された変数は初期化される必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">暗黙的に型指定された変数は、複数の宣言子を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">配列初期化子で暗黙的に型指定された変数を初期化することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">暗黙的に型指定されたローカル変数は修正できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">暗黙的に型指定された変数を定数にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">コンストラクター '{0}' は external に設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">コンストラクターは external に設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">コンテキスト キーワード 'var' は、ローカル変数宣言内またはスクリプト コード内でのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">暗黙的に型指定された配列の最適な型が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">'{0}' を匿名型のプロパティに割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">式ツリーは、ベース アクセスを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">式ツリーは、代入演算子を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">匿名型では、同じ名前を持つ複数のプロパティを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">ステートメント本体を含むラムダ式は、式ツリーに変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">ラムダ式を、型引数 '{0}' がデリゲート型ではない式ツリーに変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">定数の式では匿名型を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">演算子 'is' または 'as' の最初のオペランドを、ラムダ式、匿名メソッド、またはメソッドのグループにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">as' 演算子の最初のオペランドは、自然な型のないタプル リテラルにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">式ツリーは、多次元配列初期化子を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">引数がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">宣言する前にローカル変数 '{0}' を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">初期化子が直接的または間接的に定義を参照しているため、'{0}' の型を推論することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">宣言する前にローカル変数 '{0}' を使用できません。このローカル変数の宣言は、フィールド '{1}' を非表示にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">式ツリーのラムダには、左側に null リテラルまたは既定のリテラルのある合体演算子を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">識別子がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">; が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">構文エラーです。'{0}' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">修飾子 '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">プロパティ アクセサーは既に定義されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">byte、sbyte、short、ushort、int、uint、long または ulong のいずれかの型を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">認識できないエスケープ シーケンスです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">定数の 新しい行です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">空の文字リテラルです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">文字リテラルに文字が多すぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">無効な数字です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">get または set アクセサーが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">オブジェクト、文字列、またはクラス型が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">名前付き属性引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">catch 句を、try ステートメントの一般的な catch 句の後に置くことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">キーワード 'this' または 'base' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">オーバーロード可能な単項演算子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">オーバーロード可能な 2 項演算子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">整数定数が大きすぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">型、名前空間の定義、またはファイルの終わりが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">メンバー定義、ステートメント、またはファイルの終わりが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">埋め込みステートメントを宣言やラベル付きのステートメントにすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">プリプロセッサ ディレクティブが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">単一行コメントか行末が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">) が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">#endif ディレクティブ が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">不適切なプリプロセッサ ディレクティブです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#error: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">#warning ディレクティブ</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">型が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">ファイルの最初のトークンの後でプリプロセッサのシンボルの定義または定義の解除を行えませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">#r をファイルの最初のトークンの後に使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">ファイルの終わりが見つかりました。'*/' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">マージ競合マーカーが検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">refonly を使用する場合は、refout を使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">/refout または /refonly を使用する場合は、ネット モジュールをコンパイルできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">オーバーロード可能な演算子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">#endregion ディレクティブが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">未終了の文字列です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">プリプロセッサ ディレクティブは行でスペース以外の最初の文字でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">識別子が必要です。'{1}' はキーワードです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">{ か ; が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">for、using、fixed または declaration ステートメント に 1 つ以上の型を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">add または remove アクセサーが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">予期しない文字 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">予期しないトークン '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'{0}': 静的クラスにプロテクト メンバーを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">前の catch 句は、すべての例外を既にキャッチしています。スローされる例外以外のものはすべて System.Runtime.CompilerServices.RuntimeWrappedException にラップされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">前の catch 句は、すべての例外を既にキャッチしています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">この警告は、catch (System.Exception e) ブロックの後に catch() ブロックに指定された例外の型がない場合に発生します。警告は、catch() ブロックが例外をキャッチしないことを通知します。

AssemblyInfo.cs ファイルで RuntimeCompatibilityAttribute が false に設定されている場合 [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]、catch (System.Exception e) ブロックの後の catch() ブロックは、CLS でない例外をキャッチできます。この属性が明示的に false に設定されていない場合、すべてのスローされた CLS でない例外は例外として折り返され、catch (System.Exception e) ブロックによってキャッチされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">インクリメント演算子またはデクリメント演算子のオペランドには、変数、プロパティ、またはインデクサーを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">'{0}' に '{1}' の定義が含まれておらず、型 '{0}' の最初の引数を受け付けるアクセス可能な拡張メソッド '{1}' が見つかりませんでした。using ディレクティブまたはアセンブリ参照が不足していないことを確認してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'{0}' に '{1}' の定義が含まれておらず、型 '{0}' の最初の引数を受け付ける拡張メソッド '{1}' が見つかりませんでした ('{2}' の using ディレクティブが不足していないことを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">メソッド '{0}' には、最初のパラメーターではないパラメーター修飾子 'this' が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> パラメーター修飾子 '{0}' は '{1}' と一緒に使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">拡張メソッドの最初のパラメーターを型 '{0}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">パラメーター配列は、拡張メソッドで 'this' 修飾子と共に使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">拡張メソッドはスタティックでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">拡張メソッドは、非ジェネリック静的クラスで定義される必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">パラメーターには '{0}' 修飾子を 1 つだけ指定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">拡張メソッドは、トップ レベルの静的クラスで定義される必要があります。{0} は入れ子にされたクラスです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">コンパイラで必要とされる型 '{0}' が見つからないため、新しい拡張メソッドを定義できません。System.Core.dll への参照が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">System.Runtime.CompilerServices.ExtensionAttribute' を使用しないでください。キーワード 'this' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">System.Runtime.CompilerServices.DynamicAttribute' は使用しないでください。キーワード 'dynamic' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">コンストラクターの呼び出しは動的ディスパッチされる必要がありますが、この呼び出しはコンストラクター初期化子の一部であるためディスパッチできません。動的な引数をキャストしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">値の型 '{1}' で定義された拡張メソッド '{0}' は、デリゲートを作成するために使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">引数 {1} を指定するメソッド '{0}' のオーバーロードはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">引数 {0}: は '{1}' から '{2}' へ変換することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">ソース ファイル '{0}' を開くことができませんでした -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">モジュールをビルド中にリソース ファイルにリンクできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">リソース識別子 '{0}' は既にこのアセンブリで使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">リンクされたリソースとモジュールにはそれぞれ、一意のファイル名があります。ファイル名 '{0}' はこのアセンブリで複数回指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">参照したファイル '{0}' はアセンブリではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">ref または out 値は、割り当て可能な変数でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">キーワード 'base' は静的メソッドでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">キーワード 'base' は現在のコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">} が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">{ が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'in' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">無効なプリプロセッサの式です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, record, struct, or interface member declaration</source>
        <target state="translated">クラス、レコード、構造体、またはインターフェイス メンバーの宣言でトークン '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">メソッドは戻り値の型を持たなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">無効な基本型です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">空の switch ブロックです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">空の switch ブロックです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">catch または finally が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">'{0}' は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires an argument list or (), [], or {} after type</source>
        <target state="translated">new 式は、型の後に引数リストか、丸かっこ ()、角かっこ []、または波かっこ {} を必要とします</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">名前空間で定義された要素は明示的に private、protected、protected internal、または private protected に宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">; または = を指定してください (宣言の中にコンストラクター引数は指定できません)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">using 句は、extern エイリアス宣言以外の、名前空間で定義された他のすべての要素の前に使用しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">オーバーロードされた 2 項演算子 '{0}' に指定できるパラメーター数は 2 です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">オーバーロードされた単項演算子 '{0}' に指定できるパラメーター数は 1 です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">void は無効なパラメーター型です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">using エイリアス '{0}' は以前にこの名前空間で使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">'{1}' 型の修飾子をとおしてプロテクト メンバー '{0}' にアクセスすることはできません。修飾子は '{2}' 型、またはそれから派生したものでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'{0}' は既にアセンブリなのでこのアセンブリに加えることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">プロパティ、インデクサー、またはイベント '{0}' はこの言語でサポートされていません。アクセサー メソッドの '{1}' または '{2}' を直接呼び出してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">プロパティ、インデクサー、またはイベント '{0}' はこの言語でサポートされていません。アクセサー メソッドの '{1}' を直接呼び出してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">キーワード void はこのコンテキストで使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">インデクサーには最低パラメーターが 1 つ必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">配列型の指定子の角かっこ、[]、は、パラメーター名の前に使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">不適切な宣言です。代わりに '{0} 演算子 &lt;dest 型&gt; (...' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Main メソッドに指定された '{0}' が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</source>
        <target state="translated">Main メソッドに指定された '{0}' は、非ジェネリックのクラス、レコード、構造体、またはインターフェイスでなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">'{0}' は適切な静的 Main メソッドを含んでいません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">'{0}' はインポートされているため、Main メソッドに対して使うことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">ソースのない出力には、/out オプションを指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">競合するオプションが指定されました: Win32 リソース ファイル、Win32 マニフェスト</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">競合するオプションが指定されました: Win32 リソース ファイル、Win32 アイコン</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">リソース '{0}' を読み込み中にエラーが発生しました -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">XML ドキュメント ファイル {0} の書き込み中にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">XML コメントの XML 形式が正しくありません -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">XML コメントの XML 形式が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">XML コメントで param タグ '{0}' が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">XML コメントで param タグが重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">XML コメントには '{0}' の param タグがありますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">XML コメントに param タグが存在しますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">'{1}' の XML コメントで、'{0}' の paramref タグが存在しますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">XML コメントに paramref タグが存在しますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">パラメーター '{0}' には '{1}' の XML コメント内に対応する param タグがありませんが、他のパラメーターにはあります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">パラメーターには XML コメント内に対応する param タグがありませんが、他のパラメーターにはあります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">XML コメントに、解決できなかった cref 属性 '{0}' があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">XML コメントに、解決できなかった cref 属性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">stackalloc の式は型の後に角かっこ [] が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">#line ディレクティブの行数が指定されていないか、無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">引用符付きのファイル名、単一行コメント、または行末が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">ファイル名は引用符で囲まれている必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">#r はスクリプトでのみ許可されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">'{0}' は '{1}' のパブリック インスタンスまたは拡張機能の定義を含んでいないため、型 '{0}' の変数に対して foreach ステートメントを使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">XML コメントの cref 属性 ('{1}') のパラメーター {0} の型が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">XML コメントの cref 属性のパラメーターの型が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML コメントの cref 属性の戻り値の型が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML コメントの cref 属性の戻り値の型が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Win32 リソースの読み込み中にエラーが発生しました -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">XML コメントの cref 属性 '{0}' の構文が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">XML コメントに構文的に正しくない cref 属性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">メンバーの種類と名前の前にメンバー修飾子'{0}' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">配列を作成するには、配列のサイズまたは配列の初期化子を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML コメントが有効な言語要素の中にありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML コメントが有効な言語要素の中にありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">ファイル '{0}' の XML フラグメント '{1}' を含めることができません -- {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">XML フラグメントを含めることができません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">無効な XML のインクルード要素です -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">無効な XML のインクルード要素です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">公開されている型またはメンバー '{0}' の XML コメントがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">公開されている型またはメンバーの XML コメントがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">/doc コンパイラ オプションが指定されましたが、1 つ以上のコンストラクトにコメントがありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">コメント ファイルの中の XML 形式が正しくありません -- '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">組み込みコメント ファイルの中の XML 形式が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">デリゲート '{0}' には引数 {1} を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">メソッドまたはアクセサー ブロックの後のセミコロンの使用が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>The return type of a method, delegate, or function pointer cannot be '{0}'</source>
        <target state="translated">メソッド、デリゲート、または関数ポインターの戻り値の型を '{0}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">ユーザーによりコンパイルが取り消されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">型 '{0}' の変数を参照できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">読み取り専用であるため '{0}' に割り当てできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">'{0}' は読み取り専用なので、ref 値または out 値として使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">属性 RequiredAttribute は C# 型で許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">修飾子をイベント アクセサー宣言に付属させることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">params パラメーターは、{0} として宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">変数ではないため、'{0}' の戻り値を変更できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">インターフェイス '{1}' のマネージ コクラス ラッパー クラス '{0}' が見つかりません (アセンブリ参照が存在することを確認してください)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</source>
        <target state="translated">'{0}' が '{1}' と '{2}' の間であいまいです。' @{0}' を使用するか、'属性' サフィックスを明示的に含めてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">引数 {0} はキーワード '{1}' と共に渡すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">オプション '{0}' は、は、ソース ファイルまたは追加されたモジュールで指定された属性 '{1}' をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">オプションは、ソース ファイルまたは追加されたモジュールで指定された属性をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">この警告は、ソースにあるアセンブリの属性 AssemblyKeyFileAttribute または AssemblyKeyNameAttribute が /keyfile または/keycontainer コマンド ライン オプション、キー ファイルの名前、またはプロジェクトのプロパティで指定されたキー コンテナーと競合する場合に発生します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">/langversion のオプション '{0}' は無効です。サポートされている値を一覧表示するには、'/langversion:?' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">'{0}' またはオーバーライドされるメソッドは条件付き属性なので、この属性でデリゲートを作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">一時ファイルを作成できません -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">引数 {0} はキーワード '{1}' と共に渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">yield ステートメントは、匿名メソッドまたはラムダ式の内部では使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">反復子から値を返すことができません。yield return ステートメントを使用して値を返すか、yield break ステートメントを使用して反復子を終了してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">反復子には ref、in、out パラメーターを指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">'{1}' は反復子インターフェイス型ではないため、'{0}' の本体は反復子ブロックにできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">finally 句の本体で生成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">catch 句を含む try ブロックの本体で値を生成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">yield の戻り値の後に式が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">ref、out、in パラメーター '{0}' は、匿名メソッド、ラムダ式、クエリ式、ローカル関数の内部では使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalInnerUnsafe">
        <source>Unsafe code may not appear in iterators</source>
        <target state="translated">アンセーフ コードは反復子には記述できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">catch 句の本体で値を生成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">コントロールを匿名メソッドまたはラムダ式の本体外に出すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">認識できない #pragma ディレクティブです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">認識できない #pragma ディレクティブです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">'disable' または 'restore' を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">#pragma 警告の後に、'disable' または 'restore' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">警告 'CS{0}' はグローバルで無効にされたため、復元することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">警告はグローバルに無効にされたため復元できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">__arglist は、反復子のパラメーター リストでは許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have pointer type parameters</source>
        <target state="translated">反復子にポインター型パラメーターを指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">インターフェイス '{1}' のマネージ コクラス ラッパー クラス '{0}' は、有効なクラス名シグネチャではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">'{1}' の複数のインスタンスを実装するため、foreach ステートメントは、型 '{0}' の変数では操作できません。特定のインターフェイスのインスタンス化にキャストしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">固定サイズ バッファー フィールドには、フィールド名の後に配列サイズの指定子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">固定サイズ バッファー フィールドは、構造体のメンバーにしかなれません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">型 '{1}' の {0} に値を返さないコード パスがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">機能 '{0}' は標準 ISO C# 言語仕様ではありません。別のコンパイラでは受け入れられない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">機能は標準 ISO C# 言語仕様の一部ではありません。別のコンパイラでは受け入れられない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">verbatim 識別子の後にはキーワード、識別子、または文字列が必要です:@</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">読み取り専用フィールドを ref 値または out 値として使用することはできません (コンストラクターでは可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">読み取り専用フィールド '{0}' のメンバーを ref 値または out 値として使用することはできません (コンストラクターでは可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</source>
        <target state="translated">読み取り専用フィールドに割り当てることはできません (フィールドが定義されている型のコンストラクターか init 専用セッター、または変数初期化子では可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">読み取り専用フィールド '{0}' のメンバーは変更できません (コンストラクターまたは変数初期化子では可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' は、読み取り専用の変数であるため、ref 値または out 値として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}' のメンバーは読み取り専用の変数であるため、ref 値としても out 値としても使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">{0} に割り当てることができません。'{1}' は読み取り専用変数であるため、ref 割り当ての右辺として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">{0} のメンバーに割り当てることができません。'{1}' は読み取り専用変数であるため、ref 割り当ての右辺として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">{0} '{1}' は読み取り専用の変数であるため、書き込み可能な参照によって返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">{0} '{1}' のメンバーは読み取り専用の変数であるため、書き込み可能な参照によって返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">静的読み取り専用フィールド '{0}' のフィールドへの割り当てはできません (静的コンストラクターまたは変数初期化子では可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">静的な読み取り専用フィールド '{0}' のフィールドを ref 値または out 値として使用することはできません (静的コンストラクターでは可)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">'{0}' のメンバーは '{1}' であるため変更できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">'{0}' は '{1}' であるため、そのフィールドを ref 値または out 値として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">'{0}' は '{1}' であるため、これに割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">'{0}' は '{1}' であるため、ref 値または out 値として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}。エラー CS{1} を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">警告がエラーをオーバーライドしています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">コンパイラは、警告付きのエラーをオーバーライドしたときにこの警告を生成します。この問題の詳細については、上記のエラー コードを検索してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">{0} はデリゲート型ではないため、'{1}' 型に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">パラメーター型がデリゲート パラメーター型と一致しないため、{0} を型 '{1}' に変換することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">デリゲート戻り値の型に暗黙的に変換できない戻り値の型がブロック内にあるため、{0} を目的のデリゲート型に変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than '{1}'</source>
        <target state="translated">これは非同期メソッドであるため、return 式は '{0}' ではなく '{1}' 型である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">非同期の {0} をデリゲート型 '{1}' に変換できません。非同期の {0} は void、Task、または Task&lt;T&gt; を返しますが、いずれも '{1}' に変換することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">固定サイズ バッファーの型は次のうちの 1 つでなければなりません: bool、byte、short、int、long、char、sbyte、ushort、uint、ulong、float または double</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">長さ {0}、型 '{1}' の固定サイズ バッファーは大きすぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">固定サイズ バッファーには、0 よりも大きい値を指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">fixed でない式に含まれる固定サイズ バッファーは使用できません。fixed ステートメントを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">属性 '{0}' はプロパティまたはイベントのアクセサーでは無効です。'{1}' 宣言でのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">'{1}' で指定された無効な検索パス '{0}' です -- '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">無効な検索パスが指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">__arglist は、このコンテキストでは無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">params はこのコンテキストでは有効ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">名前空間の宣言に、修飾子または属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">/platform に対するオプション '{0}' が無効です。anycpu、x86、Itanium、arm、arm64、x64 を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.</source>
        <target state="translated">構造体内部の匿名メソッド、ラムダ式、クエリ式、またはローカル関数は、'this' のインスタンス メンバーにアクセスできません。匿名メソッド、ラムダ式、クエリ式、またはローカル関数の外部のローカル変数に 'this' をコピーして、そのローカルをご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.</source>
        <target state="translated">'{0}': using ステートメントで使用される型は、暗黙的に 'System.IDisposable' への変換が可能でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">パラメーター {0} はキーワード '{1}' で宣言する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">パラメーター {0} はキーワード '{1}' で宣言しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">パラメーター {0} は '{1}{2}' 型として宣言しますが、'{3}{4}' である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">/reference' の無効な extern エイリアスです。'{0}' は無効な識別子です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">無効な参照エイリアス オプションです: '{0}=' -- ファイル名が指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">グローバルの extern エイリアスは再定義できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">型 '{0}' への参照では、このアセンブリで定義されていると指定されていますが、ソースまたは追加モジュール内では定義されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">型 '{0}' への参照では、'{1}' で定義されていると指定されていますが、見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">定義済みの型 '{0}' は、グローバル エイリアスの複数のアセンブリ内で定義されています。'{1}' からの定義を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">グローバル エイリアスの複数のアセンブリで定義済みの型が定義されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">このエラーは、System.Int32 などの定義済みのシステム型が 2 つのアセンブリで見つかった場合に発生します。これが起こりうる 1 つの方法は、.NET Framework の 2 つのバージョンを同時に実行するなど、2 つの異なる場所から mscorlib または System.Runtime.dll を参照した場合です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">ローカル '{0}' またはそのメンバーは、アドレスを与えることも、匿名メソッドまたはラムダ式の内部で使用されることもできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">ソース ファイルは、PDB 内で表せる 16,707,565 行の限界を超えているため、デバッグ情報は不正確になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">ソース ファイルは、PDB 内で表せる 16,707,565 行の限界を超えているため、デバッグ情報は不正確になります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">デリゲート型 '{0}' には 1 つ以上の out パラメーターが含まれているため、パラメーター リストを含まない匿名メソッド ブロックをこのデリゲート型に変換することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">属性 '{0}' は、メソッドまたは属性クラスでのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">参照渡しのマーシャリングクラスのフィールドであるため、'{0}' のメンバーにアクセスすると、ランタイム例外が発生する可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">参照渡しのマーシャリングクラスのフィールドのメンバーにアクセスすると、ランタイム例外が発生する可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">この警告は、MarshalByRefObject から派生したクラスのメンバーにあるメソッド、プロパティ、またはインデクサーを呼び出し、かつメンバーが値の型である場合に発生します。MarshalByRefObject から継承するオブジェクトは、通常はアプリケーション ドメイン間の参照渡しによってマーシャリングされることになっています。コードがこのようなアプリケーション ドメイン間のオブジェクトの値の型のメンバーに直接アクセスすると、ランタイム例外が発生します。警告を解決するには、まずメンバーをローカル変数にコピーしてから、その変数でメソッドを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">'{0}' は有効な警告番号ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">無効な警告番号です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">#pragma 警告のプリプロセッサ ディレクティブに渡された番号は無効な警告番号です。番号がエラー番号ではなく警告番号を表していることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">無効な数字です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">無効な数字です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">プリプロセッサ ディレクティブに対して無効なファイル名が指定されました。ファイル名は長すぎるか、または有効なファイル名ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">プリプロセッサ ディレクティブに対して無効なファイル名が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">無効な #pragma checksum 構文です。有効な #pragma checksum は、"filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..." です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">無効な #pragma チェックサム構文です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">単一行コメントか行末が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">#pragma ディレクティブの後に、単一行コメントか行末が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">'{0}' に異なるチェックサム値が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">異なる #pragma チェックサム値が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">アセンブリ参照 '{0}' は無効であり、解決できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">アセンブリ参照が無効で、解決できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">この警告は、InternalsVisibleToAttribute などの属性が正しく指定されていないことを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">'{1}' によって使用されるアセンブリ参照 '{0}' が '{3}' の ID '{2}' と一致すると仮定して、実行時ポリシーを指定する必要がある可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">アセンブリ参照が ID と一致すると仮定します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">2 つのアセンブリはリリースまたはバージョン番号が異なります。統一するには、アプリケーションの .config ファイルにディレクティブを指定するとともに、アセンブリの厳密な名前を正しく付ける必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">'{1}' によって使用されるアセンブリ参照 '{0}' が '{3}' の ID '{2}' と一致すると仮定して、実行時ポリシーを指定する必要がある可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">アセンブリ参照が ID と一致すると仮定します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">2 つのアセンブリはリリースまたはバージョン番号が異なります。統一するには、アプリケーションの .config ファイルにディレクティブを指定するとともに、アセンブリの厳密な名前を正しく付ける必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">ID が同一の複数のアセンブリ ('{0}' と '{1}') がインポートされました。重複している参照の一方を削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">同じ簡易名 '{0}' でアセンブリが既にインポートされています。参照の 1 つ (例: '{1}') を削除するか、サイド バイ サイドを有効にするために署名してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">アセンブリ '{0}' (ID '{1}') は、参照されているアセンブリ '{3}' (ID '{4}') より新しいバージョンを含む '{2}' を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">固定サイズ バッファーには、ローカルまたはフィールドをとおしてのみアクセスできます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">XML コメントで '{0}' の typeparam タグが重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">XML コメントで typeparam タグが重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">XML コメントには '{0}' の typeparam タグがありますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">XML コメントに typeparam タグが存在しますが、その名前に相当する型パラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">'{1}' の XML コメントで、'{0}' の typeparamref タグがありますが、その名前に相当するパラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">XML コメントに typeparamref タグが存在しますが、その名前に相当する型パラメーターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">型パラメーター '{0}' には、対応する typeparam タグが '{1}' の XML コメントにありませんが、他の型パラメーターにはあります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">型パラメーターには、対応する typeparam タグが XML コメントにありませんが、他の型パラメーターにはあります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': オーバーライドされたメンバー '{1}' に対応するために、型は '{2}' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">System.Runtime.CompilerServices.FixedBuffer' 属性を使用しないでください。'fixed' フィールド修飾子を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">同じ変数に代入られました。他の変数に代入しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">同じ変数に代入されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">同じ変数と比較されました。他の変数と比較しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">同じ変数と比較されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">Win32 リソース ファイル '{0}' を開く際にエラーが発生しました -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">'{0}' の既定値が Null であるため、式は常に System.NullReferenceException になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">型の規定値が null であるため、式は常に System.NullReferenceException になります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">クラス '{0}' は複数の基底クラス ('{1}' と '{2}') を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">基底クラス '{0}' は、すべてのインターフェイスより前に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">XML コメントに型パラメーターを参照する cref 属性 '{0}' が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">XML コメントに型パラメーターを参照する cref 属性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">フレンド アセンブリ参照 '{0}' は無効です。InternalsVisibleTo 宣言にバージョン、カルチャ、公開キー トークン、またはプロセッサ属性を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">フレンド アセンブリ参照 '{0}' は無効です。厳密な名前の署名つきアセンブリはその InternalsVisibleTo 宣言内で公開キーを指定しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">System.Nullable&lt;T&gt;' のメンバーであるため、デリゲートを '{0}' にバインドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'{0}' には、引数 {1} を指定するコンストラクターは含まれていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">アセンブリ属性とモジュール属性は、句および extern エイリアス宣言を使用する場合を除き、ファイルで定義された他のすべての要素の前に指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">式が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">/subsystemversion のバージョン {0} は無効です。バージョンは、ARM または AppContainerExe の場合は 6.02 以上、それ以外の場合は 4.00 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">埋め込み相互運用メソッド '{0}' には本体が含まれます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be zero or greater</source>
        <target state="translated">警告レベルには 0 以上を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">/debug のオプション '{0}' が無効です。'portable'、'embedded'、'full'、または 'pdbonly' を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">無効なオプション '{0}' です。リソースの表示範囲は 'public' または 'private' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">DefaultParameterValue 属性への引数の型は、パラメーター型と一致していることが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">型 '{0}' の引数は DefaultParameterValue 属性には適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">メンバー '{0}' の初期化が重複しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">メンバー '{0}' はフィールドまたはプロパティではないため、初期化することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">静的フィールドまたはプロパティ '{0}' をオブジェクト初期化子に割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">型 '{1}' の読み取り専用フィールド '{0}' のメンバーは、値の型であるため、オブジェクト初期化子と共に割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">型 '{1}' のプロパティ '{0}' のメンバーは、値の型であるため、オブジェクト初期化子と共に割り当てることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">安全でない型 '{0}' をオブジェクトの作成に使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">要素初期化子を空白にはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">'{0}' に最も適しているオーバーロード メソッドには、初期化子要素の正しくないシグネチャが含まれます。初期化可能な Add は、アクセス可能なインスタンス メソッドでなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">System.Collections.IEnumerable' を実装していないため、型 '{0}' はコレクション初期化子で初期化することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">Win32 マニフェスト ファイル '{0}' を読み取り中にエラーが発生しました -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">モジュールの /win32manifest は、アセンブリにのみ適用されるため、無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">モジュールの /win32manifest は、アセンブリにのみ適用されるため、無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'{0}' に '{1}' の定義が含まれておらず、最も適している拡張メソッド オーバーロード '{2}' には '{3}' 型のレシーバーが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">範囲変数 '{0}' は既に宣言されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">範囲変数 '{0}' が '{0}' の以前の宣言と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">範囲変数に {0} を割り当てることができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">ソース型 '{0}' のクエリ パターンの実装が見つかりませんでした。'{1}' が見つかりません。範囲変数 '{2}'  の型を明示的に指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</source>
        <target state="translated">ソース型 '{0}' のクエリ パターンの実装が見つかりませんでした。'{1}' が見つかりません。'System.Linq' の必要なアセンブリ参照か using ディレクティブが不足していないかご確認ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">ソース型 '{0}' のクエリ パターンの実装が見つかりませんでした。'{1}' が見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名前 '{0}' は 'equals' の左辺のスコープにありません。'equals' の両辺の式を交換してみてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">名前 '{0}' は 'equals' の右辺のスコープにありません。'equals' の両辺の式を交換してみてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">範囲変数 '{0}' は out または ref パラメーターとして渡すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">ソース型 '{0}' に対してクエリ パターンの複数の実装が見つかりました。'{1}' の呼び出しがあいまいです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 句のいずれかの式の型が正しくありません。'{1}' の呼び出しで型を推論できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 句の式の型が正しくありません。'{1}' の呼び出しで型を推論できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">ソース型 '{1}' のクエリ式では後ろに続く from 句で型 '{0}' の式が許可されていません。'{2}' の呼び出しで型を推論できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">式ツリーは、アンセーフ ポインター操作を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">式ツリーは、匿名メソッド式を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">匿名メソッド式を式ツリーに変換することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">範囲変数 '{0}' が割り当てられません -- 読み取り専用です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">範囲変数 '{0}' は、メソッド型パラメーターと同じ名前を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">コンテキスト キーワード 'var' は、範囲変数宣言では使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">コレクション初期化子に最も適しているオーバーロード Add メソッド '{0}' には無効な引数がいくつか含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">式ツリーのラムダは、ref、in、out パラメーターを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">式ツリーのラムダは、可変引数があるメソッドを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">式ツリーのラムダには、メソッド グループを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">コレクション初期化子要素の '{0}' に最も適しているオーバーロード メソッドは使用できません。コレクション初期化子 'Add' メソッドには、ref パラメーターまたは out パラメーターを使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">実行不可能なメンバー '{0}' をメソッドのように使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">メンバー '{0}' は、インターフェイス メンバー '{1}' を型 '{2}' で実装できません。実行時に一致するインターフェイス メンバーが複数あります。どのメソッドが呼び出されるかは実装に依存しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">メンバーは、実行時に複数の一致があるインターフェイス メンバーを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">この警告は、2 つのインターフェイス メソッドが、特定のパラメーターが ref または out に設定されているかどうかのみで区別されている場合に生成されます。この警告を回避するには、コードを変更することが最善です。これは、実行時にどのメソッドが呼び出されるかが明確でないか、保証されていないためです。

C# では out と ref を区別しますが、CLR では同じと認識します。インターフェイスを実装するメソッドを決定する際、CLR がどちらか 1 つを選択します。

コンパイラにメソッドを区別する方法を与えます。たとえば、メソッドに異なる名前を付けたり、1 つのメソッドに追加のパラメーターを設けるなどです。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</source>
        <target state="translated">メンバー '{1}' は '{0}' をオーバーライドします。実行時にオーバーライドされる可能性のある候補は複数あります。どのメソッドが呼び出されるかは実装に依存しています。より新しいランタイムを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">メンバーは、実行時に複数のオーバーライド候補がある基本メンバーをオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">オブジェクトとコレクションの初期化子式は、デリゲートの作成式には適用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'{0}' は型 '{1}' です。定数宣言で指定される型は sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、string、列挙型、または参照型でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">ソース ファイル '{0}' が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">ソース ファイル '{0}' が複数回指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">ソース ファイルが複数回指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">'{0}' オプションのファイルが指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">コマンドラインの構文エラー: オプション '{1}' の '{0}' がありません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">認識されないオプション:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">ソース ファイルが指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">ソース ファイルが指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">スクリプト (.csx ファイル) が必要ですが、指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">応答ファイル '{0}' を開いているときにエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">ファイル '{0}' を開いて書き込むことができません -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">イメージの基数 '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'{0}' はテキスト ファイルではなくバイナリ ファイルです</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">コード ページ '{0}' は無効か、インストールされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">アルゴリズム '{0}' はサポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">モジュールまたはライブラリをビルドする場合は /main を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">/target のターゲット型が無効です。'exe'、'winexe'、'library'、または 'module' のいずれかを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">応答ファイルで指定されているため、/noconfig オプションを無視します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">応答ファイルで指定されているため、/noconfig オプションを無視します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">'{0}' は無効なファイル セクションの配置です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">無効な出力名: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">無効なデバッグ情報の形式: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'id#' 構文はサポートされなくなりました。'$id' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前処理シンボルの名前が無効です。'{0}' は有効な識別子ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">前処理シンボルの名前が無効です。有効な識別子ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">同じ短いファイル名を使用している長いファイル名が既に存在するとき、短いファイル名 '{0}' を作成することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">extern エイリアスを宣言する /reference オプションにはファイル名が 1 つだけ指定できます。複数のエイリアスまたはファイル名を指定するには、複数の /reference オプションを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">コマンドラインの構文エラー: オプション '{0}' の ':&lt;number&gt;' がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">/pdb オプションでは、/debug オプションも使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">式ツリーのラムダには、引数で ref を省略した COM 呼び出しを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">コマンドラインの構文エラー: オプション '{1}' の GUID 形式 '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">コマンドラインの構文エラー: オプション '{1}' の GUID がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">可変個の引数を持つメソッドは CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">可変個の引数を持つメソッドは CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">引数型 '{0}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">引数型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">'{0}' の戻り値の型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">戻り値の型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">'{0}' の型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">型が CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">public、protected、または protected internal 変数は、 共通言語仕様 (CLS) に準拠した型である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">大文字、小文字の違いのみの識別子 '{0}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">大文字、小文字の違いのみの識別子は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">ref、out、または配列のランクのみが異なるオーバーロード メソッド '{0}' は、CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">ref、out、または配列のランクのみが異なるオーバーロード メソッドは、CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">名前のない配列型のみが異なるオーバーロードされたメソッド '{0}' は、CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">名前のない配列型のみが異なるオーバーロード メソッドは CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">このエラーは、ジャグ配列を受け取るオーバーロード メソッドがあり、かつメソッドのシグネチャの唯一の違いが配列の要素型である場合に発生します。このエラーを回避するには、ジャグ配列ではなく四角形配列の使用を検討するか、追加のパラメーターを使用して関数呼び出しを明確にするか、1 つ以上のオーバーロードされたメソッドの名前を変更するか、または、CLS 準拠が不要の場合は CLSCompliantAttribute 属性を削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">識別子 '{0}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">識別子が CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}': 基本型 '{1}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">基本型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">基本型は、共通言語仕様 (CLS) 準拠であるとしたアセンブリで CLS への準拠が不要であると設定されました。アセンブリが CLS 準拠であると指定する属性を削除するか、型が CLS 準拠ではないことを示す属性を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'{0}': CLS 準拠のインターフェイスは CLS 準拠メンバーのみを含まなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">CLS 準拠のインターフェイスは CLS 準拠のメンバーのみを持つ必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'{0}': 抽象化できるのは CLS 準拠メンバーのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">抽象化できるのは CLS 準拠メンバーのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">CLS コンプライアンス チェックのためにモジュールではなく、アセンブリに CLSCompliant 属性を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">CLS コンプライアンス チェックのためにモジュールではなく、アセンブリに CLSCompliant 属性を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">追加されたモジュールは、アセンブリに一致するように CLSCompliant 属性と共に設定されなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">追加されたモジュールは、アセンブリに一致するように CLSCompliant 属性と共に設定されなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'アセンブリには属性 CLSCompliant がないため、'{0}' をCLS 準拠として設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">アセンブリに CLSCompliant 属性がないため、型またはメンバーは CLS 準拠として設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'{0}' は CLS 準拠型のみを使用するコンストラクターにアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">型には、CLS 準拠型のみを使用する、アクセス可能なコンストラクターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">属性の引数としての配列は CLS 準拠ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">属性の引数としての配列は CLS 準拠ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">アセンブリの CLSCompliant 属性と異なるモジュールの CLSCompliant 属性は指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">アセンブリの CLSCompliant 属性と異なるモジュールの CLSCompliant 属性は指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'{0}' は CLS に準拠していない型 '{1}' のメンバーであるため、CLS 準拠として設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">型は CLS に準拠していない型のメンバーになっているため、CLS 準拠として設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">'{0}' はこのアセンブリの外から認識できないため、CLS 準拠の確認は実行されません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">CLS 準拠の確認は、このアセンブリの外から認識できないため実行されません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'アセンブリには属性 CLSCompliant がないため、'{0}' に属性 CLSCompliant は不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">アセンブリに CLSCompliant 属性がないため、型またはメンバーには CLSCompliant 属性は不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 属性は、パラメーターに適用されても意味がありません。メソッドに適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">CLSCompliant 属性は、パラメーターに適用しても意味がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 属性は、戻り値の型に適用されても意味がありません。メソッドに適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">CLSCompliant 属性は、戻り値の型に適用しても意味がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">制約型 '{0}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">制約型が CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">CLS 準拠フィールド '{0}' を volatile にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">CLS 準拠フィールドを volatile にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'基底インターフェイス '{1}' が CLS 準拠でないため、'{0}' は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">基底インターフェイスが CLS に準拠していないため、型は CLS に準拠していません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">'await' では、型 {0} に適切な GetAwaiter メソッドがあることが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">'{0}' を待機することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">'await' では、'{1}.GetAwaiter()' の戻り値の型 '{0}' に適切な IsCompleted、OnCompleted、GetResult メンバーがあり、INotifyCompletion または ICriticalNotifyCompletion を実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">'await' では、型 '{0}' に適切な GetAwaiter メソッドが必要です。'System' に使用中のディレクティブは指定されていますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">void' を待機することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'非同期メソッドまたはラムダ式の内部で 'await' を識別子として使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'{0}' は '{1}' を実装しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression</source>
        <target state="translated">'{0}' は '{1}' を返す非同期メソッドであるため、return キーワードの後にオブジェクト式を続けてはなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">非同期メソッドの戻り値の型は、void、Task、Task&lt;T&gt;、task-like 型、IAsyncEnumerable&lt;T&gt;、IAsyncEnumerator&lt;T&gt; でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">void' 型の式を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">__arglist は、非同期メソッドのパラメーター リストに含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>'await' cannot be used in an expression containing the type '{0}'</source>
        <target state="translated">'await' は、型 '{0}' を含む式では使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have pointer type parameters</source>
        <target state="translated">非同期メソッドにポインター型パラメーターを指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">非同期メソッドには ref、in、out パラメーターを指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">await' 演算子は、'async' 修飾子が指定されているメソッドまたはラムダ式に含まれている場合にのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">await' 演算子は、非同期の {0} でのみ使用できます。この {0} を 'async' 修飾子でマークすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">await' 演算子は、非同期メソッド内でのみ使用できます。このメソッドを 'async' 修飾子でマークし、戻り値の型を 'Task&lt;{0}&gt;' に変更することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">await' 演算子は、非同期メソッド内でのみ使用できます。このメソッドに 'async' 修飾子を指定し、戻り値の型を 'Task' に変更することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">finally 句の本体で待機することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">catch 句を待機することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">catch 句のフィルター式を待機することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">lock ステートメントの本体で待機することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">await' 演算子は、静的なスクリプト変数初期化子では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">unsafe コンテキストで待機することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">async' 修飾子は、本体があるメソッドでのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefLocal">
        <source>Parameters or locals of type '{0}' cannot be declared in async methods or async lambda expressions.</source>
        <target state="translated">'{0}' 型のパラメーターまたはローカルは、非同期メソッドまたは非同期ラムダ式で宣言することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefIterator">
        <source>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.</source>
        <target state="translated">'{0}' は ref 構造体であるため、非同期または反復子のメソッド内で型 '{0}' の列挙子に対して foreach ステートメントは機能しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">セキュリティ属性 '{0}' を非同期メソッドに適用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">非同期メソッドは、'SecurityCritical' または 'SecuritySafeCritical' 属性を持つインターフェイス、クラス、または構造体では許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">await' 演算子は、最初の 'from' 句の最初のコレクション式、または 'join' 句のコレクション式に含まれるクエリ式でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">この非同期メソッドには 'await' 演算子がないため、同期的に実行されます。'await' 演算子を使用して非ブロッキング API 呼び出しを待機するか、'await Task.Run(...)' を使用してバックグラウンドのスレッドに対して CPU 主体の処理を実行することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">非同期メソッドは、'await' 演算子がないため、同期的に実行されます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">この呼び出しを待たないため、現在のメソッドの実行は、呼び出しが完了するまで続行します。呼び出しの結果に 'await' 演算子を適用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">この呼び出しは待機されなかったため、現在のメソッドの実行は呼び出しの完了を待たずに続行されます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">現在のメソッドでは、Task または Task&lt;TResult&gt; を返す非同期メソッドを呼び出すため、await 演算子は結果に適用されません。非同期メソッド呼び出しにより、非同期タスクが開始されます。しかし、await 演算子が適用されないため、プログラムはタスクが完了するのを待たずに継続されます。ほとんどの場合、この動作は期待されているものではありません。通常、呼び出しているメソッドの他のアスペクトは呼び出し結果に依存します。または最低限でも、呼び出されたメソッドは、呼び出しを含んでいるメソッドから復帰する前に完了していることが必要とされます。

同様に重要な問題として、呼び出された非同期メソッドでどんな例外が発生するかということがあります。Task または Task&lt;TResult&gt; を返すメソッドで発生した例外は、返されたタスクに保管されます。タスクを待機しないか例外を明示的にチェックしない場合、例外は失われます。タスクを待機する場合、例外は再スローされます。

ベスト プラクティスとして、常に呼び出しを待機するようにしてください。

警告を表示しないことを考慮するのは、非同期の呼び出しの完了の待機を行う必要がなく、呼び出されたメソッドが例外を起こさないことが確実な場合だけにしてください。その場合、呼び出しのタスク結果を変数に割り当てて、警告を表示しないようにできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'MethodImplOptions.Synchronized' は、非同期メソッドに適用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">型 '{0}' を型 '{1}' に変換する標準変換が存在しないため、CallerLineNumberAttribute を適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">型 '{0}' を型 '{1}' に変換する標準変換が存在しないため、CallerFilePathAttribute を適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">型 '{0}' を型 '{1}' に変換する標準変換が存在しないため、CallerMemberNameAttribute を適用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute は、既定値を含むパラメーターにのみ適用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute は、既定値を含むパラメーターにのみ適用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute は、既定値を含むパラメーターにのみ適用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">パラメーター '{0}' に適用された CallerLineNumberAttribute は、省略可能な引数を許可しないコンテキストで使用されるメンバーに適用されるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute は、オプションの引数を許可していないコンテキストで使用されるメンバーに適用されるため、効果がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">オプションの引数が許可されないコンテキストで使用されるメンバーに適用されるため、パラメーター '{0}' に適用された CallerFilePathAttribute は無効になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">オプションの引数が許可されないコンテキストで使用されるメンバーに適用されるため、CallerFilePathAttribute は無効になります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">パラメーター '{0}' に適用された CallerMemberNameAttribute は、省略可能な引数を許可しないコンテキストで使用されるメンバーに適用されるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute は、オプションの引数を許可していないコンテキストで使用されるメンバーに適用されるため、効果がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">プログラムは、エントリ ポイントに適切な静的 'Main' メソッドを含んでいません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">長さが '{0}' の配列初期化子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">入れ子になった配列初期化子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">無効な変性修飾子です。バリアントとして指定できるのは、インターフェイスおよびデリゲートの型パラメーターだけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">エイリアス名の予期しない使用方法です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">ジェネリック名の予期しない使用方法です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">バインドされていないジェネリック名の予期しない使用方法です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">式とステートメントはメソッド本体でのみ発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">配列のアクセスには名前付き引数の指定子を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">この言語機能 ('{0}') はまだ実装されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">このコンテキストでは、既定値は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">アイコン ファイル {0} を開く際にエラーが発生しました -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">Win32 マニフェスト ファイル {0} を開く際にエラーが発生しました -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Win32 リソースのビルド中にエラーが発生しました -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">省略可能なパラメーターはすべての必須パラメーターの後で指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">メソッド '{1}' が ref と out のみ異なるオーバーロードを含むようになるため、指定された型パラメーターではインターフェイス '{0}' を継承できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">'{0}' の partial 宣言では、同じ型パラメーター名と変性修飾子を同じ順序で指定しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">変性が無効です: 型のパラメーター '{1}' は '{0}' で有効な {3} である必要があります。'{1}' は {2} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'{0}': 動的な型から派生することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'{0}': 動的インターフェイス '{1}' を実装できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">制約を動的な型にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">制約は動的な型 '{0}' にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">動的な式のコンパイルに必要な 1 つ以上の型が見つかりません。参照が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">名前 '{0}' が、メタデータで許可されている最大文字数を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">属性は、このコンテキストでは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'このコンテキストでは 'extern エイリアス' は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">'{1}' との互換性をテストするために '{0}' を使用することは、 '{2}' との互換性をテストすることと実質的に同じであり、null 以外のすべての値で成功します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">is' を 'dynamic' との互換性をテストするために使用することは、'Object' との互換性をテストすることと実質的に同じです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">最上位のスクリプト コードで 'yield' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">スクリプト コードで名前空間を宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">アセンブリ属性とモジュール属性は、このコンテキストでは許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">デリゲート '{0}' には invoke メソッドがないか、サポートされていない戻り値の型またはパラメーター型の invoke メソッドがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global code; ignoring '{0}' entry point.</source>
        <target state="translated">プログラムのエントリ ポイントは、グローバル コードです。エントリ ポイント '{0}' を無視します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global code; ignoring entry point</source>
        <target state="translated">プログラムのエントリ ポイントがグローバル コード、エントリ ポイントを無視</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">アクセシビリティに一貫性がありません。イベント型 '{1}' のアクセシビリティはイベント '{0}' よりも低く設定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">名前付き引数は、すべての固定引数を指定した後に指定する必要があります。末尾以外の名前付き引数を許可するには、言語バージョン {0} 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">動的呼び出しでは、すべての固定引数を指定した後に名前付き引数を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">'{0}' に最も適しているオーバーロードには '{1}' という名前のパラメーターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">デリゲート '{0}' には '{1}' という名前のパラメーターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">'{0}' という名前付き引数が複数指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">名前付き引数 '{0}' は、場所引数が既に指定されているパラメーターを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">名前付き引数 '{0}' の場所が正しくありません。後ろに名前なし引数があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">DefaultParameterAttribute または OptionalAttribute と共に既定パラメーター値を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">'{0}' の既定のパラメーター値は、コンパイル時の定数である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">ref パラメーターまたは out パラメーターには既定値を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">this' パラメーターには既定値を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter array</source>
        <target state="translated">パラメーター配列には既定値を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">型 '{1}' への標準変換が存在しないため、型 '{0}' の値を既定のパラメーターとして使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">'{0}' は単純型ではないため、型 '{0}' の値を Null 許容パラメーター '{1}' の既定のパラメーターとして使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'{0}' の型は '{1}' です。文字列以外の参照型の既定のパラメーター値は null でのみ初期化できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">パラメーター '{0}' に対して指定されている既定値は、省略可能な引数を許可しないコンテキストで使用されるメンバーに適用されるため無効となります</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">指定されている既定値は、省略可能な引数を許可しないコンテキストで使用されるメンバーに適用されるため、効果がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">ファイル '{0}' から公開キーで出力に署名する際にエラーが発生しました -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">コンテナー '{0}' から公開キーで出力に署名する際にエラーが発生しました -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">動的な型では typeof 演算子を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">式ツリーに動的な操作を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">非同期ラムダ式を式ツリーに変換することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">コンパイラの必須型 '{0}' が見つからないため、'dynamic' を利用するクラスまたはメンバーを定義できません。参照が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">フレンド アセンブリ名に null を渡すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">署名に必要な、キー ファイル '{0}' のプライベート キーがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">公開署名が指定され、公開キーを必要としますが、公開キーは指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">netmodule では公開署名はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">遅延署名が指定されたため、公開キーが必要ですが、公開キーが指定されませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">遅延署名が指定されたため、公開キーが必要ですが、公開キーが指定されませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">指定したバージョン文字列 '{0}' は、必要な形式 (major[.minor[.build[.revision]]]) に従っていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">指定されたバージョン文字列 '{0}' には、決定性と互換性のないワイルドカードが含まれています。バージョン文字列からワイルドカードを削除するか、このコンパイルの決定性を無効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">指定したバージョン文字列 '{0}' は、必要な形式 (major.minor.build.revision、ワイルドカードなし) に従っていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定したバージョン文字列 '{0}' は、推奨される形式 (major.minor.build.revision) に従っていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定したバージョン文字列は、推奨される形式 (major.minor.build.revision) に従っていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">実行可能ファイルをサテライト アセンブリにできません。カルチャは常に空でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</source>
        <target state="translated">'{0}' の必要なパラメーター '{1}' に対応する特定の引数がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">コマンド ライン スイッチ '{0}' はまだ実装されていないため、無視されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">コマンド ライン スイッチはまだ実装されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">モジュール '{0}' の生成に失敗しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">匿名メソッド、ラムダ式、またはクエリ式の内部では、固定のローカルな '{0}' は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">名前付き引数の指定を式ツリーに含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">省略可能な引数を使用する呼び出しを式ツリーに含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">式ツリーにインデックス付きプロパティを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">インデックス付きプロパティ '{0}' には、省略できない引数を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">インデックス付きプロパティ '{0}' では、すべての引数が省略可能である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">型 '{0}' のインスタンスは、入れ子になった関数、クエリ式、反復子ブロック、または非同期メソッドの中では使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">セキュリティ属性の最初の引数は有効な SecurityAction である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">セキュリティ属性 '{0}' に無効な SecurityAction の値 '{1}' があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">SecurityAction の値 '{0}' は、アセンブリに適用されたセキュリティ属性に対して無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">SecurityAction の値 '{0}' は、型またはメソッドに適用するセキュリティ属性に対して無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">SecurityAction の値 '{0}' が属性 PrincipalPermission に対して無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">式ツリーに '{0}' を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">PermissionSet 属性の名前付き引数 '{1}' に対して指定されたファイル パス '{0}' を解決できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">PermissionSet 属性 ('{2}') の名前付き引数 '{1}' に対して指定されたファイル '{0}' の読み取り中にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">型名 '{0}' がグローバル名前空間に見つかりませんでした。この型はアセンブリ '{1}' に転送されています。このアセンブリに参照を追加することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">型名 '{0}' は名前空間 '{1}' に見つかりませんでした。この型はアセンブリ '{2}' に転送されました。このアセンブリへの参照を追加することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">型名 '{0}' が見つかりませんでした。この型はアセンブリ '{1}' に転送されています。このアセンブリに参照を追加することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">アセンブリ '{0}' および '{1}' は同じメタデータを参照していますが、リンクされている参照 (/link オプションを使用して指定される) は 1 つのみです。いずれかの参照を削除することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">コレクション初期化子要素に最も適しているオーバーロード Add メソッド '{0}' は、古い形式です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">コレクション初期化子要素に最も適しているオーバーロード Add メソッドは古い形式です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">コレクション初期化子要素に最も適しているオーバーロード Add メソッド '{0}' は古い形式です。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">コレクション初期化子要素に最も適しているオーバーロード Add メソッドは古い形式です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">コレクション初期化子要素に最も適しているオーバーロード Add メソッド '{0}' は古い形式です。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">セキュリティ属性 '{0}' はこの宣言型では無効です。セキュリティ属性は、アセンブリ、型、メソッドの宣言でのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">型 '{0}' の式を、動的ディスパッチされる操作の引数として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">最初にデリゲートまたは式ツリー型にキャストしていない場合は、ラムダ式を、動的ディスパッチされる操作の引数として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">メソッドのグループを動的ディスパッチされる操作の引数として使用することはできません。このメソッドを呼び出しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">メソッド '{0}' の呼び出しは動的ディスパッチされる必要がありますが、ベース アクセス式の一部であるためディスパッチできません。動的引数のキャストまたはベース アクセスの削除を検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">ソース型 'dynamic' に対するクエリ式または型 'dynamic' の結合シーケンスのあるクエリ式は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">インデクサー アクセスは動的ディスパッチされる必要がありますが、ベース アクセス式の一部であるためディスパッチできません。動的引数のキャストまたはベース アクセスの削除を検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">適用可能な 1 つ以上のオーバーロードが条件付きメソッドであるため、動的ディスパッチされたメソッド '{0}' の呼び出しは実行時に失敗する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">適用可能な 1 つ以上のオーバーロードが条件付きメソッドであるため、動的ディスパッチされた呼び出しは実行時に失敗することがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">'{0}' には、'{1}'という名前の該当するメソッドがありませんが、同じ名前の拡張メソッドがあるようです。拡張メソッドは動的ディスパッチできません。動的引数をキャストするか、または拡張メソッド構文を使用しないで拡張メソッドを呼び出すことを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerMemberNameAttribute は、CallerFilePathAttribute.によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerMemberNameAttribute は効果がなく、CallerFilePathAttribute によってオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerMemberNameAttribute は、CallerLineNumberAttribute によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerMemberNameAttribute は効果がなく、CallerLineNumberAttribute によってオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用された CallerFilePathAttribute は、CallerLineNumberAttribute によってオーバーライドされるため無効となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerFilePathAttribute は効果がなく、CallerLineNumberAttribute によってオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">式はブール型に暗黙的に変換できるか、式の型 '{0}' で演算子 '{1}' を定義する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'{2}' は Windows ランタイム イベントで、'{3}' は通常の .NET イベントであるため、'{0}' は '{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">{0} の割り当てられたインスタンスへの参照がすべてスコープ外になる前に、そのインスタンスの System.IDisposable.Dispose() を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">割り当てられたインスタンスへの参照がすべてスコープ外になる前に、そのインスタンスの System.IDisposable.Dispose() を呼び出します</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">{0} の割り当てられたインスタンスが破棄されない例外パスがあります。System.IDisposable.Dispose() への参照がスコープ外になる前にこれを呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">割り当てられたインスタンスがすべての例外パスで破棄されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">オブジェクト '{0}' は複数回破棄することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">オブジェクトは複数回破棄することができます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">相互運用型 '{0}' を埋め込むことができません。該当するインターフェイスを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">型 '{0}' は入れ子型であるため埋め込むことができません。'相互運用機能型の埋め込み' プロパティを false に設定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">型 '{0}' にはジェネリック引数があるため、この型を埋め込むことはできません。'相互運用型の埋め込み' プロパティを false に設定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">埋め込み相互運用構造体 '{0}' には、パブリック インスタンス フィールドのみを含めることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Windows ランタイム イベントを out または ref のパラメーターとして渡すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">ソース インターフェイス '{0}' に、イベント '{2}' を埋め込むために必要なメソッド '{1}' がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">イベント '{1}' の埋め込みに必要な、インターフェイス '{0}' のソース インターフェイスが無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">相互運用型 '{0}' は、必須の '{1}' 属性がないため、埋め込むことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">アセンブリ '{0}' に '{1}' 属性が指定されていないため、このアセンブリから相互運用型を埋め込むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">アセンブリ '{0}' には '{1}' 属性または '{2}' 属性が指定されていないため、このアセンブリから相互運用型を埋め込むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">アセンブリ '{1}' および '{2}' の両方に見つかった相互運用型 '{0}' は埋め込むことができません。'相互運用機能型の埋め込み' プロパティを false に設定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">アセンブリ '{1}' から相互運用型 '{0}' を埋め込むと、現在のアセンブリで名前の競合が発生します。'相互運用機能型の埋め込み' プロパティを false に設定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">間接的な参照がアセンブリ '{1}' によって作成されたため、埋め込み相互運用機能アセンブリ '{0}' への参照が作成されました。いずれかのアセンブリで '相互運用型の埋め込み' プロパティを変更することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">間接的なアセンブリの参照があるため、埋め込み相互運用機能アセンブリに対して参照が作成されました</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">/link (相互運用機能型の埋め込みプロパティを True に設定する) を使用して、アセンブリへの参照を追加しました。これを実行することで、コンパイラにそのアセンブリから相互運用の型情報を埋め込むよう指示します。しかし、参照した別のアセンブリが /reference (相互運用機能型の埋め込みプロパティを False に設定する) を使用してそのアセンブリを参照しているため、コンパイラはそのアセンブリの相互運用の型情報を埋め込むことができません。

両方のアセンブリの相互運用の型情報を埋め込むには、各アセンブリへの参照に /link (相互運用機能型の埋め込みプロパティを True に設定する) を使用します。

警告を取り除くには、代わりに /reference (相互運用機能型の埋め込みプロパティを False に設定) を使用します。この場合、プライマリ相互運用機能アセンブリ (PIA) が相互運用の型情報を提供します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">アセンブリ '{1}' の型 '{0}' には、埋め込み相互運用型のジェネリック型引数があるため、アセンブリ境界を越えて使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">埋め込み相互運用型 '{0}' と一致する相互運用型が見つかりません。アセンブリ参照が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">'{1}' に格納されているモジュール名 '{0}' はファイル名と一致する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">無効なモジュール名: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">'{0}' の値 '{1}' は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath は絶対パスである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">モジュール '{1}' の属性 '{0}' は、ソースに表示されるインスタンスのために無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">インスタンスがソースに表示されるため、属性は無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">ソース ファイルで指定された属性 '{0}' はオプション '{1}' と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">固定バッファーには 1 次元のみを指定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">参照アセンブリ '{0}' には厳密な名前がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">参照されているアセンブリには、厳密な名前がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">無効な署名公開キーが AssemblySignatureKeyAttribute で指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">モジュール '{1}' からエクスポートされた型 '{0}' は、このアセンブリのプライマリ モジュールで宣言した型と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">モジュール '{1}' からエクスポートされた型 '{0}' は、モジュール '{3}' からエクスポートされた型 '{2}' と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">転送された型 '{0}' は、このアセンブリのプライマリ モジュールで宣言した型と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">アセンブリ '{1}' に転送された型 '{0}' は、アセンブリ '{3}' に転送された型 '{2}' と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">アセンブリ '{1}' に転送された型 '{0}' は、モジュール '{3}' からエクスポートされた型 '{2}' と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">参照アセンブリ '{0}' には '{1}' の異なるカルチャ設定があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">参照されているアセンブリのカルチャ設定が異なります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">不明なアセンブリにプロセッサ固有モジュール '{0}' を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">アセンブリとモジュール '{0}' で異なるプロセッサを対象にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">参照アセンブリ '{0}' は、異なるプロセッサをターゲットにしています。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">参照アセンブリが異なるプロセッサを対象にしています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">ハッシュを生成中に暗号化に失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">'{0}' netmodule への参照がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">モジュール '{0}' は既にこのアセンブリに定義されています。各モジュールには一意のファイル名がある必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">構成ファイル '{0}' を読み取れません -- '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">編集に埋め込み型の '{0}' への参照が含まれるため続行できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">現在のデバッグ セッション中に追加されたメンバー '{0}' には、宣言しているアセンブリ '{1}' からのみアクセスできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">コンパイル オプション '{0}' と '{1}' の両方を同時に指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">リンクされた netmodule メタデータには完全な PE イメージ '{0}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred は、/t:exe、/t:winexe、/t:appcontainerexe でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;path list&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;text&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">Null を反映する演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">式のようなメソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">式のようなプロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">式のようなインデクサー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">自動プロパティ初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;namespace&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">byref ローカル変数と返却</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">読み取り専用の参照</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">ref 構造体</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">コンパイル (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">構文ノードが構文ツリー内にありません</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">提供される型の修飾子を最小にするため、場所を提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">型の修飾子を最小にするため、SyntaxTreeSemanticModel を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">コンパイル {1} から '{0}' 型のコンパイルを参照できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">構文ツリーが既に存在しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">送信にはスクリプト コードのみを含めることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">送信に含めることができる構文ツリーは 1 つのみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">ツリーには、SyntaxKind.CompilationUnit を伴うルート ノードがある必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">型引数を null にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">型引数の数が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">名前が名前 {0} と競合しています</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions に無効な組み合わせのオプションがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">アイテム: 空にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier や Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier を使用して、識別子トークンを作成してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal を使用して、文字のリテラル トークンを作成してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal を使用して、数値のリテラル トークンを作成してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">このメソッドは、トークンの作成にのみ使用できます - {0} はトークンの種類ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">ジェネリック パラメーターは、参照 {0} である必要がある場合に定義されます</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">複数の変数宣言子を含んでいる可能性がある宣言ノードに対して GetDeclarationName を呼び出しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">場所が全スパン {0} の構文ツリー内にありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">言語名 '{0}' は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">言語名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">'{1}' のフィールド '{0}' で透過識別子のメンバーのアクセスに失敗しました。クエリされているデータはクエリ パターンを実装しますか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">パラメーターに複数の異なる既定値があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">フィールドに複数の異なる定数値があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">属性 cref 内では、入れ子型のジェネリック型を修飾する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">属性 cref 内では、入れ子型のジェネリック型を修飾する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">C# シンボルではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">using ディレクティブは不要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">extern エイリアスは未使用です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">要素を null にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">LIB 環境変数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">/LIB オプション</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH オプション</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">ディレクトリが存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">パスが長すぎるか、無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">RuntimeMetadataVersion の値が見つかりませんでした。System.Object を含むアセンブリが見つからず、オプションを使用して RuntimeMetadataVersion の値が指定されてもいませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">RuntimeMetadataVersion の値が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">{0} の SemanticModel が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">ラムダ式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 1 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 2 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 3 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 4 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 5 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 6 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 7.0 では使用できません。{1} 以上の言語バージョンをご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'実験的'</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">場所は、構文ツリーのスパン内にある必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">推測される構文ノードは、現在のコンパイルの構文ツリーに属することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">予測セマンティック モデルのチェーンはサポートしていません。非予測 ParentModel から予測モデルを作成する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Microsoft (R) Visual C# Compiler</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} バージョン {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. All rights reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">サポートされる言語バージョン:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'{0}': ComImport 属性を含むクラスにフィールド初期化子を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">ローカル名 '{0}' は PDB に対して長すぎます。短縮するか、/debug なしでコンパイルすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">PDB のローカル名が長すぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">void に変換されデリゲートを返す匿名関数は、値を返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a '{0}' returning delegate cannot return a value</source>
        <target state="translated">デリゲートを返す '{0}' に変換された非同期ラムダ式は値を返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">アナライザー {0} のインスタンスは {1} ({2}) から作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">アナライザーのインスタンスを作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">アセンブリ {0} にアナライザーは含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">アセンブリに、アナライザーが含まれていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">アナライザーのアセンブリ {0} ({1}) を読み込むことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">アナライザーのアセンブリを読み込むことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">ReflectionTypeLoadException ({1}) のため、アナライザー アセンブリ {0} の一部の型をスキップしています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">規則セット ファイル {0} を読み込み中にエラーが発生しました - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">'{0}' のデバッグ情報の読み取りエラー</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">この操作によってスタック オーバーフローが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">識別子または数値リテラルが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">識別子または数値リテラルが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties can have initializers.</source>
        <target state="translated">自動実装プロパティのみが初期化子を持つことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">自動実装プロパティは get アクセサーを持つ必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">自動実装プロパティは、オーバーライドされたプロパティのすべてのアクセサーをオーバーライドする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">明示的なコンストラクターがない構造体には、初期化子を持つメンバーを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">エンコーディングせずにソース テキストのデバッグ情報を作成することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">ブロック本体と式本体を両方とも指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">コントロールは switch の最後の case ラベル ('{0}') から出ることができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">nameof 演算子では型の引数を使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">式ツリーのラムダに null 伝搬演算子を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">式ツリーのラムダに辞書初期化子を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">拡張 Add メソッドは、ラムダ式のコレクション初期化子ではサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">nameof 演算子</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">辞書初期化子</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">{' で始まる挿入式の終了区切り文字 '}' がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">補間された文字列の中で単一行コメントを使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">式が長すぎるか複雑すぎるため、コンパイルできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">式に名前がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">サブ式は nameof への引数に使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">エイリアスで修飾された名前は式ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">型パラメーターは、メソッド グループで 'nameof' への引数として使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">SearchCriteria が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">アセンブリ カルチャ文字列に埋め込み NUL 文字を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">補間された文字列</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">catch ブロックおよび finally ブロックで待機</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">バイナリ リテラル</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">桁区切り記号</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">ローカル関数</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">文字 '{0}' は、補間された文字列内で (二重にすることで) エスケープする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">文字 '{0}' は、補間された文字列内で '{0}{0}' を二重にすることでのみエスケープできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">書式指定子に末尾の空白を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">書式指定子が空です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">参照アセンブリ '{0}' にエラーがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">式または宣言文が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">拡張メソッドのグループは、'nameof' の引数として許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">配置の値 {0} は大きさが {1} を上回り、大型のフォーマットの文字列になる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">extern エイリアスは未使用です</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">using ディレクティブは不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">ReflectionTypeLoadException のために失敗したアナライザーのアセンブリ内の型の読み込みをスキップします</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">配置の値は、大型のフォーマットの文字列になる可能性がある大きさです</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">連結の結果による文字列定数の長さが、System.Int32.MaxValue を超えています。文字列を複数の定数に分割してみてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">タプルには 2 つ以上の要素が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">デバッグ エントリ ポイントは、現在のコンパイルで宣言されたメソッドの定義でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load は、スクリプト内でのみ許可されています</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">ファイルの最初のトークンの後は、#load を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">ファイルが見つかりませんでした。</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">SyntaxTree は #load ディレクティブから発生しているため、直接的に削除または置換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">ソース ファイル参照はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">pathmap オプションが正しく書式設定されていませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">実数値リテラルが正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">自動実装プロパティは参照渡しで返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">参照渡しで返すプロパティは get アクセサーを持たなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">参照渡しで返すプロパティは set アクセサーを持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">'{0}' は、オーバーライドされるメンバー '{1}' の参照渡しの戻り値に一致する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">参照渡しの返却は、参照で返すメソッドでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">値渡しの返却は、値渡しで返すメソッドでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">このメソッドは参照渡しで返すため、return 式の型は '{0}' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">'{0}' はインターフェイス メンバー '{1}' を実装しません。'{2}' は参照渡しで返される対応する値がないため、'{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">'{0}' は参照渡しで返すため、'{0}' の本文を反復子ブロックにすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">参照渡しで返すラムダ式は、式ツリーに変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">式ツリーのラムダには、参照渡しで返すメソッド、プロパティ、インデクサーの呼び出しを含めることができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">参照渡しによって渡したり返したりすることができないため、このコンテキストで使用できない式があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">'{0}' は参照渡しで返せない値に初期化されたため、参照渡しで返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">'{0}' のメンバーは参照渡しで返せない値に初期化されたため、参照渡しで返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">読み取り専用であるため、'{0}' を参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">範囲変数 '{0}' を参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">'{1}' であるため、'{0}' を参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">読み取り専用フィールドを書き込み可能な参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">静的な読み取り専用フィールドを書き込み可能な参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">読み取り専用フィールド '{0}' のメンバーを書き込み可能な参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">静的な読み取り専用フィールド '{0}' のフィールドを書き込み可能な参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref parameter</source>
        <target state="translated">参照 '{0}' は ref パラメーターではないため、パラメーターを返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">ref パラメーターでも out パラメーターでもないため、パラメーター '{0}' のメンバーを参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">ローカル変数 '{0}' は ref ローカル変数ではないため、参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">ローカル変数 '{0}' は ref ローカル変数ではないため、そのメンバーを参照渡しで返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">構造体メンバーは 'this' または他のインスタンス メンバーを参照渡しで返すことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">間接的に変数が宣言のスコープ外に公開される可能性があるため、このコンテキストで式は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があるため、このコンテキストで '{0}' の結果を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があるため、このコンテキストで '{0}' の結果のメンバーを使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">パラメーター '{1}' によって参照される変数が宣言のスコープ外に公開される可能性があるため、'{0}' に対してこの引数の組み合わせは許可されません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ref 条件演算子のブランチでは、互換性のない宣言スコープを持つ変数を参照できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">stackalloc 式の型 '{0}' の結果は、それを含んでいるメソッドの外部に公開される可能性があるため、このコンテキストでは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">参照を使用して値渡し変数を初期化することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">値を使用して参照渡し変数を初期化することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">式は参照渡しで割り当てられるため、型 '{0}' でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">参照渡し変数の宣言には初期化子が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">匿名メソッド、ラムダ式、クエリ式内で ref ローカル変数 '{0}' は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorLocalType">
        <source>Iterators cannot have by-reference locals</source>
        <target state="translated">反復子は参照渡しのローカル変数を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLocalType">
        <source>Async methods cannot have by-reference locals</source>
        <target state="translated">非同期メソッドは参照渡しのローカル変数を持つことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">'{0}' への呼び出しによって返された参照は、'await' または 'yield' 境界を越えて保持することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'await' は、ref 条件演算子を含む式の中で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">条件演算子の両辺の値は、両方とも ref 値にするか、両方とも ref 以外の値にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">式は、代替 ref 値と一致するために、型 '{0}' である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">式ツリーには、ローカル関数への参照が含まれていない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">動的な型の引数をローカル 関数 '{1}' の params パラメーター '{0}' に渡すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">構文ツリーは、送信から作成する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">プログラムで使うユーザー文字列の長さの合計が許可されている制限を超えています。文字列リテラルの使用を減らしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</source>
        <target state="translated">パターンで Null 許容型 '{0}?' を使用することはできません。代わりに基になる型 '{0}' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">出力ファイルの書き込み中にエラーが発生しました: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">タプル要素名は一意である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">タプル要素名 '{0}' は位置 {1} でのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">タプル要素名 '{0}' はいずれの位置でも使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">メンバー '{0}' はアセンブリ '{2}' の型 '{1}' に見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">タプル</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">{1} out パラメーターと void 戻り値の型を持つ、型 '{0}' の適切な分解インスタンスまたは拡張メソッドが見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">分解の代入には、右側の型を持つ式が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">switch 式は値である必要があります。'{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">種類 '{0}' の式は、種類 '{1}' のパターンで処理することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">公開署名が指定されると、属性 '{0}' は無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">公開署名が指定されると、属性は無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">オプション '{0}' は絶対パスにする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">{0} 要素でのタプルを型 '{1}' に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">出力変数の宣言</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">暗黙的に型指定された out 変数 '{0}' への参照は、同じ引数リストでは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">暗黙的に型指定された out 変数 '{0}' の型を推論できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">暗黙的に型指定された分解変数 '{0}' の型を推論できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">暗黙的に型指定された破棄の型を推論できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">'{0}' 要素のタプルを '{1}' 変数に分解することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">動的オブジェクトを分解することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">分解は少なくとも 2 つの変数を含む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">ターゲット型 '{1}' によって異なる名前が指定されている、または名前が何も指定されていないため、タプル要素名 '{0}' は無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">代入先によって異なる名前が指定されているか、名前が何も指定されていないため、タプル要素名は無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">定義済みの型 '{0}' は構造体である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'new' はタプル型では併用できません。代わりに、タプル リテラル式を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">分解 `変数 (...)` フォームは特定の種類の '変数' を許可しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">コンパイラの必須型 '{0}' が見つからないため、タプルを利用するクラスまたはメンバーを定義できません。参照が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">System.Runtime.CompilerServices.TupleElementNamesAttribute' を明示的に参照できません。タプル構文を使用してタプル名を定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">式のツリーは、出力引数の変数宣言を含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">式ツリーに discard を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">式のツリーは、'is' パターン マッチング演算子を含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">式のツリーは、タプル リテラルを含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">式のツリーは、タプル変換を含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">/sourcelink スイッチは、PDB を生成する場合にのみサポートされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">/embed スイッチは、PDB を生成する場合にのみサポートされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">無効なインストルメンテーションの種類: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">左辺値としての構文 'var (...)' は予約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">{ or ; or =&gt; 必要</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">このコンテキストではスロー式は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">宣言はこのコンテキストでは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">foreach ループでは繰り返し変数を宣言する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">分解の左側でタプル要素名は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">負の値をキャストするには、値をかっこで囲んでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">式ツリーにスロー式を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">無効なアセンブリ名: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">型 '{0}' を型 '{1}' の AsyncMethodBuilder として使うには、その Task プロパティが型 '{2}' ではなく型 '{1}' を返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">アセンブリ '{1}' のモジュール '{0}' によって、型 '{2}' が複数のアセンブリ '{3}' および '{4}' に転送されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">パターン内で型 'dynamic' を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">指定されたドキュメント モードがサポートされていないか無効です: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">指定されたソース コードの種類がサポートされていないか無効です: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">指定された言語バージョンがサポートされていないか無効です: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">前処理シンボルの名前が無効です。'{0}' は有効な識別子ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 7.1 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 7.2 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">指定された言語バージョン '{0}' の先頭にゼロを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">型 'void' の値を割り当てることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">'{0}' は、評価の目的でのみ提供されています。将来の更新で変更または削除されることがあります。続行するには、この診断を非表示にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">種類は、評価の目的でのみ提供されています。将来の更新で変更または削除されることがあります。続行するには、この診断を非表示にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">コンパイラ バージョン: '{0}'。言語バージョン: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">async main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">タプル要素名 '{0}' と推測されます。推測される名前で要素にアクセスするには、言語バージョン {1} 以上をお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">タプルに型 'void' の値を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">エントリ ポイントを返す void または int を async にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">種類 '{0}' の式は、C# {2} で種類 '{1}' のパターンによって処理することができません。言語バージョン {3} 以上をお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">ローカル関数 '{0}' は宣言されていますが、一度も使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">ローカル関数は宣言されていますが、一度も使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="translated">ローカル関数 '{0}' は、'static extern' とマークされていないため、本体を宣言しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">メソッド '{0}' (トークン 0x{1:X8}) のデバッグ情報をアセンブリ '{2}' から読み取ることができません</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} は有効な C# 変換式ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">動的な型のある引数は、推定された型の引数のある汎用ローカル関数 '{0}' に渡すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">先頭の桁区切り記号</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">'{0}' は使用しないでください。コンパイラの使用のために予約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">型名 '{0}' は、コンパイラによる使用のために予約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">拡張メソッド '{0}' の最初の 'in' または 'ref readonly' パラメーターは、具象 (非ジェネリック) の値型である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">読み取り専用の構造体のインスタンス フィールドは、読み取り専用である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">読み取り専用の構造体に含まれる自動実装インスタンスのプロパティは、読み取り専用である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">読み取り専用の構造体では、フィールドに類似したイベントを使用することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">ref 拡張メソッド</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">型 '{0}' の stackalloc 式を型 '{1}' に変換することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">ref' 拡張メソッド '{0}' の最初のパラメーターは、値型または構造体に制限されたジェネリック型でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">in パラメーターに Out 属性を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} は有効な C# の複合代入操作ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">フィルター式は定数 'false' です。catch 句の削除を検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">フィルター式は定数 'false' です</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">フィルター式は定数 'false' です。try-catch ブロックの削除を検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">フィルター式は定数 'false' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">__arglist に void 型の引数を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">':' は文字列補間を終了させるため、条件式を文字列補間で直接使用することはできません。条件式をかっこで囲んでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">プロパティでは 'System.Runtime.CompilerServices.FixedBuffer' 属性を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">機能 '{0}' は C# 7.3 では使用できません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">自動プロパティ上でフィールドをターゲットとする属性を使用することは、言語バージョン {0} ではサポートされていません。{1} 以上の言語バージョンをお使いください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">自動プロパティ上でフィールドをターゲットとする属性を使用することは、このバージョンの言語ではサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">非同期ストリーム</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">'{0}': 非同期 using ステートメントで使用される型は、暗黙的に 'System.IAsyncDisposable' に変換可能であるか、適切な 'DisposeAsync' メソッドを実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">非同期 foreach では、戻り値の型 '{1}' の '{0}' に適切なパブリック 'MoveNextAsync' メソッドおよびパブリック 'Current' プロパティが含まれている必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">'{1}' の複数のインスタンスを実装するため、非同期 foreach ステートメントは、型 '{0}' の変数では操作できません。特定のインターフェイスのインスタンス化にキャストしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</source>
        <target state="translated">インターフェイスで宣言された変換演算子、等値演算子、または非等値演算子は abstract または virtual である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">ターゲット ランタイムは、既定のインターフェイスの実装をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">ターゲットのランタイムは既定のインターフェイス実装をサポートしていないため、'{0}' は型 '{2}' のインターフェイス メンバー '{1}' を実装できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</source>
        <target state="translated">'{0}' はインターフェイスメンバー '{1}' を実装しません。'{2}' は、C# {3} でパブリックでないメンバーを暗黙的に実装することはできません。'{4}' 以上の言語バージョンを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">インターフェイス メンバー '{0}' には最も固有な実装がありません。'{1}' と '{2}' のどちらも最も固有なものではありません。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>