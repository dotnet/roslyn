<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CallingConventionTypeIsInvalid">
        <source>Cannot use '{0}' as a calling convention modifier.</source>
        <target state="translated">Невозможно использовать "{0}" в качестве модификатора соглашения о вызовах.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallingConventionTypesRequireUnmanaged">
        <source>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</source>
        <target state="translated">Передача "{0}" недопустима, если "{1}" является "SignatureCallingConvention.Unmanaged".</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">Не удается создать сконструированный универсальный тип из другого сконструированного универсального типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">Не удается создать сконструированный универсальный тип из неуниверсального типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractConversionNotInvolvingContainedType">
        <source>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</source>
        <target state="translated">Определяемое пользователем преобразование в интерфейсе должно выполнять преобразование в параметр типа или из параметра типа для включающего типа, ограниченного включающим типом</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">"{0}": абстрактное событие не может использовать синтаксис метода доступа к событиям.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInIterator">
        <source>The '&amp;' operator cannot be used on parameters or local variables in iterator methods.</source>
        <target state="translated">Оператор "&amp;" нельзя использовать с параметрами или локальными переменными в методах итераторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfMethodGroupInExpressionTree">
        <source>'&amp;' on method groups cannot be used in expression trees</source>
        <target state="translated">"&amp;" в группах методов не может использоваться в деревьях выражений</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfToNonFunctionPointer">
        <source>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</source>
        <target state="translated">Невозможно преобразовать тип группы &amp;методов "{0}" в указатель не на функцию "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AllowsClauseMustBeLast">
        <source>The 'allows' constraint clause must be the last constraint specified</source>
        <target state="translated">Предложение ограничения "allows" должно быть последним указанным ограничением</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">Чтобы применять "@$" вместо "$@" для интерполированной буквальной строки, следует использовать версию языка "{0}" или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</source>
        <target state="translated">Оператор "{0}" для операндов "{1}" и "{2}" является неоднозначным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">Оператор "{0}" не может быть применен к "default" и операнду типа "{1}", так как это параметр типа, который не является ссылочным типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigExtension">
        <source>The extension resolution is ambiguous between the following members: '{0}' and '{1}'</source>
        <target state="new">The extension resolution is ambiguous between the following members: '{0}' and '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver">
        <source>Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.</source>
        <target state="translated">Идентификатор "{0}" является неоднозначным между типом "{1}" и параметром "{2}" в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">При создании объекта невозможно использовать ссылочный тип, допускающий значения NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseRefLike">
        <source>Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Невозможно использовать параметр "{0}" типа ref-like внутри анонимного метода, лямбда-выражения, выражения запроса или локальной функции</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterCaptured">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member</source>
        <target state="translated">Анонимные методы, лямбда-выражения, выражения запроса и локальные функции внутри структуры не могут получить доступ к параметру основного конструктора, также используемому внутри элемента экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterInMember">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter</source>
        <target state="translated">Анонимные методы, лямбда-выражения, выражения запроса и локальные функции внутри элемента экземпляра структуры не могут получить доступ к параметру основного конструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">Имена элементов запрещены при сопоставлении шаблонов с помощью "System.Runtime.CompilerServices.ITuple".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Недопустимо использовать ссылочный тип "{0}", допускающий значения NULL, в выражении "as". Используйте вместо него базовый тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Параметр основного конструктора типа, доступного только для чтения, нельзя использовать в назначении (за исключением метода задания с типом, предназначенным только для инициализации, или инициализатора переменной)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Элементы параметра основного конструктора "{0}" типа, доступного только для чтения, нельзя изменить (за исключением метода задания с типом, предназначенным только для инициализации, или инициализатора переменной)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</source>
        <target state="translated">Значение свойства, задаваемого только при инициализации, или значение индексатора "{0}" может быть присвоено только в инициализаторе объекта, в свойствах "this" или "base" в конструкторе экземпляра или в методе доступа "init".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">Тип "{0}" нельзя использовать в этом контексте, так как он не может быть представлен в метаданных.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrTypeArgCannotBeTypeVar">
        <source>'{0}': an attribute type argument cannot use type parameters</source>
        <target state="translated">"{0}": аргумент типа атрибута не может использовать параметры типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCannotBeAppliedManually">
        <source>'{0}' cannot be applied manually.</source>
        <target state="new">'{0}' cannot be applied manually.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Атрибут "{0}" запрещено использовать в методах доступа к событиям. Он допустим только для объявлений "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesRequireParenthesizedLambdaExpression">
        <source>Attributes on lambda expressions require a parenthesized parameter list.</source>
        <target state="translated">Для атрибутов в лямбда-выражениях требуется указать список параметров в круглых скобках.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">Автоматически реализуемое свойство "{0}" не может быть помечено как readonly, так как имеет метод доступа set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Автоматически реализуемый метод доступа set "{0}" не может быть помечен как readonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</source>
        <target state="translated">Асинхронный оператор foreach не работает с переменными типа "{0}", так как "{0}" не содержит подходящее открытое определение экземпляра или расширения для "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">Асинхронный оператор foreach не работает с переменными типа "{0}", так как "{0}" не содержит открытое определение экземпляра или расширения для "{1}" Возможно, вы имели в виду "foreach", а не "await foreach"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Один из параметров бинарного оператора должен быть содержащего типа, или его параметр типа должен ограничиваться содержащим типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractEqualityOperatorSignature">
        <source>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</source>
        <target state="translated">Один из параметров оператора равенства или неравенства, объявленный в интерфейсе "{0}" должен быть параметром типа "{0}" с ограничением "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecRetType">
        <source>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</source>
        <target state="translated">Возвращаемый тип для оператора + + или-- должен либо совпадать с типом параметра, либо быть производным от типа параметра, либо быть содержащим типом для типа параметра, ограниченного им, кроме случаев, когда параметр типа является параметром другого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Тип параметра оператора ++ или -- должен быть содержащим типом, или параметр его типа должен ограничиваться только этим параметром.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</source>
        <target state="translated">Тип первого операнда перегруженного оператора сдвига должен совпадать с содержащим типом или с ограниченным им параметром типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractStaticMemberAccess">
        <source>A static virtual or abstract interface member can be accessed only on a type parameter.</source>
        <target state="translated">Доступ к статическому виртуальному или абстрактному элементу интерфейса возможен только для параметра типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Параметр унарного оператора должен быть содержащим типом, или параметр его типа должен ограничиваться только этим параметром.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAllowByRefLikeEnumerator">
        <source>foreach statement cannot operate on enumerators of type '{0}' because it is a type parameter that allows ref struct and it is not known at compile time to implement IDisposable.</source>
        <target state="translated">Оператор foreach не может работать с перечислителями типа "{0}", поскольку это параметр типа, который позволяет использовать структуру ref и неизвестен во время компиляции для реализации IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRefLangVersion">
        <source>Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.</source>
        <target state="translated">Аргумент {0} не может передаваться с ключевым словом "ref" в языке версии {1}. Чтобы передать аргументы "ref" в параметры "in", повысьте статус до языка версии {2} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryReadOnlySpanConcatenation">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</source>
        <target state="translated">Невозможно применить оператор "{0}" к операндам типа "{1}" и "{2}", которые не являются байтовыми представлениями UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
        <source>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</source>
        <target state="translated">Класс CallerArgumentExpressionAttribute можно применять только к параметрам со значениями по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCaseInSwitchArm">
        <source>A switch expression arm does not begin with a 'case' keyword.</source>
        <target state="translated">ARM выражения переключателя не начинается с ключевого слова "case".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompoundAssignmentOpArgs">
        <source>Overloaded compound assignment operator '{0}' takes one parameter</source>
        <target state="new">Overloaded compound assignment operator '{0}' takes one parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">Не удается использовать коллекцию динамического типа в асинхронном операторе foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the extended type.</source>
        <target state="new">One of the parameters of a binary operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionContainingType">
        <source>Extensions must be declared in a top-level, non-generic, static class</source>
        <target state="new">Extensions must be declared in a top-level, non-generic, static class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the extended type.</source>
        <target state="new">The parameter type for ++ or -- operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the extended type</source>
        <target state="new">The first operand of an overloaded shift operator must have the same type as the extended type</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the extended type.</source>
        <target state="new">The parameter of a unary operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFieldTypeInRecord">
        <source>The type '{0}' may not be used for a field of a record.</source>
        <target state="translated">Тип "{0}" не может быть использован для поля записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerArgCount">
        <source>Function pointer '{0}' does not take {1} arguments</source>
        <target state="translated">Указатель на функцию "{0}" не принимает следующее число аргументов: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerParamModifier">
        <source>'{0}' cannot be used as a modifier on a function pointer parameter.</source>
        <target state="translated">"{0}" не может использоваться в качестве модификатора для параметра указателя на функцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInheritanceFromRecord">
        <source>Only records may inherit from records.</source>
        <target state="translated">Наследоваться от записей могут только записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInitAccessor">
        <source>The 'init' accessor is not valid on static members</source>
        <target state="translated">Метод доступа "init" не может использоваться для статических элементов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonVirtualInterfaceMemberAccessOnAllowsRefLike">
        <source>A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.</source>
        <target state="translated">Доступ к невиртуальному элементу интерфейса экземпляра невозможен для параметра типа, допускающего структуру ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">Недопустимый параметр "{0}" для /nullable. Допустимые значения: "disable", "enable", "warnings" или "annotations"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableReferenceTypeInUsingAlias">
        <source>Using alias cannot be a nullable reference type.</source>
        <target state="translated">Параметр использования псевдонима не может быть ссылочным типом, допускающим значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">Оператор typeof невозможно использовать для ссылочного типа, допускающего значения NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefaultOrNew">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">Оператор "{0}" невозможно применить к операнду "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">Недопустимый операнд для сопоставления с шаблоном. Требуется значение, но найдено "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordBase">
        <source>Records may only inherit from object or another record</source>
        <target state="translated">Записи могут наследоваться только от объекта или другой записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordMemberForPositionalParameter">
        <source>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</source>
        <target state="translated">Элемент записи "{0}" должен быть доступным для чтения свойством экземпляра или полем типа "{1}", чтобы соответствовать позиционному параметру "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefParameter">
        <source>Parameters of type '{0}' cannot be declared in async methods or async lambda expressions.</source>
        <target state="translated">Параметры типа "{0}" не могут быть объявлены в асинхронных методах или асинхронных лямбда-выражениях.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefInUsingAlias">
        <source>Using alias cannot be a 'ref' type.</source>
        <target state="translated">Параметр использования псевдонима не может быть типом "ref".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpreadInCatchFilter">
        <source>Cannot use '..' spread operator in the filter expression of a catch clause</source>
        <target state="new">Cannot use '..' spread operator in the filter expression of a catch clause</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticAfterUnsafe">
        <source>'static' modifier must precede 'unsafe' modifier.</source>
        <target state="translated">Модификатор "static" должен предшествовать модификатору "unsafe".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">Ошибка в синтаксисе командной строки: "{0}" не является допустимым значением для параметра "{1}". Значение должно иметь форму "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnsafeInUsingDirective">
        <source>Only a 'using static' or 'using alias' can be 'unsafe'.</source>
        <target state="translated">Только параметр "using static" или "using alias" может иметь значение "unsafe".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingStaticType">
        <source>'{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.</source>
        <target state="translated">' {0} ' недопустим для 'использования статики'. Можно использовать только класс, структуру, интерфейс, перечисление, делегат или пространство имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseType">
        <source>Inconsistent accessibility: type '{1}' is less accessible than class '{0}' </source>
        <target state="new">Inconsistent accessibility: type '{1}' is less accessible than class '{0}' </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInUnsafe">
        <source>Cannot use 'yield return' in an 'unsafe' block</source>
        <target state="translated">Невозможно использовать "yield return" в блоке "unsafe".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BuilderAttributeDisallowed">
        <source>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</source>
        <target state="translated">Атрибут AsyncMethodBuilder запрещен для анонимных методов без явного типа возвращаемого значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToMember">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on this member.</source>
        <target state="translated">Невозможно использовать "OverloadResolutionPriorityAttribute" с этим членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToOverride">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.</source>
        <target state="translated">Невозможно использовать "OverloadResolutionPriorityAttribute" с переопределяемым членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeConvertedToUtf8">
        <source>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</source>
        <target state="translated">Невозможно преобразовать входную строку в эквивалентное байтовое представление UTF-8.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">"{0}" не может быть стать параметром, допускающим NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotClone">
        <source>The receiver type '{0}' is not a valid record type and is not a struct type.</source>
        <target state="translated">Тип получателя "{0}" не является допустимым типом записи и не является типом структуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertAddressOfToDelegate">
        <source>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</source>
        <target state="translated">Невозможно преобразовать &amp;группу методов "{0}" в тип делегата "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDynamicInvokeOnExpression">
        <source>Cannot perform a dynamic invocation on an expression with type '{0}'.</source>
        <target state="translated">Не удается выполнить динамический вызов для выражения с типом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferDelegateType">
        <source>The delegate type could not be inferred.</source>
        <target state="translated">Не удалось вывести тип делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotMatchOnINumberBase">
        <source>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specific numeric type.</source>
        <target state="needs-review-translation">Невозможно использовать числовую константу или реляционный шаблон для "{0}", поскольку он наследует от "INumberBase&lt;T&gt;" или расширяет его. Рассмотрите возможность использовать шаблон типа, чтобы указать конкретный числовой тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
        <source>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</source>
        <target state="translated">Соглашение о вызовах "managed" невозможно использовать вместе с спецификаторами неуправляемых соглашений о вызовах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseFunctionPointerAsFixedLocal">
        <source>The type of a local declared in a fixed statement cannot be a function pointer type.</source>
        <target state="translated">Локальная переменная, объявленная в операторе fixed, не может быть указателем на функцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
        <source>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Невозможно использовать "{0}" как тип {1} для метода с атрибутом "UnmanagedCallersOnly".</target>
        <note>1 is the localized word for 'parameter' or 'return'. UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_CannotUseReducedExtensionMethodInAddressOf">
        <source>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</source>
        <target state="translated">Невозможно использовать метод расширения с приемником в качестве целевого объекта оператора "&amp;".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseRefInUnmanagedCallersOnly">
        <source>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Нельзя использовать "ref", "in" или "out" в сигнатуре метода с атрибутом "UnmanagedCallersOnly".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
        <source>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</source>
        <target state="translated">Аргументы InterpolatedStringHandlerArgumentAttribute не могут ссылаться на параметр, в котором используется атрибут.</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_CantChangeInitOnlyOnOverride">
        <source>'{0}' must match by init-only of overridden member '{1}'</source>
        <target state="translated">"{0}" и переопределяемый элемент "{1}" должны соответствовать по методу доступа, вызываемому только во время инициализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturnType">
        <source>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</source>
        <target state="translated">Невозможно преобразовать {0} в тип "{1}", поскольку возвращаемый тип не совпадает с возвращаемым типом делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">В __arglist невозможно передать аргумент с помощью in или out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
        <source>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</source>
        <target state="translated">Этот конструктор должен добавлять "SetsRequiredMembers", поскольку он связан с конструктором с этим атрибутом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOperatorNeedsMatch">
        <source>The operator '{0}' requires a matching non-checked version of the operator to also be defined</source>
        <target state="translated">Для оператора "{0}" требуется, чтобы была определена соответствующая непроверенная версия этого оператора</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassIsCombinedWithRefStruct">
        <source>Cannot allow ref structs for a type parameter known from other constraints to be a class</source>
        <target state="translated">Невозможно разрешить использование ссылочных структур для параметра типа, известного из других ограничений как класс.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloneDisallowedInRecord">
        <source>Members named 'Clone' are disallowed in records.</source>
        <target state="translated">Элементы с именем "Clone" не могут использоваться в записях.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotStatic">
        <source>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</source>
        <target state="translated">"{0}" не реализует элемент статический элемент интерфейса "{1}". "{2}" не может реализовать этот элемент интерфейса, поскольку он является статическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberOperatorMismatch">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because one of them is not an operator.</source>
        <target state="new">'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because one of them is not an operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</source>
        <target state="translated">"{0}" не реализует элемент интерфейса "{1}". "{2}" не может реализовывать "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidMethodName">
        <source>The CollectionBuilderAttribute method name is invalid.</source>
        <target state="translated">Недопустимое имя метода CollectionBuilderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidType">
        <source>The CollectionBuilderAttribute builder type must be a non-generic class or struct.</source>
        <target state="translated">Тип построителя CollectionBuilderAttribute должен быть неуниверсальным классом или структурой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeMethodNotFound">
        <source>Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan&lt;{1}&gt;' and return type '{2}'.</source>
        <target state="translated">Не удалось найти доступный метод "{0}" с ожидаемой подписью: статический метод с одним параметром типа "ReadOnlySpan&lt;{1}&gt;" и типом возвращаемого значения "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderNoElementType">
        <source>'{0}' has a CollectionBuilderAttribute but no element type.</source>
        <target state="translated">"{0}" содержит CollectionBuilderAttribute, но не имеет типа элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionEscape">
        <source>A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</source>
        <target state="translated">Выражение коллекции типа "{0}" нельзя использовать в этом контексте, так как он может быть доступен вне текущей области.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionImmutableArray">
        <source>This version of '{0}' cannot be used with collection expressions.</source>
        <target state="translated">Невозможно использовать эту версию "{0}" с выражениями коллекций.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingAdd">
        <source>Collection expression type '{0}' must have an instance or extension method 'Add' that can be called with a single argument.</source>
        <target state="translated">Тип выражения коллекции "{0}" должен иметь экземпляр или метод расширения "Add", который можно вызвать с помощью одного аргумента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingConstructor">
        <source>Collection expression type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Тип выражения коллекции должен иметь применимый конструктор, который может быть вызван без аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionNoTargetType">
        <source>There is no target type for the collection expression.</source>
        <target state="translated">Отсутствует тип целевого объекта для выражения коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetNoElementType">
        <source>Collection expression target '{0}' has no element type.</source>
        <target state="translated">У целевого объекта выражения "{0}" нет типа элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetTypeNotConstructible">
        <source>Cannot initialize type '{0}' with a collection expression because the type is not constructible.</source>
        <target state="translated">Не удается инициализировать тип "{0}" с выражением коллекции, так как тип не является конструируемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitializerInfiniteChainOfAddCalls">
        <source>Collection initializer results in an infinite chain of instantiations of collection '{0}'.</source>
        <target state="translated">Инициализатор коллекции приводит к созданию бесконечной цепочки экземпляров коллекции "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Параметр типа "{1}" имеет ограничение "unmanaged", поэтому "{1}" не может использоваться в качестве ограничения для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="translated">Локальная функция "{0}" должна быть "static", чтобы использовать атрибут Conditional</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">Выражение типа "{0}" не может быть обработано шаблоном типа "{1}". Используйте версию языка "{2}" или более позднюю, чтобы сопоставить открытый тип с постоянным шаблоном.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantValueOfTypeExpected">
        <source>A constant value of type '{0}' is expected</source>
        <target state="translated">Ожидается значение константы типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorMustInvokeBaseCopyConstructor">
        <source>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</source>
        <target state="translated">Конструктор копий в записи должен вызвать конструктор копий базового класса или конструктор объекта без параметров, если запись наследуется от объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorWrongAccessibility">
        <source>A copy constructor '{0}' must be public or protected because the record is not sealed.</source>
        <target state="translated">Конструктор копий "{0}" должен быть открытым или защищенным, так как запись не запечатана.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DataSectionStringLiteralHashCollision">
        <source>Cannot emit this string literal into the data section because it has XXHash128 collision with another string literal: {0}</source>
        <target state="new">Cannot emit this string literal into the data section because it has XXHash128 collision with another string literal: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">Имя "{0}" не соответствует указанному параметру "Deconstruct" "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructVariableCannotBeByRef">
        <source>A deconstruction variable cannot be declared as a ref local</source>
        <target state="translated">Переменная деконструирования не может быть объявлена как локальная переменная ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultConstraintOverrideOnly">
        <source>The 'default' constraint is valid on override and explicit interface implementation methods only.</source>
        <target state="translated">Ограничение "default" допустимо только для переопределенных и явных методов реализации интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Не удается внедрить тип "{0}", так как он имеет неабстрактный член. Попробуйте задать для свойства "Внедрить типы взаимодействия" значение false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">Отсутствует целевой тип для литерала по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">Литерал по умолчанию "default" недопустимо использовать в качестве шаблона. Используйте другой литерал (например, "0" или "null") по мере необходимости. Чтобы задать полное совпадение, используйте шаблон отмены "_".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeneathPatternCombinator">
        <source>A variable may not be declared within a 'not' or 'or' pattern.</source>
        <target state="translated">Переменная не может быть объявлена в шаблоне "not" или "or".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">Шаблон отмены запрещено использовать как метку case в операторе switch. Используйте "case var _:" в качестве шаблона отмены или "case @_:" в качестве константы "_".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseEqualityContract">
        <source>'{0}' does not override expected property from '{1}'.</source>
        <target state="translated">"{0}" не переопределяет ожидаемое свойство из "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseMethod">
        <source>'{0}' does not override expected method from '{1}'.</source>
        <target state="translated">"{0}" не переопределяет ожидаемый метод из "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideMethodFromObject">
        <source>'{0}' does not override expected method from 'object'.</source>
        <target state="translated">"{0}" не переопределяет ожидаемый метод из "object".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupReturnTypeMod">
        <source>A return type can only have one '{0}' modifier.</source>
        <target state="translated">Тип возвращаемого значения может иметь только один модификатор "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">"{0}" явно реализуется больше одного раза.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterceptor">
        <source>The indicated call is intercepted multiple times.</source>
        <target state="translated">Указанный вызов перехватывается несколько раз.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithDifferencesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</source>
        <target state="translated">"{0}" уже указан в списке интерфейсов в типе "{2}" в виде "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">Оператор подавления повторяющихся значений NULL ("!")</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">Запрещено указывать модификаторы readonly для обоих методов доступа свойства или индексатора "{0}". Вместо этого укажите модификатор readonly для самого свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicDispatchToParamsCollection">
        <source>'{0}' is applicable only with expanded form of non-array params collection which is not supported during dynamic dispatch.</source>
        <target state="translated">"{0}" применимо только с расширенной формой коллекции параметров, не являющейся массивом, которая не поддерживается во время динамической отправки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">"else" не может запускать оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingSymbol">
        <source>Cannot emit update; {0} '{1}' is missing.</source>
        <target state="translated">Не удается создать обновление;  {0} '{1}' отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EntryPointCannotBeUnmanagedCallersOnly">
        <source>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Точки входа приложения не могут иметь атрибут "UnmanagedCallersOnly".</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_EqualityContractRequiresGetter">
        <source>Record equality contract property '{0}' must have a get accessor.</source>
        <target state="translated">Свойство контракта на равенство записей "{0}" должно иметь метод доступа get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeVariable">
        <source>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Невозможно использовать переменную "{0}" в этом контексте, поскольку при этом могут быть раскрыты доступные по ссылке переменные вне их области объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInterpolatedString">
        <source>Expected interpolated string</source>
        <target state="translated">Ожидается интерполированная строка</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplementationOfOperatorsMustBeStatic">
        <source>Explicit implementation of a user-defined operator '{0}' must be declared static</source>
        <target state="translated">Явная реализация определяемого пользователем оператора "{0}" должна быть объявлена статической</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceMemberReturnTypeMismatch">
        <source>'{0}': return type must be '{1}' to match implemented member '{2}'</source>
        <target state="new">'{0}': return type must be '{1}' to match implemented member '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceMemberTypeMismatch">
        <source>'{0}': type must be '{1}' to match implemented member '{2}'</source>
        <target state="new">'{0}': type must be '{1}' to match implemented member '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">Явное применение атрибута "System.Runtime.CompilerServices.NullableAttribute" не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArrayOrCollection">
        <source>Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">Не используйте System.ParamArrayAttribute/System.Runtime.CompilerServices.ParamCollectionAttribute. Используйте ключевое слово "params".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMismatchInitOnly">
        <source>Accessors '{0}' and '{1}' should both be init-only or neither</source>
        <target state="translated">Каждый из методов доступа "{0}" и "{1}" должен вызываться только во время инициализации либо ни один из этих методов доступа не должен вызываться таким образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitRequiredMember">
        <source>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</source>
        <target state="translated">Не используйте "System.Runtime.CompilerServices.RequiredMemberAttribute". Вместо этого используйте ключевое слово "required" для обязательных полей и свойств.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitScopedRef">
        <source>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</source>
        <target state="translated">Не используйте "System.Runtime.CompilerServices.ScopedRefAttribute". Вместо этого используйте ключевое слово "scoped".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">Заданное выражение невозможно использовать в операторе fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">Дерево выражений не может содержать назначение объединения со значением NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">Дерево выражений не может содержать значение ref struct или ограниченный тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
        <source>An expression tree may not contain an access of static virtual or abstract interface member</source>
        <target state="translated">Дерево выражения не может содержать доступ к статическому виртуальному или абстрактному элементу интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsCollectionExpression">
        <source>An expression tree may not contain a collection expression.</source>
        <target state="translated">Дерево выражения не может содержать выражение коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsExtensionBasedConditionalLogicalOperator">
        <source>An expression tree may not contain '&amp;&amp;' or '||' operators that use extension user defined operators.</source>
        <target state="new">An expression tree may not contain '&amp;&amp;' or '||' operators that use extension user defined operators.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsExtensionPropertyAccess">
        <source>An expression tree may not contain an extension property access</source>
        <target state="new">An expression tree may not contain an extension property access</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="translated">Дерево выражений не может содержать выражение индекса, отсчитываемого с конца ("^").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInlineArrayOperation">
        <source>An expression tree may not contain an inline array access or conversion</source>
        <target state="translated">Дерево выражения не может содержать встроенный доступ к массиву или преобразование</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
        <source>An expression tree may not contain an interpolated string handler conversion.</source>
        <target state="translated">Дерево выражения не может содержать преобразование обработчика интерполированных строк.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgumentOutOfPosition">
        <source>An expression tree may not contain a named argument specification out of position</source>
        <target state="new">An expression tree may not contain a named argument specification out of position</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternImplicitIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="translated">Дерево выражения не может содержать доступ к индексатору System.Index или System.Range шаблона.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="translated">Дерево выражений не может содержать выражение диапазона ("..").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">Дерево выражений не может содержать выражение switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">Дерево выражений не может содержать оператор == или != кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsWithExpression">
        <source>An expression tree may not contain a with-expression.</source>
        <target state="translated">Дерево выражения не может содержать выражение with.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionBlockCollision">
        <source>This extension block collides with another extension block. They result in conflicting content-based type names in metadata, so must be in separate enclosing static classes.</source>
        <target state="new">This extension block collides with another extension block. They result in conflicting content-based type names in metadata, so must be in separate enclosing static classes.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionDisallowsMember">
        <source>This member is not allowed in an extension block</source>
        <target state="new">This member is not allowed in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionDisallowsName">
        <source>Extension declarations may not have a name.</source>
        <target state="new">Extension declarations may not have a name.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionParameterDisallowsDefaultValue">
        <source>The receiver parameter of an extension cannot have a default value</source>
        <target state="new">The receiver parameter of an extension cannot have a default value</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionResolutionFailed">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension member '{1}' for receiver of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="new">'{0}' does not contain a definition for '{1}' and no accessible extension member '{1}' for receiver of type '{0}' could be found (are you missing a using directive or an assembly reference?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionTypeNameDisallowed">
        <source>Types and aliases cannot be named 'extension'.</source>
        <target state="new">Types and aliases cannot be named 'extension'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">"{0}": внешнее событие не может иметь инициализатор</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">Функция "{0}" сейчас находится на этапе предварительной версии и *является неподдерживаемой*. Для работы с предварительными версиями функций используйте версию языка "preview".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">Функция "{0}" является экспериментальной и не поддерживается; используйте "/features:{1}" для включения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion10">
        <source>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 10.0. Используйте версию языка {1} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion11">
        <source>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 11.0. Используйте язык версии {1} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion12">
        <source>Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 12.0. Используйте язык версии {1} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion13">
        <source>Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 13.0. Используйте язык версии {1} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion14">
        <source>Feature '{0}' is not available in C# 14.0. Please use language version {1} or greater.</source>
        <target state="new">Feature '{0}' is not available in C# 14.0. Please use language version {1} or greater.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 8.0. Используйте версию языка {1} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion9">
        <source>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</source>
        <target state="translated">Функция "{0}" недоступна в C# 9.0. Используйте как минимум версию языка {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">Подобное полю событие "{0}" не может быть readonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileLocalDuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}' in this file.</source>
        <target state="translated">Пространство имен "{1}" уже содержит определение для "{0}" в этом файле.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FilePathCannotBeConvertedToUtf8">
        <source>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</source>
        <target state="translated">Невозможно использовать локальный для файла тип "{0}", так как путь к содержащему файлу не может быть преобразован в эквивалентное байтовое представление UTF-8. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedAndNormalNamespace">
        <source>Source file can not contain both file-scoped and normal namespace declarations.</source>
        <target state="translated">Исходный файл не может содержать объявления пространства имен с файловой областью и объявления обычных пространств имен одновременно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedNamespaceNotBeforeAllMembers">
        <source>File-scoped namespace must precede all other members in a file.</source>
        <target state="translated">Пространство имен с файловой областью должно быть раньше всех остальных элементов в файле.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeBase">
        <source>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</source>
        <target state="translated">Невозможно использовать локальный для файла тип "{0}" в качестве базового типа для нелокального типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeDisallowedInSignature">
        <source>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</source>
        <target state="translated">Невозможно использовать локальный для файла тип "{0}" в подписи элемента нелокального типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNameDisallowed">
        <source>Types and aliases cannot be named 'file'.</source>
        <target state="translated">У типов и псевдонимов не может быть имя "file".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNested">
        <source>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</source>
        <target state="translated">Локальный для файла тип "{0}" должен быть определен в типе верхнего уровня. "{0}" является вложенным типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNoExplicitAccessibility">
        <source>File-local type '{0}' cannot use accessibility modifiers.</source>
        <target state="translated">Локальный для файла тип "{0}" не может использовать модификаторы специальных возможностей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNonUniquePath">
        <source>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</source>
        <target state="translated">Локальный для файла тип "{0}" должен быть объявлен в файле с уникальным путем. Путь "{1}" используется в нескольких файлах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedFieldMustNotBeRef">
        <source>A fixed field must not be a ref field.</source>
        <target state="translated">Фиксированное поле не должно быть полем ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">Оператор foreach не работает с переменными типа "{0}", так как "{0}" не содержит открытое определение экземпляра или расширения для "{1}" Возможно, вы имели в виду "await foreach", а не "foreach"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrMethMustBeStatic">
        <source>Cannot create a function pointer for '{0}' because it is not a static method</source>
        <target state="translated">Не удается создать указатель на функцию для "{0}", поскольку эта функция не является статическим методом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrRefMismatch">
        <source>Ref mismatch between '{0}' and function pointer '{1}'</source>
        <target state="translated">Несоответствие ссылок между "{0}" и указателем на функцию "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointerTypesInAttributeNotSupported">
        <source>Using a function pointer type in this context is not supported.</source>
        <target state="translated">Использование типа указателя функции в этом контексте не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointersCannotBeCalledWithNamedArguments">
        <source>A function pointer cannot be called with named arguments.</source>
        <target state="translated">Невозможно вызвать указатель на функцию с именованными аргументами.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
        <source>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</source>
        <target state="translated">Невозможно использовать интерфейс "{0}" в качестве аргумента типа. У статического члена "{1}" нет наиболее конкретной реализации в интерфейсе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingInNamespace">
        <source>A global using directive cannot be used in a namespace declaration.</source>
        <target state="translated">Глобальную директиву using нельзя использовать в объявлении пространства имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingOutOfOrder">
        <source>A global using directive must precede all non-global using directives.</source>
        <target state="translated">Глобальная директива using должна предшествовать всем неглобальным директивам using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingStaticFileType">
        <source>File-local type '{0}' cannot be used in a 'global using static' directive.</source>
        <target state="translated">Невозможно использовать локальный для файла тип "{0}" в директиве "global using static".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">Оператор goto не может переходить к расположению раньше объявления using в том же блоке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">Оператор goto не может переходить к расположению после объявления using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HiddenPositionalMember">
        <source>The positional member '{0}' found corresponding to this parameter is hidden.</source>
        <target state="translated">Обнаруженный позиционный элемент "{0}", соответствующий этому параметру, скрыт.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAtSequence">
        <source>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</source>
        <target state="translated">Последовательность символов \"@\" не разрешена. Буквальная строка или идентификатор может содержать только один символ \"@\", а необработанная строка не может содержать их вообще.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">Оператор подавления недопустим в данном контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitConversionOperatorCantBeChecked">
        <source>An 'implicit' user-defined conversion operator cannot be declared checked</source>
        <target state="translated">Невозможно объявить определяемый пользователем оператор преобразования с параметром "implicit" как проверенный</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}". "{2}" не может неявно реализовать недоступный член.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">Вызов неявного индексатора для индекса не может присвоить аргументу имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationIllegalTargetType">
        <source>The type '{0}' may not be used as the target type of new()</source>
        <target state="translated">Тип "{0}" не может использоваться в качестве типа целевого объекта для new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNoTargetType">
        <source>There is no target type for '{0}'</source>
        <target state="translated">Отсутствует целевой тип для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNotValid">
        <source>Use of new() is not valid in this context</source>
        <target state="translated">Использование new() в этом контексте не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">Вызов неявного индексатора для диапазона не может присвоить аргументу имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedDefaultParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have a default value.</source>
        <target state="translated">Неявно типизованный параметр "{0}" не может иметь значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedParamsParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have the 'params' modifier.</source>
        <target state="new">Implicitly typed lambda parameter '{0}' cannot have the 'params' modifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableUsedInForbiddenZone">
        <source>Reference to an implicitly-typed variable '{0}' is not permitted in this location.</source>
        <target state="new">Reference to an implicitly-typed variable '{0}' is not permitted in this location.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">Аргументы с модификатором "in" невозможно использовать в динамически диспетчеризируемых выражениях.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionParameterMustBeValueType">
        <source>The 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.</source>
        <target state="new">The 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritingFromRecordWithSealedToString">
        <source>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</source>
        <target state="translated">Наследование от записи с запечатанным Object. ToString не поддерживается в C# {0}. Используйте версию языка "{1}" или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitCannotBeReadonly">
        <source>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</source>
        <target state="translated">Методы доступа "init" не могут быть помечены как доступные только для чтения. Вместо них пометьте "{0}" как доступные только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitInExtension">
        <source>'{0}': cannot declare init-only accessors in an extension block</source>
        <target state="new">'{0}': cannot declare init-only accessors in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayAttributeOnRecord">
        <source>Attribute 'System.Runtime.CompilerServices.InlineArray' cannot be applied to a record struct.</source>
        <target state="translated">Невозможно применить атрибут "System.Runtime.CompilerServices.InlineArray" к структуре записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayBadIndex">
        <source>Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.</source>
        <target state="translated">К элементам типа встроенного массива можно получить доступ только с одним аргументом, неявно преобразуемым в «int», «System.Index» или «System.Range».</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToReadOnlySpanNotSupported">
        <source>Cannot convert expression to '{0}' because it may not be passed or returned by reference</source>
        <target state="translated">Невозможно преобразовать выражение в ' {0} ', так как оно не может быть передано или возвращено по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToSpanNotSupported">
        <source>Cannot convert expression to '{0}' because it is not an assignable variable</source>
        <target state="translated">Невозможно преобразовать выражение в ' {0} ', так как это не присваиваемая переменная</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayForEachNotSupported">
        <source>foreach statement on an inline array of type '{0}' is not supported</source>
        <target state="translated">Оператор foreach во встроенном массиве типа "{0}" не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayIndexOutOfRange">
        <source>Index is outside the bounds of the inline array</source>
        <target state="translated">Индекс находится за пределами встроенного массива</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayUnsupportedElementFieldModifier">
        <source>Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.</source>
        <target state="translated">Поле элемента встроенного массива нельзя объявить как обязательное, доступное только для чтения, переменное или как буфер фиксированного размера.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberWithUnnamedExtensionsParameter">
        <source>'{0}': cannot declare instance members in an extension block with an unnamed receiver parameter</source>
        <target state="new">'{0}': cannot declare instance members in an extension block with an unnamed receiver parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceOperatorExtensionWrongReceiverType">
        <source>Cannot declare instance extension operator for a type that is not known to be a struct and is not known to be a class</source>
        <target state="new">Cannot declare instance extension operator for a type that is not known to be a struct and is not known to be a class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceOperatorStructExtensionWrongReceiverRefKind">
        <source>Cannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter</source>
        <target state="new">Cannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstancePropertyInitializerInInterface">
        <source>Instance properties in interfaces cannot have initializers.</source>
        <target state="translated">Свойства экземпляра в интерфейсах не могут иметь инициализаторы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptableMethodMustBeOrdinary">
        <source>Cannot intercept '{0}' because it is not an invocation of an ordinary member method.</source>
        <target state="translated">Невозможно перехватить "{0}", так как это не вызов обычного метода элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorArityNotCompatible">
        <source>Method '{0}' must be non-generic or have arity {1} to match '{2}'.</source>
        <target state="translated">Метод "{0}" должен быть неуниверсальным или иметь арность {1} для соответствия "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotBeGeneric">
        <source>Method '{0}' must be non-generic to match '{1}'.</source>
        <target state="translated">Метод "{0}" должен быть неуниверсальным, чтобы соответствовать "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotInterceptNameof">
        <source>A nameof operator cannot be intercepted.</source>
        <target state="translated">Имя оператора не может быть перехвачено.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotUseUnmanagedCallersOnly">
        <source>An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.</source>
        <target state="translated">Перехватчик не может быть помечен атрибутом UnmanagedCallersOnlyAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCharacterOutOfRange">
        <source>The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.</source>
        <target state="translated">Данная строка имеет длину ' {0} ' символов, что меньше предоставленного количества символов ' {1} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorContainingTypeCannotBeGeneric">
        <source>Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</source>
        <target state="translated">Метод "{0}" нельзя использовать в качестве перехватчика, так как его содержащий тип имеет параметры типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorFilePathCannotBeNull">
        <source>Interceptor cannot have a 'null' file path.</source>
        <target state="translated">Перехватчик не может иметь «нулевой» путь к файлу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorGlobalNamespace">
        <source>An interceptor cannot be declared in the global namespace.</source>
        <target state="translated">Перехватчик невозможно объявить в глобальном пространстве имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineCharacterMustBePositive">
        <source>Line and character numbers provided to InterceptsLocationAttribute must be positive.</source>
        <target state="translated">Номера строк и символов, предоставляемые InterceptsLocationAttribute, должны быть положительными.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineOutOfRange">
        <source>The given file has '{0}' lines, which is fewer than the provided line number '{1}'.</source>
        <target state="translated">В данном файле есть строки ' {0} ', что меньше предоставленного номера строки ' {1} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMethodMustBeOrdinary">
        <source>An interceptor method must be an ordinary member method.</source>
        <target state="translated">Метод-перехватчик должен быть обычным методом-элементом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustHaveMatchingThisParameter">
        <source>Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.</source>
        <target state="translated">Перехватчик должен иметь параметр this, соответствующий параметру ' {0} ' на ' {1} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustNotHaveThisParameter">
        <source>Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.</source>
        <target state="translated">У перехватчика не должно быть параметра this, потому что у {0} нет параметра this.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustReferToStartOfTokenPosition">
        <source>The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?</source>
        <target state="translated">Предоставленный номер строки и символа не относится к началу токена ' {0} '. Вы хотели использовать строку ' {1} ' и символ ' {2} '?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNameNotInvoked">
        <source>Possible method name '{0}' cannot be intercepted because it is not being invoked.</source>
        <target state="translated">Возможное имя метода " {0} " не может быть перехвачено, так как он не вызывается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNonUniquePath">
        <source>Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.</source>
        <target state="translated">Невозможно перехватить вызов в файле с путем ' {0} ', так как несколько файлов в компиляции имеют этот путь.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNotAccessible">
        <source>Cannot intercept call with '{0}' because it is not accessible within '{1}'.</source>
        <target state="translated">Невозможно перехватить вызов с ' {0} ', так как он недоступен внутри ' {1} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilation">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'.</source>
        <target state="translated">Невозможно перехватить: компиляция не содержит файла с путем ' {0} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithCandidate">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?</source>
        <target state="translated">Невозможно перехватить: компиляция не содержит файла с путем ' {0} '. Вы хотели использовать путь ' {1} '?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPositionBadToken">
        <source>The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.</source>
        <target state="translated">Предоставленная строка и номер символа относятся не к имени перехватываемого метода, а скорее к токену ' {0} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorScopedMismatch">
        <source>Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.</source>
        <target state="translated">Не удается перехватить вызов ' {0} ' с ' {1} ' из-за разницы в модификаторах 'scoped' или атрибутах '[UnscopedRef]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorSignatureMismatch">
        <source>Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.</source>
        <target state="translated">Невозможно перехватить метод " {0} " с перехватчиком " {1} ", поскольку подписи не совпадают.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorsFeatureNotEnabled">
        <source>The 'interceptors' feature is not enabled in this namespace. Add '{0}' to your project.</source>
        <target state="translated">Функция "interceptors" не включена в этом пространстве имен. Добавьте "{0}" в свой проект.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidFormat">
        <source>The data argument to InterceptsLocationAttribute is not in the correct format.</source>
        <target state="translated">Аргумент данных InterceptsLocationAttribute имеет неправильный формат.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidPosition">
        <source>The data argument to InterceptsLocationAttribute refers to an invalid position in file '{0}'.</source>
        <target state="translated">Аргумент данных InterceptsLocationAttribute ссылается на недопустимую позицию в файле "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDuplicateFile">
        <source>Cannot intercept a call in file '{0}' because it is duplicated elsewhere in the compilation.</source>
        <target state="translated">Не удается перехватить вызов в файле "{0}", так как он дублируется в другом месте компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationFileNotFound">
        <source>Cannot intercept a call in file '{0}' because a matching file was not found in the compilation.</source>
        <target state="translated">Не удается перехватить вызов в файле "{0}", поскольку соответствующий файл не найден в компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationUnsupportedVersion">
        <source>Version '{0}' of the interceptors format is not supported. The latest supported version is '1'.</source>
        <target state="translated">Версия "{0}" формата перехватчиков не поддерживается. Последняя поддерживаемая версия: "1".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
        <source>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Метод UnmanagedCallersOnly "{0}" не может реализовать элемент интерфейса "{1}" в типе "{2}"</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">"{0}" не может реализовать член интерфейса "{1}" в типе "{2}" из-за наличия параметра __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">Внутренняя ошибка в компиляторе C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
        <source>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</source>
        <target state="translated">Неверный формат типа InterpolatedStringHandlerArgumentAttribute, примененного к параметру "{0}", интерпретация невозможна. Создайте экземпляр "{1}" вручную.</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentDisallowed">
        <source>Interpolated string handler arguments are not allowed in this context.</source>
        <target state="new">Interpolated string handler arguments are not allowed in this context.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
        <source>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</source>
        <target state="translated">Параметр "{0}" является аргументом для преобразования обработчика интерполированной строки в параметре "{1}", но соответствующий аргумент указан после выражения интерполированной строки. Измените порядок аргументов, поместив "{0}" перед "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
        <source>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</source>
        <target state="translated">Параметр "{0}" явно не указан, но он используется в качестве аргумента для преобразования обработчика интерполированной строки в параметре "{1}". Укажите значение "{0}" перед "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
        <source>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</source>
        <target state="translated">Конструкция обработчика интерполированных строк не может использовать dynamic. Создайте экземпляр "{0}" вручную.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnInconsistent">
        <source>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</source>
        <target state="translated">Метод обработчика интерполированной строки "{0}" имеет несогласованный тип возвращаемого значения. Ожидаемый тип возвращаемого значения "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnMalformed">
        <source>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</source>
        <target state="translated">Неверный формат метода обработчика интерполированных строк "{0}". Он не возвращает значения "void" или "bool".</target>
        <note>void and bool are keywords</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
        <source>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</source>
        <target state="translated">Преобразования обработчика интерполированной строки, ссылающиеся на индексируемый экземпляр, нельзя использовать в инициализаторах элементов индексатора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExperimentalDiagID">
        <source>The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</source>
        <target state="translated">Аргумент diagnosticId атрибута "Experimental" должен быть допустимым идентификатором</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExtensionParameterReference">
        <source>Cannot use extension parameter '{0}' in this context.</source>
        <target state="new">Cannot use extension parameter '{0}' in this context.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFuncPointerReturnTypeModifier">
        <source>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</source>
        <target state="translated">"{0}" не является допустимым модификатором типа для возвращаемого значения указателя на функцию. Допустимые модификаторы: ref и ref readonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFunctionPointerCallingConvention">
        <source>'{0}' is not a valid calling convention specifier for a function pointer.</source>
        <target state="translated">"{0}" не является допустимым соглашением о вызовах для указателя на функцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">Недопустимое имя хэш-алгоритма: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayFields">
        <source>Inline array struct must declare one and only one instance field.</source>
        <target state="translated">Структура встроенного массива должна объявлять одно и только одно поле экземпляра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLayout">
        <source>Inline array struct must not have explicit layout.</source>
        <target state="translated">Структура встроенного массива не должна иметь явного макета.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLength">
        <source>Inline array length must be greater than 0.</source>
        <target state="translated">Длина встроенного массива должна быть больше 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not a valid parameter name from '{1}'.</source>
        <target state="translated">"{0}" не является допустимым именем параметра из "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierForLanguageVersion">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">Модификатор "{0}" недопустим для этого элемента в C# {1}. Используйте версию языка "{2}" или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameInSubpattern">
        <source>Identifier or a simple member access expected.</source>
        <target state="translated">Ожидается доступ к идентификатору или простому элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">Недопустимое создание объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPrimaryConstructorParameterReference">
        <source>Cannot use primary constructor parameter '{0}' in this context.</source>
        <target state="translated">Невозможно использовать параметр основного конструктора "{0}" в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">Запрещено указывать модификаторы readonly для свойства или индексатора "{0}" и его метода доступа. Удалите один из них.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">"Недопустимый описатель ранга: ожидается "]"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUnmanagedCallersOnlyCallConv">
        <source>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</source>
        <target state="translated">"{0}" не является допустимым типом соглашения о вызовах для "UnmanagedCallersOnly".</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InvalidWithReceiverType">
        <source>The receiver of a `with` expression must have a non-void type.</source>
        <target state="translated">Получатель выражения "with" должен иметь тип, отличный от void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Недопустимо использовать ссылочный тип "{0}", допускающий значения NULL, в выражении "is-type". Используйте вместо него базовый тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">Выражение типа "{0}" невозможно сопоставить с указанным шаблоном.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">Чтобы возвращать "{1}", метод "{0}" с блоком итератора должен быть асинхронным ("async").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorRefLikeElementType">
        <source>Element type of an iterator may not be a ref struct or a type parameter allowing ref structs</source>
        <target state="translated">Тип элемента итератора не может быть структурой ссылок или параметром типа, разрешая структуры ссылок</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaExplicitReturnTypeVar">
        <source>The contextual keyword 'var' cannot be used as an explicit lambda return type</source>
        <target state="translated">Контекстное ключевое слово "var" нельзя использовать в качестве явного типа возвращаемого значения лямбда-выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaWithAttributesToExpressionTree">
        <source>A lambda expression with attributes cannot be converted to an expression tree</source>
        <target state="translated">Невозможно преобразовать лямбда-выражение с атрибутами в дерево выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">"{0}" не может реализовать член интерфейса "{1}" в типе "{2}", так как функция "{3}" недоступна в C# {4}. Используйте версию языка "{5}" или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContainsDifferentWhitespace">
        <source>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</source>
        <target state="translated">Строка содержит пробел, отличный от пробела закрывающей строки литерала необработанной строки: {0} и {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineDoesNotStartWithSameWhitespace">
        <source>Line does not start with the same whitespace as the closing line of the raw string literal.</source>
        <target state="translated">Строка не начинается с того же пробела, что и закрывающая строка литерала необработанной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveEndLessThanStart">
        <source>The #line directive end position must be greater than or equal to the start position</source>
        <target state="translated">Позиция окончания директивы #line должна больше или равна позиции начала</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveInvalidValue">
        <source>The #line directive value is missing or out of range</source>
        <target state="translated">Значение директивы #line отсутствует или находится за пределами допустимого диапазона</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveRequiresSpace">
        <source>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</source>
        <target state="translated">Для директивы диапазона #line требуется пробел перед первой скобкой. перед смещением символа и перед именем файла</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ListPatternRequiresLength">
        <source>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</source>
        <target state="translated">Шаблоны списка не могут использоваться для значения типа {0}. Подходящее свойство \"Length\" или \"Count\" не найдено.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsExtensionParameter">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as an extension parameter</source>
        <target state="new">'{0}': a parameter, local variable, or local function cannot have the same name as an extension parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsExtensionTypeParameter">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameter</source>
        <target state="new">'{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsExtendedType">
        <source>'{0}': extension member names cannot be the same as their extended type</source>
        <target state="new">'{0}': extension member names cannot be the same as their extended type</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethFuncPtrMismatch">
        <source>No overload for '{0}' matches function pointer '{1}'</source>
        <target state="translated">Нет перегруженного метода для "{0}", который соответствует указателю на функцию "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplAttributeAsyncCannotBeUsed">
        <source>'MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.</source>
        <target state="new">'MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.</target>
        <note>'MethodImplAttribute.Async' and 'async' are not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_MisplacedExtension">
        <source>An extension member syntax is disallowed in nested position within an extension member syntax</source>
        <target state="new">An extension member syntax is disallowed in nested position within an extension member syntax</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedRecord">
        <source>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</source>
        <target state="translated">Непредвиденное ключевое слово \"record\". Возможно, вы имели в виду \"record struct\" или \"record class\"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedSlicePattern">
        <source>Slice patterns may only be used once and directly inside a list pattern.</source>
        <target state="translated">Шаблоны среза можно использовать только один раз и непосредственно внутри шаблона списка.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedUnchecked">
        <source>Unexpected keyword 'unchecked'</source>
        <target state="translated">Непредвиденное ключевое слово "unchecked"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddressOf">
        <source>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</source>
        <target state="translated">Не удается преобразовать группу методов в указатель на функцию. (Возможно, пропущен "&amp;"?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">Отсутствует шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModifierOnUnnamedReceiverParameter">
        <source>Cannot use modifiers on the unnamed receiver parameter of extension block</source>
        <target state="new">Cannot use modifiers on the unnamed receiver parameter of extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
        <source>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Инициализатор модуля не может иметь атрибут "UnmanagedCallersOnly".</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
        <source>Module initializer method '{0}' must not be generic and must not be contained in a generic type</source>
        <target state="translated">Метод инициализатора модуля "{0}" не должен быть универсальным и не должен содержаться в универсальном типе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
        <source>Module initializer method '{0}' must be accessible at the module level</source>
        <target state="translated">Метод инициализатора модуля "{0}" должен быть доступен на уровне модуля.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeOrdinary">
        <source>A module initializer must be an ordinary member method</source>
        <target state="translated">Инициализатор модуля должен быть обычным методом-элементом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
        <source>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</source>
        <target state="translated">Метод инициализатора модуля "{0}" должен быть статическим, не должен быть виртуальным, у него не должно быть параметров, он должен возвращать "void"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">В одном каталоге ("{0}") не может находиться несколько файлов конфигурации анализатора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">Атрибут [EnumeratorCancellation] невозможно использовать для нескольких параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleFileScopedNamespace">
        <source>Source file can only contain one file-scoped namespace declaration.</source>
        <target state="translated">Исходный файл может содержать только одно объявление пространства имен с файловой областью.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleRecordParameterLists">
        <source>Only a single partial type declaration may have a parameter list</source>
        <target state="translated">Только отдельное объявление разделяемого типа может содержать список параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForInlineArray">
        <source>An inline array access may not have a named argument specifier</source>
        <target state="translated">Доступ к встроенному массиву может не иметь спецификатора именованного аргумента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMember">
        <source>Extension members are not allowed as an argument to 'nameof'.</source>
        <target state="new">Extension members are not allowed as an argument to 'nameof'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">Ограничение "new()" невозможно использовать вместе с ограничением "unmanaged"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintCannotHaveRequiredMembers">
        <source>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</source>
        <target state="translated">"{2}" не соответствует ограничению "new()" параметра "{1}" в универсальном типе или методе "{0}", поскольку у "{2}" есть обязательные элементы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
        <source>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</source>
        <target state="translated">Новые строки внутри небуквальной интерполированной строки не поддерживаются в C# {0}. Используйте версию языка {1} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">"{0}": тип, используемый в асинхронном операторе using, должен допускать реализовывать "System.IAsyncDisposable" или подходящий метод "DisposeAsync". Возможно, вы имели в виду "using", а не "await using"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">"{0}": тип, используемый в операторе using, должен реализовывать "System.IDisposable". Возможно, вы имели в виду "await using", а не "using"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerArgumentExpressionParam">
        <source>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Невозможно применить CallerArgumentExpressionAttribute, поскольку нет стандартных преобразований из типа "{0}" в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCopyConstructorInBaseType">
        <source>No accessible copy constructor found in base type '{0}'.</source>
        <target state="translated">Доступный конструктор копий не найден в базовом типе "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDelegateConstraint">
        <source>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</source>
        <target state="translated">Ключевое слово \"delegate\" не может использоваться в качестве ограничения. Возможно, вы имели в виду \"System.Delegate\"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEnumConstraint">
        <source>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</source>
        <target state="translated">Ключевое слово \"enum\" не может использоваться в качестве ограничения. Возможно, вы имели в виду \"struct, System.Enum\"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvTargetTypedConditional">
        <source>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</source>
        <target state="translated">Условное выражение недопустимо в версии языка {0}, поскольку между "{1}" и "{2}" не найден общий тип. Для использования преобразования с целевым типом обновите язык до версии {3} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnUsing">
        <source>Modifiers cannot be placed on using declarations</source>
        <target state="translated">Модификаторы нельзя разместить при использовании объявлений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="translated">Не удалось определить выходной каталог</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPrivateAPIInRecord">
        <source>Record member '{0}' must be private.</source>
        <target state="translated">Элемент записи "{0}" должен быть закрытым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonProtectedAPIInRecord">
        <source>Record member '{0}' must be protected.</source>
        <target state="translated">Элемент записи "{0}" должен быть защищенным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicAPIInRecord">
        <source>Record member '{0}' must be public.</source>
        <target state="translated">Элемент записи "{0}" должен быть открытым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicParameterlessStructConstructor">
        <source>The parameterless struct constructor must be 'public'.</source>
        <target state="translated">Конструктор структуры без параметров должен быть публичным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughCloseBracesForRawString">
        <source>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</source>
        <target state="translated">Интерполяция должна заканчиваться количеством закрывающих фигурных скобок, совпадающим с количеством символов \"$\", с которых начинается литерал необработанной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughQuotesForRawString">
        <source>Not enough quotes for raw string literal.</source>
        <target state="translated">Недостаточно кавычек для литерала необработанной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not an instance method, the receiver or extension receiver parameter cannot be an interpolated string handler argument.</source>
        <target state="translated">Поскольку "{0}" не является методом экземпляра, получатель не может быть аргументом обработчика интерполированных строк.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableAPIInRecord">
        <source>'{0}' must allow overriding because the containing record is not sealed.</source>
        <target state="translated">"{0}" должен допускать переопределение, поскольку содержащая его запись не является запечатанной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotRefStructConstraintNotSatisfied">
        <source>The type '{2}' may not be a ref struct or a type parameter allowing ref structs in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Тип "{2}" не может быть ссылочной структурой или параметром типа, позволяющим использовать ссылочные структуры в качестве параметра "{1}" в универсальном типе или методе "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullInvalidInterpolatedStringHandlerArgumentName">
        <source>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</source>
        <target state="translated">"Null" не является допустимым именем параметра. Для получения доступа к приемнику метода экземпляра используйте пустую строку в качестве имени параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">Ожидается "enable", "disable" или "restore"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">Ожидаемые значения: "warnings", "annotations" или конец директивы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">Недопустимое значение "{0}": "{1}" для C# {2}. Используйте версию языка "{3}" или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">Параметр типа, допускающий значение null, должен представлять собой тип значения или ссылку на тип, не допускающую значение null, если не используется версия языка "{0}" или выше. Попробуйте изменить версию языка или добавить ограничение "class", "struct" или ограничение типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedTypeArgument">
        <source>Omitting the type argument is not allowed in the current context</source>
        <target state="translated">Пропуск аргумента типа в текущем контексте не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantBeChecked">
        <source>User-defined operator '{0}' cannot be declared checked</source>
        <target state="translated">Невозможно объявить определяемый пользователем оператор "{0}" как проверенный</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInExtensionOfStaticClass">
        <source>An extension block extending a static class cannot contain user-defined operators</source>
        <target state="new">An extension block extending a static class cannot contain user-defined operators</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMismatchOnOverride">
        <source>'{0}': cannot override inherited member '{1}' because one of them is not an operator.</source>
        <target state="new">'{0}': cannot override inherited member '{1}' because one of them is not an operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustReturnVoid">
        <source>The return type for this operator must be void</source>
        <target state="new">The return type for this operator must be void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBePublic">
        <source>User-defined operator '{0}' must be declared public</source>
        <target state="new">User-defined operator '{0}' must be declared public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStaticAndPublic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="new">User-defined operator '{0}' must be declared static and public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefReadonlyParam">
        <source>A ref readonly parameter cannot have the Out attribute.</source>
        <target state="translated">Параметр ref, доступный только для чтения, не может иметь атрибут Out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">Выходная переменная не может быть объявлена как локальная переменная ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideDefaultConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</source>
        <target state="translated">Метод "{0}" задает ограничение "default" для параметра типа "{1}", но соответствующий параметр типа "{2}" переопределенного или явно реализованного метода "{3}" ограничен и может представлять собой только тип ссылки или тип значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideMustHaveRequired">
        <source>'{0}' must be required because it overrides required member '{1}'</source>
        <target state="translated">Необходимо требовать "{0}" до переопределения обязательного элемента "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">Метод "{0}" задает ограничение class для параметра типа "{1}", но соответствующий параметр типа "{2}" переопределенного или явно реализованного метода "{3}" не является ссылочным типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">Метод "{0}" задает ограничение struct для параметра типа "{1}", но соответствующий параметр типа "{2}" переопределенного или явно реализованного метода "{3}" не является типом значения, не допускающим значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredFollowsIf">
        <source>'#:' directives cannot be after '#if' directive</source>
        <target state="new">'#:' directives cannot be after '#if' directive</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredFollowsToken">
        <source>'#:' directives cannot be after first token in file</source>
        <target state="new">'#:' directives cannot be after first token in file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredNeedsFileBasedProgram">
        <source>'#:' directives can be only used in file-based programs ('-features:FileBasedProgram')</source>
        <target state="new">'#:' directives can be only used in file-based programs ('-features:FileBasedProgram')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPShebangInProjectBasedProgram">
        <source>'#!' directives can be only used in scripts or file-based programs</source>
        <target state="new">'#!' directives can be only used in scripts or file-based programs</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionConstructorDoesntInitializeRequiredMember">
        <source>Constructor '{0}' leaves required member '{1}' uninitialized.</source>
        <target state="translated">Конструктор "{0}" оставляет необходимый элемент "{1}" не инициализированным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExpressionTree">
        <source>An expression tree may not contain an expanded form of non-array params collection parameter.</source>
        <target state="translated">Дерево выражений не может содержать расширенную форму параметра коллекции params, не являющегося массивом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExtensionAddMethod">
        <source>'{0}' does not contain a definition for a suitable instance 'Add' method</source>
        <target state="translated">"{0}" не содержит определения для подходящего экземпляра метода "Add"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionInfiniteChainOfConstructorCalls">
        <source>Creation of params collection '{0}' results in an infinite chain of invocation of constructor '{1}'.</source>
        <target state="translated">Создание коллекции params "{0}" приводит к бесконечной цепочке вызовов конструктора "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionMissingConstructor">
        <source>Non-array params collection type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Тип коллекции params, не являющийся массивом, должен иметь применимый конструктор, который можно вызывать без аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMemberCannotBeLessVisibleThanDeclaringMember">
        <source>Method '{0}' cannot be less visible than the member with params collection '{1}'.</source>
        <target state="translated">Метод "{0}" не может быть менее видимым, чем элемент с коллекцией параметров "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeCollection">
        <source>The params parameter must have a valid collection type</source>
        <target state="translated">Параметр params должен иметь допустимый тип коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialConstructorInitializer">
        <source>'{0}': only the implementing declaration of a partial constructor can have an initializer</source>
        <target state="new">'{0}': only the implementing declaration of a partial constructor can have an initializer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialEventInitializer">
        <source>'{0}': partial event cannot have initializer</source>
        <target state="new">'{0}': partial event cannot have initializer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberAccessibilityDifference">
        <source>Both partial member declarations must have identical accessibility modifiers.</source>
        <target state="translated">У обоих объявлений частичного члена должны быть идентичные модификаторы доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberCannotBeAbstract">
        <source>A partial member cannot have the 'abstract' modifier</source>
        <target state="translated">У частичного члена не может быть модификатора "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberDuplicateDefinition">
        <source>Partial member '{0}' may not have multiple defining declarations.</source>
        <target state="new">Partial member '{0}' may not have multiple defining declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberDuplicateImplementation">
        <source>Partial member '{0}' may not have multiple implementing declarations.</source>
        <target state="new">Partial member '{0}' may not have multiple implementing declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberInconsistentTupleNames">
        <source>Both partial member declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">Оба определения частичного члена "{0}" и "{1}" должны использовать одинаковые имена элементов кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberMissingDefinition">
        <source>Partial member '{0}' must have a definition part.</source>
        <target state="new">Partial member '{0}' must have a definition part.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberMissingImplementation">
        <source>Partial member '{0}' must have an implementation part.</source>
        <target state="new">Partial member '{0}' must have an implementation part.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberOnlyInPartialClass">
        <source>A partial member must be declared within a partial type</source>
        <target state="translated">Частичный член должен быть объявлен из частичного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberParamsDifference">
        <source>Both partial member declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">Оба объявления частичного члена должны использовать параметр "params" или оба не должны использовать параметр "params"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberReadOnlyDifference">
        <source>Both partial member declarations must be readonly or neither may be readonly</source>
        <target state="translated">Оба объявления частичного члена должны быть доступными только для чтения или оба не должны быть доступными только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberExtendedModDifference">
        <source>Both partial member declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</source>
        <target state="translated">У обоих объявлений частичного члена должны быть одинаковые сочетания модификаторов "'virtual", "override", "sealed" и "new".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberRefReturnDifference">
        <source>Partial member declarations must have matching ref return values.</source>
        <target state="translated">У объявлений частичного члена должны совпадать возвращаемые значения "ref".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberTypeDifference">
        <source>Both partial member declarations must have the same type.</source>
        <target state="new">Both partial member declarations must have the same type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberUnsafeDifference">
        <source>Both partial member declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">Оба объявления частичного члена должны быть небезопасными или оба не должны быть небезопасными</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReturnTypeDifference">
        <source>Both partial method declarations must have the same return type.</source>
        <target state="translated">Оба объявления разделяемого метода должны иметь одинаковый тип возвращаемого значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
        <source>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</source>
        <target state="translated">Разделяемый метод "{0}" должен содержать часть реализации, так как он имеет модификаторы доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithExtendedModMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</source>
        <target state="translated">Разделяемый метод "{0}" должен иметь модификаторы доступа, так как он содержит модификатор "virtual", "override", "sealed", "new" или "extern".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</source>
        <target state="translated">Разделяемый метод "{0}" должен иметь модификаторы доступа, так как он возвращает значение, отличное от void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithOutParamMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</source>
        <target state="translated">Разделяемый метод "{0}" должен иметь модификаторы доступа, так как он содержит параметры "out".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateDefinition">
        <source>A partial property may not have multiple defining declarations, and cannot be an auto-property.</source>
        <target state="translated">У частичного свойства не может быть нескольких определяющих определений, оно не может быть автоматическим свойством.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateImplementation">
        <source>A partial property may not have multiple implementing declarations</source>
        <target state="translated">У частичного свойства не может быть нескольких реализующих объявлений</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateInitializer">
        <source>A partial property cannot have an initializer on both the definition and implementation.</source>
        <target state="translated">Частичное свойство не может содержать инициализатор одновременно в определении и реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyInitMismatch">
        <source>Property accessor '{0}' must be '{1}' to match the definition part</source>
        <target state="translated">Метод доступа "{0}" должен быть "{1}", чтобы соответствовать части определения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingAccessor">
        <source>Property accessor '{0}' must be implemented because it is declared on the definition part</source>
        <target state="translated">Метод доступа "{0}" должен быть реализован, поскольку он объявлен в части определения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingDefinition">
        <source>Partial property '{0}' must have a definition part.</source>
        <target state="translated">У частичного свойства "{0}" должна быть часть определения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingImplementation">
        <source>Partial property '{0}' must have an implementation part.</source>
        <target state="translated">У частичного свойства "{0}" должна быть часть реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyRequiredDifference">
        <source>Both partial property declarations must be required or neither may be required</source>
        <target state="translated">Оба объявления частичного члена должны быть обязательными или оба не должны быть обязательными</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyUnexpectedAccessor">
        <source>Property accessor '{0}' does not implement any accessor declared on the definition part</source>
        <target state="translated">Метод доступа "{0}" не реализует методы доступа, объявленные для части определения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternSpanCharCannotBeStringNull">
        <source>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</source>
        <target state="translated">Строковая константа "null" не поддерживается в качестве шаблона для "{0}". Используйте вместо этого пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">Сопоставление шаблонов запрещено для типов указателей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">Текст метода асинхронного итератора должен содержать оператор "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">Текст метода асинхронного итератора должен содержать оператор "yield". Попробуйте удалить "async" из объявления метода или добавить оператор "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">Для вложенного шаблона свойств требуется ссылка на свойство или поле для сопоставления, например, "{{ Name: {0} }}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInExtension">
        <source>'{0}': new protected member declared in an extension block</source>
        <target state="new">'{0}': new protected member declared in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringDelimiterOnOwnLine">
        <source>Raw string literal delimiter must be on its own line.</source>
        <target state="translated">Разделитель литерала необработанной строки должен находиться в отдельной строке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringInVerbatimInterpolatedStrings">
        <source>Multi-line raw string literals are only allowed in verbatim interpolated strings.</source>
        <target state="translated">Многострочные литералы необработанных строк разрешены только в интерполированных буквальных строках.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringMustContainContent">
        <source>Multi-line raw string literals must contain at least one line of content.</source>
        <target state="translated">Многострочные литералы необработанных строк должны содержать по крайней мере одну строку содержимого.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringNotInDirectives">
        <source>Raw string literals are not allowed in preprocessor directives.</source>
        <target state="translated">Литералы необработанных строк не разрешены в директивах препроцессора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Невозможно внедрить тип "{0}", так как он переопределяет абстракцию элемента базового интерфейса. Попробуйте задать для свойства "Внедрить типы взаимодействия" значение false (ложь).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">"{0}": readonly можно использовать для методов доступа, только если свойство или индексатор имеет оба метода доступа, get и set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReceiverParameterOnlyOne">
        <source>An extension container can have only one receiver parameter</source>
        <target state="new">An extension container can have only one receiver parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReceiverParameterSameNameAsTypeParameter">
        <source>'{0}': a receiver parameter cannot have the same name as an extension container type parameter</source>
        <target state="new">'{0}': a receiver parameter cannot have the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordAmbigCtor">
        <source>The primary constructor conflicts with the synthesized copy constructor.</source>
        <target state="translated">Первичный конструктор конфликтует с синтезированным конструктором копий.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordStructConstructorCallsDefaultConstructor">
        <source>A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</source>
        <target state="translated">Конструктор, объявленный в "struct" со списком параметров, должен содержать инициализатор "this", вызывающий основной конструктор или явно объявленный конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Не удается присвоить по ссылке "{1}" для "{0}", так как escape-область у "{1}" уже, чем у "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignReturnOnly">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">Не удается присвоить по ссылкеь "{1}" для "{0}",так как "{1}" может избежать текущего метода только через оператор return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignValEscapeWider">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.</source>
        <target state="translated">Невозможно присвоить ссылку "{1}" на "{0}", так как "{1}" имеет более широкую область экранирования значения, чем "{0}", что позволяет назначать через "{0}" значения с более узкой областью экранирования, чем "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionParameterMustBeValueTypeOrConstrainedToOne">
        <source>The 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.</source>
        <target state="new">The 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldCannotReferToRefStruct">
        <source>A ref field cannot refer to a ref struct.</source>
        <target state="translated">Поле ref не должно ссылаться на ref struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldInNonRefStruct">
        <source>A ref field can only be declared in a ref struct.</source>
        <target state="translated">Поле ссылки может быть объявлено только в структуре ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalAcrossAwait">
        <source>A 'ref' local cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Локальный "ref" не может быть сохранен за границей "await" или "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref variable.</source>
        <target state="translated">Левая сторона назначения ref должна быть переменной ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadOnlyWrongOrdering">
        <source>'readonly' modifier must be specified after 'ref'.</source>
        <target state="translated">Модификатор "readonly" должен указываться после "ref".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Параметр основного конструктора типа, доступного только для чтения, нельзя использовать как значение ref или out (за исключением метода задания с типом, предназначенным только для инициализации, или инициализатора переменной)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Элементы параметра основного конструктора "{0}" типа, доступного только для чтения, нельзя использовать как значение ref или out (за исключением метода задания с типом, предназначенным только для инициализации, или инициализатора переменной)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter">
        <source>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Не удается вернуть параметр по ссылке "{0}" с помощью параметра ref, его можно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter2">
        <source>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Не удается вернуть элемент параметра "{0}" с помощью параметра ref, его можно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnPrimaryConstructorParameter">
        <source>Cannot return primary constructor parameter '{0}' by reference.</source>
        <target state="translated">Невозможно вернуть параметр основного конструктора "{0}" с помощью ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be returned by writable reference</source>
        <target state="translated">Параметр основного конструктора типа, доступного только для чтения, нельзя вернуть с помощью записываемой ссылки</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference</source>
        <target state="translated">Элементы параметра основного конструктора "{0}" типа, доступного только для чтения, нельзя вернуть с помощью записываемой ссылки</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter">
        <source>Cannot return a parameter by reference '{0}' because it is scoped to the current method</source>
        <target state="translated">Не удается вернуть параметр по ссылке "{0}", так как он имеет область действия текущего метода</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</source>
        <target state="translated">Не удается вернуть по ссылке элемент параметра "{0}", так как он имеет область действия текущего метода</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningPropertiesCannotBeRequired">
        <source>Ref returning properties cannot be required.</source>
        <target state="translated">Возвращаемые свойства ссылки не могут быть обязательными.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructConstraintAlreadySpecified">
        <source>'ref struct' is already specified.</source>
        <target state="translated">"ref struct" уже указан.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' for ref struct '{2}'.</source>
        <target state="translated">"{0}" не удается реализовать элемент интерфейса "{1}" для ref struct "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RelationalPatternWithNaN">
        <source>Relational patterns may not be used for a floating-point NaN.</source>
        <target state="translated">Реляционные шаблоны не могут использоваться для NaN с плавающей запятой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeHidden">
        <source>Required member '{0}' cannot be hidden by '{1}'.</source>
        <target state="translated">Требуемый элемент "{0}" не может быть скрыт элементом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
        <source>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</source>
        <target state="translated">Обязательный элемент "{0}" или его метод задания не может быть менее видимым, чем содержащий тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSet">
        <source>Required member '{0}' must be set in the object initializer or attribute constructor.</source>
        <target state="translated">Необходимо задать обязательный элемент "{0}" в инициализаторе объектов или в конструкторе атрибутов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSettable">
        <source>Required member '{0}' must be settable.</source>
        <target state="translated">Обязательный элемент "{0}" должен быть задаваемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersBaseTypeInvalid">
        <source>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</source>
        <target state="translated">Неправильный формат списка обязательных элементов для базового типа "{0}", его не удается интерпретировать. Чтобы использовать этот конструктор, примените атрибут "SetsRequiredMembers".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersInvalid">
        <source>The required members list for '{0}' is malformed and cannot be interpreted.</source>
        <target state="translated">Неправильный формат списка обязательных элементов для "{0}", его не удается интерпретировать.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersMustBeAssignedValue">
        <source>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</source>
        <target state="translated">Обязательному элементу "{0}" должно быть назначено значение, он не может использовать вложенный элемент или инициализатор коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNameDisallowed">
        <source>Types and aliases cannot be named 'required'.</source>
        <target state="translated">У типов и псевдонимов не может быть имя "required".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmbeddedAttributeMustFollowPattern">
        <source>The type 'Microsoft.CodeAnalysis.EmbeddedAttribute' must be non-generic, internal, non-file, sealed, non-static, have a parameterless constructor, inherit from System.Attribute, and be able to be applied to any type.</source>
        <target state="needs-review-translation">Тип "Microsoft.CodeAnalysis.EmbeddedAttribute" должен быть неуниверсанным, внутренним, запечатанным, нестатическим, иметь конструктор без параметров, наследовать от System.Attribute и иметь возможность применяться к любому типу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportByRefLikeGenerics">
        <source>Target runtime doesn't support by-ref-like generics.</source>
        <target state="translated">Целевая среда выполнения не поддерживает параметрические полиморфизмы, подобные ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
        <source>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">"{0}": целевая среда выполнения не поддерживает ковариантные типы в переопределениях. Для сопоставления переопределенного элемента "{1}" необходимо использовать тип "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
        <source>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">"{0}": целевая среда выполнения не поддерживает ковариантные возвращаемые типы в переопределениях. Для сопоставления переопределенного элемента "{1}" необходимо использовать возвращаемый тип "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportInlineArrayTypes">
        <source>Target runtime doesn't support inline array types.</source>
        <target state="translated">Целевая среда выполнения не поддерживает встроенные типы массивов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">Целевая среда выполнения не поддерживает специальные возможности "защищенный", "внутренний защищенный" или "частный защищенный" для члена интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportRefFields">
        <source>Target runtime doesn't support ref fields.</source>
        <target state="translated">Целевая среда выполнения не поддерживает поля ссылок.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
        <source>Target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">Целевая среда выполнения не поддерживает статические абстрактные элементы в интерфейсах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">"{0}" не может реализовать элемент интерфейса "{1}" в типе "{2}", поскольку целевая среда выполнения не поддерживает статические абстрактные элементы в интерфейсах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
        <source>The target runtime doesn't support extensible or runtime-environment default calling conventions.</source>
        <target state="translated">Целевая среда выполнения не поддерживает расширяемые или принадлежащие среде выполнения соглашения о вызовах по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedDiscard">
        <source>The 'scoped' modifier cannot be used with discard.</source>
        <target state="translated">Модификатор "scoped" нельзя использовать с отменой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Модификатор "scoped" параметра "{0}" не совпадает с переопределенным или реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfPartial">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match partial definition.</source>
        <target state="translated">Модификатор "scoped" параметра "{0}" не соответствует частичному определению.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Модификатор "scoped" параметра "{0}" не соответствует целевому "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedRefAndRefStructOnly">
        <source>The 'scoped' modifier can be used for refs and ref struct values only.</source>
        <target state="translated">Модификатор "scoped" можно использовать только для ref и для значений ref struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedTypeNameDisallowed">
        <source>Types and aliases cannot be named 'scoped'.</source>
        <target state="translated">У типов и псевдонимов не может быть имя "scoped".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
        <source>Required members are not allowed on the top level of a script or submission.</source>
        <target state="translated">Обязательные члены не разрешены на верхнем уровне сценария или отправки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedAPIInRecord">
        <source>'{0}' cannot be sealed because containing record is not sealed.</source>
        <target state="translated">"{0}" не может быть запечатанным, поскольку содержащая его запись не является запечатанной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignatureMismatchInRecord">
        <source>Record member '{0}' must return '{1}'.</source>
        <target state="translated">Элемент записи "{0}" должен возвращать "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramIsEmpty">
        <source>At least one top-level statement must be non-empty.</source>
        <target state="translated">По крайней мере один оператор верхнего уровня не должен быть пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
        <source>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</source>
        <target state="translated">Невозможно использовать локальную переменную или локальную функцию "{0}", объявленную в инструкции верхнего уровня в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
        <source>Only one compilation unit can have top-level statements.</source>
        <target state="translated">Только одна единица компиляции может содержать инструкции верхнего уровня.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramNotAnExecutable">
        <source>Program using top-level statements must be an executable.</source>
        <target state="translated">Программы, использующие инструкции верхнего уровня, должны быть исполняемыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpreadMissingMember">
        <source>Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">Оператор расширения ".." не работает с переменными типа "{0}", так как "{0}" не содержит открытое определение экземпляра или расширения для "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAPIInRecord">
        <source>Record member '{0}' may not be static.</source>
        <target state="translated">Элемент записи "{0}" не может быть статическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureThis">
        <source>A static anonymous function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Статическая анонимная функция не может содержать ссылку на "this" или "base".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureVariable">
        <source>A static anonymous function cannot contain a reference to '{0}'.</source>
        <target state="translated">Статическая анонимная функция не может содержать ссылку на "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Статическая локальная функция не может содержать ссылку на "this" или "base".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">Статическая локальная функция не может содержать ссылку на "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Статический член "{0}" не может быть помечен как readonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">Указан аргумент stdin "-", но входные данные не были перенаправлены из стандартного входного потока.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StringMustStartWithQuoteCharacter">
        <source>String must start with quote character: "</source>
        <target state="translated">Строка должна начинаться с символа кавычки "</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructHasInitializersAndNoDeclaredConstructor">
        <source>A 'struct' with field initializers must include an explicitly declared constructor.</source>
        <target state="translated">Параметр struct с инициализаторами полей должен включать явно объявленный конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCyclePrimaryConstructorParameter">
        <source>Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Параметр основного конструктора структуры "{0}" типа "{1}" вызывает цикл в макете структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</source>
        <target state="translated">Шаблон является недоступным. Он уже был обработан в предыдущем блоке выражения switch или условие для него не может быть выполнено.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</source>
        <target state="translated">Блок выражения switch case является недоступным. Он уже был обработан в предыдущем блоке или условие для него не может быть выполнено.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">Не удалось найти лучший тип для выражения switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">Вокруг главного выражения switch требуются скобки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SymbolDefinedInAssembly">
        <source>'{0}' is defined in assembly '{1}'.</source>
        <target state="translated">'{0}' определен в сборке '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCloseBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</source>
        <target state="translated">Интерполированный литерал необработанной строки не начинается с достаточного количества символов \"$\", чтобы разрешить использование такого же количества последовательных закрывающих фигурных скобок в качестве содержимого.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyOpenBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</source>
        <target state="translated">Интерполированный литерал необработанной строки не начинается с достаточного количества символов \"$\", чтобы разрешить использовать такое же количество последовательных открывающих фигурных скобок в качестве содержимого.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyQuotesForRawString">
        <source>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</source>
        <target state="translated">Литерал необработанной строки не начинается с достаточного количества символов кавычек, чтобы разрешить использовать такое же количество последовательных символов кавычек в качестве содержимого.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings_RestartRequired">
        <source>Combined length of user strings used by the program exceeds allowed limit. Adding a string literal requires restarting the application.</source>
        <target state="new">Combined length of user strings used by the program exceeds allowed limit. Adding a string literal requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TopLevelStatementAfterNamespaceOrType">
        <source>Top-level statements must precede namespace and type declarations.</source>
        <target state="translated">Инструкции верхнего уровня должны предшествовать объявлениям пространств имен и типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">Неожиданная последовательность символов "…"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">Имя "{0}" не определяет элемент кортежа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">Типы кортежей, используемые в качестве операндов оператора == или !=, должны иметь соответствующие кратности. Однако этот оператор имеет типы кортежей с кратностью {0} слева и {1} справа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConstraintsMustBeUniqueAndFirst">
        <source>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</source>
        <target state="translated">Ограничения "class", "struct", "unmanaged", "notnull" и "default" не могут быть объединены или повторяться, поэтому они должны быть указаны первыми в списке ограничений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeIsNotAnInterpolatedStringHandlerType">
        <source>'{0}' is not an interpolated string handler type.</source>
        <target state="translated">"{0}" не является типом обработчика интерполированных строк.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMustBePublic">
        <source>Type '{0}' must be public to be used as a calling convention.</source>
        <target state="translated">Тип "{0}" должен быть открытым для использования в качестве соглашения о вызовах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParameterSameNameAsExtensionParameter">
        <source>Type parameter '{0}' has the same name as an extension parameter</source>
        <target state="new">Type parameter '{0}' has the same name as an extension parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParameterSameNameAsExtensionTypeParameter">
        <source>Type parameter '{0}' has the same name as an extension container type parameter</source>
        <target state="new">Type parameter '{0}' has the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Автоматически реализуемое свойство "{0}" должно быть полностью назначено перед возвратом контроля вызывающему элементу. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значение по умолчанию к этому свойству.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Поле '{0}' должно быть полностью назначенным перед возвратом контроля вызывающему элементу. Попробуйте обновить поле до языковой версии "{1}", чтобы автоматически применить значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnderspecifiedExtension">
        <source>The type parameter `{0}` is not referenced by either the extension parameter or a parameter of this member</source>
        <target state="new">The type parameter `{0}` is not referenced by either the extension parameter or a parameter of this member</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedParameterList">
        <source>Unexpected parameter list.</source>
        <target state="translated">Неожиданный список параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</source>
        <target state="translated">"{0}" имеет атрибут "UnmanagedCallersOnly" и не может вызываться напрямую. Получите указатель на функцию для этого метода.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</source>
        <target state="translated">"{0}" имеет атрибут "UnmanagedCallersOnly" и не может быть преобразован в тип делегата. Получите указатель на функцию для этого метода.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedRefSafetyRulesAttributeVersion">
        <source>'{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.</source>
        <target state="translated">"{0}" определен в модуле с нераспознанной версией RefSafetyRulesAttribute. Ожидается "11".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeInterfaceImplementation">
        <source>UnscopedRefAttribute cannot be applied to an interface implementation because implemented member '{0}' doesn't have this attribute.</source>
        <target state="translated">UnscopedRefAttribute нельзя применить к реализации интерфейса, поскольку реализованный элемент {0} не содержит этого атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedMemberTarget">
        <source>UnscopedRefAttribute can only be applied to struct or virtual interface instance methods and properties, and cannot be applied to constructors or init-only members.</source>
        <target state="translated">UnscopedRefAttribute можно применять только к методам и свойствам экземпляра структуры или виртуального интерфейса и нельзя применять к конструкторам или элементам, предназначенным только для инициализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedTarget">
        <source>UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.</source>
        <target state="translated">Не удается применить UnscopedRefAttribute к этому параметру, так как у него по умолчанию нет области действия.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedScoped">
        <source>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</source>
        <target state="translated">Невозможно применить UnscopedRefAttribute к параметрам, у которых есть модификатор "scoped".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCompilerFeature">
        <source>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</source>
        <target state="translated">Для "{0}" требуется функция компилятора "{1}", которая не поддерживается в этой версии компилятора C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedFeatureInRuntimeAsync">
        <source>Method '{0}' uses a feature that is not supported by runtime async currently. Opt the method out of runtime async by attributing it with 'System.Runtime.CompilerServices.RuntimeAsyncMethodGenerationAttribute(false)'.</source>
        <target state="new">Method '{0}' uses a feature that is not supported by runtime async currently. Opt the method out of runtime async by attributing it with 'System.Runtime.CompilerServices.RuntimeAsyncMethodGenerationAttribute(false)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRef">
        <source>Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member</source>
        <target state="translated">Невозможно использовать параметр основного конструктора "{0}" с модификаторами ref, out или in внутри элемента экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefAny">
        <source>Cannot use primary constructor parameter of type '{0}' inside an instance member</source>
        <target state="translated">Невозможно использовать первичный параметр конструктора типа "{0}" внутри элемента экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefLike">
        <source>Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member</source>
        <target state="translated">Невозможно использовать параметр основного конструктора "{0}" типа ref-like внутри элемента экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForListPattern">
        <source>List patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Шаблоны списка не могут использоваться для значений типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedRawString">
        <source>Unterminated raw string literal.</source>
        <target state="translated">Незавершенный литерал необработанной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Используется поле "{0}", которое может быть не назначено. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Используется автоматически реализуемое свойство "{0}", которое может быть не назначено. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Нельзя использовать объект "this", пока не будут назначены все его поля. Попробуйте обновить до языковой версии "{0}", чтобы автоматически применить значения по умолчанию к неназначенным полям.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueParameterSameNameAsExtensionParameter">
        <source>'value': an automatically-generated parameter name conflicts with an extension parameter name</source>
        <target state="new">'value': an automatically-generated parameter name conflicts with an extension parameter name</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueParameterSameNameAsExtensionTypeParameter">
        <source>'value': an automatically-generated parameter name conflicts with an extension type parameter name</source>
        <target state="new">'value': an automatically-generated parameter name conflicts with an extension type parameter name</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableDeclarationNamedField">
        <source>In language version {0}, 'field' is a keyword within a property accessor. Rename the variable or use the identifier '@field' instead.</source>
        <target state="new">In language version {0}, 'field' is a keyword within a property accessor. Rename the variable or use the identifier '@field' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongArityAsyncReturn">
        <source>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</source>
        <target state="translated">Ожидался универсальный возвращаемый тип, схожий с задачей, но тип "{0}", обнаруженный в атрибуте "AsyncMethodBuilder", не подходит. Требуется неограниченный универсальный тип c арностью 1, а его содержащий тип (если есть) не должен быть универсальным</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing">
        <source>The using directive for '{0}' appeared previously as global using</source>
        <target state="translated">Директива using "{0}" ранее использовалась в качестве глобальной</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing_Title">
        <source>The using directive appeared previously as global using</source>
        <target state="translated">Директива using ранее использовалась в качестве глобальной</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPattern">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPatternStackGuard">
        <source>The pattern is too complex to analyze for redundancy.</source>
        <target state="new">The pattern is too complex to analyze for redundancy.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPatternStackGuard_Title">
        <source>The pattern is too complex to analyze for redundancy.</source>
        <target state="new">The pattern is too complex to analyze for redundancy.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPattern_Title">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ArrayAccess">
        <source>array access</source>
        <target state="translated">доступ к массиву</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AsyncMethodBuilderOverride">
        <source>async method builder override</source>
        <target state="translated">переопределение построителя методов async</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CollectionExpression">
        <source>collection expression</source>
        <target state="new">collection expression</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAllowsRefStructConstraint">
        <source>allows ref struct constraint</source>
        <target state="translated">разрешает ограничение структуры "ref"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoDefaultStructs">
        <source>auto default struct fields</source>
        <target state="translated">автоматически применять значения по умолчанию к полям структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCheckedUserDefinedOperators">
        <source>checked user-defined operators</source>
        <target state="translated">проверенные операторы, определяемые пользователем</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressions">
        <source>collection expressions</source>
        <target state="translated">выражения коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCovariantReturnsForOverrides">
        <source>covariant returns</source>
        <target state="translated">ковариантные возвращаемые значения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDiscards">
        <source>discards</source>
        <target state="translated">пустые переменные</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDisposalPattern">
        <source>pattern-based disposal</source>
        <target state="translated">аннулирование на основе шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPropertyPatterns">
        <source>extended property patterns</source>
        <target state="translated">шаблоны расширенных свойств</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensions">
        <source>extensions</source>
        <target state="new">extensions</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFieldKeyword">
        <source>field keyword</source>
        <target state="translated">ключевое слово поля</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileScopedNamespace">
        <source>file-scoped namespace</source>
        <target state="translated">пространство имен с файловой областью</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileTypes">
        <source>file types</source>
        <target state="translated">типы файлов</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFirstClassSpan">
        <source>first-class Span types</source>
        <target state="translated">типы диапазона первого класса</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenericAttributes">
        <source>generic attributes</source>
        <target state="translated">универсальные атрибуты</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalUsing">
        <source>global using directive</source>
        <target state="translated">глобальная директива using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitIndexerInitializer">
        <source>implicit indexer initializer</source>
        <target state="translated">неявный инициализатор индексатора</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitObjectCreation">
        <source>target-typed object creation</source>
        <target state="translated">создание объекта с типом целевого объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImprovedInterpolatedStrings">
        <source>interpolated string handlers</source>
        <target state="translated">обработчики интерполированных строк</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInferredDelegateType">
        <source>inferred delegate type</source>
        <target state="translated">выводимый тип делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInlineArrays">
        <source>inline arrays</source>
        <target state="translated">встроенные массивы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInstanceMemberInNameof">
        <source>instance member in 'nameof'</source>
        <target state="translated">элемент экземпляра в "nameof"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaAttributes">
        <source>lambda attributes</source>
        <target state="translated">лямбда-атрибуты</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaOptionalParameters">
        <source>lambda optional parameters</source>
        <target state="translated">дополнительные параметры лямбды</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaParamsArray">
        <source>lambda params array</source>
        <target state="translated">массив лямбда-параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaReturnType">
        <source>lambda return type</source>
        <target state="translated">тип возвращаемого значения лямбда</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureListPattern">
        <source>list pattern</source>
        <target state="translated">шаблон списка</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLockObject">
        <source>Lock object</source>
        <target state="translated">Блокировать объект</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNewLinesInInterpolations">
        <source>newlines in interpolations</source>
        <target state="translated">новые линии в интерполяции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullConditionalAssignment">
        <source>null conditional assignment</source>
        <target state="new">null conditional assignment</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOverloadResolutionPriority">
        <source>overload resolution priority</source>
        <target state="translated">приоритет разрешения перегрузки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParameterlessStructConstructors">
        <source>parameterless struct constructors</source>
        <target state="translated">конструкторы структуры без параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParamsCollections">
        <source>params collections</source>
        <target state="translated">коллекции params</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialEventsAndConstructors">
        <source>partial events and constructors</source>
        <target state="new">partial events and constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePositionalFieldsInRecords">
        <source>positional fields in records</source>
        <target state="translated">позиционные поля в записях</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrimaryConstructors">
        <source>primary constructors</source>
        <target state="translated">основные конструкторы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRawStringLiterals">
        <source>raw string literals</source>
        <target state="translated">литералы необработанных строк</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecordStructs">
        <source>record structs</source>
        <target state="translated">структуры записей</target>
        <note>'record structs' is not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFields">
        <source>ref fields</source>
        <target state="translated">поля ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReadonlyParameters">
        <source>ref readonly parameters</source>
        <target state="translated">Параметры ref, доступные только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructInterfaces">
        <source>ref struct interfaces</source>
        <target state="translated">интерфейсы ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefUnsafeInIteratorAsync">
        <source>ref and unsafe in async and iterator methods</source>
        <target state="translated">ref и unsafe в асинхронных и итераторных методах</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelaxedShiftOperator">
        <source>relaxed shift operator</source>
        <target state="translated">нестрогий оператор сдвига</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRequiredMembers">
        <source>required members</source>
        <target state="translated">обязательные элементы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSealedToStringInRecord">
        <source>sealed ToString in record</source>
        <target state="translated">запечатанный ToString в записи</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSimpleLambdaParameterModifiers">
        <source>simple lambda parameter modifiers</source>
        <target state="new">simple lambda parameter modifiers</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStringEscapeCharacter">
        <source>string escape character</source>
        <target state="translated">escape-символ строки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStructFieldInitializers">
        <source>struct field initializers</source>
        <target state="translated">инициализаторы полей структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnboundGenericTypesInNameof">
        <source>unbound generic types in nameof operator</source>
        <target state="translated">не привязанные универсальные типы в операторе nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnsignedRightShift">
        <source>unsigned right shift</source>
        <target state="translated">сдвиг вправо без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUserDefinedCompoundAssignmentOperators">
        <source>user-defined compound assignment operators</source>
        <target state="new">user-defined compound assignment operators</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUtf8StringLiterals">
        <source>UTF-8 string literals</source>
        <target state="translated">Строковые литералы UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingTypeAlias">
        <source>using type alias</source>
        <target state="translated">использование псевдонима типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnAnonymousTypes">
        <source>with on anonymous types</source>
        <target state="translated">с использованием анонимных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAbstractMembersInInterfaces">
        <source>static abstract members in interfaces</source>
        <target state="translated">абстрактные статические элементы в интерфейсах</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnStructs">
        <source>with on structs</source>
        <target state="translated">с использованием структур</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSpanCharConstantPattern">
        <source>pattern matching ReadOnly/Span&lt;char&gt; on constant string</source>
        <target state="translated">сопоставление шаблонов ReadOnly/Span&lt;char&gt; в строке константы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Missing">
        <source>&lt;missing&gt;</source>
        <target state="translated">&lt;missing&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PointerElementAccess">
        <source>pointer element access</source>
        <target state="translated">доступ к элементу указателя</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ARRAY">
        <source>array</source>
        <target state="translated">множество</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_DYNAMIC">
        <source>dynamic</source>
        <target state="translated">динамический</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FUNCTION_POINTER">
        <source>function pointer</source>
        <target state="translated">указатель функции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_POINTER">
        <source>pointer</source>
        <target state="translated">указатель</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas">
        <source>Compiling requires binding the lambda expression at least {0} times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">Компиляция требует по крайней мере {0}-кратной привязки лямбда-выражения. Рассмотрите возможность объявления лямбда-выражения с явными типами параметров или, если содержащий его вызов метода является универсальным, рассмотрите возможность использования аргументов явного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas_Title">
        <source>Compiling requires binding the lambda expression many times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">Компиляция требует многократной привязки лямбда-выражения. Рассмотрите возможность объявления лямбда-выражения с явными типами параметров или, если содержащий его вызов метода является универсальным, рассмотрите возможность использования аргументов явного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISpreadOperationIsNotCSharpSpread">
        <source>{0} is not a valid C# spread operation</source>
        <target state="translated">{0} не является допустимой операцией расширения C#</target>
        <note />
      </trans-unit>
      <trans-unit id="NodeIsNotAwaitUsingDeclaration">
        <source>'node' is not an 'await using' declaration</source>
        <target state="new">'node' is not an 'await using' declaration</target>
        <note>node and await using are not localizable</note>
      </trans-unit>
      <trans-unit id="NodeIsNotAwaitUsingStatement">
        <source>'node' is not an 'await using' statement</source>
        <target state="new">'node' is not an 'await using' statement</target>
        <note>node and await using are not localizable</note>
      </trans-unit>
      <trans-unit id="ParameterRequiresTypeOrIdentifier">
        <source>ParameterSyntax requires either a type or an identifier.</source>
        <target state="new">ParameterSyntax requires either a type or an identifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AccessorDoesNotUseBackingField">
        <source>The '{0}' accessor of property '{1}' should use 'field' because the other accessor is using it.</source>
        <target state="translated">Метод '{0}' доступа к '{1}' должен использовать "field", так как он используется другим методом доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AccessorDoesNotUseBackingField_Title">
        <source>Property accessor should use 'field' because the other accessor is using it.</source>
        <target state="translated">Метод доступа к свойству должен использовать "field", так как он используется другим методом доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">Оператор "&amp;" не следует использовать для параметров или локальных переменных в асинхронных методах.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync_Title">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">Оператор "&amp;" не следует использовать для параметров или локальных переменных в асинхронных методах.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">Сборка "{0}", содержащая тип "{1}", ссылается на платформу .NET Framework, которая не поддерживается.</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">Загруженная сборка ссылается на платформу .NET Framework, которая не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler">
        <source>Analyzer assembly '{0}' cannot be used because it references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="needs-review-translation">Сборка анализатора "{0}" ссылается на версию "{1}" компилятора, являющуюся более новой, чем версия "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler_Title">
        <source>Analyzer assembly cannot be used because it references a newer version of the compiler than the currently running version.</source>
        <target state="needs-review-translation">Сборка анализатора ссылается на более новую версию компилятора, чем установленная сейчас.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn">
        <source>Argument {0} should be passed with the 'in' keyword</source>
        <target state="translated">Аргумент {0} должен передаваться с использованием ключевого слова "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn_Title">
        <source>Argument should be passed with the 'in' keyword</source>
        <target state="translated">Аргумент должен передаваться с использованием ключевого слова "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn">
        <source>Argument {0} should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">Аргумент {0} должен передаваться с использованием ключевого слова "ref" или "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn_Title">
        <source>Argument should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">Аргумент должен передаваться с использованием ключевого слова "ref" или "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef">
        <source>The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Модификатор "ref" для аргумента {0}, соответствующего параметру "in", эквивалентен "in". Попробуйте вместо этого использовать "in".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef_Title">
        <source>The 'ref' modifier for an argument corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Модификатор "ref" для аргумента, соответствующего параметру "in", эквивалентен "in". Попробуйте вместо этого использовать "in".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">Должен быть указан параметр атрибута "SizeConst".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired_Title">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">Должен быть указан параметр атрибута "SizeConst".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру "{0}" не подействует, поскольку он применен с недопустимым именем параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
        <source>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</source>
        <target state="translated">Класс CallerArgumentExpressionAttribute применен с недопустимым именем параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру "{0}" не подействует, так как он ссылается сам на себя.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
        <source>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру не подействует, поскольку он ссылается сам на себя.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Применение CallerArgumentExpressionAttribute к параметру "{0}" не подействует, поскольку он применяется к элементу, который использован в контекстах, где не разрешены необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute не подействует, поскольку он применяется к элементу, которые использован в контекстах, где не разрешены необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется классом CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">Класс CallerArgumentExpressionAttribute не подействует. Он переопределяется классом CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру "{0}" не подействует, он переопределен классом CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Класс CallerArgumentExpressionAttribute не подействует, он переопределен классом CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</source>
        <target state="translated">Применение класса CallerArgumentExpressionAttribute к параметру "{0}" не подействует, он будет переопределен классом CallerMemberNameAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</source>
        <target state="translated">Класс CallerArgumentExpressionAttribute не подействует, он переопределен классом CallerMemberNameAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Параметр ' {0} ' фиксируется в состоянии объемлющего типа, и его значение также используется для инициализации поля, свойства или события.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Параметр фиксируется в состоянии объемлющего типа, и его значение также используется для инициализации поля, свойства или события.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Параметр "{0}" записан в состоянии включающего типа, а его значение также передается базовому конструктору. Значение также может быть записано базовым классом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Параметр записан в состоянии включающего типа, а его значение также передается базовому конструктору. Значение также может быть записано базовым классом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">Выражение коллекции типа "{0}" может привести к непредвиденным выделениям кучи. Рассмотрите возможность явного создания массива, а затем преобразования в "{0}", чтобы сделать выделение явным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">Выражение коллекции может привести к непредвиденным выделениям кучи. Рассмотрите возможность явного создания массива, а затем преобразования в конечный тип, чтобы сделать выделение явным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">Выражение коллекции типа "{0}" может привести к непредвиденным выделениям кучи из-за использования расширений "..". Рассмотрите возможность явного создания массива, а затем преобразования в "{0}", чтобы сделать выделение явным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations due to use of '..' spreads. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">Выражение коллекции может привести к непредвиденным выделениям кучи из-за использования расширений "..". Рассмотрите возможность явного создания массива, а затем преобразования в конечный тип, чтобы сделать выделение явным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow">
        <source>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Операция может привести к переполнению "{0}" в среде выполнения (для переопределения используйте синтаксис "unchecked")</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow_Title">
        <source>The operation may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Операция может привести к переполнению в среде выполнения (для переопределения используйте синтаксис "unchecked")</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Значение типа "System.Threading.Lock", преобразованное в другой тип, будет использовать (скорее всего, непреднамеренную) блокировку на основе монитора в инструкции "lock".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock_Title">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Значение типа "System.Threading.Lock", преобразованное в другой тип, будет использовать (скорее всего, непреднамеренную) блокировку на основе монитора в инструкции "lock".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers">
        <source>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</source>
        <target state="translated">Сравнение указателей на функции может привести к непредвиденному результату, так как указатели на одну и ту же функцию могут быть разными.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers_Title">
        <source>Do not compare function pointer values</source>
        <target state="translated">Не сравнивайте значения указателей на функции</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference">
        <source>Analyzer reference '{0}' specified multiple times</source>
        <target state="translated">Ссылка анализатора "{0}" указана несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference_Title">
        <source>Analyzer reference specified multiple times</source>
        <target state="translated">Ссылка на анализатор указана несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</source>
        <target state="translated">Результат выражения stackalloc типа "{0}" в этом контексте может быть представлен за пределами содержащего его метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc_Title">
        <source>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</source>
        <target state="translated">Результат выражения stackalloc этого типа в этом контексте может быть представлен за пределами содержащего его метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable">
        <source>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Использование переменной "{0}" в этом контексте может выставить ссылочные переменные за пределы области их объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable_Title">
        <source>Use of variable in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Использование переменной в этом контексте может представить ссылочные переменные за пределами области их объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExperimentalWithMessage">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates: '{1}'. Suppress this diagnostic to proceed.</source>
        <target state="translated">"{0}" предназначен только для оценки и может быть изменен или удален в будущих обновлениях: "{1}". Чтобы продолжить, скройте эту диагностику.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExperimentalWithMessage_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Тип предназначен только для оценки и может быть изменен или удален в будущих обновлениях. Чтобы продолжить, скройте эту диагностику.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous">
        <source>In language version {0}, the 'field' keyword binds to a synthesized backing field for the property. To avoid generating a synthesized backing field, and to refer to the existing member, use 'this.field' or '@field' instead.</source>
        <target state="translated">В версии языка {0} ключевое слово "field" привязывается к синтезированному резервному полю для свойства. Чтобы не создавать синтезированное резервное поле и ссылаться на существующий элемент, используйте вместо этого "this.field" или "@field".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous_Title">
        <source>The 'field' keyword binds to a synthesized backing field for the property.</source>
        <target state="translated">Ключевое слово "field" привязывается к синтезированному резервному полю для свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">Оператор преобразования встроенного массива не будет использоваться для преобразования из выражения объявляющего типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed_Title">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">Оператор преобразования встроенного массива не будет использоваться для преобразования из выражения объявляющего типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">Индексатор встроенного массива не будет использоваться для выражения доступа к элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed_Title">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">Индексатор встроенного массива не будет использоваться для выражения доступа к элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">Функция языка "Встроенные массивы" не поддерживается для встроенного типа массива, который недопустим в качестве аргумента типа или использует тип элемента, недопустимый в качестве аргумента типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage_Title">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">Функция языка "Встроенные массивы" не поддерживается для встроенного типа массива, который недопустим в качестве аргумента типа или использует тип элемента, недопустимый в качестве аргумента типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Метод "Slice" встроенного массива не будет использоваться для выражения доступа к элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed_Title">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Метод "Slice" встроенного массива не будет использоваться для выражения доступа к элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.</source>
        <target state="translated">Модификатор типа ссылки параметра "{0}" не совпадает с соответствующим параметром "{1}" в скрытом элементе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in hidden member.</source>
        <target state="translated">Модификатор типа ссылки параметра не совпадает с соответствующим параметром в скрытом элементе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch">
        <source>Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.</source>
        <target state="translated">Перехват вызова ' {0} ' с перехватчиком ' {1} ', но подписи не совпадают.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch_Title">
        <source>Signatures of interceptable and interceptor methods do not match.</source>
        <target state="translated">Сигнатуры методов перехвата и перехватчика не совпадают.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptsLocationAttributeUnsupportedSignature">
        <source>'InterceptsLocationAttribute(string, int, int)' is not supported. Move to 'InterceptableLocation'-based generation of these attributes instead. (https://github.com/dotnet/roslyn/issues/72133)</source>
        <target state="translated">Атрибут InterceptsLocationAttribute(string, int, int)" не поддерживается. Вместо этого перейдите в поколение этих атрибутов на основе InterceptableLocation. (https://github.com/dotnet/roslyn/issues/72133)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptsLocationAttributeUnsupportedSignature_Title">
        <source>'InterceptsLocationAttribute(string, int, int)' is not supported. Move to 'InterceptableLocation'-based generation of these attributes instead. (https://github.com/dotnet/roslyn/issues/72133)</source>
        <target state="translated">Атрибут InterceptsLocationAttribute(string, int, int)" не поддерживается. Вместо этого перейдите в поколение этих атрибутов на основе InterceptableLocation. (https://github.com/dotnet/roslyn/issues/72133)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">Атрибут InterpolatedStringHandlerArgument не действует при применении к лямбда-параметрам и будет проигнорирован на сайте вызова.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">Атрибут InterpolatedStringHandlerArgument не действует при применении к лямбда-параметрам и будет проигнорирован на сайте вызова.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName">
        <source>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Имя типа "{0}" содержит только строчные символы ASCII. Такие имена могут резервироваться для языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName_Title">
        <source>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Имя типа содержит только строчные символы ASCII. Такие имена могут резервироваться для языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</source>
        <target state="translated">Это принимает адрес, получает размер или объявляет указатель на управляемый тип ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr_Title">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type</source>
        <target state="translated">Это принимает адрес, получает размер или объявляет указатель на управляемый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel">
        <source>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Преобразование группы методов "{0}" в незаменяемый тип "{1}". Вы намеревались вызвать этот метод?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel_Title">
        <source>Converting method group to non-delegate type</source>
        <target state="translated">Преобразование группы методов в незаменямый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ветви условного оператора ref ссылаются на переменные с несовместимыми областями объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary_Title">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ветви условного оператора ref ссылаются на переменные с несовместимыми областями объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.</source>
        <target state="translated">Обнуляемость ссылочных типов в типе параметра ' {0} ' не соответствует перехватываемому методу ' {1} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor_Title">
        <source>Nullability of reference types in type of parameter doesn't match interceptable method.</source>
        <target state="translated">Обнуляемость ссылочных типов в типе параметра не соответствует перехватываемому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor">
        <source>Nullability of reference types in return type doesn't match interceptable method '{0}'.</source>
        <target state="translated">Обнуляемость ссылочных типов в возвращаемом типе не соответствует перехватываемому методу ' {0} '.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor_Title">
        <source>Nullability of reference types in return type doesn't match interceptable method.</source>
        <target state="translated">Обнуляемость ссылочных типов в возвращаемом типе не соответствует перехватываемому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired">
        <source>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">У обязательного элемента "{0}" не должно быть атрибута "ObsoleteAttribute", если содержащий тип или все конструкторы не являются устаревшими.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired_Title">
        <source>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">Элементы с атрибутом "ObsoleteAttribute" не должны быть обязательными, если содержащий тип или все конструкторы не являются устаревшими.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch">
        <source>Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.</source>
        <target state="translated">Параметр {0} имеет значение по умолчанию "{1:10}" в лямбде, но "{2:10}" в типе целевого делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch_Title">
        <source>The default parameter value does not match in the target delegate type.</source>
        <target state="translated">Значение параметра по умолчанию не совпадает с типом целевого делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.</source>
        <target state="translated">Модификатор типа ссылки параметра "{0}" не совпадает с соответствующим параметром "{1}" в переопределенном или реализованном элементе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in overridden or implemented member.</source>
        <target state="translated">Модификатор типа ссылки параметра не совпадает с соответствующим параметром в переопределенном или реализованном элементе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull">
        <source>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</source>
        <target state="translated">При выходе параметр "{0}" должен иметь значение, отличное от NULL, так как параметр "{1}" имеет значение, отличное от NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull_Title">
        <source>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</source>
        <target state="translated">При выходе параметр должен иметь значение, отличное от NULL, так как параметр, на который ссылается NotNullIfNotNull, имеет значение, отличное от NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
        <source>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.</source>
        <target state="translated">Параметр {0} указан после {1} в списке параметров, но используется в качестве аргумента для преобразований обработчика интерполированных строк. В этом случае вызывающий должен изменить порядок параметров с именованными аргументами на сайте вызова. Рекомендуем разместить параметр обработчика интерполированных строк после всех используемых аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
        <source>Parameter to interpolated string handler conversion occurs after handler parameter</source>
        <target state="translated">Параметр преобразования обработчика интерполированных строк находится позже параметра обработчика</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly">
        <source>Parameter {0} has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">У параметра {0} есть модификатор params в лямбде, но не в типе целевого делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly_Title">
        <source>Parameter has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">У параметра есть модификатор params в лямбде, но не в типе целевого делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMemberSignatureDifference">
        <source>Partial member declarations '{0}' and '{1}' have signature differences.</source>
        <target state="new">Partial member declarations '{0}' and '{1}' have signature differences.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMemberSignatureDifference_Title">
        <source>Partial member declarations have signature differences.</source>
        <target state="new">Partial member declarations have signature differences.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase">
        <source>Primary constructor parameter '{0}' is shadowed by a member from base.</source>
        <target state="translated">Параметр "{0}" первичной конструкции затемнен элементом из базы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase_Title">
        <source>Primary constructor parameter is shadowed by a member from base</source>
        <target state="translated">Параметр первичной конструкции затемнен элементом из базы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode">
        <source>'{0}' defines 'Equals' but not 'GetHashCode'</source>
        <target state="translated">"{0}" определяет "Equals", но не "GetHashCode"</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode_Title">
        <source>Record defines 'Equals' but not 'GetHashCode'.</source>
        <target state="translated">Запись определяет "Equals", но не "GetHashCode".</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
        <source>Mixed declarations and expressions in deconstruction</source>
        <target state="translated">Смешанные объявления и выражения в деконструировании</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference">
        <source>Partial method declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">Объявления разделяемого метода "{0}" и "{1}" имеют различия в сигнатуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference_Title">
        <source>Partial method declarations have signature differences.</source>
        <target state="translated">Объявления разделяемого метода имеют различия в сигнатуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Типы и псевдонимы не могут иметь имя "record"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed_Title">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Типы и псевдонимы не могут иметь имя "record"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RedundantPattern">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RedundantPattern_Title">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Это присваивает по ссылке "{1}" "{0}", но "{1}" имеет более узкую область выхода, чем "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower_Title">
        <source>This ref-assigns a value that has a narrower escape scope than the target.</source>
        <target state="translated">Это присваивает по ссылке значение с более узкой областью выхода, чем у целевого объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">Это присваивает по ссылке "{1}" "{0}", но "{1}" может избежать текущего метода только через оператор return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly_Title">
        <source>This ref-assigns a value that can only escape the current method through a return statement.</source>
        <target state="translated">Это присваивает по ссылке значение, которое может избежать текущего метода только через оператор return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.</source>
        <target state="translated">Эта ссылка присваивает "{1}" значение "{0}", но "{1}" имеет более широкую область действия значения, чем "{0}", позволяя назначать через "{0}" значения с более узкой областью действия, чем "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider_Title">
        <source>This ref-assigns a value that has a wider value escape scope than the target allowing assignment through the target of values with narrower escapes scopes.</source>
        <target state="translated">Это присваивает по ссылке значение, которое имеет более широкую область выхода, чем цель, что позволяет присваивать через цель значения с более узкими областями выхода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable">
        <source>Argument {0} should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">Аргумент {0} должен быть переменной, так как он передается параметру "ref readonly"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable_Title">
        <source>Argument should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">Аргумент должен быть переменной, так как он передается параметру "ref readonly"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue">
        <source>A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Значение по умолчанию указано для параметра "ref readonly" "{0}", но "ref readonly" следует использовать только для ссылок. Рассмотрите возможность объявления параметра как "in".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue_Title">
        <source>A default value is specified for 'ref readonly' parameter, but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Значение по умолчанию указано для параметра "ref readonly", но "ref readonly" следует использовать только для ссылок. Рассмотрите возможность объявления параметра как "in".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal">
        <source>This returns local '{0}' by reference but it is not a ref local</source>
        <target state="translated">Это возвращает local "{0}" по ссылке, но это не ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2">
        <source>This returns a member of local '{0}' by reference but it is not a ref local</source>
        <target state="translated">Это возвращает элемент local "{0}" по ссылке, но это не ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2_Title">
        <source>This returns a member of local by reference but it is not a ref local</source>
        <target state="translated">Это возвращает элемент local по ссылке, но это не ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal_Title">
        <source>This returns local by reference but it is not a ref local</source>
        <target state="translated">Это возвращает local по ссылке, но не является ref local</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal">
        <source>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Local "{0}" возвращается по ссылке, но инициализирован значением, которое не может быть возвращено по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2">
        <source>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Элемент "{0}" возвращается по ссылке, но инициализирован значением, которое не может быть возвращено по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2_Title">
        <source>A member is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Элемент возвращается по ссылке, но инициализирован значением, которое не может быть возвращено по ссылке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal_Title">
        <source>Local is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Local возвращается по ссылке, но инициализирован значением, которое не может быть возвращено по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter">
        <source>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Это возвращает параметр по ссылке "{0}" с помощью параметра ref; однако его можно безопасно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2">
        <source>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Это возвращает по ссылке элемент параметра "{0}" через параметр ref, но его можно безопасно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2_Title">
        <source>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Это возвращает по ссылке элемент параметра через параметр ref, но его можно безопасно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter_Title">
        <source>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Это возвращает параметр по ссылке через параметр ref, но его можно безопасно вернуть только в операторе return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter">
        <source>This returns a parameter by reference '{0}' but it is not a ref parameter</source>
        <target state="translated">Это возвращает параметр по ссылке "{0}", но это не является параметром ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2">
        <source>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</source>
        <target state="translated">Это возвращает по ссылке элемент параметра "{0}", который не является параметром ref или out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2_Title">
        <source>This returns by reference a member of parameter that is not a ref or out parameter</source>
        <target state="translated">Это возвращает по ссылке элемент параметра, не являющийся параметром ref или out.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter_Title">
        <source>This returns a parameter by reference but it is not a ref parameter</source>
        <target state="translated">Это возвращает параметр по ссылке, но это не параметр ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter">
        <source>This returns a parameter by reference '{0}' but it is scoped to the current method</source>
        <target state="translated">Это возвращает параметр по ссылке "{0}", но он находится в области действия текущего метода</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2">
        <source>This returns by reference a member of parameter '{0}' that is scoped to the current method</source>
        <target state="translated">Это возвращает по ссылке элемент параметра "{0}", который имеет область действия текущего метода</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2_Title">
        <source>This returns by reference a member of parameter that is scoped to the current method</source>
        <target state="translated">Это возвращает по ссылке элемент параметра, относящийся к текущему методу</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter_Title">
        <source>This returns a parameter by reference but it is scoped to the current method</source>
        <target state="translated">Это возвращает параметр по ссылке, но он привязан к текущему методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Элемент структуры возвращает "этот" или другие элементы экземпляра по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis_Title">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Элемент структуры возвращает "этот" или другие элементы экземпляра по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull">
        <source>Return value must be non-null because parameter '{0}' is non-null.</source>
        <target state="translated">Возвращаемое значение должно быть отлично от NULL, так как параметр "{0}" имеет значение, отличное от NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull_Title">
        <source>Return value must be non-null because parameter is non-null.</source>
        <target state="translated">Возвращаемое значение должно быть отлично от NULL, так как параметр имеет значение, отличное от NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Модификатор "scoped" параметра "{0}" не совпадает с переопределенным или реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
        <source>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</source>
        <target state="translated">Модификатор "scoped" параметра не соответствует переопределенному или реализованному элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Модификатор "scoped" параметра "{0}" не соответствует целевому "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget_Title">
        <source>The 'scoped' modifier of parameter doesn't match target.</source>
        <target state="translated">Модификатор "scoped" параметра не соответствует целевому объекту.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые типы входных значений, в том числе неименованное значение перечисления (не является исчерпывающим). Например, не охвачен шаблон "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые типы входных значений, в том числе неименованное значение перечисления (не является исчерпывающим).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SyncAndAsyncEntryPoints">
        <source>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</source>
        <target state="translated">Метод "{0}" не будет использоваться в качестве точки входа, так как была найдена синхронная точка входа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotFound">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">Тип "{0}" не определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentList">
        <source>Unexpected argument list.</source>
        <target state="translated">Непредвиденный список аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedOrMissingConstructorInitializerInRecord">
        <source>A constructor declared in a type with parameter list must have 'this' constructor initializer.</source>
        <target state="translated">Конструктор, объявленный в типе со списком параметров, должен содержать инициализатор конструктора "this".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVarianceStaticMember">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</source>
        <target state="translated">Недопустимая вариантность: если не используется как минимум версия языка "{4}", параметр типа "{1}" должен быть допустимым ({3}) для "{0}". Состояние "{1}": {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">"{0}": невозможно одновременно задать класс ограничения и ограничение "unmanaged"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
        <source>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</source>
        <target state="translated">Методы с атрибутом "UnmanagedCallersOnly" не могут иметь параметры универсального типа и не могут быть объявлены в универсальном типе.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyRequiresStatic">
        <source>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</source>
        <target state="translated">"UnmanagedCallersOnly" может применяться только к обычным статическим неабстрактным и невиртуальным методам или к статическим локальным функциям.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Чтобы тип "{2}" можно было использовать как параметр "{1}" в универсальном типе метода "{0}", он должен быть типом значения, который, как и все поля на любом уровне вложения, не допускает значения NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCallingConvention">
        <source>The calling convention of '{0}' is not supported by the language.</source>
        <target state="translated">Соглашение о вызовах "{0}" не поддерживается в данном языке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForRelationalPattern">
        <source>Relational patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Реляционные шаблоны не могут использоваться для значений типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">Переменную using невозможно использовать напрямую в разделе switch (рекомендуется использовать скобки). </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">Синтаксису "var" для шаблона запрещено ссылаться на тип, но "{0}" здесь входит в область.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">Перечисления, классы и структуры не могут быть объявлены в интерфейсе, имеющем параметр типа "In" или "Out".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongFuncPtrCallingConvention">
        <source>Calling convention of '{0}' is not compatible with '{1}'.</source>
        <target state="translated">Соглашение о вызовах "{0}" несовместимо с "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">Для сопоставления типа кортежа "{0}" требуются вложенные шаблоны "{1}", но сейчас есть вложенные шаблоны "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Имя файла "{0}" пустое, содержит недопустимые символы, имеет имя диска без абсолютного пути или слишком длинное.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AddressOfMethodGroup">
        <source>&amp;method group</source>
        <target state="translated">&amp;группа методов</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0 or higher) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.
-skipanalyzers[+|-]           Skip execution of diagnostic analyzers.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-sdkpath:&lt;path&gt;         Path used to search for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
-generatedfilesout:&lt;dir&gt;      Place files generated during compilation in the
                              specified directory.
-reportivts[+|-]                    Output information on all IVTs granted to this
                              assembly by all dependencies, and annotate foreign assembly
                              accessibility errors with what assembly they came from.
</source>
        <target state="needs-review-translation">
                             Параметры компилятора Visual C#

                       - ВЫХОДНЫЕ ФАЙЛЫ -
-out:&lt;file&gt;                   Укажите имя выходного файла (по умолчанию: базовое имя
                              файл с основным классом или первый файл)
-target:exe                   Создать исполняемый файл консоли (по умолчанию) (сокращение
                              форма: -t:exe)
-target:winexe                Создать исполняемый файл Windows (краткая форма:
                              -t:winexe)
-target:library               Создать библиотеку (краткая форма: -t:library)
-target:module                Создать модуль, который можно добавить к другому
                              сборка (краткая форма: -t:модуль)
-target:appcontainerexe       Создать исполняемый файл Appcontainer (краткая форма:
                              -t:appcontainerexe)
-target:winmdobj              Создать промежуточный файл среды выполнения Windows, который
                              потребляется WinMDExp (краткая форма: -t:winmdobj)
-doc:&lt;file&gt;                   Файл XML-документации для создания
-refout:&lt;file&gt;                Ссылка на выходные данные сборки для создания
-platform:&lt;string&gt;            Ограничить платформы, на которых может работать этот код: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred или
                              любой процессор. По умолчанию используется любой процессор.

                       - ВХОДНЫЕ ФАЙЛЫ -
--recurse:&lt;wildcard&gt;           Включить все файлы в текущем каталоге и
                              подкаталогах в соответствии с подстановочными
                              знаками
-reference:&lt;alias&gt;=&lt;file&gt;     Ссылка на метаданные из указанного файла сборки
                              с использованием заданного псевдонима (краткая форма: -r)
-reference:&lt;file list&gt;        Ссылочные метаданные из указанных файлов
                              сборки (краткая форма: -r)
-addmodule:&lt;file list&gt;        Связать указанные модули с этой сборкой
-link:&lt;file list&gt;             Внедрить метаданные из указанных файлов
                              сборки взаимодействия (краткая форма: -l)
-analyzer:&lt;file list&gt;         Запустить анализаторы из этой сборки
                              (Краткая форма: -а)
-additionalfile:&lt;file list&gt; Дополнительные файлы, не влияющие напрямую на генерацию
                              кода, но которые могут использоваться анализаторами для создания
                              ошибок и предупреждений.
-embed                        Встроить все исходные файлы в PDB.
-embed:&lt;file list&gt;            Встроить определенные файлы в PDB.

                       - РЕСУРСЫ -
-win32res:&lt;file&gt;              Укажите файл ресурсов Win32 (.res)
-win32icon:&lt;file&gt;             Использовать этот значок для вывода
-win32manifest:&lt;file&gt;         Укажите файл манифеста Win32 (.xml)
-nowin32manifest              Не включать манифест Win32 по умолчанию
-resource:&lt;resinfo&gt;           Встроить указанный ресурс (краткая форма: -res)
-linkresource:&lt;resinfo&gt;       Связать указанный ресурс с этой сборкой
                              (Короткая форма: -linkres) Где формат resinfo
                              равен &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - ГЕНЕРАЦИЯ КОДА -
-debug[+|-]                   Выдать отладочную информацию
-debug:{full|pdbonly|portable|embedded}
                              Укажите тип отладки («полный» по умолчанию,
                              «портативный» — это кроссплатформенный формат,
                              'встроенный' – это кроссплатформенный формат, встроенный в
                              целевой файл .dll или .exe)
-optimize[+|-]                Включить оптимизацию (краткая форма: -o)
-optimize[+|-]                Производство детерминированной сборки
                              (включая GUID версии модуля и метку времени)
-refonly                      Изготовить эталонную сборку вместо основной продукции
-instrument:TestCoverage      Создать сборку, предназначенную для сбора
                              сведений об охвате
-sourcelink:&lt;file&gt;            Информация об исходной ссылке для встраивания в PDB.

                       - ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ -
-warnaserror[+|-]             Сообщить обо всех предупреждениях как об ошибках
-warnaserror[+|-]:&lt;warn list&gt; Сообщать об определенных предупреждениях как об ошибках
                              (используйте "nullable" для всех предупреждений об отсутствии значений)
-warn:&lt;n&gt;                     Установить уровень предупреждения (0 или выше) (краткая форма: -w)
-nowarn:&lt;warn list&gt;           Отключить определенные предупреждающие сообщения
                              (используйте "nullable" для всех предупреждений об отсутствии значений)
-ruleset:&lt;file&gt;               Укажите файл набора правил, который отключает определенную
                              диагностики.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Укажите файл для регистрации всего компилятора и анализатора
                              диагностики.
                              sarif_version:{1|2|2.1} По умолчанию 1. 2 и 2.1
                              оба означают SARIF версии 2.1.0.
-reportanalyzer               Сообщать дополнительную информацию об анализаторе, такую как
                              время выполнения.
-skipanalyzers[+|-]           Пропустить выполнение диагностических анализаторов.

                       - ЯЗЫК -
-checked[+|-]                 Генерировать проверки переполнения
-unsafe[+|-]                  Разрешить «небезопасный» код
-define:&lt;symbol list&gt;         Определить символ(ы) условной компиляции (краткая
                              форма: -d)
-langversion:?                Показать допустимые значения для языковой версии
-langversion:&lt;string&gt;         Укажите языковую версию, например
                              `latest` (последняя версия, включая дополнительные версии),
                              `default` (то же, что и `последняя`),
                              `latestmajor` (последняя версия, исключая дополнительные версии),
                              `preview` (последняя версия, включая функции в неподдерживаемой предварительной версии),
                              или специальные версии, такие как «6» или «7.1»
-nullable[+|-]                Указать параметр контекста, допускающий значение null, enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Укажите параметр контекста, допускающий значение NULL, enable|disable|warnings|annotations.

                       - БЕЗОПАСНОСТЬ -
-delaysign[+|-]               Отложить подписание сборки, используя только открытый
                              части ключа строгого имени
-publicsign[+|-]              Общедоступная подпись сборки с использованием только общедоступной
                              части ключа строгого имени
-keyfile:&lt;file&gt;               Укажите файл ключа со строгим именем
-keycontainer:&lt;string&gt;        Укажите контейнер ключей строгого имени
-highentropyva[+|-]           Включить высокоэнтропийный ASLR

                       - РАЗНОЕ -
@&lt;file&gt;                       Прочтите файл ответов, чтобы узнать о дополнительных параметрах
-help                         Показать это сообщение об использовании (краткая форма: -?)
-nologo                       Подавить сообщение об авторских правах компилятора
-nologo                       Не включать автоматически файл CSC.RSP
-parallel[+|-]                Параллельная сборка.
-version                      Показать номер версии компилятора и выйти.

                       - РАСШИРЕННЫЙ -
-baseaddress:&lt;address&gt;        Базовый адрес для создаваемой библиотеки
-checksumalgorithm:&lt;alg&gt;      Указать алгоритм вычисления контрольной суммы исходного файла,
                              хранящегося в PDB. Поддерживаемые значения:
                              SHA1 или SHA256 (по умолчанию).
-codepage:&lt;n&gt;                 Укажите кодовую страницу для использования при открытии исходных
                              файлов
-utf8output                   Выводить сообщения компилятора в кодировке UTF-8
-main:&lt;type&gt;                  Укажите тип, который содержит точку входа
                              (игнорировать все другие возможные точки входа) (короткая
                              форма: -m)
-fullpaths                    Компилятор создает полные пути
-filealign:&lt;n&gt;                Укажите выравнивание, используемое для разделов
                              выходного файла
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Укажите сопоставление для имен исходных путей, выводимых с помощью
.
                              компилятора.
-pdb:&lt;file&gt;                   Указать имя файла отладочной информации (по умолчанию:
                              имя выходного файла с расширением .pdb)
-errorendlocation             Строка вывода и столбец конечного местоположения
                              каждой ошибки
-preferreduilang              Укажите предпочтительное имя языка вывода.
-nosdkpath                    Отключить поиск стандартных библиотечных сборок по пути SDK по умолчанию.
-nostdlib[+|-]                Не ссылаться на стандартную библиотеку (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Укажите версию подсистемы этой сборки
-lib:&lt;file list&gt;              Указать дополнительные каталоги для поиска
                              ссылок
-errorreport:&lt;string&gt;         Укажите, как обрабатывать внутренние ошибки компилятора:
                              запросить, отправить, поставить в очередь или никаких действий. Значение по умолчанию
                              очередь.
-appconfig:&lt;file&gt;             Указать файл конфигурации приложения
                              содержащий параметры привязки сборки
-moduleassemblyname:&lt;string&gt; Название сборки, частью которой будет
                              этот модуль
-modulename:&lt;string&gt;          Укажите имя исходного модуля
-generatedfilesout:&lt;dir&gt;      Поместить файлы, сгенерированные во время компиляции, в
                              указанный каталог.
-reportivts[+|-]                    Вывести информацию обо всех IVT, предоставленных этой
                              сборке по всем зависимостям и аннотировать ошибки доступности
                              сторонних сборок с указанием того, из какой сборки они произошли..
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">реализация интерфейса по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">высвобождаемый</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">альтернативные интерполированные буквальные строки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAndPattern">
        <source>and pattern</source>
        <target state="translated">и шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">асинхронный оператор using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">назначение объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureConstantInterpolatedStrings">
        <source>constant interpolated strings</source>
        <target state="translated">константные интерполированные строки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultTypeParameterConstraint">
        <source>default type parameter constraints</source>
        <target state="translated">ограничения параметров типа по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">ограничения универсального типа для делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">ограничения универсального типа перечисления</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">объявление переменных выражения в инициализаторах члена и запросах</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPartialMethods">
        <source>extended partial methods</source>
        <target state="translated">расширенные разделяемые методы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">расширяемый оператор fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetAsyncEnumerator">
        <source>extension GetAsyncEnumerator</source>
        <target state="translated">GetAsyncEnumerator расширения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetEnumerator">
        <source>extension GetEnumerator</source>
        <target state="translated">GetEnumerator расширения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="translated">Внешние локальные функции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFunctionPointers">
        <source>function pointers</source>
        <target state="translated">указатели на функцию</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">оператор index</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">индексирование перемещаемых буферов фиксированного размера</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInitOnlySetters">
        <source>init-only setters</source>
        <target state="translated">методы задания значения, вызываемые только при инициализации</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="translated">Атрибуты локальной функции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">Параметры удаления лямбда-выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureMemberNotNull">
        <source>MemberNotNull attribute</source>
        <target state="translated">Атрибут MemberNotNull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleInitializers">
        <source>module initializers</source>
        <target state="translated">инициализаторы модулей</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">скрытие имен во вложенных функциях</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNativeInt">
        <source>native-sized integers</source>
        <target state="translated">целые числа собственного размера</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">stackalloc во вложенных выражениях</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">ограничение универсального типа notnull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotPattern">
        <source>not pattern</source>
        <target state="translated">не шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPointerConstantPattern">
        <source>null pointer constant pattern</source>
        <target state="translated">Указатель на шаблон константы имеет значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">ссылочные типы, допускающие значение NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">устарело для метода доступа к свойству</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOrPattern">
        <source>or pattern</source>
        <target state="translated">или шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParenthesizedPattern">
        <source>parenthesized pattern</source>
        <target state="translated">шаблон в круглых скобках</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">действие warning с enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">оператор range</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">члены только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecords">
        <source>records</source>
        <target state="translated">записи</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">рекурсивные шаблоны</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">Условное выражение ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">переменные цикла for-loop для ссылки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">переменные итерации foreach для ссылки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">повторное назначение по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelationalPattern">
        <source>relational pattern</source>
        <target state="translated">реляционный шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">инициализатор stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAnonymousFunction">
        <source>static anonymous function</source>
        <target state="translated">статическая анонимная функция</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">статические локальные функции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;выражения для выбора вариантов&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTargetTypedConditional">
        <source>target-typed conditional expression</source>
        <target state="translated">условное выражение с целевым типом</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">равенство кортежей</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypePattern">
        <source>type pattern</source>
        <target state="translated">шаблон типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">параметры неограниченного типа в операторе объединения со значением NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">неуправляемые сконструированные типы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">ограничения неуправляемого универсального типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">объявления using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
        <source>variance safety for static interface members</source>
        <target state="translated">безопасность вариантности для статических элементов интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;NULL&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">ограничения для методов переопределения и явной реализации интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Parameter">
        <source>parameter</source>
        <target state="translated">параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Return">
        <source>return</source>
        <target state="translated">возвращаемый</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;выражение throw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(Местоположение символа, связанного с предыдущей ошибкой)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(Местоположение символа, связанного с предыдущим предупреждением)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TopLevelStatements">
        <source>top-level statements</source>
        <target state="translated">инструкции верхнего уровня</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> Невозможно включить некорректный файл XML "{0}". </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> Сбой при вставке некоторых или всех включенных XML </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Недопустимый тег Include </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated">Не обнаружено элементов, соответствующих тегу include. </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">Отсутствует атрибут file</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">Отсутствует атрибут path</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;глобальное пространство имен&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">универсальные типы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">анонимные методы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">модуль как спецификатор конечного объекта атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">квалификатор псевдонима пространства имен</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">буферы фиксированного размера</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">статические классы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">структуры только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">разделяемые типы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">асинхронная функция</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">выбор по значению логического типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">группа методов</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">анонимный метод</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">лямбда-выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">коллекция</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">модификаторы доступа в свойствах</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">внешний псевдоним</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">итераторы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">оператор по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">литерал по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">частный защищенный</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">типы, допускающие значение NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">сопоставление шаблону</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">метод доступа к свойству тела выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">конструктор и деструктор тела выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">выражение Throw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">неявно типизированный массив</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">неявно типизированная локальная переменная</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">анонимные типы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">автоматически реализованные свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">автоматически реализуемые свойства только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">инициализатор объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">инциализатор коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">выражение запроса</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">метод расширения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">разделяемый метод</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">метод</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">тип</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">пространство имен</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">поле</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">элемент</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">переменная</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">метка</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">событие</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">параметр типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">псевдоним using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">внешний псевдоним</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">конструктор</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">переменная цикла foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">переменная fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">переменная using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">контравариантный</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">контравариантно</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">ковариантный</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">ковариантно</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">инвариантно</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">динамический</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">именованный аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">необязательный параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">фильтр исключений</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">вариантность типа</target>
        <note />
      </trans-unit>
      <trans-unit id="NotSameNumberParameterTypesAndRefKinds">
        <source>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</source>
        <target state="translated">Заданные типы параметров {0} и типы ссылок на параметры {1}. Эти массивы должны иметь одинаковую длину.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutIsNotValidForReturn">
        <source>'RefKind.Out' is not a valid ref kind for a return type.</source>
        <target state="translated">RefKind.Out не является допустимым типом ссылки для типа возвращаемого значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">SyntaxTree не входит в компиляцию</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">SyntaxTree не входит в компиляцию, поэтому его невозможно удалить</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">Имя "_" ссылается на константу, а не на шаблон отмены. Используйте "var _", чтобы отменить значение, или "@_", чтобы сослаться на константу по этому имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">Не используйте "_" для константы case.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked">
        <source>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Константное значение "{0}" может привести к переполнению "{1}" во время выполнения (для переопределения используйте синтаксис "unchecked").</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked_Title">
        <source>Constant value may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Константное значение может привести к переполнению во время выполнения (для переопределения используйте синтаксис "unchecked")</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Преобразование литерала, допускающего значение NULL или возможного значения NULL в тип, не допускающий значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Преобразование литерала, допускающего значение NULL или возможного значения NULL в тип, не допускающий значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Возможное значение NULL не может использоваться для типа, помеченного как [NotNull] или [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Возможное значение NULL не может использоваться для типа, помеченного как [NotNull] или [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">В методе "{0}" отсутствует аннотация "[DoesNotReturn]" для сопоставления реализованного или переопределенного члена.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">В методе отсутствует аннотация "[DoesNotReturn]" для сопоставления реализованного или переопределенного члена.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">"{0}" уже указан в списке интерфейсов типа "{1}"с другой допустимостью значений NULL ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">Интерфейс уже указан в списке интерфейсов с другой допустимостью значений NULL ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Генератору "{0}" не удалось создать источник. Это не повлияет на выходные данные и ошибки компиляции, которые могут возникнуть в результате. Тип возникшего исключения: "{1}", сообщение: "{2}".
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">Генератору не удалось создать источник.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Не удалось инициализировать генератор "{0}". Это не повлияет на выходные данные и ошибки компиляции, которые могут возникнуть в результате. Тип возникшего исключения: "{1}", сообщение: "{2}".
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">Не удалось инициализировать генератор.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Указанное выражение всегда соответствует предоставленной константе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">Указанное выражение всегда соответствует предоставленной константе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">Указанное выражение всегда соответствует предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern_Title">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">Указанное выражение всегда соответствует предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Указанное выражение никогда не соответствует предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">Указанное выражение никогда не соответствует предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">Вызов члена "{0}", не являющегося доступным только для чтения, из члена readonly приводит к появлению неявной копии "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">Вызов члена, не являющегося доступным только для чтения, из члена readonly приводит к появлению неявной копии.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways">
        <source>An expression of type '{0}' always matches the provided pattern.</source>
        <target state="translated">Выражение типа "{0}" всегда соответствует предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways_Title">
        <source>The input always matches the provided pattern.</source>
        <target state="translated">Входные данные всегда соответствуют предоставленному шаблону.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">Имя "_" ссылается на тип "{0}", а не на шаблон отмены. Используйте "@_" в качестве типа или "var _" для отмены.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">Не используйте "_" для ссылки на тип в выражении is-type.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull">
        <source>Member '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Элемент "{0}" должен иметь значение, отличное от NULL, при выходе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember">
        <source>Member '{0}' cannot be used in this attribute.</source>
        <target state="translated">Элемент "{0}" не может использоваться в этом атрибуте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember_Title">
        <source>Member cannot be used in this attribute.</source>
        <target state="translated">Элемент не может использоваться в этом атрибуте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen">
        <source>Member '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Элемент "{0}" должен иметь значение, отличное от NULL, при выходе с "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen_Title">
        <source>Member must have a non-null value when exiting in some condition.</source>
        <target state="translated">Элемент должен иметь значение, отличное от NULL, при выходе в определенном состоянии.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull_Title">
        <source>Member must have a non-null value when exiting.</source>
        <target state="translated">Элемент должен иметь значение, отличное от NULL, при выходе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Аннотацию для ссылочных типов, допускающих значения NULL, следует использовать в коде только в контексте аннотаций "#nullable".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Заметка к ссылочным типам, допускающим значение NULL, должна использоваться в коде только в контексте заметок "#nullable". Автоматически создаваемый исходный код требует директиву "#nullable" в явном виде.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Заметка к ссылочным типам, допускающим значение NULL, должна использоваться в коде только в контексте заметок "#nullable". Автоматически создаваемый исходный код требует директиву "#nullable" в явном виде.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">Аннотацию для ссылочных типов, допускающих значения NULL, следует использовать в коде только в контексте аннотаций "#nullable".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Литерал, равный NULL, не может быть преобразован в ссылочный тип, не допускающий значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Литерал, равный NULL, не может быть преобразован в ссылочный тип, не допускающий значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">Возможно, аргумент-ссылка, допускающий значение NULL, для параметра "{0}" в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">Возможно, аргумент-ссылка, допускающий значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">Возможно, назначение-ссылка, допускающее значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">Возможно, назначение-ссылка, допускающее значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">Инициализатор объекта или коллекции неявно разыменовывает член "{0}", который может быть равен NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">Инициализатор объекта или коллекции неявно разыменовывает член, который может быть равен NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Разыменование вероятной пустой ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Разыменование вероятной пустой ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">Возможно, возврат ссылки, допускающей значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">Возможно, возврат ссылки, допускающей значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Аргумент типа "{0}" запрещено использовать для параметра "{2}" типа "{1}" в "{3}" из-за различий в отношении допустимости значений NULL для ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Аргумент типа "{0}" запрещено использовать в качестве выходных данных типа "{1}" для параметра "{2}" в "{3}" из-за различий в отношении допустимости значений NULL для ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Аргумент запрещено использовать в качестве выходных данных для параметра из-за различий в отношении допустимости значений NULL для ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Аргумент запрещено использовать для параметра из-за различий в отношении допустимости значений NULL для ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">Допустимость значения NULL в значении типа "{0}" не соответствует целевому типу "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в значении не соответствует целевому типу.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Допустимость значения NULL в ограничениях для параметра типа "{0}" метода "{1}" не соответствует ограничениям параметра типа "{2}" метода интерфейса "{3}". Рассмотрите возможность явной реализации интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">Допустимость значения NULL в ограничениях для параметра типа не соответствует ограничениям параметра типа в явно реализованном методе интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">Несогласованные ограничения допустимости значения NULL для параметра типа "{1}" в частичных объявлениях метода "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">Несогласованные ограничения допустимости значения NULL для параметра типа в частичных объявлениях метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Допустимость значения NULL ссылочных типов в явном указателе интерфейсов не соответствует интерфейсу, реализованному типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Допустимость значения NULL ссылочных типов в явном указателе интерфейсов не соответствует интерфейсу, реализованному типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">"{0}" не реализует элемент интерфейса "{1}". Допустимость значения NULL ссылочных типов в интерфейсе, реализованном базовым типом, не совпадает.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Тип не реализует элемент интерфейса. Допустимость значения NULL ссылочных типов в интерфейсе, реализованном базовым типом, не совпадает.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра "{0}" объекта "{1}" не соответствует целевому объекту делегирования "{2}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра не соответствует целевому объекту делегирования (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра "{0}" не совпадает с реализованным членом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра не совпадает с реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра "{0}" объекта "{1}" не совпадает с явно реализованным членом "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра не совпадает с явно реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра "{0}" не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра "{0}" не совпадает с частичным объявлением метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе параметра не совпадает с частичным объявлением метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения "{0}" не соответствует целевому объекту делегирования "{1}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения не соответствует целевому объекту делегирования (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в возвращаемом типе не совпадает с реализованным членом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в возвращаемом типе не совпадает с реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения объекта "{0}" не совпадает с явно реализованным членом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в возвращаемом типе не совпадает с явно реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в возвращаемом типе не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в возвращаемом типе не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе возвращаемого значения не совпадает с объявлением разделяемого метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе возвращаемого значения не совпадает с объявлением разделяемого метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе не совпадает с реализованным членом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе не совпадает с реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе объекта "{0}" не совпадает с явно реализованным членом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе не совпадает с явно реализованным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Допустимость значения NULL для ссылочных типов в типе не совпадает с переопределенным членом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Допустимость значения NULL для аргумента типа "{3}" не соответствует типу ограничения "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">Тип не может быть использован как параметр типа в универсальном типе или методе. Допустимость значения NULL для аргумента типа не соответствует типу ограничения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">Тип "{2}" не может быть использован как параметр типа "{1}" в универсальном типе или методе "{0}". Допустимость значения NULL для аргумента типа "{2}" не соответствует ограничению "notnull".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">Тип не может быть использован как параметр типа в универсальном типе или методе. Допустимость значения NULL для аргумента типа не соответствует ограничению "notnull".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">Тип "{2}" не может быть использован как параметр типа "{1}" в универсальном типе или методе "{0}". Допустимость значения NULL для аргумента типа "{2}" не соответствует ограничению "class".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">Тип не может быть использован как параметр типа в универсальном типе или методе. Допустимость значения NULL для аргумента типа не соответствует ограничению "class".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Тип значения, допускающего NULL, может быть NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Тип значения, допускающего NULL, может быть NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">До передачи управления из текущего метода параметру, помеченному ключевым словом out, "{0}" должно быть присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned_Title">
        <source>An out parameter must be assigned to before control leaves the method</source>
        <target state="translated">Параметру out должно быть присвоено значение до передачи управления из метода</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Параметр "{0}" должен иметь значение, отличное от NULL, при выходе с "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting in some condition.</source>
        <target state="translated">Параметр должен иметь значение, отличное от NULL, при выходе в определенном состоянии.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Параметр "{0}" должен иметь значение, отличное от NULL, при выходе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting.</source>
        <target state="translated">Параметр должен иметь значение, отличное от NULL, при выходе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">"{0}": нельзя использовать статические типы в качестве параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass_Title">
        <source>Static types cannot be used as parameters</source>
        <target state="translated">Статические типы не могут использоваться в качестве параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion">
        <source>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</source>
        <target state="translated">Не удается использовать оператор "{0}" в этом месте из-за приоритета. Для устранения неоднозначности используйте круглые скобки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion_Title">
        <source>Operator cannot be used here due to precedence.</source>
        <target state="translated">Не удается использовать оператор в этом месте из-за приоритета</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</source>
        <target state="translated">"{0}" не реализует шаблон "{1}". "{2}" не является общедоступным экземпляром либо методом расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance_Title">
        <source>Type does not implement the collection pattern; member is is not a public instance or extension method.</source>
        <target state="translated">Тип не реализует шаблон коллекции; член не является общедоступным экземпляром или методом расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">"{0}": нельзя использовать статические типы в качестве возвращаемых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass_Title">
        <source>Static types cannot be used as return types</source>
        <target state="translated">Статические типы не могут использоваться в качестве возвращаемых типов</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Метод, помеченный [DoesNotReturn], не должен возвращать значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Метод, помеченный [DoesNotReturn], не должен возвращать значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">Второй операнд оператора "is" или "as" не может быть статического типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs_Title">
        <source>The second operand of an 'is' or 'as' operator may not be a static type</source>
        <target state="translated">Второй операнд оператора "is" или "as" не может иметь статический тип</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Выражение switch не обрабатывает все возможные типы входных значений (не является исчерпывающим). Например, шаблон "{0}" не охвачен.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые входные значения, равные null (не является исчерпывающим). Например, шаблон "{0}" не охвачен.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые входные значения null (не является исчерпывающим). Например, шаблон "{0}" не охвачен. Однако шаблон с предложением "when" может соответствовать этому значению.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые входные данные NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">Выражение switch не обрабатывает некоторые входные данные NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">Выражение switch не обрабатывает все возможные значения входного типа (не является исчерпывающим). Например, шаблон "{0}" не охвачен. Однако шаблон с предложением "when" может соответствовать этому значению.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Выражение switch обрабатывает не все возможные значения своего типа входных данных (оно не полное).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">Выражение switch обрабатывает не все возможные значения своего типа входных данных (оно не полное).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.</source>
        <target state="translated">Модификатор типа ссылки параметра "{0}" не совпадает с соответствующим параметром "{1}" в целевом объекте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in target.</source>
        <target state="translated">Модификатор типа ссылки параметра не совпадает с соответствующим параметром в целевом объекте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">Выданное значение может быть равно NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">Выданное значение может быть равно NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра "{0}" не соответствует реализованному элементу "{1}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра не соответствует реализованному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра "{0}" объекта "{1}" не соответствует неявно реализованному элементу "{2}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе параметра не соответствует неявно реализованному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для типа параметра "{0}" не соответствует переопределенному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для типа параметра не соответствует переопределенному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения не соответствует реализованному элементу "{0}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения не соответствует реализованному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения "{0}" не соответствует неявно реализованному элементу "{1}" (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для ссылочных типов в типе возвращаемого значения не соответствует неявно реализованному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для типа возвращаемого значения не соответствует переопределенному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Допустимость значений NULL для типа возвращаемого значения не соответствует переопределенному элементу (возможно, из-за атрибутов допустимости значений NULL).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Имя элемента кортежа "{0}" игнорируется, так как на другой стороне оператора == или != кортежа имя имеет другое значение или отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Имя элемента кортежа игнорируется, так как на другой стороне оператора == или != кортежа имя имеет другое значение или отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">Параметр типа "{0}" имеет то же имя, что и параметр типа во внешнем методе "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">Параметр типа имеет то же имя, что и параметр типа во внешнем методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalRefField">
        <source>Field '{0}' is never ref-assigned to, and will always have its default value (null reference)</source>
        <target state="translated">Поле "{0}" никогда не имеет ссылки и всегда будет иметь значение по умолчанию (нулевая ссылка)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalRefField_Title">
        <source>Field is never ref-assigned to, and will always have its default value (null reference)</source>
        <target state="translated">Поле не содержит ссылки и всегда будет иметь значение по умолчанию (нулевая ссылка)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion">
        <source>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Контроль возвращается вызывающему элементу до явного назначения автоматически реализуемого свойства "{0}", что приводит к предшествующему неявному назначению "default"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion_Title">
        <source>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Контроль возвращается вызывающему элементу до явного назначения автоматически реализуемого свойства, что приводит к предшествующему неявному назначению "default"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Автоматически реализуемое свойство "{0}" должно быть полностью назначено перед возвратом контроля вызывающему элементу. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значение по умолчанию к этому свойству.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
        <source>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Автоматически реализуемое свойство должно быть полностью назначено перед возвратом контроля вызывающему элементу. Попробуйте обновить языковую версию, чтобы автоматически применить значение по умолчанию к этому свойству.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion">
        <source>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Контроль возвращается вызывающему элементу до явного назначения поля "{0}", что приводит к предшествующему неявному назначению "default"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion_Title">
        <source>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Контроль возвращается вызывающему элементу до явного назначения поля, что приводит к предшествующему неявному назначению "default"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Поле '{0}' должно быть полностью назначенным перед возвратом контроля вызывающему элементу. Попробуйте обновить поле до языковой версии "{1}", чтобы автоматически применить значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion_Title">
        <source>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</source>
        <target state="translated">Поля структуры должны быть полностью назначены в конструкторе перед возвратом контроля вызывающему элементу. Попробуйте обновить языковую версию, чтобы автоматически применить значение по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Распаковка-преобразование вероятного значения NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Распаковка-преобразование вероятного значения NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Атрибут EnumeratorCancellationAttribute, применяемый к параметру "{0}", не будет оказывать никакого влияния. Этот атрибут действует только для параметра типа CancellationToken в методе асинхронного итератора, возвращающем IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">Атрибут EnumeratorCancellationAttribute не будет оказывать никакого влияния. Этот атрибут действует только для параметра типа CancellationToken в методе асинхронного итератора, возвращающем IAsyncEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Асинхронный итератор "{0}" имеет один или несколько параметров типа "CancellationToken", но ни один из них не снабжен атрибутом "EnumeratorCancellation", поэтому параметр токена отмены из созданного "IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator" не будет использован.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Элемент асинхронного итератора имеет один или несколько параметров типа "CancellationToken", но ни один из них не снабжен атрибутом "EnumeratorCancellation", поэтому параметр токена отмены из созданного "IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator" не будет использован.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableBackingField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier, or declaring the {0} as nullable, or safely handling the case where 'field' is null in the 'get' accessor.</source>
        <target state="translated">{0} "{1}", не допускающий значения NULL, должен содержать значение, отличное от NULL, при выходе из конструктора. Рассмотрите возможность добавить модификатор "required", объявить {0} как допускающее значение NULL или добавить атрибуты "[field: MaybeNull, AllowNull]".</target>
        <note>Similar diagnostic message as 'WRN_UninitializedNonNullableField'</note>
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableBackingField_Title">
        <source>Non-nullable property must contain a non-null value when exiting constructor. Consider adding the 'required' modifier, or declaring the property as nullable, or safely handling the case where 'field' is null in the 'get' accessor.</source>
        <target state="translated">Свойство, не допускающее значения NULL, должно содержать значение, отличное от NULL, при выходе из конструктора. Рассмотрите возможность добавить модификатор "required", объявить свойство как допускающее значение NULL или добавить атрибуты "[field: MaybeNull, AllowNull]".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring the {0} as nullable.</source>
        <target state="translated">{0} "{1}", не допускающий значения NULL, должен содержать значение, отличное от NULL, при выходе из конструктора. Рассмотрите возможность добавления модификатора "required" или объявления значения {0}, допускающего значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.</source>
        <target state="translated">Поле, не допускающее значения NULL, должно содержать значение, отличное от NULL, при выходе из конструктора. Рассмотрите возможность добавления модификатора "required" или объявления значения, допускающего значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter">
        <source>Parameter '{0}' is unread.</source>
        <target state="translated">Параметр "{0}" не прочитан.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter_Title">
        <source>Parameter is unread.</source>
        <target state="translated">Параметр не прочитан.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter">
        <source>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Параметр "{0}" не читается. Возможно, вы забыли использовать его для инициализации свойства с таким же именем?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter_Title">
        <source>Parameter is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Параметр не читается. Возможно, вы забыли использовать его для инициализации свойства с таким же именем?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnscopedRefAttributeOldRules">
        <source>UnscopedRefAttribute is only valid in C# 11 or later or when targeting net7.0 or later.</source>
        <target state="translated">UnscopedRefAttribute допустим только в C# 11 или более поздней версии или при нацелии на net7.0 или более позднюю версию.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnscopedRefAttributeOldRules_Title">
        <source>UnscopedRefAttribute is only valid in C# 11 or later or when targeting net7.0 or later.</source>
        <target state="translated">UnscopedRefAttribute допустим только в C# 11 или более поздней версии или при нацелии на net7.0 или более позднюю версию.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Использование локальной переменной "{0}", которой не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Использование поля "{0}", которому, возможно, не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion">
        <source>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Поле "{0}" прочитывается до явного назначения, что приводит к предшествующему неявному назначению "default".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion_Title">
        <source>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Это поле прочитывается до явного назначения, что приводит к предшествующему неявному назначению "default".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Используется поле "{0}", которое может быть не назначено. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion_Title">
        <source>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</source>
        <target state="translated">Используется поле, которое может быть не назначено. Попробуйте обновить языковую версию, чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField_Title">
        <source>Use of possibly unassigned field</source>
        <target state="translated">Использование поля, которому, возможно, не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Использование выходного параметра "{0}", которому не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut_Title">
        <source>Use of unassigned out parameter</source>
        <target state="translated">Использование параметра out, которому не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Использование автоматически реализованного свойства "{0}", которому, возможно, не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion">
        <source>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Автоматически реализуемое свойство "{0}" прочитывается до явного назначения, что приводит к предшествующему неявному назначению "default".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion_Title">
        <source>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Автоматически реализуемое свойство прочитывается до явного назначения, что приводит к предшествующему неявному назначению "default".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Используется автоматически реализуемое свойство "{0}", которое может быть не назначено. Попробуйте обновить до языковой версии "{1}", чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion_Title">
        <source>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Используется автоматически реализуемое свойство, которое может быть не назначено. Попробуйте обновить языковую версию, чтобы автоматически применить значения по умолчанию к этому полю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty_Title">
        <source>Use of possibly unassigned auto-implemented property</source>
        <target state="translated">Использование автоматически реализованного свойства, которому, возможно, не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField">
        <source>Ref field '{0}' should be ref-assigned before use.</source>
        <target state="translated">Поле ссылки "{0}" должно быть назначено при помощи ref перед использованием.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField_Title">
        <source>Ref field should be ref-assigned before use.</source>
        <target state="translated">Поле ссылки должно быть назначено при помощи ref перед использованием.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">Объект "this" прочитывается до назначения всех его полей, что приводит к неявному назначению "default" полям, которые не назначены явным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion_Title">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">Объект "this" прочитывается до назначения всех его полей, что приводит к неявному назначению "default" полям, которые не назначены явным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Нельзя использовать объект "this", пока не будут назначены все его поля. Попробуйте обновить до языковой версии "{0}", чтобы автоматически применить значения по умолчанию к неназначенным полям.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion_Title">
        <source>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</source>
        <target state="translated">Нельзя использовать объект "this" в конструкторе, пока не будут назначены все его поля. Попробуйте обновить языковую версию, чтобы автоматически применить значения по умолчанию к неназначенным полям.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation_Title">
        <source>Use of unassigned local variable</source>
        <target state="translated">Использование локальной переменной, которой не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">"{0}" предназначен только для оценки и может быть изменен или удален в будущих обновлениях.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">Тип предназначен только для оценки и может быть изменен или удален в будущих обновлениях.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">В этом месте нельзя использовать символы "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">Неверный синтаксис комментария.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">В ссылке на сущность используется недопустимый символ.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">Ожидался "&gt;" или " /&gt;" для закрытия тега "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">Требуется идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Недопустимый символ Юникода.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">В этом месте пробел не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">Символ "&lt;" нельзя использовать в значении атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">Отсутствует знак равенства между атрибутом и его значением.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">Ссылка на неопределенную сущность "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">Ожидался литерал строки, однако знак открывающих кавычек обнаружен не был.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">Отсутствуют закрывающие кавычки у литерала строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">Не допускается использование знаков кавычек в кодировке, отличной от ASCII, до и после литералов строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">Конечный тег в этом месте не ожидался.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">Конечный тег "{0}" не соответствует начальному тегу "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">Требуется конечный тег для элемента "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">Отсутствует требуемый пробел.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">Непредвиденный символ в этом месте.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">Использование строки литерала "]]&gt;" в содержимом элемента не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Повторяющийся атрибут "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">Не удалось найти файл метаданных "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">Ссылки на метаданные не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">Не удалось открыть файл метаданных "{0}" — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Тип "{0}" определен в сборке, на которую нет ссылки. Следует добавить ссылку на сборку "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">Тип "{0}" определен в модуле, который еще не был добавлен. Необходимо добавить модуль "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">Не удалось произвести запись в выходной файл "{0}" — "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">Для программы определено несколько точек входа. Компиляция с /main позволит указать тип, содержащий точку входа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">Оператор "{0}" невозможно применить к операнду типа "{1}" и "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">Деление на константу, равную нулю</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">Не удается применить индексирование через [] к выражению типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">Неверное число индексов в []; требуется {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">Оператор "{0}" невозможно применить к операнду типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">Ключевое слово "this" не может использоваться в инициализаторах статических свойств, методов или полей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">Ключевое слово "this" неприменимо в текущем контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">"{0}" имеет неправильную сигнатуру и не может быть точкой входа</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">Метод содержит неправильную подпись и не может быть точкой входа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">Не удается неявно преобразовать тип "{0}" в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">Не удается преобразовать тип "{0}" в "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">Значение константы "{0}" не может быть преобразовано в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">Оператор "{0}" для операнда типа "{1}" и "{2}" является неоднозначным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">Оператор "{0}" для операнда типа "{1}" является неоднозначным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">Выходной параметр не может иметь атрибут In.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">Не удается преобразовать значение NULL в "{0}", поскольку этот тип значений не допускает значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">Не удается преобразовать тип "{0}" в "{1}" с помощью преобразования ссылок, упаковки-преобразования, распаковки-преобразования, преобразования в оболочку или преобразования типа Null</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">Неожиданная ошибка при записи информации отладки — "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности метода "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности метода "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа поля "{1}" ниже доступности поля "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа свойства "{1}" ниже доступности свойства "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность индексатора возвращаемого типа "{1}" ниже доступности индексатора "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer or property '{0}'</source>
        <target state="needs-review-translation">Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности индексатора "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности оператора "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности оператора "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности делегата "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности делегата "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность базового класса "{1}" ниже доступности класса "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность базового интерфейса "{1}" ниже доступности интерфейса "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">"{0}": свойство события должно иметь методы доступа для добавления и удаления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">"{0}": событие должно иметь тип делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">Событие "{0}" никогда не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">Событие не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">"{0}": событие экземпляра в интерфейсе не может иметь инициализатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">Событие "{0}" может присутствовать только в левой части операций += и -= (кроме случая использования в типе "{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">Явная реализация интерфейса события должна использовать синтаксис метода доступа к событиям.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">"{0}": невозможно переопределить, так как "{1}" не является событием.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">Методы доступа add и remove должны иметь тело.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">"{0}": абстрактное событие не может иметь инициализатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">Имя сборки "{0}" зарезервировано и не может использоваться как ссылка в интерактивном сеансе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">Имя перечислителя "{0}" зарезервировано и не может использоваться.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">Оператор as должен использоваться со ссылочным типом или с типом, допускающим значение Null (тип "{0}" не допускает значение Null).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">Суффикс "l" легко спутать с цифрой "1" -- для ясности используйте "L"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">Суффикс l легко спутать с цифрой 1</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">Событие "{0}" может находиться только в левой части операции += или -=</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">Ограничения не разрешены в объявлениях, не являющихся универсальными.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">Объявление параметра-типа должно быть идентификатором, а не типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">Тип "{1}" уже резервирует член "{0}" с такими же типами параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">Повторяющееся имя параметра "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">Пространство имен "{1}" уже содержит определение для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">Тип "{0}" уже содержит определение для "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">Имя "{0}" не существует в текущем контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">Имя "{0}" не существует в текущем контексте (возможно, отсутствует ссылка на сборку "{1}"?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">"{0}" является неоднозначной ссылкой между "{1}" и "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">Директива using для "{0}" ранее встречалась в этом пространстве имен</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">Директива Using уже использовалась в этом пространстве имен</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">Модификатор "{0}" недопустим для этого элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">Несколько модификаторов защиты.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">"{0}" скрывает наследуемый член "{1}". Если скрытие было намеренным, используйте ключевое слово new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">Член скрывает унаследованный член: отсутствует новое ключевое слово</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">Переменная объявлена с тем же именем, что и переменная в базовом типе, однако, не было использовано ключевое слово new. Это предупреждение сообщает о том, что следует использовать ключевое слово new: переменная объявлена так, как если бы в объявлении использовалось ключевое слово new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">Член "{0}" не скрывает доступный член. Ключевое слово new не требуется.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">Член не скрывает унаследованный член: новое ключевое слово не требуется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">При оценке постоянного значения для "{0}" используется циклическое определение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">Тип "{1}" уже определяет член "{0}" с такими же типами параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member cannot be marked as '{0}'</source>
        <target state="translated">Статический элемент не может быть помечен как "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">Член "{0}", помеченный как override, не может быть помечен как new или virtual.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">"{0}" скрывает наследуемый член "{1}". Чтобы текущий член переопределял эту реализацию, добавьте ключевое слово override. В противном случае добавьте ключевое слово new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">Член скрывает унаследованный член: отсутствует ключевое слово переопределения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">"{0}": не найден метод, пригодный для переопределения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields, methods or statements</source>
        <target state="translated">Пространство имен не может напрямую включать в себя такие элементы, как методы или операторы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">"{0}" не содержит определение для "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">"{0}" является {1}, но используется как {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">"{0}" является {1}, который недопустим в данном контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">Для нестатического поля, метода или свойства "{0}" требуется ссылка на объект.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">Неоднозначный вызов следующих методов или свойств: "{0}" и "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">"{0}" недоступен из-за его уровня защиты.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">Нет перегруженного метода для "{0}", который соответствует делегату "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">Требуется объект с типом, приводимым к "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">Так как "{0}" возвращает значение void, поэтому после ключевого слова return не должно присутствовать выражение объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">Локальная переменная или функция с именем "{0}" уже определена в этой области.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">Левая часть выражения назначения должна быть переменной, свойством или индексатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">"{0}": статический конструктор не должен иметь параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">Назначаемое для "{0}" выражение должно быть константным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">"{0}" является типом "{1}". Константное поле ссылочного типа, отличного от string, может инициализироваться только значением Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">Локальная переменная или параметр с именем "{0}" нельзя объявить в данной области, так как это имя используется во включающей локальной области для определения локальной переменной или параметра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">Директива "using namespace" может применяться только к пространствам имен; "{0}" является типом, а не пространством имен. Используйте директиву "using static"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">Директива "using static" может применяться только к типам; "{0}" является пространством имен, а не типом. Используйте директиву "using namespace"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">Невозможно использовать директиву "using static" для объявления псевдонима</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">Отсутствует внешний цикл для прерывания или продолжения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">Повторяющаяся метка "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">Для типа "{0}" не определен конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract type or interface '{0}'</source>
        <target state="translated">Не удается создать экземпляр абстрактного типа или интерфейса "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">Требуется указать значение поля const.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base type dependency involving '{0}' and '{1}'</source>
        <target state="translated">Циклическая зависимость базового типа включает "{0}" и "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">Делегат "{0}" не имеет допустимого конструктора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">Требуется имя метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">Требуется постоянное значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">Выражение switch или метка case должны быть логическим значением, символом, строкой, целым числом, перечислением или соответствующим типом, принимающим значение NULL, в C# 6 и более ранних версиях.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">Предложение Switch содержит несколько случаев со значением метки "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">Оператор goto case допустим только внутри оператора выбора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">Свойство или индексатор "{0}" не может использоваться в этом контексте, так как не имеет метода доступа get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">Тип в операторах caught или thrown должен быть производным от System.Exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">Оператор throw без аргументов не может использоваться вне предложения catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">Управление не может быть передано из тела предложения finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">Метка "{0}" во вложенной области видимости скрывает другую метку с тем же именем.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">В области видимости оператора goto отсутствует метка "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">Предыдущее предложение catch уже перехватывает все исключения этого типа или супертипа ("{0}").</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">Выражение фильтра является константой "true", попробуйте удалить фильтр.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">Выражение фильтра является константой "true"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">"{0}": не все пути к коду возвращают значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">Обнаружен недостижимый код</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">Обнаружен недостижимый код</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">Управление не может передаваться вниз от одной метки case ("{0}") к другой.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">Отсутствует ссылка на эту метку.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">Отсутствует ссылка на эту метку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Использование локальной переменной "{0}", которой не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">Переменная "{0}" объявлена, но ни разу не использована.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">Переменная объявлена, но не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">Поле "{0}" никогда не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">Поле не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Использование поля "{0}", которому, возможно, не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Использование автоматически реализованного свойства "{0}", которому, возможно, не присвоено значение</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">Невозможно определить тип условного выражения, так как "{0}" и "{1}" неявно преобразовываются друг в друга.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">Не удается определить тип условного выражения, так как неявного преобразования между "{0}" и "{1}" не существует.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">Для ссылки "base" требуется базовый класс.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">Использование ключевого слова "base" в этом контексте не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">Доступ к члену "{0}" через ссылку на экземпляр невозможен; вместо этого уточните его, указав имя типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">До передачи управления из текущего метода параметру, помеченному ключевым словом out, "{0}" должно быть присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">Недопустимый спецификатор ранга: требуется "," или "]".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">"{0}" не может одновременно быть внешним и объявлять тело.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'Параметр "{0}" не может быть внешним и иметь инициализатор конструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">"{0}" не может одновременно внешним и абстрактным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">Параметр конструктора атрибута "{0}" имеет тип "{1}", который является недопустимым типом параметра атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">Аргументом атрибута должно быть константное выражение, выражение typeof или выражение создания массива того же типа, что и параметр атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">Параметр конструктора атрибута "{0}" необязателен, однако значение параметра по умолчанию указано не было.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">Данное выражение всегда имеет указанный тип ("{0}")</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'Выражение, заданное выражению is всегда имеет указанный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">Данное выражение никогда не имеет указанный тип ("{0}")</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'Выражение, заданное выражению is не может иметь указанный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">"{0}" не является ссылочным типом, как требуется в операторе lock.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">Использование NULL в этом контексте не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">Использование литерала по умолчанию недопустимо в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">Конструкция __arglist допускается только в методе с переменным числом аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">К указателю должен быть применен оператор * или -&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">Указатель должен быть проиндексирован только по одному значению.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Использование "{0}" в качестве значения ref или out или получение его адреса может вызвать исключение времени выполнения, поскольку это поле класса, который маршалируется по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">Использование поля класса с маршалингом по ссылке в виде значения ref или out или получение его адреса может вызвать исключение времени выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Присваивание значений доступному только для чтения статическому полю допускается только в статическом конструкторе и в инициализаторе переменных.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Доступное только для чтения статическое поле можно использовать как значение ref или out только в статическом конструкторе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Невозможно присвоить значение свойству или индексатору "{0}" — доступ только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">В качестве оператора могут использоваться только выражения назначения, вызова, инкремента, декремента и создания нового объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">Оператор foreach требует, чтобы возвращаемый тип "{0}" для "{1}" имел соответствующий открытый метод MoveNext и открытое свойство Current.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">Допускается использование только 65 534 локальных переменных с учетом тех, которые были созданы компилятором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Не удается вызвать абстрактный член базового класса: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A non ref-returning property or indexer may not be used as an out or ref value</source>
        <target state="translated">Свойство или индексатор, не возвращающие значения, не могут использоваться в качестве значения out или ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">Не удается получить адрес, определить размер или объявить указатель на управляемый тип ("{0}").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">Локальная переменная, объявленная в операторе fixed, должна иметь тип указателя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">Требуется указать инициализатор в объявлении оператора fixed или using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">Невозможно получить адрес указанного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">Адрес нефиксированного выражения можно получить только внутри инициализатора оператора fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">Получить адрес фиксированного выражения с помощью оператора fixed невозможно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">Указатели и буферы фиксированного размера можно использовать только в небезопасном контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">Тип возвращаемого значения операторов Истина и Ложь должен быть логическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">Для оператора "{0}" требуется, чтобы был определен соответствующий оператор "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">Для использования в качестве логического оператора краткой записи пользовательский логический оператор ("{0}") должен иметь такой же возвращаемый тип и типы параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">Чтобы применить "{0}" в качестве логического оператора краткой записи, его объявляющий тип "{1}" должен определять оператор True и оператор False.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">Переменной "{0}" присвоено значение, но оно ни разу не использовано.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">Переменная назначена, но ее значение не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">Переполнение при выполнении операции во время компиляции в режиме проверки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">Постоянное значение "{0}" не может быть преобразовано в "{1}" (для переопределения используйте синтаксис "unchecked").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">Метод с vararg не может быть универсальным, иметь универсальный тип или параметр params</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">Выражение __arglist может появляться только в вызове или в выражении new.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">Небезопасный код может использоваться только при компиляции с параметром /unsafe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">Неоднозначность между "{0}" и "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">В операторе foreach требуется указать и тип, и идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a parameter list</source>
        <target state="translated">Параметр params должен быть последним в списке параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">"{0}" не имеет предопределенный размер, поэтому оператор sizeof может использоваться только в небезопасном (unsafe) контексте</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">Тип или имя пространства имен "{0}" не существует в пространстве имен "{1}" (возможно, отсутствует ссылка на сборку).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">Инициализатор поля не может обращаться к нестатическому полю, методу или свойству "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">"{0}" не может быть запечатанным, т. к. не содержит модификатора override.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">"{0}": невозможно переопределить наследуемый член "{1}", так как он запечатан.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">При указателях на объекты неизвестного типа данная операция не определена.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">Недопустимый атрибут Conditional для "{0}", так как он является методом переопределения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">Ни "is", ни "as" недопустимы в типах указателей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">Непосредственный вызов деструкторов и функций object.Finalize запрещен. Рекомендуется вызов функции IDisposable.Dispose, если она доступна.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Не удалось найти тип или имя пространства имен "{0}" (возможно, отсутствует директива using или ссылка на сборку).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">stackalloc не может использоваться вместе с отрицательным размером.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">Невозможно создать массив с отрицательным размером.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">Не следует переопределять object.Finalize. Укажите деструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base type Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">Не вызывайте метод Finalize базового типа напрямую. Он вызывается автоматически из деструктора.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">Индексирование массива с отрицательным индексом (индексы массива всегда начинаются с нуля)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">Индексация массива с отрицательным индексом</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">Возможно, непреднамеренное сравнение ссылок; для получения сравнения значений приведите левую часть к типу "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">Возможно, использовано непреднамеренное сравнение ссылок: для левой стороны требуется приведение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">Возможно, непреднамеренное сравнение ссылок; для получения сравнения значений приведите правую часть к типу "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">Возможно, использовано непреднамеренное сравнение ссылок: для правой стороны требуется приведение</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">Правая часть назначения оператора fixed не может быть выражением приведения типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">stackalloc не может использоваться в блоке catch или в блоке finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a parameter list</source>
        <target state="translated">Параметр __arglist должен быть последним в списке параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">Отсутствует модификатор partial в объявлении типа "{0}"; существует другое разделяемое объявление этого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</source>
        <target state="translated">Все разделяемые объявления "{0}" должны относиться к одному типу (классы, классы записей, записи, структуры, структуры записей или интерфейсы)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">Конфликт модификаторов доступа в разделяемых объявлениях "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">Разделяемые объявления "{0}" не должны указывать различные базовые классы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">В разделяемых объявлениях "{0}" имена параметров типов и их порядок должны быть одинаковыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Несовместимые ограничения для параметров типа "{1}" в разделяемых объявлениях "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">Не удается неявно преобразовать тип "{0}" в "{1}". Существует явное преобразование (возможно, пропущено приведение типов).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', 'event', an instance constructor name, or a method or property return type.</source>
        <target state="needs-review-translation">Модификатор "partial" может использоваться только перед ключевыми словами "class", "record", "struct" и "interface", а также перед возвращаемым типом метода или свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base type dependency.</source>
        <target state="translated">Недопустимый импортированный тип "{0}". Он содержит циклическую зависимость базового типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Использование выходного параметра "{0}", которому не присвоено значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">Размер массива не может быть указан в объявлении переменной (попытайтесь инициализировать его с помощью оператора new).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">Свойство или индексатор "{0}" невозможно использовать в данном контексте, так как метод доступа get недоступен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">Свойство или индексатор "{0}" невозможно использовать в данном контексте, так как метод доступа set недоступен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">Модификатор доступа метода доступа "{0}" должен быть более ограничивающим, чем у свойства или индексатора "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">Не удается определить модификаторы доступа для обоих методов доступа свойства или индексатора "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">"{0}": модификаторы доступа для методов доступа могут использоваться, только если свойство или индексатор имеет оба метода доступа, get и set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}". "{2}" не открытый.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">"{0}" не реализует шаблон "{1}". "{2}" неоднозначен с "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">Тип не реализует шаблон коллекции: члены неоднозначны</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">"{0}" не реализует шаблон "{1}". "{2}" имеет неправильную сигнатуру.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">Тип не реализует шаблон коллекции: член содержит неправильную подпись</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">Дружественный доступ предоставлен "{0}", однако открытый ключ выходной сборки ("{1}") не соответствует ключу, определенному атрибутом InternalsVisibleTo предоставляющей сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">Дружественный доступ предоставлен "{0}", однако состояние подписи строгого имени выходной сборки не соответствует состоянию предоставляющей сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">Нет определенного порядка полей при нескольких объявлениях разделяемой структуры "{0}". Чтобы определить порядок, все поля экземпляра должны быть в одном объявлении.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">Не определен порядок полей в нескольких декларациях разделяемой структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">Тип "{0}" не может быть объявлен как const.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">Не удается создать экземпляр переменной типа "{0}", так как у нее отсутствуют ограничения new().</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">Использование универсального {1} "{0}" требует аргументы типа {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">Тип "{0}" не может использоваться в качестве аргумента типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} "{0}" нельзя использовать с аргументами типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Неуниверсальный {1} "{0}" нельзя использовать с аргументами типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'{2}" должен быть неабстрактным типом и иметь открытый конструктор без параметров, чтобы использовать его в качестве параметра "{1}" в универсальном типе или методе "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования неявной ссылки из "{3}" в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Тип "{3}", допускающий значение Null, не соответствует ограничению "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Тип "{3}", допускающий значение Null, не соответствует ограничению "{1}". Типы, допускающие значение Null, не соответствуют никаким ограничениям интерфейсов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки или преобразования параметра типа из "{3}" в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки из "{3}" в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">Имя параметра "{0}" конфликтует с автоматически созданным именем параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">Не удалось найти тип или имя пространства имен "{0}" в глобальном пространстве имен (возможно, отсутствует ссылка на сборку?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last restrictive constraint specified</source>
        <target state="translated">Ограничение new() должно быть последним указанным ограничительным ограничением.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">"{0}": точка входа не может быть универсальной или находиться в универсальном типе</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">Точка входа не может быть универсальной или иметь универсальный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">Невозможно преобразовать Null к параметру типа "{0}", так как он может быть типом значения, не допускающим значения Null. Используйте вместо этого "default({0})".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">Повторяющееся ограничение "{0}" для параметра типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">Все другие ограничения должны следовать после ограничения типа класса "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'{1} {0}" имеет неправильный возвращаемый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">Несоответствие ссылок между методом "{0}" и делегатом "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">Для параметра типа "{0}" уже указано предложение ограничения. Все ограничения для параметра типа должны быть объявлены в одном предложении Where.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">Аргументы типа для метода "{0}" не могут определяться по использованию. Попытайтесь явно определить аргументы типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">"{0}": имя параметра, локальной переменной или локальной функции не может совпадать с именем параметра типа метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">Параметр типа "{0}" не может использоваться с оператором "as", так как он не имеет ни ограничений типа класса, ни ограничения "class".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">Полю "{0}" присвоено значение, но оно ни разу не использовано.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">Поле назначено, но его значение не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">Атрибут "{0}" применим только для индексатора, который не является явным объявлением члена интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">"{0}": аргумент атрибута не может использовать параметры типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">"{0}": при создании экземпляра типа переменной не удается задать аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract type cannot be sealed or static</source>
        <target state="translated">"{0}": абстрактный тип не может быть запечатанным или статическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">Неоднозначная ссылка в атрибуте cref: "{0}". Предполагается "{1}", но может также соответствовать другим перегрузкам, включая "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">Неоднозначная ссылка в атрибуте cref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">"{0}": ссылка на временное поле не будет считаться временной.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">Ссылка на поле с модификатором volatile не будет использоваться как изменяемая ссылка</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">Непостоянное поле обычно не должно использоваться в качестве значения ref или out, так как оно не будет считаться непостоянным. Существуют исключения, например при вызове заблокированного API.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">Поскольку "{1}" имеет атрибут ComImport, "{0}" должен быть внешним или абстрактным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">"{0}": класс с атрибутом ComImport не может указывать базовый класс.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Ограничения для параметра типа "{0}" метода "{1}" должны соответствовать ограничениям параметра типа "{2}" метода интерфейса "{3}". Рассмотрите возможность явной реализации интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">Имена элементов кортежа в сигнатуре метода "{0}" должны совпадать с именами элементов кортежа в методе интерфейса "{1}" (включая тип возвращаемого значения).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">Имя типа "{0}" не существует в типе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Не удается преобразовать группу методов "{0}" в тип, не являющийся делегатом "{1}". Предполагалось вызывать этот метод?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">В параметре /reference не указан внешний псевдоним "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">Не удается использовать псевдоним "{0}" с "::" так как псевдоним ссылается на тип. Вместо этого используйте объект ".".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">Не удалось найти псевдоним "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">Тип "{1}" существует как в "{0}", так и в "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">Пространство имен "{1}" в "{0}" конфликтует с типом "{3}" в "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">Пространство имен "{1}" в "{0}" конфликтует с импортированным типом "{3}" в "{2}". Используется пространство имен, определенное в "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">Пространство имен конфликтует с импортированным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Тип "{1}" в "{0}" конфликтует с импортированным типом "{3}" в "{2}". Используется тип, определенный в "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">Тип конфликтует с импортированным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Тип "{1}" в "{0}" конфликтует с импортированным пространством имен "{3}" в "{2}". Используется тип, определенный в "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">Тип конфликтует с импортированным пространством имен</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">Тип "{1}" в "{0}" конфликтует с пространством имен "{3}" в "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">Объявление внешнего псевдонима должно предшествовать всем другим элементам, определенным в пространстве имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">Определение псевдонима с именем "global" не рекомендуется из-за того, что "global::" всегда указывает на глобальное пространство имен и не является псевдонимом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">Определение псевдонима с именем global не рекомендуется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a type cannot be both static and sealed</source>
        <target state="translated">"{0}": тип не может быть одновременно статическим и запечатанным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">"{0}": абстрактные свойства не могут иметь закрытых методов доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">Синтаксическая ошибка; требуется значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">Невозможно изменить результат преобразования при распаковке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">Работа оператора Foreach в "{0}" невозможна. Действительно вызвать "{0}"?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">Возвращаемый тип оператора ++ или -- должен соответствовать типу параметра или быть производным от типа параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">"{0}": невозможно одновременно задать класс ограничения и ограничения "class" или "struct".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">Ограничение "new()" невозможно использовать вместе с ограничением "struct".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Тип "{2}" должен быть ссылочным типом для его использования в качестве параметра "{1}" в универсальном типе или методе "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть типом значения, не допускающим значения Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">Циклическая зависимость ограничений включает "{0}" и "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">Параметр типа "{0}" наследует конфликтующие ограничения "{1}" и "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Параметр типа "{1}" имеет ограничение "struct", поэтому "{1}" не может использоваться в качестве ограничения для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">Неоднозначные пользовательские преобразования "{0}" и "{1}" при преобразовании из "{2}" в "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">Результатом этого выражения всегда будет "Null" типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">Результат выражения — всегда NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">Невозможно вернуть this по ссылке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.</source>
        <target state="translated">Невозможно использовать конструктор атрибута "{0}", так как он содержит параметры "in" или "ref readonly".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">Ограничения для переопределения и явные методы реализации интерфейса унаследованы от базового метода, поэтому они не могут быть указаны напрямую, кроме ограничения class или struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">Наследуемые члены "{0}" и "{1}" имеют одинаковую сигнатуру в типе "{2}", поэтому их нельзя переопределить.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">Ошибка при вычислении выражения десятичной константы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">Операция сравнения со значением Null типа "{0}" всегда возвращает False.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">Сравнение со значением NULL или типом структуры всегда вызывает false</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">Введение метода Finalize может помешать вызову деструктора. Предполагается объявить деструктор?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">Введение метода Finalize может помешать вызову деструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">Это предупреждение возникает, когда создается класс с методом, подпись которого является открытым, виртуальным, недействительным методом Finalize.

Если такой класс используется в качестве базового, а производный класс определяет деструктор, то деструктор переопределит метод Finalize базового класса, а не метод Finalize производного класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">"{0}" не должен иметь параметр params, так как у "{1}" его нет.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">Значение "goto case" невозможно неявно преобразовать в тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">Значение "goto case" не может быть неявно преобразовано в тип switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Метод "{0}" не может реализовать метод доступа интерфейса "{1}" для типа "{2}". Используйте явную реализацию интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Результат выражения всегда равен "{0}", поскольку значение типа "{1}" никогда не равно Null типа "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Результат значения всегда одинаковый, так как значение этого типа никогда не равно NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Результат выражения всегда равен "{0}", поскольку значение типа "{1}" никогда не равно Null типа "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Результат значения всегда одинаковый, так как значение этого типа никогда не равно NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">Явная реализация интерфейса '{0}' соответствует более чем одному члену интерфейса. Выбор члена интерфейса зависит от реализации. Возможно, требуется использовать неявную реализацию.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">Реализация явного интерфейса совпадает больше чем с одним членом интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">"{0}" не может объявить тело, потому что помечен как abstract.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">"{0}" должен объявлять тело, так как он не помечен модификатором abstract, extern или partial.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">"{0}" не может быть одновременно абстрактным и запечатанным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">Абстрактный метод {0} "{1}" не может быть помечен как virtual.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">Константа "{0}" не может быть помечена модификатором static.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">"{0}": невозможно переопределить, так как "{1}" не является функцией.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">"{0}": невозможно переопределить наследуемый член "{1}", так как он не помечен как virtual, abstract или override.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">"{0}": невозможно изменить модификаторы доступа при переопределении "{1}", унаследованном из "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">"{0}": невозможно изменить имена элементов кортежа при переопределении наследуемого элемента "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">"{0}": возвращаемый тип должен быть "{2}", чтобы соответствовать переопределенному члену "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">"{0}": не может быть производным от запечатанного типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract type '{1}'</source>
        <target state="translated">"{0}" является абстрактным, но содержится в типе "{1}", который не является абстрактным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">"{0}": статический конструктор не может иметь явный вызов конструктора "this" или "base".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">"{0}": модификаторы доступа для статических конструкторов не разрешены.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">Конструктор "{0}" не может вызвать сам себя</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">Конструктор "{0}" не может вызвать сам себя посредством другого конструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">"{0}" не имеет базового класса и не может вызвать базовый конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Предопределенный тип "{0}" не определен или не импортирован</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Предопределенный тип "{0}" не определен или не импортирован</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeAmbiguous">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">Предопределенный тип "{0}" объявлен в нескольких сборках, на которые имеются ссылки: "{1}" и "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">"{0}": структуры не могут вызывать конструкторы базового класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Член структуры "{0}" типа "{1}" приводит к циклу в этом макете структуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">Интерфейсы не могут содержать поля экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">Интерфейсы не могут содержать конструкторы экземпляров</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">Тип "{0}" в списке интерфейсов не является интерфейсом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">"{0}" уже присутствует в списке интерфейсов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">"{0}" уже указан в списке интерфейсов типа "{2}" с другими именами элементов кортежа: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">Наследуемый интерфейс "{1}" образует циклическую ссылку в иерархии интерфейсов для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">"{0}" скрывает наследуемый абстрактный член "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">"{0}" не реализует наследуемый абстрактный член "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">Класс System.Object не может иметь базовый класс или реализовывать интерфейс.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">"{0}" в явном объявлении интерфейса не является интерфейсом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">Не удается найти "{0}" в явном объявлении интерфейса среди членов интерфейса, которые могут быть реализованы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">"{0}": вмещающий тип не реализует интерфейс "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</source>
        <target state="translated">"{0}": явное объявление интерфейса может содержаться только в классе, записи, структуре или интерфейсе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">"{0}": имена членов не могут совпадать с именами типов, в которых они содержатся</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">"{0}": значение перечислителя недопустимо велико для типа, к которому он относится.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">"{0}": невозможно переопределить, так как "{1}" не является свойством.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">"{0}": переопределение невозможно, так как "{1}" не имеет функции доступа get, доступной для переопределения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">"{0}": переопределение невозможно, так как "{1}" не имеет функции доступа set, доступной для переопределения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">"{0}": свойство или индексатор не могут иметь тип void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">"{0}": для свойства или индексатора должен быть указан по крайней мере один метод доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed type '{1}'</source>
        <target state="translated">"{0}" — новый виртуальный элемент в запечатанном типе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">"{0}" добавляет метод доступа, не обнаруженный в члене интерфейса "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">В явной реализации интерфейса "{0}" отсутствует метод доступа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">"{0}": не разрешено пользовательское преобразование в интерфейс или из интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base type are not allowed</source>
        <target state="translated">"{0}": не разрешено пользовательское преобразование в базовый тип или из базового типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived type are not allowed</source>
        <target state="translated">"{0}": не разрешено пользовательское преобразование в производный тип или из производного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot convert a type to itself</source>
        <target state="translated">Определяемый пользователем оператор не может преобразовать тип в себя</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">Определенное пользователем преобразование должно осуществлять преобразование в данный включающий тип или из данного включающего типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">Повторяющееся определенное пользователем преобразование в типе "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">Параметр для операторов ++ и -- должен иметь вмещающий тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">Тип параметра унарного оператора должен быть вмещающим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">Тип одного из параметров бинарного оператора должен быть вмещающим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type</source>
        <target state="translated">Тип первого операнда перегруженного оператора сдвига должен совпадать с содержащим типом</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">Перечисления не могут содержать явные конструкторы без параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">"{0}": невозможно переопределение "{1}", так как такая операция в данном языке не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'{0}' не поддерживается данным языком.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">"{0}": явный вызов оператора или метода доступа невозможен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">"{0}": невозможно сослаться на тип через выражение; попытайтесь использовать "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of type</source>
        <target state="translated">Имя деструктора должно соответствовать имени типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">Деструкторы могут содержаться только в типах классов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">Пространство имен "{1}" содержит определение, конфликтующее с псевдонимом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">Псевдоним "{0}" конфликтует с определением {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</source>
        <target state="translated">Атрибут Conditional недопустим для "{0}", так как это конструктор, деструктор, оператор, лямбда-выражение или явная реализация интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">Атрибут Conditional для "{0}" недопустим, так как возвращаемый тип не является недействительным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">Повторяющийся атрибут "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">Повторяющийся атрибут "{0}" в "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">Атрибут Conditional недопустим для членов интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">Определяемые пользователем операторы не могут возвращать значения типа void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">"{0}": пользовательские преобразования в динамические типы или из них не разрешены.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">Недопустимое значение аргумента атрибута "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">Недопустимый параметр для указанного неуправляемого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">Должен быть указан параметр атрибута "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">Должен быть указан параметр атрибута "{0}" или "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Неуправляемый тип "{0}" недопустим для полей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Неуправляемый тип "{0}" допустим только для полей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">Атрибут "{0}" не допускается для этого типа объявления. Он допустим только для объявлений "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">Константа с плавающей запятой вне допустимого диапазона для типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">Вместе с атрибутом ComImport следует задать атрибут Guid.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">Недопустимое значение именованного аргумента атрибута "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'extern' that is either 'static' or an extension member</source>
        <target state="needs-review-translation">Атрибут DllImport должен быть указан для метода, который помечен как "static" и "extern".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="translated">Атрибут DllImport не может применяться для универсального метода или метода, содержащегося в универсальном методе или типе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">Поле или свойство не может иметь тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">Поле или автоматически реализуемое свойство не может быть типа "{0}", если это не член экземпляра ссылочной структуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">Элементы массива не могут иметь тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">"{0}" является устаревшим.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Тип или член устарел</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">"{0}" не является классом атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">"{0}" недопустимый именованный аргумент атрибута. Аргументы именованного атрибута должны быть полями без описателей readonly, static и const или открытыми нестатическими свойствами с доступом на чтение и запись.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">"{0}" является устаревшим: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Тип или член устарел</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">"{0}" является устаревшим: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">Индексатор не может иметь тип void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">"{0}": виртуальные и абстрактные члены не могут быть закрытыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">Назначение типов массивов разрешено только через выражения инициализации массивов. Используйте выражение с оператором new.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">Инициализаторы массивов могут использоваться только в инициализаторах переменных или полей. Используйте выражение с оператором new.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">"{0}": поле экземпляра с типами, помеченными StructLayout(LayoutKind.Explicit), должно иметь атрибут FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">Метод, оператор или метод доступа "{0}" помечен как внешний и не имеет атрибутов. Для указания на внешнюю реализацию, возможно, следует добавить атрибут DllImport.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">Метод, оператор или метод доступа помечен как внешний и не имеет атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed type</source>
        <target state="translated">"{0}": новый защищенный элемент объявлен в запечатанном типе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed type</source>
        <target state="translated">Новый защищенный элемент объявлен в запечатанном типе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Условный член "{0}" не может реализовать член интерфейса "{1}" в типе "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">Ключевые слова ref и out недопустимы в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">Аргумент для атрибута "{0}" должен быть допустимым идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Атрибут FieldOffset может назначаться только членам типов, для которых используется StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">Для полей static и const атрибут FieldOffset не разрешен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">Атрибут "{0}" допустим только для классов, наследуемых из System.Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Возможно, ошибочный пустой оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">Возможно, ошибочный пустой оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">"{0}" повторяющийся именованный аргумент атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">"{0}" не может наследовать от специального класса "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">Невозможно указать атрибут DefaultMember для типа, содержащего индексатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">"{0}" является типом, который не поддерживается в данном языке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">Полю "{0}" нигде не присваивается значение, поэтому оно всегда будет иметь значение по умолчанию {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">Поле никогда не назначается и всегда будет иметь значение по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">Неверный оператор объявления массива. Для объявления управляемого массива спецификатор ранга должен предшествовать идентификатору переменной. Чтобы объявить поле буфера фиксированного размера, перед типом поля используйте ключевое слово fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">Сравнение с целочисленной константой не имеет смысла; константа находится вне диапазона значений типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">Сравнение с константой интеграции бесполезно: константа находится за пределами диапазона типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">Не удается использовать класс атрибута "{0}", так как он является абстрактным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">"{0}" не является допустимым аргументом именованного атрибута, так как он не является допустимым типом параметра атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">Отсутствует обязательный для компилятора член "{0}.{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">"{0}" недопустимое место атрибута для этого объявления. Для этого объявления допускаются следующие места атрибутов: "{1}". Все атрибуты этого блока будут проигнорированы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">Недопустимое расположение атрибута для объявления</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">"{0}" не распознан как расположение атрибута. Допустимые расположения атрибута для этого объявления: "{1}". Все атрибуты этого блока будут проигнорированы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">Нераспознанное расположение атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">"{0}" переопределяет Object.Equals(object o), но не переопределяет Object.GetHashCode().</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">Тип переопределяет Object.Equals(object o), но не переопределяет Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">"{0}" определяет оператор "==" или оператор "!=", но не переопределяет Object.Equals(object o).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">Тип определяет оператор == или оператор !=, но не переопределяет Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">"{0}" определяет оператор "==" или оператор "!=", но не переопределяет Object.GetHashCode().</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">Тип определяет оператор == или оператор !=, но не переопределяет Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">Невозможно указать атрибут Out в параметре ref, не указав также атрибут In.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">"{0}" не может определять перегруженный {1}, который отличается только модификаторами параметров "{2}" и "{3}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">Литерал с типом double не может быть неявно преобразован к типу "{1}"; используйте суффикс "{0}" для создания литерала этого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">В условных выражениях назначение всегда постоянное. Предполагалось использовать ==, а не = ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">Назначение в условном выражении всегда является константой</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">"{0}": новый защищенный член объявлен в структуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">Имена двух индексаторов различаются; для каждого индексатора в пределах типа следует использовать атрибут IndexerName с одним и тем же именем.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">Класс с атрибутом ComImport не может иметь определенного пользователем конструктора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">Поле не может иметь тип void.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">Член "{0}" переопределяет устаревший член "{1}". Добавьте к "{0}" атрибут Obsolete.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">Член переопределяет устаревший член</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">System.Void из C# использоваться не может -- для получения объекта типа void используйте typeof(void).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">Побитовый оператор "ИЛИ" применен к операнду, расширенному знаком; рекомендуется предварительное приведение к меньшему беззнаковому типу</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">Битовая операция или оператор, использовавшийся в операнде с расширением знака</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">Компилятор неявно расширил переменную с расширением знака, а затем использовал полученное значение в битовой или обычной операции. Это может вызвать непредсказуемое поведение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">"{0}": изменяемое поле не может быть типа "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">"{0}": поле не может быть одновременно изменяемым и доступным только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">Для полей модификатор метода "abstract" недопустим. Вместо этого попробуйте использовать свойство.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">"{0}" не удается реализовать "{1}", так как он не поддерживается в данном языке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'Невозможно реализовать "{0}" через явную реализацию метода "{1}", так как он является методом доступа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'"Интерфейс "{0}" помечен с помощью "CoClassAttribute" и не помечен с помощью "ComImportAttribute".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">Интерфейс, помеченный как CoClassAttribute, не помечен как ComImportAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Член с атрибутом Conditional "{0}" не может иметь параметр с ключевым словом out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Метод доступа "{0}" не может реализовать член интерфейса "{1}" для типа "{2}". Используйте явную реализацию интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">Квалификатор псевдонима пространства имен "::" всегда разрешается в тип или пространство имен, что в данном случае недопустимо. Рассмотрите возможность использования ".".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">Невозможно наследовать от "{0}", так как он не является параметром типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">Повторяющийся параметр типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">Имя типа параметра "{0}" совпадает с именем типа параметра внешнего типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">Параметр типа имеет то же имя, что и параметр, указанный во внешнем типе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">Параметр типа "{0}" совпадает с именем вмещающего типа или метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">"{0}" не в состоянии реализовать ни "{1}", ни "{2}", так как они могут быть идентичными для некоторых подстановок параметров типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">"{1}" не определяет параметр типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">"{0}" не является допустимым ограничением. Тип, использованный в качестве ограничения, должен быть интерфейсом, незапечатанным классом или параметром-типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">Ограничение не может быть специальным классом "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа ограничения "{1}" ниже доступности "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">Невозможно выполнить поиск невиртуального члена в "{0}", поскольку это параметр типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">Недопустимый тип ограничения. Тип, использованный в качестве ограничения, должен быть интерфейсом, незапечатанным классом или параметром-типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">"{0}": нельзя объявлять члены экземпляра в статическом классе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">"{1}": не может быть производным от статического класса "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">Статические классы не могут иметь конструкторы экземпляров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">Статические классы не могут содержать деструкторы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">Не удается создать экземпляр статического класса "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">Статический класс "{0}" не может быть производным от типа "{1}". Статические классы должны быть производными от object.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">"{0}": реализация интерфейсов статическими классами невозможна.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">"{0}": статические классы не могут содержать определяемых пользователем операторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">Не удается преобразовать в статический тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">"{0}": нельзя использовать статические классы в качестве ограничений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">"{0}": нельзя использовать статические типы в качестве аргументов типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">"{0}": элементы массива не могут быть статического типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">"{0}": нельзя объявлять индексаторы в статическом классе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">"{0}": нельзя использовать статические типы в качестве параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">"{0}": нельзя использовать статические типы в качестве возвращаемых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">Не удается объявить переменную статического типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">Недопустимо использовать оператор throw без аргументов в предложении finally, которая находится в ближайшем вложенном предложении catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">"{0}" не является допустимым описателем формата.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">Возможно, неправильное назначение локальной переменной "{0}", которая является аргументом оператора using или lock. Вызов Dispose или разблокирование произойдет на ее оригинальном значении.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">Возможно, используется недопустимое назначение для локального параметра, который является аргументом оператора using или lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">Тип "{0}" определен в этой сборке, но для нее указан метод передачи типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">Не удается переадресовать тип "{0}", так как он является вложенным типом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">Метод передачи типа для типа "{0}" в сборке "{1}" приводит к циклу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">Параметр /moduleassemblyname может использоваться только при сборке модуля.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Ссылка сборки "{0}" является недопустимой и не может быть разрешена.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">В качестве аргумента для атрибута TypeForwardedTo указан недопустимый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</source>
        <target state="translated">"{0}" не реализует элемент экземпляра интерфейса "{1}". "{2}" не может реализовать элемент интерфейса, потому что он является статическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}". '{2}" не может реализовать член интерфейса, потому что он не является открытым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}". '{2}" не может реализовать "{1}", потому что не имеет соответствующего возвращаемого типа "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">"{0}" повторяющийся TypeForwardedToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">Тело запроса должно заканчиваться предложением select или предложением group.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">Требуется контекстное ключевое слово "on".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">Требуется контекстное ключевое слово "equals".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">Требуется контекстное ключевое слово "by".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">Недопустимый оператор объявления элемента анонимного типа. Элементы анонимного типа должны быть объявлены назначением элемента, простым именем или доступом к элементу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">Недопустимый оператор объявления элемента инициализатора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Несовместимое использование лямбда-параметра; типы параметров должны быть либо все явными, либо все неявными.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberNotExplicit">
        <source>A partial member may not explicitly implement an interface member</source>
        <target state="translated">Частичный член не может явным образом реализовать член интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">Разделяемый метод должен быть либо оба раза объявлен как метод расширения, либо нигде не объявлен как метод расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">Разделяемый метод не может иметь несколько определяющих объявлений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">Разделяемый метод не может иметь несколько реализующих объявлений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">Отсутствует определяющее объявление для реализующего объявления разделяемого метода "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Несогласованные ограничения для параметра типа "{1}" в частичных объявлениях метода "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">Невозможно создать делегат на основе метода "{0}, так как он является разделяемым методом без реализующего объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberStaticDifference">
        <source>Both partial member declarations must be static or neither may be static</source>
        <target state="translated">Оба объявления частичного члена должны быть статическими или оба не должны быть статическими</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">В деревьях выражений не могут использоваться разделяемые методы, имеющие только определяющее объявление или только удаленные условные методы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">Член с атрибутом "obsolete" "{0}" переопределяет член без атрибута "obsolete" "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">Устаревший член переопределяет неустаревший член</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">Слишком длинное полное имя "{0}" для отладочной информации. Компилируйте без параметра "/debug".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">Полное имя слишком длинное для сведений об отладке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">Не удается присвоить {0} неявно типизированной переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">Неявно типизированные переменные должны быть инициализированы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">Неявно типизированные переменные не могут иметь множество операторов объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">Невозможно инициализировать неявно типизированную переменную инициализатором массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">Неявно типизированная локальная переменная не может быть фиксированной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">Неявно типизированные переменные не могут быть константными</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">Конструктор "{0}" помечен как внешний</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">Конструктор помечен как внешний</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">Контекстное ключевое слово "var" может использоваться только в объявлении локальной переменной или в скрипте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">Нет подходящего типа для неявно типизированного массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">Невозможно присвоить "{0}" свойству анонимного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">Дерево выражения не может иметь доступ к базовым членам.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">Дерево выражения не может содержать оператор назначения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">Анонимный тип не может иметь несколько свойств с одинаковыми именами.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">Лямбда-выражение с телом оператора не может быть преобразовано в дерево выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">Не удается преобразовать лямбда-выражение в дерево выражения, чей аргумент типа "{0}" не является делегатом</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">Невозможно использовать анонимный тип в константном выражении.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">Первый операнд операторов "is" или "as" не может быть лямбда-выражением, анонимным методом или группой методов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">Первый операнд оператора as не может быть литералом кортежа без естественного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">Дерево выражения не может содержать инициализатор многомерного массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">Аргумент отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">Невозможно использовать локальную переменную "{0}" перед ее объявлением.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">Не удается получить тип "{0}", так как инициализатор прямо или косвенно ссылается на определение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">Невозможно использовать локальную переменную "{0}" перед ее объявлением. Объявление данной локальной переменной скрыто в поле "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">Лямбда-выражение дерева выражений не может содержать объединяющий оператор с литералом NULL или литералом по умолчанию в качестве левого операнда.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Требуется идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">Требуется ";".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">Синтаксическая ошибка, требуется "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">Повторяющийся модификатор "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">Метод доступа к свойству уже определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">Требуется тип byte, sbyte, short, ushort, int, uint, long или ulong.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">Нераспознанная escape-последовательность</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">Символ новой строки в константе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">Пустая символьная константа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">Превышение допустимого числа символов в символьной константе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Недопустимое число</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">Требуется метод доступа get или set.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">Требуется объект, строка или тип класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">Требуется именованный аргумент атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Конструкции catch не могут использоваться после универсальной конструкции catch оператора try</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">Требуется ключевое слово "this" или "base".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">Требуется перегружаемый унарный оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">Требуется перегружаемый бинарный оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">Значение целочисленной константы слишком велико.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">Требуется определение типа или пространства имен, либо признак конца файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">Требуется определение члена, оператор или признак конца файла</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">Внедренный оператор не может быть объявлением или оператором с идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">Требуется директива препроцессора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Требуется однострочный комментарий или признак конца строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">Требуется ")"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">Требуется директива #endif.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">Непредвиденная директива препроцессору.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#error: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: "{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">Директива #warning</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">Требуется тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">Невозможно определить символы препроцессора или отменить их определение где-либо, кроме начала файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">Нельзя использовать #r после первой лексемы в файле.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">Обнаружен признак конца файла, требуется "*/".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">Встретилась отметка о конфликте слияния</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">Не используйте refout при использовании refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">Не удается скомпилировать сетевые модули при использовании /refout или /refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">Требуется перегружаемый оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">Требуется директива #endregion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">Строковая константа без признака завершения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">Перед директивами препроцессору могут находиться только пробельные знаки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">Требуется идентификатор, "{1}" является ключевым словом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">Требуется "{" или ";".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">В операторах for, using, fixed и операторах объявления не может использоваться более одного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">Требуется функция доступа add или remove.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Недопустимый символ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">Непредвиденный токен "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">"{0}": статические классы не могут содержать защищенные члены.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">Предыдущее предложение catch уже перехватывает все исключения. Все возникшие необработанные исключения будут перенесены в System.Runtime.CompilerServices.RuntimeWrappedException.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">Предыдущее выражение catch уже получило все исключения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">Это предупреждение возникает, если в блоке catch() не указан тип исключений после блока catch (System.Exception e). В предупреждении рекомендуется, чтобы блок catch() не получал исключения.

В блоке catch(), находящемся после блока catch (System.Exception e), могут возникнуть исключения, не связанные с CLS, если для параметра RuntimeCompatibilityAttribute задано значение false в файле AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Если для этого атрибута не задано явно значение false, все исключения, не связанные с CLS, упаковываются как исключения и их получает блок catch (System.Exception e).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">Операндом оператора инкремента или декремента должна быть переменная, свойство или индексатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">"{0}" не содержит определения "{1}", и не удалось найти доступный метод расширения "{1}", принимающий тип "{0}" в качестве первого аргумента (возможно, пропущена директива using или ссылка на сборку).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">"{0}" не содержит определения для "{1}", и не удалось найти метод расширения "{1}", принимающий тип "{0}" в качестве первого аргумента (возможно, пропущена директива using для "{2}").</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">Метод "{0}" имеет параметр с модификатором "this", не являющийся первым параметром метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> Модификатор параметра "{0}" не может использоваться с "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The receiver parameter of an extension cannot be of type '{0}'</source>
        <target state="needs-review-translation">Первый параметр метода расширения не может иметь тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">Массив параметров не может быть использован с модификатором "this" в методе расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">Метод расширения должен быть статическим.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">Метод расширения должен быть определен в неуниверсальном статическом классе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">Параметр может иметь только один модификатор "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">Методы расширения должны быть определены в статическом классе верхнего уровня; {0} является вложенным классом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="needs-review-translation">Не удается определить новый метод расширения, так как не найден требуемый компилятором тип "{0}". Возможно, отсутствует ссылка на System.Core.dll</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">Не используйте "System.Runtime.CompilerServices.ExtensionAttribute". Используйте вместо этого ключевое слово "this".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">Не используйте "System.Runtime.CompilerServices.DynamicAttribute". Используйте вместо этого ключевое слово "dynamic".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">Не удается выполнить требуемую для вызова конструктора динамическую диспетчеризацию, поскольку этот вызов является частью инициализатора конструктора. Попробуйте привести динамические аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">Методы расширения "{0}", определенные на типе значения "{1}", не могут применяться для создания делегатов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">Ни одна из перегрузок метода "{0}" не принимает {1} аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">Аргумент {0}: не удается преобразовать из "{1}" в "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">Не удалось открыть исходный файл "{0}" — {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">Не удается связать файлы ресурсов при сборке модуля.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">Идентификатор ресурса "{0}" в этой сборке уже использован.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">Каждый связанный ресурс и модуль должны иметь уникальное имя файла. Имя файла "{0}" определено более одного раза в этой сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">Файл "{0}", на который дается ссылка, не является сборкой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">Значения ref или out должно быть переменной, которой можно присвоить значение</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">Ключевое слово "base" неприменимо в статическом методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">Ключевое слово "base" неприменимо в текущем контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">Требуется "}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">Требуется "{"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'Требуется "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">Недопустимое выражение препроцессора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in a member declaration</source>
        <target state="needs-review-translation">Недопустимый токен "{0}" в объявлении класса, записи, структуры или элемента интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">Метод должен иметь тип возвращаемого значения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">Недопустимый базовый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">Пустой блок switch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">Пустой блок switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">Требуется catch или finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">Недопустимый термин "{0}" в выражении</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires an argument list or (), [], or {} after type</source>
        <target state="translated">В выражении new после типа требуется список аргументов либо "()", []" или "{}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">Элементы, определенные в пространстве имен, нельзя объявлять в явном виде как частные, защищенные, защищенные внутренние или частные защищенные.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">Требуется ";" или "=" (невозможно задать аргументы конструктора в объявлении).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">Предложение Using должно предшествовать любым другим элементам пространства имен кроме объявлений внешних псевдонимов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">Перегруженный бинарный оператор "{0}" принимает два параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">Перегруженный унарный оператор "{0}" принимает один параметр.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">Параметр имеет недопустимый тип "void".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">Псевдоним using "{0}" ранее встречался в этом пространстве имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">Доступ к защищенному члену "{0}" через квалификатор типа "{1}" невозможен; квалификатор должен иметь тип "{2}" (или производный от него тип).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">"{0}" не может быть добавлен к этой сборке, так как он уже там находится.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попытайтесь вызвать методы доступа "{1}" или "{2}" напрямую.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попытайтесь вызвать метод доступа "{1}" напрямую.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">Использование ключевого слова "void" в этом контексте недопустимо.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">Индексаторы должны иметь хотя бы один параметр.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">Спецификатор типа массива, [], должен располагаться перед именем параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">Объявление недействительно; используйте "{0} оператор &lt;результирующий тип&gt; (..." вместо</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Не удалось найти "{0}", определенного для метода Main.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</source>
        <target state="translated">"{0}", определенный для метода Main, должен быть неуниверсальным классом, записью, структурой или интерфейсом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">"{0}" не имеет подходящего статического метода Main.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">Для создания результирующего файла без исходных текстов должен быть задан параметр /out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">Заданы несовместимые параметры: файл ресурсов Win32; манифест Win32.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">Заданы несовместимые параметры: файл ресурсов Win32; значок Win32.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">Ошибка чтения ресурса "{0}" — "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">Ошибка при записи в XML-файл документации: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">Комментарий XML содержит некорректный XML — "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">Комментарий XML содержит неправильно сформированный XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">Комментарий XML имеет повторяющийся тег param для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">Комментарий XML содержит повторяющийся тег параметра</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Комментарий XML имеет тег param для "{0}", но параметр с таким именем отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">Комментарий XML содержит тег param, но параметр с таким именем не существует</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Комментарий XML в "{1}" имеет тег paramref для "{0}", но параметр для этого имени отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">Комментарий XML содержит тег paramref, но параметр с таким именем не существует</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">Параметр "{0}" не имеет совпадающего тега param в комментарии XML для "{1}" (в отличие от остальных параметров)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">Параметр не имеет соответствующий тег параметра в комментарии XML (в отличие от остальных параметров)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">Комментарий XML содержит атрибут cref "{0}", который не удалось разрешить.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">Комментарий XML содержит атрибут cref, который не удалось разрешить</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">В выражении stackalloc после типа требуется [].</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">Номер строки, указанный для директивы #line, отсутствует или недействителен.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">Ожидается имя файла в кавычках, однострочный комментарий или признак конца строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">Требуется имя файла в кавычках</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">Использование #r допускается только в скриптах.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">Оператор foreach не работает с переменными типа "{0}", так как "{0}" не содержит открытое определение экземпляра или расширения для "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">Недопустимый тип для параметра {0} в атрибуте cref комментария XML: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">Недопустимый тип параметра в атрибуте cref комментария XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Недопустимый тип возвращаемого значения в атрибуте cref XML-комментария</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Недопустимый тип возвращаемого значения в атрибуте cref XML-комментария</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Ошибка при чтении ресурсов Win32 — {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">В комментарии XML имеется атрибут cref "{0}" с неверным синтаксисом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">Синтаксически недопустимый атрибут cref в комментарии XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">Модификатор члена "{0}" должен указываться перед типом и именем члена.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">При создании массива следует указать размер массива или инициализатор массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">За XML-комментарием не следует допустимый элемент языка</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">За XML-комментарием не следует допустимый элемент языка</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">Не удалось включить фрагмент XML "{1}" файла "{0}" — {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">Не удалось включить фрагмент XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">Недопустимый элемент включения для XML — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">Недопустимый элемент включения для XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">Отсутствует комментарий XML для публично видимого типа или члена "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">Отсутствует комментарий XML для открытого видимого типа или члена</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">Указан параметр компилятора /doc, но одна или несколько конструкций не содержат комментарии.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Некорректный XML во включенном файле комментариев — "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Неправильно сформированный XML во включенном файле комментариев</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">Делегат "{0}" не принимает аргументы {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">Использование точки с запятой после блока метода или доступа недопустимо.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>The return type of a method, delegate, or function pointer cannot be '{0}'</source>
        <target state="translated">Тип возвращаемого значения метода, делегата или указателя на функцию не может иметь значение "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">Компиляция отменена пользователем.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">Не удается сделать ссылку на переменную типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">Невозможно присвоить значение "{0}", так как он доступен только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">Невозможно использовать "{0}" как значение ref или out, так как он доступен только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">Атрибут RequiredAttribute не разрешен для типов C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">Модификаторы нельзя размещать в объявлениях методов доступа к событиям.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">Параметр params не может объявляться с ключевым словом {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">Не удалось изменить возвращаемое значение "{0}", т. к. оно не является переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">Не удается найти управляемый класс-оболочку coclass "{0}" для интерфейса "{1}" (возможно, была пропущена ссылка на сборку).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</source>
        <target state="translated">"{0}" является неоднозначным между "{1}" и "{2}". Используйте "@{0}" или явно добавьте суффикс Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">Аргумент "{0}" не должен передаваться с ключевым словом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">Параметр "{0}" переопределяет атрибут "{1}", заданный в исходном файле или в добавленном модуле.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">Параметр переопределяет атрибут, заданный в исходном файле или добавленном модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">Это предупреждение возникает, если атрибуты сборки AssemblyKeyFileAttribute или AssemblyKeyNameAttribute в источнике конфликтуют с параметром командной строки /keyfile или /keycontainer либо с именем файла ключа или контейнером ключа, указанном в свойствах проекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">Недопустимый параметр "{0}" для /langversion. Используйте "/langversion:?" для вывода списка поддерживаемых значений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">Не удается создать делегат с "{0}", так как он или метод, который он переопределяет, имеет атрибут Conditional.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">Не удается создать временный файл — {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">Аргумент {0} должен передаваться с ключевым словом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">Внутри анонимного метода или лямбда-выражения нельзя использовать оператор yield.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">Невозможно вернуть значение итератора. Используйте оператор yield return для возвращения значения или оператор yield break для окончания итерации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">Итераторы не могут иметь параметры ref, in или out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">Тело "{0}" не может быть блоком итератора, так как "{1}" не является типом интерфейса итератора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">Нельзя использовать оператор yield в теле предложения finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">Нельзя использовать оператор yield в теле блока try, имеющего предложение catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">Требуется выражение после оператора yield return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Недопустимо использовать параметр "{0}" с модификаторами ref, out или in внутри анонимного метода, лямбда-выражения, выражения запроса или локальной функции</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">Нельзя использовать оператор yield в теле предложения catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">Невозможно передать управление из тела анонимного метода или лямбда-выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Нераспознанная директива #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">Нераспознанная директива #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">Ожидается "disable" или "restore"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">После предупреждения #pragma ожидается "disable" или "restore"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">Не удается восстановить предупреждение "CS{0}", так как оно было глобально отключено.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">Невозможно восстановить предупреждение, так как оно было отключено глобально</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">__arglist не разрешается использовать в списке параметров итераторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have pointer type parameters</source>
        <target state="translated">Итераторы не могут использовать параметры типа указателя</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">Сигнатура управляемого класса-оболочки coclass "{0}" для интерфейса "{1}" не является допустимой сигнатурой имени класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Оператор foreach не может использоваться с переменными типа "{0}", так как он реализует создание нескольких экземпляров "{1}". Попробуйте выполнить приведение к созданию экземпляра определенного интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">Поле буфера фиксированного размера должно иметь спецификатор размера массива после имени поля.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">Поля буферов фиксированного размера могут быть только членами структур.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">Не все пути к коду возвращают значение в {0} типа "{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Возможность "{0}" не входит в спецификацию языка C#, стандартизированную ISO, и может не распознаваться другими компиляторами</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">Компонент не является частью стандартизированной спецификации ISO языка C# и может не приниматься другими компиляторами</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">После спецификатора verbatim (@) требуется ключевое слово, идентификатор или строка.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Доступное только для чтения поле можно использовать как значение ref или out только в конструкторе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Члены доступного только для чтения поля "{0}" можно использовать как значение ref или out только в конструкторе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</source>
        <target state="translated">Полю, которое доступно только для чтения, не может быть присвоено значение (значение может быть присвоено только в конструкторе типа, в методе задания значения, вызываемом только при инициализации типа, в котором определено поле, либо в инициализаторе переменной)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">Члены поля "{0}", предназначенного только для чтения, могут быть изменены только в конструкторе или инициализаторе переменных.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">Невозможно использовать {0} "{1}" как значение ref или out, так как это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">Члены {0} "{1}" невозможно использовать как значения ref или out, так как это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Не удается назначить {0} "{1}" или использовать это как правую часть назначения ref, поскольку это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Не удается назначить участнику {0} "{1}" или использовать это как правую часть назначения ref, поскольку это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">Невозможно вернуть {0} "{1}" по ссылке для записи, так как это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">Члены {0} "{1}" невозможно вернуть по ссылке для записи, так как это переменная только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Присваивание значений полям доступного только для чтения статического поля "{0}" допускается только в статическом конструкторе и в инициализаторе переменных.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Поля доступного только для чтения статического поля "{0}" можно использовать как значение ref или out только в статическом конструкторе</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">Невозможно изменить члены "{0}", так как это "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Невозможно использовать поля "{0}" как значение ref или out, так как это "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">Невозможно присвоить "{0}" значение, так как он является "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Невозможно вернуть "{0}" как значение ref или out, так как это "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}. См. также ошибку CS{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">Предупреждение переопределяет ошибку</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">Компилятор определяет это предупреждение, когда оно переопределяет ошибку с предупреждением. Для получения дополнительных сведений о проблеме выполните поиск упомянутой ошибки кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">Не удается преобразовать {0} к типу "{1}", так как он не является типом делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">Невозможно преобразовать {0} в тип "{1}", так как типы параметров не совпадают с типами параметров делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">Не удается преобразовать {0} в требуемый тип делегата, так как некоторые возвращаемые типы блока не могут быть неявно преобразованы в возвращаемый тип делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than '{1}'</source>
        <target state="translated">Поскольку данный метод является асинхронным, возвращаемое выражение должно относиться к типу "{0}", а не к типу "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">Не удается преобразовать асинхронный тип {0} в тип делегата "{1}". Асинхронный тип {0} может возвращать значения Void, Task или Task&lt;T&gt;, ни одно из которых не преобразуется в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">Тип буфера фиксированного размера должен входить в следующий список: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float или double.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">Буфер фиксированного размера с длиной {0} и типом "{1}" слишком велик.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">Буферы фиксированного размера должны иметь ненулевую длину.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">Невозможно использовать буферы фиксированного размера в нефиксированных выражениях. Попробуйте использовать оператор fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">Атрибут "{0}" нельзя использовать в методах доступа к свойствам или событиям. Он допустим только для объявлений "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">Недопустимый путь для поиска "{0}" указан в "{1}" — "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">Указан недопустимый путь поиска</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">__arglist недопустим в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">params недопустим в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">Объявление пространства имен не может содержать модификаторы или атрибуты.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">Недопустимый параметр "{0}" для /platform; должен быть anycpu, x86, Itanium, arm, arm64 или x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.</source>
        <target state="translated">Анонимные методы, лямбда-выражения, выражения запроса и локальные функции внутри структуры не имеют доступа к элементам экземпляра "this". Возможно, следует скопировать "this" в локальную переменную за пределами анонимного метода, лямбда-выражения, выражения запроса или локальной функции и использовать эту локальную переменную.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'.</source>
        <target state="translated">"{0}": тип, используемый в операторе using, должен реализовывать "System.IDisposable".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">Параметр {0} должен быть объявлен с ключевым словом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">Параметр {0} должен быть объявлен с ключевым словом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">Параметр {0} объявлен как тип "{1}{2}" вместо "{3}{4}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">Недопустимый внешний псевдоним для /reference; "{0}" является недопустимым идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">Недопустимый параметр псевдонима ссылки: "{0}=" — не указано имя файла</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">Нельзя переопределять глобальный внешний псевдоним.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">Ссылка на тип "{0}" требует его определения в данной сборке, однако он не определен в исходном тексте программы или добавленных модулях.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">Ссылка на тип "{0}" требует его определения в "{1}", но его не удалось найти.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">Предопределенный тип "{0}" определен в нескольких сборках в глобальном псевдониме; используется описание из "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">Предопределенный тип определяется в нескольких сборках глобального псевдонима</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">Эта ошибка происходит, когда предопределенный тип системы, например System.Int32, находится в двух сборках. Единственная причина этого — ссылка на mscorlib или System.Runtime.dll из двух разных расположений, например, при попытке запустить две версии .NET Framework одновременно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">Локаль "{0}" или его члены не могут получить свои адреса и использоваться внутри анонимного метода или лямбда-выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Файл с исходным текстом программы превысил установленный в PDB-файле предел в 16 707 565 строк; отладочная информация будет неправильной</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Файл с исходным текстом программы превысил установленный в PDB-файле предел в 16 707 565 строк; отладочная информация будет неправильной</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">Невозможно преобразовать блок анонимного метода без списка параметров в тип делегата "{0}", так как он имеет один или несколько выходных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">Атрибут "{0}" допустим только для методов или классов атрибутов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Доступ к члену в "{0}" может вызвать исключение времени исполнения, поскольку он является полем класса, который маршалируется по ссылке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">Доступ к члену в поле класса маршалинга по ссылке может вызвать исключение времени выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">Это предупреждение возникает при попытке вызвать метод, свойство или индексатор в члене или классе, производном от MarshalByRefObject; при этом член является типом значения. Объекты, наследуемые от MarshalByRefObject, обычно упаковываются по ссылке в домене приложений. Если код пытается получить прямой доступ к члену типа значения такого объекта в домене приложений, возникнет исключение времени выполнения. Чтобы устранить предупреждение, сначала скопируйте член в локальную переменную и вызовите метод в этой переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Недопустимое число</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">Недопустимое число</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">Неверный синтаксис #pragma checksum; должно быть #pragma checksum "имя файла" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">Недопустимый синтаксис контрольной суммы #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">Требуется однострочный комментарий или признак конца строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">После директивы #pragma ожидается комментарий длиной в одну строку или комментарий в конце строки</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">Для "{0}" даны разные контрольные суммы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">Заданы разные значения контрольной суммы #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Ссылка сборки "{0}" является недопустимой и не может быть разрешена.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">Ссылка на сборку недопустима и не может быть разрешена</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">Это предупреждение указывает, что атрибут, например InternalsVisibleToAttribute, был указан неправильно.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">При предположении, что ссылка на сборку "{0}", используемая "{1}", совпадает с удостоверением "{2}"для "{3}", возможно, потребуется задать политику среды выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Предполагается, что ссылка на сборку совпадает с удостоверением</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Две сборки отличаются номером выпуска или версии. Для унификации необходимо указать директивы в CONFIG-файле приложения и предоставить допустимое строгое имя сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">При предположении, что ссылка на сборку "{0}", используемая "{1}", совпадает с удостоверением "{2}"для "{3}", возможно, потребуется задать политику среды выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Предполагается, что ссылка на сборку совпадает с удостоверением</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">Две сборки отличаются номером выпуска или версии. Для унификации необходимо указать директивы в CONFIG-файле приложения и предоставить допустимое строгое имя сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">Импортировано несколько сборок с одинаковыми удостоверениями: "{0}" и "{1}". Удалите одну из повторяющихся ссылок.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">Сборка с аналогичным простым именем "{0}" уже была импортирована. Попробуйте удалить одну из ссылок (например "{1}") или подпишите их для параллельного использования.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">Сборка "{0}" с удостоверением "{1}" использует "{2}" с более высокой версией, чем у сборки "{3}" с удостоверением "{4}", на которую делается ссылка.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">Доступ к буферам фиксированного размера разрешен только через локальные переменные или поля.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">Комментарий XML имеет повторяющийся тег для "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">Комментарий XML содержит повторяющийся тег параметра типа</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Комментарий XML для "{0}" имеет тег typeparam, но тип параметра для этого имени отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">Комментарий XML содержит тег typeparam, но параметр типа с таким именем не существует</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Комментарий XML в "{1}" имеет тег typeparam для "{0}", но тип параметра для этого имени отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">Комментарий XML содержит тег typeparamref, но параметр типа с таким именем не существует</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">Параметр типа "{0}" не имеет совпадающего тега typeparam в комментарии XML для "{1}" (в отличие от остальных параметров типов)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">Параметр типа не имеет соответствующий тег параметра типа в комментарии XML (в отличие от остальных параметров)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">"{0}": тип должен быть "{2}", чтобы соответствовать переопределенному члену "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">Не используйте атрибут "System.Runtime.CompilerServices.FixedBuffer". Вместо него следует применять модификатор "fixed".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">Проведено присвоение той же переменной; действительно выполнить такое назначение, а не иное?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">Назначение выполнено для той же переменной</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">Сравнение выполнено с той же переменной. Действительно следует выполнять такое сравнение?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">Выполнено сравнение с той же переменной</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">Ошибка при открытии файла ресурсов Win32 "{0}" — "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">Выражение всегда будет вызывать System.NullReferenceException, поскольку значение "{0}" по умолчанию равно Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">Выражение будет всегда вызывать исключение System.NullReferenceException, так как значение по умолчанию для типа равно NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">Класс "{0}" не может иметь несколько базовых классов: '{1}" и "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">Перед интерфейсом должен быть указан базовый класс "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">Комментарий XML для "{0}" имеет атрибут cref, который ссылается на параметр типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">Атрибут cref комментария XML ссылается на параметр типа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Недопустимая дружественная ссылка на сборку "{0}". Объявления InternalsVisibleTo не содержат определения версии, языка и региональных параметров, токена открытого ключа или архитектуры процессора.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Недопустимая дружественная ссылка на сборку "{0}". Сборки, подписанные строгим именем, должны содержать в объявлении InternalsVisibleTo открытый ключ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">Не удается привязать делегат к "{0}", так как он является членом "System.Nullable&lt;T&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">"{0}" не содержит конструктор, который принимает аргументы {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">Атрибуты сборки и модуля должны находиться перед всеми остальными элементами в файле, кроме предложений using и описаний внешних псевдонимов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">Требуется выражение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">Недопустимое значение версии {0} для /subsystemversion. Для ARM или AppContainerExe должна быть указана версия 6.02, в остальных случаях - версия 4.00 или выше</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">Внедренный метод взаимодействия "{0}" содержит тело.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be zero or greater</source>
        <target state="translated">Уровень предупреждений должен быть неотрицательным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">Недопустимый параметр "{0}" для /debug; допустимые значения: "portable", "embedded", "full" или "pdbonly"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">Недопустимый параметр "{0}"; видимость ресурса должна быть либо "public", либо "private".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">Тип аргумента для атрибута DefaultParameterValue должен соответствовать типу параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">Аргумент типа "{0}" неприменим для атрибута DefaultParameterValue.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">Повторная инициализация члена "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">Не удается инициализировать член "{0}". Это не поле или свойство.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">Статическому полю или свойству "{0}" не может быть присвоено значение внутри инициализатора объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Членам поля только для чтения "{0}" типа "{1}" не могут быть присвоены значения с помощью инициализатора объекта, так как они имеют тип значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Членам свойства "{0}" типа "{1}" не могут быть присвоены значения с помощью инициализатора объекта, так как они имеют тип значения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">Небезопасный тип "{0}" не может применяться при создании объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">Инициализатор элемента не может быть пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">Наиболее подходящий перегруженный метод для "{0}" имеет неправильную сигнатуру элемента инициализатора. Инициализируемый метод Add должен быть доступным методом экземпляра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">Не удается инициализировать тип "{0}" инициализатором набора, потому что он не реализует интерфейс "System.Collections.IEnumerable".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Ключ /win32manifest для модуля пропущен, т. к. используется только для сборок</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">Ключ /win32manifest для модуля пропущен, т. к. используется только для сборок</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">"{0}" не содержит определение для "{1}", и наиболее подходящий перегруженный метод расширения "{2}" требует наличия получателя типа "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">Переменная диапазона "{0}" уже была объявлена.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">Переменная диапазона "{0}" конфликтует с предыдущим объявлением "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">Невозможно присвоить {0} переменной диапазона.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">Не удалось найти реализацию шаблона запроса для исходного типа "{0}".  "{1}" не найден.  Попробуйте явно указать тип переменной диапазона "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</source>
        <target state="translated">Не удалось найти реализацию шаблона запроса для исходного типа "{0}". "{1}" не найден. Возможно, не хватает обязательных ссылок на сборку или используется директива для "System.Linq".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">Не удалось найти реализацию шаблона запроса для исходного типа "{0}".  "{1}" не найден.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Имя "{0}" находится вне области левой части конструкции "equals".  Возможно, требуется поменять местами выражения с обеих сторон "equals".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Имя "{0}" находится вне области правой части конструкции "equals".  Возможно, требуется поменять местами выражения с обеих сторон "equals".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">Невозможно передать переменную диапазона "{0}" как параметр с ключевыми словами out или ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">Обнаружены повторные реализации шаблона запроса для исходного типа "{0}".  Неоднозначный вызов "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Тип одного из выражений в предложении {0} неверен.  Ошибка определения типа при вызове в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Тип выражения в предложении {0} неверен.  Ошибка определения типа при вызове в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">Выражение типа "{0}" недопустимо в последующем предложении from в выражении запроса с исходным типом "{1}".  Ошибка определения типа при вызове в "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">Дерево выражения не может содержать небезопасные операции над указателями.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">Дерево выражения не может содержать выражение анонимного метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">Выражение анонимного метода не может быть преобразовано в дерево выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Невозможно присвоить значение переменной диапазона "{0}", доступной только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">Переменная диапазона "{0}" не может иметь имя, совпадающее с именем параметра типа метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">Контекстное ключевое слово "var" не может быть использовано в объявлении переменной диапазона.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">Наиболее подходящий перегруженный метод Add "{0}" для инициализатора набора содержит недопустимые аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">Дерево лямбда-выражения не может содержать параметр ref, in или out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">Дерево лямбда-выражения не может содержать метод с изменяющимся числом аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">Наиболее подходящий перегруженный метод, соответствующий "{0}" для элемента инициализации коллекции, не может быть использован. Методы инициализации коллекции "Add" не имеют ссылочных и выходных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">Невызываемый член "{0}" не может использоваться как метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">Член "{0}" реализует интерфейсный член "{1}" в типе "{2}". Во время выполнения возникает множественное соответствие интерфейсных членов. Реализация зависит от того, какой метод будет вызван.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">Член реализует член интерфейса с несколькими совпадениями во время выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">Это предупреждение может быть создано, если два метода интерфейса различаются только по тому, помечен ли конкретный параметр как ref или как out. Рекомендуется изменить код, чтобы избежать этого предупреждения, так как неочевидно, какой метод вызывается во время выполнения, и вызов нужного метода не гарантируется.

Хотя C# разделяет параметры out и ref, спецификация CLR не видит отличий и выбирает случайный метод, реализующий интерфейс.

Предоставьте компилятору способ различения методов. Например, можно дать им разные имена или указать дополнительный параметр в одном из них.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</source>
        <target state="translated">Элемент "{1}" переопределяет "{0}". Во время выполнения появляется множество кандидатов на переопределение. Реализация зависит от того, какой метод будет вызван. Используйте более позднюю версию среды выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">Член переопределяет базовый член с помощью нескольких кандидатов переопределения во время выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">Выражения, инициализирующие коллекцию и объект, не могут быть применены к выражению создания делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">"{0}" является типом "{1}". Тип, заданный в объявлении константы, должен быть sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, типом enum или ссылочным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">Не удалось найти исходный файл "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">Исходный файл "{0}" задан несколько раз.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">Исходный файл указан несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">Отсутствует спецификация файла для параметра "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">Ошибка в синтаксисе командной строки: Отсутствует "{0}" для параметра "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Нераспознанный параметр: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">Не указаны файлы с исходным кодом.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">Не указаны исходные файлы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">Ожидался скрипт (CSX-файл), но ни один не был указан</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">Ошибка при открытии файла ответа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- {1}</source>
        <target state="translated">Не удается открыть "{0}" для записи — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">Недопустимый номер базы образа "{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">"{0}" является двоичным файлом, а не текстовым.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">Кодовая страница "{0}" является недопустимой или не установлена.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">Алгоритм "{0}" не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">Не допускается указывать /main при сборке модуля или библиотеки.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">Недопустимый тип результата для /target: необходимо указать "exe", "winexe", "library" или "module"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Параметр /noconfig пропущен, т. к. он задан в файле ответов</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">Параметр /noconfig пропущен, т. к. он задан в файле ответов</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">Недопустимое выравнивание разделов файла "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">Недопустимое имя выходных данных: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">Недопустимый формат отладочной информации: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'Синтаксис "id#" больше не поддерживается. Вместо этого используйте "$id".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Недопустимое имя символа предварительной обработки. "{0}" не является допустимым идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">Недопустимое имя символа предварительной обработки; недопустимый идентификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">Невозможно создать короткое имя файла "{0}", если уже существует длинное имя файла, содержащее это короткое имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">В параметре /reference, объявляющем внешний псевдоним, можно задать только одно имя файла. Чтобы задать несколько псевдонимов или имен файлов, следует использовать несколько параметров /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">Ошибка в синтаксисе командной строки: Отсутствует ":&lt;номер&gt;" для параметра "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">Параметр /pdb требует использования параметра /debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">Дерево лямбда-выражения не может содержать вызов COM с пропущенным аргументом ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">Ошибка в синтаксисе командной строки: Недопустимый формат Guid "{0}" для параметра "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">Ошибка в синтаксисе командной строки: Отсутствует Guid для параметра "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Методы с переменным числом аргументов не совместимы с требованиями CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">Методы с переменным числом аргументов не совместимы с требованиями CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">Аргумент типа "{0}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">Тип аргумента несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">Тип возвращаемого значения "{0}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">Тип возвращаемого значения несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">Тип ограничения "{0}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">Тип несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">Открытая, защищенная или защищенная внутренняя переменная должна иметь тип, совместимый с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">Идентификатор "{0}", отличающийся только регистром, несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">Идентификатор, отличающийся только регистром, несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Перегруженный метод "{0}", отличающийся только параметром с ключевым словом ref или out, либо рангом массива, несовместимы с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Перегруженный метод, отличающийся только в параметре ref или out или в ранге массива, несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Перегруженный метод "{0}", отличающий только типами массивов без имен, несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Перегруженный метод, отличающийся только типами неименованных массивов, несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">Эта ошибка происходит, если перегруженный метод получает массив массивов, и единственное отличие между подписями методов — тип элементов массива. Чтобы избежать этой ошибки, рассмотрите возможность использования прямоугольного массива вместо массива массивов; используйте дополнительный параметр, чтобы разрешить неоднозначность вызова функции, переименуйте один или несколько перегруженных методов или, если совместимость с CLS не требуется, удалите атрибут CLSCompliantAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">Идентификатор "{0}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">Идентификатор несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">"{0}": базовый тип "{1}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">Базовый тип несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">Базовый тип помечен как несовместимый с CLS в сборке, помеченной как совместимая с CLS. Удалите атрибут, указывающий совместимость сборки с CLS, или удалите атрибут, указывающий несовместимость типа с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">"{0}": совместимые с CLS интерфейсы должны иметь только совместимые с CLS члены.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">Интерфейсы, совместимые с CLS, должны включать только совместимые с CLS члены</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">"{0}": только совместимые с CLS члены могут быть абстрактными.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">Только члены, совместимые с CLS, могут быть абстрактными</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Для включения проверки на соответствие CLS следует назначить сборке, а не модулю, атрибут CLSCompliant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Для включения проверки на соответствие CLS следует назначить сборке, а не модулю, атрибут CLSCompliant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Добавленные модули должны быть помечены атрибутом CLSCompliant, чтобы соответствовать этой сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">Добавленные модули должны быть помечены атрибутом CLSCompliant, чтобы соответствовать этой сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">"{0}" не может быть помечен как совместимый с CLS, поскольку сборка не имеет атрибута CLSCompliant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Тип или член не может быть помечен как совместимый с CLS, так как сборка не содержит атрибут CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">"{0}" не имеет доступных конструкторов, которые используют совместимые с CLS типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">Тип не содержит доступных конструкторов, которые используют только совместимые с CLS типы</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Использование массивов как аргументов атрибутов в CLS не разрешено</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">Использование массивов как аргументов атрибутов в CLS не разрешено</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Невозможно задать аргумент CLSCompliant в модуле, который отличается от атрибута CLSCompliant в сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Невозможно задать аргумент CLSCompliant в модуле, который отличается от атрибута CLSCompliant в сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">"{0}" не может быть помечен как совместимый с CLS, поскольку является членом типа "{1}", несовместимого с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">Тип невозможно пометить как совместимый с CLS, так как он является членом несовместимого с CLS типа</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">Проверка на соответствие CLS не будет выполнена для "{0}", поскольку он не видим за пределами данной сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">Проверка совместимости с CLS не будет выполнена, так как она не видима за пределами этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">"{0}" не требуется атрибут CLSCompliant, так как сборка не имеет атрибута CLSCompliant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Типу или члену не требуется атрибут, совместимый с CLS, так как сборка не содержит атрибут CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">Атрибут CLSCompliant не применяется к параметрам. Попробуйте разместить его в методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">Атрибут CLSCompliant не имеет значения при применении к параметрам</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">Атрибут CLSCompliant не применяется к возвращаемым типам. Попробуйте разместить его в методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">Атрибут CLSCompliant не имеет значения при применении к типам возвращаемых значений</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">Тип ограничения "{0}" несовместим с CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">Тип ограничения несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">Поле "{0}", совместимое с CLS, не может быть временным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">Поле, совместимое с CLS, не может иметь модификатор volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">"{0}" несовместим с CLS, поскольку с ним несовместим базовый интерфейс "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">Тип несовместим с CLS, так как базовый интерфейс несовместим с CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">'Для применения оператора "await" у типа {0} должен быть подходящий метод GetAwaiter.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">Ожидание "{0}" невозможно</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">Для использования оператора "Await" необходимо, чтобы у возвращаемого типа "{0}" метода "{1}.GetAwaiter()" были соответствующие члены IsCompleted, OnCompleted и GetResult и чтобы этот тип реализовывал интерфейс INotifyCompletion или ICriticalNotifyCompletion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">'Для применения оператора "await" у типа "{0}" должен быть подходящий метод GetAwaiter. Возможно отсутствует директива using для "System".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">Ожидание "void" невозможно</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'Оператор await нельзя использовать в качестве идентификатора в асинхронном методе или лямбда-выражении.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">"{0}" не реализует "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression</source>
        <target state="translated">Поскольку "{0}" является асинхронным методом, возвращающим "{1}", за ключевым словом return не может следовать выражение объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">Возвращаемым типом асинхронного метода должен быть void, Task, Task&lt;T&gt; или аналогичный тип, IAsyncEnumerable&lt;T&gt; или IAsyncEnumerator&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">Невозможно вернуть выражение типа void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">Недопустимо использовать __arglist в списке параметров асинхронного метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>Instance of type '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Экземпляр типа "{0}" не может быть сохранен за границей "await" или "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have pointer type parameters</source>
        <target state="translated">Асинхронные методы не могут использовать параметры типа указателя</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">Асинхронные методы не могут иметь параметры ref, in или out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">Оператор await можно использовать, только если он содержится в методе или лямбда-выражении, помеченном модификатором async.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">Оператор "await" можно использовать только в методах с модификатором async {0}. Попробуйте пометить {0} модификатором "async".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">Оператор await можно использовать только в методах с модификатором async. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">Оператор await можно использовать только в методах с модификатором async. Попробуйте пометить этот метод модификатором async и изменить тип его возвращаемого значения на Task.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">Невозможно ожидание в теле предложения finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">Невозможное ожидание в предложении catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">Невозможное ожидание в выражении фильтра предложения catch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">Невозможное ожидание в теле оператора lock.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">Оператор "await" невозможно использовать в инициализаторе статической переменной скрипта.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">Невозможно ожидание в небезопасном контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">Модификатор "async" можно использовать только в методах, имеющих тело.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">Атрибут безопасности "{0}" нельзя применить к асинхронному методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">Не допускается использование асинхронных методов в интерфейсе, классе или структуре с атрибутом "SecurityCritical" или "SecuritySafeCritical".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">Оператор await можно использовать только в выражении запроса в первом выражении коллекции начального предложения From или в выражении коллекции предложения Join.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">Поскольку этот вызов не ожидается, выполнение текущего метода продолжается до завершения вызова. Попробуйте применить оператор await к результату вызова.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">Так как этот вызов не ожидается, выполнение существующего метода продолжается до тех пор, пока вызов не будет завершен</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">Существующий метод вызывает асинхронный метод, который возвращает Task или Task&lt;TResult&gt; и не применяет оператор await к результату. Вызов асинхронного метода запускает асинхронную задачу. Однако, так как оператор await не применяется, программа продолжает работу, не дождавшись выполнения задачи. В большинстве случаев такое поведение не ожидается. Обычно другие аспекты вызова метода зависят от результатов вызова, или предполагается, что вызываемый метод будет завершен как минимум до возврата значения из метода, содержащего вызов.

Не менее важно то, что происходит с исключениями, возникающими в вызываемом асинхронном методе. Исключение, возникающее в методе, который возвращает Task или Task&lt;TResult&gt;, хранится в возвращенной задаче. Если не ждать завершения задачи или не выполнить явную проверку на исключения, исключение теряется. Если подождать завершения задачи, исключение вызывается повторно.

Рекомендуется всегда дожидаться вызова.

Подавление предупреждений следует использовать только в том случае, если вы не хотите ждать завершения асинхронного вызова, а вызванный метод не создаст исключений. В этом случае можно подавить предупреждение, назначив результат задачи вызова для переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'Невозможно применить MethodImplOptions.Synchronized к асинхронному методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Невозможно применить CallerLineNumberAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Невозможно применить CallerFilePathAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Невозможно применить CallerMemberNameAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute можно применять только к параметрам со значениями по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute можно применять только к параметрам со значениями по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute можно применять только к параметрам со значениями по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Применение атрибута CallerLineNumberAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Атрибут CallerLineNumberAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Применение атрибута CallerFilePathAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Атрибут CallerFilePathAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Применение атрибута CallerMemberNameAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Атрибут CallerMemberNameAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">Программа не содержит статического метода "Main", подходящего для точки входа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">Требуется инициализатор массива длиной "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">Требуется вложенный инициализатор массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">Недопустимый модификатор вариантности. В качестве варианта допускается указывать только параметры типа интерфейса и делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">Неожиданное использование псевдонима.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">Неожиданное использование универсального имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">Неожиданное использование несвязанного универсального имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">Выражения и операторы можно использовать только в теле метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">Возможно, для доступа к массиву отсутствует спецификатор именованного аргумента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">В этом контексте значения по умолчанию недействительны.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">Ошибка при открытии файла значка {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">Ошибка при открытии файла манифеста Win32 {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Ошибка при сборке ресурсов Win32 — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">Необязательные параметры должны быть указаны после всех требуемых параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">Не удается наследовать интерфейс "{0}" с указанными параметрами типов, так как из-за этого метод "{1}" содержит перегрузки, различающиеся только параметрами ref и out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">В разделяемых объявлениях "{0}" должны быть одинаковыми имена параметров типов, модификаторы вариантности и их порядок.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">Недопустимое отклонение: Параметр типа "{1}" должен быть {3}, допустимым на "{0}". "{1}" является {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">"{0}": не может наследовать от динамического типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">"{0}": не может реализовывать динамический интерфейс "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">Ограничение не может быть динамическим типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">Ограничение не может быть динамическим типом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">Не удается обнаружить один или несколько типов, необходимых для компиляции динамического выражения. Возможно, отсутствует ссылка.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">Имя "{0}" превышает максимальную длину, допустимую в метаданных.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">В этом контексте атрибуты недопустимы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'"внешний псевдоним" недопустим в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">Использование "{0}" для проверки совместимости с "{1}" равнозначно проверке совместимости с "{2}" и проходит успешно для всех значений, кроме значений Null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">Использование is для проверки совместимости с типом dynamic равнозначно проверке совместимости с типом Object</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">Невозможно использовать "yield" в коде скрипта верхнего уровня</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">Невозможно объявить пространство имен в коде скрипта</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">В данном контексте нельзя использовать атрибуты сборки и модуля</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">Делегат "{0}" не содержит метода invoke или метода invoke с возвращаемым типом или типами параметров, которые не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global code; ignoring '{0}' entry point.</source>
        <target state="translated">Точкой входа программы является глобальный код; игнорируется точка входа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global code; ignoring entry point</source>
        <target state="translated">Точкой входа программы является глобальный код; игнорируется точка входа</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">Несогласованность по доступности: доступность типа события "{1}" ниже доступности события "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">Спецификации именованных аргументов должны создаваться после указания всех фиксированных аргументов. Используйте версию языка {0} или более позднюю, чтобы разрешить неконечные именованные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">Спецификации именованных аргументов должны создаваться после всех указанных фиксированных аргументов в динамическом вызове.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Наиболее подходящий перегруженный метод для "{0}" не имеет параметр с именем "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Делегат "{0}" не имеет параметра с именем "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">Нельзя указывать именованный аргумент "{0}" несколько раз.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">Именованный аргумент "{0}" задает параметр, для которого уже был установлен позиционный аргумент.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">Именованный аргумент "{0}" используется не на своем месте, но за ним следует неименованный аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">Не удалось указать значение параметра по умолчанию вместе с DefaultParameterAttribute или OptionalAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">Значение параметра по умолчанию для "{0}" должно быть константой времени компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">Параметр ref или out не может иметь значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">Не удалось указать значение по умолчанию для параметра this.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter collection</source>
        <target state="translated">Не удается указать значение по умолчанию для коллекции параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">Использование значения типа "{0}" в качестве параметра по умолчанию недопустимо, так как отсутствуют стандартные методы преобразования в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">Значение типа "{0}" нельзя использовать в качестве параметра по умолчанию для допускающего значение Null параметра "{1}", так как "{0}" не является простым типом</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">"{0}" является типом "{1}". Значение по умолчанию для параметра, имеющее ссылочный тип, который отличается от string, может инициализироваться только значением Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Значение по умолчанию, указанное для параметра "{0}", не будет действовать, так как оно применяется к члену, используемому в контекстах, не допускающих необязательных аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Указанное значение по умолчанию не будет работать, так как оно применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">Ошибка при подписи выхода открытым ключом из файла "{0}" — {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">Ошибка при подписи выхода открытым ключом из контейнера "{0}" — {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">Оператор typeof не может использоваться для динамического типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">Дерево выражения не может содержать динамическую операцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">Асинхронные лямбда-выражения невозможно преобразовывать в деревья выражений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Не удается определить класс или член, использующий dynamic, так как не удается найти требуемый компилятором тип "{0}". Возможно, отсутствует ссылка.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">Невозможно передать значение NULL в качестве имени дружественной сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">В файле ключа "{0}" отсутствует закрытый ключ, необходимый для подписи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">Указано общедоступное подписывание, для которого требуется открытый ключ, но он не указан.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">Общедоступные подписи не поддерживаются для netmodule.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Была указана отложенная подпись, для которой требуется открытый ключ, но открытый ключ не был указан</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">Была указана отложенная подпись, для которой требуется открытый ключ, но открытый ключ не был указан</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">Указанная строка версии "{0}" не соответствует требуемому формату: основной номер[.дополнительный номер[.сборка[.редакция]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">Указанная строка версии "{0}" содержит подстановочные знаки, которые несовместимы с детерминизмом. Удалите подстановочные знаки из строки версии или отключите детерминизм для этой компиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">Указанная строка версии "{0}" не соответствует требуемому формату: основной номер.дополнительный номер.сборка.редакция (без подстановочных знаков)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Указанная строка версии "{0}" не соответствует рекомендованному формату: основной номер.дополнительный номер.сборка.редакция</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">Указанная строка версии не соответствует рекомендованному формату — основной номер.дополнительный номер.сборка.редакция</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">Исполняемые файлы не могут быть вспомогательными сборками; язык и региональные параметры должны быть пустыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</source>
        <target state="translated">Отсутствует аргумент, соответствующий требуемому параметру "{0}" из "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">Переключатель командной строки "{0}" еще не реализован и был пропущен.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">Переключатель командной строки еще не реализован</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">Не удалось выдать модуль "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Не удается использовать фиксированную локальную переменную "{0}" внутри анонимного метода, лямбда-выражения или выражения запроса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">Дерево выражения не может содержать спецификацию именованного аргумента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">Дерево выражения не может содержать вызов, для которого используются необязательные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">Дерево выражения не может содержать индексированное свойство.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">Индексированное свойство "{0}" содержит необязательные аргументы, которые необходимо указать</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">У индексированного свойства "{0}" все аргументы должны быть необязательными</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">Экземпляр типа "{0}" нельзя использовать внутри вложенной функции, выражения запроса, блока итератора или асинхронного метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">Первым аргументом атрибута безопасности должен быть допустимый SecurityAction.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">Атрибут безопасности "{0}" имеет недопустимое значение SecurityAction "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">Значение SecurityAction "{0}" недопустимо для атрибутов безопасности, применяемых к сборке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">Значение SecurityAction "{0}" недопустимо для атрибутов безопасности, применяемых к типу или методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">Значение SecurityAction "{0}" недопустимо для атрибута PrincipalPermission.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">Дерево выражения не может содержать "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">Не удается разрешить путь файла "{0}", определенный для именованного аргумента "{1}" атрибута PermissionSet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">Ошибка чтения файла "{0}", указанного для именованного аргумента "{1}" для атрибута PermissionSet: '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">Не удалось найти имя типа "{0}" в глобальном пространстве имен. Этот тип был отправлен в сборку "{1}". Попробуйте добавить ссылку на эту сборку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">Не удалось найти имя типа "{0}" в пространстве имен "{1}". Этот тип был отправлен в сборку "{2}". Попробуйте добавить ссылку на эту сборку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">Не удалось найти имя типа "{0}". Этот тип был перемещен в сборку "{1}". Возможно, стоит добавить ссылку на эту сборку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">Сборки "{0}" и "{1}" ссылаются на одни метаданные, но только одна из них является связанной ссылкой (указан параметр using /link); попробуйте удалить одну из ссылок.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Рекомендуемый перегружаемый метод Add для элемента инициализатора коллекции устарел</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Рекомендуемый перегружаемый метод Add для элемента инициализатора коллекции устарел</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">Атрибут безопасности "{0}" не допускается для этого типа объявления. Атрибуты безопасности допустимы только в сборке, типе и объявлениях метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">Не удается использовать выражение типа "{0}" в качестве аргумента для динамически диспетчеризируемой операции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">Не удается использовать лямбда-выражение в качестве аргумента для динамически диспетчеризируемой операции без предварительного преобразования его в делегат или тип дерева выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">Не удается использовать группу методов в качестве аргумента для динамически диспетчеризируемой операции. Предполагалось вызывать этот метод?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Не удается выполнить требуемую для вызова метода "{0}" динамическую диспетчеризацию в связи с тем, что этот метод является частью базового выражения доступа. Попробуйте привести типы динамических аргументов или исключить доступ к базовым членам.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">Выражения запросов по источнику типа "dynamic" или с последовательностью объединения типа "dynamic" запрещены.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Не удается выполнить требуемую для доступа к индексатору динамическую диспетчеризацию, поскольку он является частью базового выражения доступа. Попробуйте привести типы динамических аргументов или исключить доступ к базовым членам.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">Вызов метода "{0}" с динамической диспетчеризацией может привести к ошибке во время выполнения, поскольку одна или несколько применимых перегрузок являются условными методами.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">Может произойти сбой динамически диспетчеризируемого вызова во время выполнения, так как одна или несколько применимых перегрузок являются условными методами</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">"{0}" не имеет применимого метода с именем "{1}", но, по-видимому, имеет метод расширения с таким именем. Методы расширения диспетчеризовать динамически. Попробуйте привести динамические аргументы или вызвать метод расширения без использования синтаксиса метода расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Применение CallerMemberNameAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">Атрибут CallerMemberNameAttribute не будет работать: он переопределяется атрибутом CallerFilePathAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Применение CallerMemberNameAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Атрибут CallerMemberNameAttribute не будет работать: он переопределяется атрибутом CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">Применение CallerFilePathAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerLineNumberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">Атрибут CallerFilePathAttribute не будет работать: он переопределяется атрибутом CallerLineNumberAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">Выражение должно быть неявно преобразуемым в логическое значение, или его тип "{0}" должен определять оператор "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">"{0}" не может реализовать "{1}", так как "{2}" является событием среды выполнения Windows и "{3}" является регулярным событием .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">Не удается внедрить тип взаимодействия "{0}". Используйте вместо него доступный интерфейс.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Не удается внедрить тип "{0}", так как он является вложенным. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Не удается внедрить тип "{0}", так как он имеет универсальный аргумент. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">Внедренная структура взаимодействия "{0}" может содержать только открытые экземпляры полей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Событие среды выполнения Windows не может передаваться как параметр out или ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">В исходном интерфейсе "{0}" отсутствует метод "{1}", обязательный для внедрения события "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">Интерфейс "{0}" имеет недопустимый исходный интерфейс, который требуется для внедрения события "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">Не удается внедрить тип взаимодействия "{0}", так как у него отсутствует обязательный атрибут "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">Не удается внедрить типы взаимодействия из сборки "{0}" из-за отсутствия в ней атрибута "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">Внедрение типов взаимодействия из сборки "{0}" невозможно, так как у нее отсутствует атрибут "{1}" или атрибут "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Не удается внедрить тип взаимодействия "{0}", находящийся в обеих сборках "{1}" и "{2}". Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Внедрение типа взаимодействия "{0}" из сборки "{1}" служит причиной конфликта имен в текущей сборке. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">Была создана ссылка на внедренную сборку взаимодействия "{0}", поскольку существует косвенная ссылка на эту сборку, созданная сборкой "{1}". Рассмотрите возможность изменения свойства "Внедрять типы взаимодействия" в любой сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">Создана ссылка на внедренную сборку взаимодействия из-за непрямой ссылки на сборку</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">Вы добавили ссылку на сборку с помощью /link (для свойства "Внедрять типы взаимодействия" задано значение true). Это сообщает компилятору, что следует внедрять сведения о типе взаимодействия из этой сборки. Однако компилятор не может внедрять сведения о типе взаимодействия из этой сборки, так как сборка, на которую указывает ссылка, также ссылается на сборку, использующую /reference (для свойства "Внедрять типы взаимодействия" задано значение false).

Чтобы внедрить сведения о типах взаимодействия в обе сборки, используйте /link для ссылок на каждую сборку (задайте для свойства "Внедрять типы взаимодействия" значение true).

Чтобы удалить предупреждение, можно использовать /reference (задайте для свойства "Внедрять типы взаимодействия" значение false). В этом случае основная сборка взаимодействия предоставит сведения о типе взаимодействия.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">Тип "{0}" из сборки "{1}" не может быть использован за границами сборки, так как имеет аргумент универсального типа, являющийся внедренным типом взаимодействия.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">Не удается найти тип взаимодействия, соответствующий внедренному типу взаимодействия "{0}". Возможно, отсутствует ссылка на сборку.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">Имя модуля "{0}", сохраненное в "{1}", должно соответствовать его имени файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">Недопустимое имя модуля: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">Недопустимое значение "{0}": '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath должен быть абсолютным.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Атрибут "{0}" модуля "{1}" будет игнорироваться, вместо него используется экземпляр в источнике.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">Вместо атрибута будет использоваться экземпляр, отображающийся в источнике</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">Атрибут "{0}", заданный в исходном файле, конфликтует с параметром "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">Буфер фиксированного размера может иметь только одно измерение.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">У сборки "{0}", на которую дается ссылка, нет строгого имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">Сборка, на которую указывает ссылка, не имеет строгого имени</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">В AssemblySignatureKeyAttribute определен недопустимый открытый ключ подписи.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Тип "{0}", экспортированный из модуля "{1}", конфликтует с типом, объявленным в основном модуле этой сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Тип "{0}", экспортированный из модуля "{1}", конфликтует с типом "{2}", экспортированным из модуля "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Отправленный тип "{0}" конфликтует с типом, объявленным в основном модуле этой сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">Тип "{0}", отправленный в сборку "{1}", конфликтует с типом "{2}", отправленным в сборку "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Тип "{0}", отправленный в сборку "{1}", конфликтует с типом "{2}", экспортированным из модуля "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">Сборка "{0}", на которую дается ссылка, использует другой параметр языка и региональных параметров "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">Сборка, на которую указывает ссылка, содержит другой параметр языка и региональных параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">Безразмерная сборка не может иметь модуль для конкретного процессора "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">Сборка и модуль "{0}" не могут предназначаться для разных процессоров.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">Сборка, на которую дана ссылка "{0}", направлена на другой процессор.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">Сборка, на которую указывает ссылка, предназначена для другого процессора</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">Сбой шифрования при создании хэшей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">Отсутствует ссылка на "{0}" netmodule.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">Модуль "{0}" уже определен в этой сборке. Каждый модуль должен иметь уникальное имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">Не удается выполнить чтение файла конфигурации "{0}" — "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">Не удается продолжить, так как оператор edit содержит ссылку на встроенный тип: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">Доступ к члену "{0}", добавленному в ходе текущего сеанса отладки, возможен только из его объявляющей сборки "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">Параметры компиляции "{0}" и "{1}" невозможно использовать одновременно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">Связанные метаданные netmodule должны обеспечивать полный образ PE: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred может использоваться только вместе с /t:exe, /t:winexe and /t:appcontainerexe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;список путей&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;текст&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">оператор, распространяющий значения Null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">метод, воплощающий выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">свойство, воплощающее выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">индексатор, воплощающий выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">автоматический инициализатор свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;пространство имен&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">возвращаемые данные и локальные переменные типа ByRef</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">ссылки только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">ссылочные структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">Компиляция (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">Синтаксический узел не находится в синтаксическом дереве.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Чтобы выполнить минимальную квалификацию типа, необходимо указать расположение.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Чтобы выполнить минимальную квалификацию типа, необходимо использовать SyntaxTreeSemanticModel.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">Не удается создать ссылку на компиляцию типа "{0}" из компиляции {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">Синтаксическое дерево уже имеется</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">Отправка может включать только код скрипта.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">Отправка может иметь максимум одно синтаксическое дерево.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">Дерево должно иметь корневой узел в SyntaxKind.CompilationUnit</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">Аргумент типа не может иметь значение Null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">Неверное число аргументов типа</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">Конфликтующее имя {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions имеет недопустимую комбинацию параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">элементы: не должно быть пустым</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Чтобы создать токены идентификаторов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier или Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Чтобы создать токены символьных литералов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Чтобы создать токены цифровых литералов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">Этот метод можно использовать только для создания токенов — {0} не является видом токена.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">Универсальный параметр является определением, а ожидается, что он будет ссылкой {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">GetDeclarationName вызывается для узла объявления, который может содержать множество операторов объявления переменных.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">Позиция не находится в пределах синтаксического дерева с полным диапазоном {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">Недопустимое имя языка "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">Имя языка недопустимо</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">Сбой при доступе к прозрачному члену идентификатора для поля "{0}" из "{1}".  Запрашиваемые данные реализуют шаблон запроса?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">Параметр имеет несколько различных значений по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">Поле имеет несколько различных константных значений.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">В атрибутах cref вложенные типы универсальных типов должны быть полными.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">Вложенные типы универсальных типов должны соответствовать в атрибутах cref</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">Не символ C# .</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">Ненужная директива using.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">Неиспользованный внешний псевдоним.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">Элементы не могут иметь значение Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">Переменная окружения LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">параметр /LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">Параметр /REFERENCEPATH</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">каталог не существует</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">слишком длинный или недопустимый путь.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">Значение для RuntimeMetadataVersion не обнаружено. Не обнаружена также сборка, содержащая System.Object, или значение для RuntimeMetadataVersion не определено параметрами.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">Не удалось найти значение RuntimeMetadataVersion</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">Требуется {0} SemanticModel.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">лямбда-выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 1. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 2. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 3. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 4. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 5. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 6. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 7.0. Используйте версию языка {1} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'"экспериментальный"</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">Позиция должна находиться в диапазоне синтаксического дерева.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">Предполагаемый синтаксический узел не может принадлежать синтаксическому дереву из текущей компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">Построение цепочки наблюдающей семантической модели не поддерживается. Необходимо создать наблюдающую модель из ненаблюдающей ParentModel.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Компилятор Microsoft (R) Visual C#</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} версии {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">© Корпорация Майкрософт (Microsoft Corporation). Все права защищены.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Поддерживаемые языковые версии:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">"{0}": класс с атрибутом ComImport не может указывать инициализаторы полей.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">Слишком длинное локальное имя "{0}" для PDB.  Попробуйте сократить или компилировать без /debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">Локальное имя слишком длинное для PDB-файла</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">Анонимная функция, преобразованная в делегата, возвращающего void, не может возвращать значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a '{0}' returning delegate cannot return a value</source>
        <target state="translated">Асинхронное лямбда-выражение, преобразованное в делегата, возвращающего "{0}", не может возвращать значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">Экземпляр анализатора {0} невозможно создать из {1} : {2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">Невозможно создать экземпляр анализатора</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">Сборка {0} не содержит анализаторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">Сборка не содержит анализаторов</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">Не удается загрузить сборку Analyzer {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">Не удалось загрузить сборку анализатора</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">Пропуск некоторых типов в сборке анализатора {0} из-за исключения ReflectionTypeLoadException: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">Ошибка при чтении файла с набором правил {0} — {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">Ошибка чтения отладочной информации для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">Операция вызвала переполнение стека.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">Ожидается идентификатор или численный литерал.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">Ожидается идентификатор или численный литерал</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties, or properties that use the 'field' keyword, can have initializers.</source>
        <target state="translated">Только автоматически реализованные свойства или свойства, использующие ключевое слово "field", могут содержать инициализаторы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">Автоматически реализованные свойства должны иметь методы доступа get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">Автоматически реализуемые свойства должны переопределять все методы доступа переопределенного свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">Не удается выдать отладочную информацию для исходного текста без кодировки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">Нельзя указывать тела блоков одновременно с телами выражений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">Управление не может выйти за пределы переключателя с окончательной меткой case ("{0}")</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">Лямбда дерева выражения не может содержать оператор распространения значений NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">Лямбда дерева выражения не может содержать инициализатор словаря.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">Расширение "Добавление метода" не поддерживается для инициализатора коллекции в лямбда-выражении.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">оператор nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">инициализатор словаря</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">Отсутствует закрывающий разделитель "}" для интерполированного выражения, начинающегося с "{".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">Выражение слишком длинное или сложное для компиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">Выражение не имеет имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">Невозможно использовать подвыражение в аргументе nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">Полное имя псевдонима не является выражением.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">Параметры типа не разрешены в группе методов в качестве аргумента "nameof".</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">Ожидается SearchCriteria.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">Строки языка и региональных параметров сборки могут не содержать встроенных символов NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">интерполированные строки</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">ожидать в блоках "Catch" и "Finally"</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">двоичные литералы</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">цифровые разделители</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">локальные функции</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">Символ "{0}" необходимо экранировать (путем дублирования) в интерполированной строке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">Символ "{0}" можно экранировать только двойными символами "{0}{0}" в интерполированной строке.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">Спецификатор формата не должен оканчиваться пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">Пустой спецификатор формата.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">Ошибка в связанной сборке "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">Ожидался оператор выражения или оператор объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">Группы метода выражения недопустимо использовать в качестве аргумента для nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">Величина значения выравнивания {0} больше, чем {1}; это может привести к возникновению большой форматированной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">Неиспользованный внешний псевдоним</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">Ненужная директива using</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">Пропуск загрузки типов в сборке анализатора, завершившихся сбоем из-за ReflectionTypeLoadException</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">Величина значения выравнивания может привести к возникновению большой форматированной строки</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">Длина строковой константы, полученной в результате объединения, превышает значение System.Int32.MaxValue. Попробуйте разделить строку на несколько констант.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">Кортеж должен содержать по меньшей мере два элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">Точкой входа отладки должно быть определение метода, объявленное в текущей компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load допускается только в скриптах</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">Нельзя использовать #load после первого токена в файле</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">Не удалось найти файл.</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">SyntaxTree получено из директивы #load и не может быть удалено или перемещено напрямую.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">Ссылки на исходный файл не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">Неправильный формат параметра pathmap.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">Недопустимый реальный литерал.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">Автоматически реализованные свойства не могут возвращать данные по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">Свойства, возвращающие данные по ссылке, должны иметь метод доступа get</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">Свойства, возвращающие данные по ссылке, не могут иметь методы доступа set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">"{0}" должен соответствовать возвращаемому по ссылке типу переопределенного члена "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">Возвращаемые по ссылке данные можно использовать только в методах, которые возвращают данные по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">Возвращаемые по значению данные можно использовать только в методах, которые возвращают данные по значению</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">Выражение return должно иметь тип "{0}", так как этот метод возвращает данные по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">"{0}" не реализует член интерфейса "{1}". "{2}" не может реализовать "{1}", так как он не имеет соответствующего возвращаемого по ссылке типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">Тело "{0}" не может быть блоком итератора, так как "{0}" возвращает данные по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">Лямбда-выражения, возвращающие данные по ссылке, невозможно преобразовать в деревья выражений</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">Дерево лямбда-выражения не может содержать вызов метода, свойства или индексатора, который возвращает данные по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">Невозможно использовать выражение в этом контексте, так как его невозможно передать или вернуть по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Невозможно вернуть по ссылке "{0}", так как он был инициализирован значением, которое нельзя вернуть по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Невозможно вернуть по ссылке член "{0}", так как он был инициализирован значением, которое нельзя вернуть по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">Невозможно вернуть переменную диапазона "{0}" по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">Поле, доступное только для чтения, невозможно вернуть по ссылке, доступной для записи</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">Статическое поле, доступное только для чтения, невозможно вернуть по ссылке для записи</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Члены поля "{0}", доступного только для чтения, нельзя вернуть по ссылке, доступной для записи</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Поля статического поля "{0}", доступного только для чтения, нельзя вернуть по ссылке для записи</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref parameter</source>
        <target state="translated">Невозможно вернуть параметр по ссылке "{0}" поскольку это не параметр ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">Невозможно вернуть по ссылке член параметра "{0}", так как это не параметр ref или out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Невозможно вернуть по ссылке локальный "{0}", так как это не локальная переменная ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Невозможно вернуть по ссылке член локального элемента "{0}", так как это не локальная переменная ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">Члены структуры не могут возвращать по ссылке члены экземпляра this или другого экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">Выражение нельзя использовать в этом контексте, так как из-за этого переменные могут стать косвенно доступными за пределами их области объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Результат "{0}" нельзя использовать в этом контексте, так как из-за этого переменные, на которые ссылается параметр "{1}", могут стать доступными за пределами их области объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Элемент результата "{0}" нельзя использовать в этом контексте, так как из-за этого переменные, на которые ссылается параметр "{1}", могут стать доступными за пределами их области объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Это сочетание аргументов для "{0}" запрещено, так как оно может делать переменные, на которые ссылается параметр "{1}", доступными за пределами их области объявления</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">Ветви условного оператора ref не могут ссылаться на переменные с несовместимыми областями объявления</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">Результат выражения stackalloc типа "{0}" нельзя использовать в этом контексте, так как он может быть доступен вне содержащего метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">Невозможно инициализировать ссылкой переменную по значению</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">Невозможно инициализировать значением переменную по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">Выражение должно иметь тип "{0}", так как ему назначается значение по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">Объявление переменной по ссылке должно иметь инициализатор</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Невозможно использовать локальную переменную ref "{0}" внутри анонимного метода, лямбда-выражения или выражения запроса</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Ссылка, возвращенная вызовом ' {0} ', не может быть сохранена за границей 'wait' или 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'await не может использоваться в выражении, содержащем условный оператор ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">Либо оба значения ссылочного оператора должны быть ссылочными, либо ни одно из них не должно быть ссылочным</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">Для соответствия альтернативному ссылочному значению выражение должно иметь тип "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">Дерево выражений не может содержать ссылку на локальную функцию</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">Нельзя передать аргумент динамического типа в параметр params "{0}" локальной функции "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">Дерево синтаксиса должно быть создано из отправки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals or try the EXPERIMENTAL feature flag 'experimental-data-section-string-literals'.</source>
        <target state="translated">Объединенная длина пользовательских строк, используемых программой, превышает допустимый предел. Попробуйте уменьшить использование строковых литералов или попробуйте ЭКСПЕРИМЕНТАЛЬНЫЙ флаг функции "experimental-data-section-string-literals".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</source>
        <target state="translated">В шаблоне не может использоваться тип "{0}", допускающий значение NULL. Используйте вместо него базовый тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">Произошла ошибка при записи выходного файла: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">Имена элементов кортежа должны быть уникальными.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">Имя элемента кортежа "{0}" допускается только в позиции {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">Имя элемента кортежа "{0}" не допускается ни в одной позиции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">Член "{0}" не найден в типе "{1}" из сборки "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">кортежи</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">Для типа "{0}" не найден подходящий экземпляр деконструкции или метод расширения с типом возвращаемого значения void и следующим числом параметров out: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">Назначению деконструкции требуется выражение с типом справа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">Выражение оператора switch должно быть значением; найдено "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">Выражение типа "{0}" не может быть обработано шаблоном типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">Атрибут "{0}" пропускается при указании общедоступного подписывания.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">Атрибут пропускается при указании общедоступного подписывания.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">Параметр "{0}" должен быть абсолютным путем.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">Кортеж со следующим числом элементов: {0} невозможно преобразовать в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">объявление переменной с параметром OUT</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">Невозможно определить тип неявно типизированной переменной "out" "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">Не удается вывести тип переменной неявно типизированных деконструирований "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">Невозможно определить тип неявно типизированной отмены.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">Невозможно деконструировать кортеж элементов "{0}" на переменные "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">Невозможно деконструировать динамические объекты.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">Деконструирование должно иметь не менее двух переменных.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">Имя элемента кортежа "{0}" игнорируется, так как целевым типом "{1}" задано другое имя либо имя не задано.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">Имя элемента кортежа игнорируется, так как целевым объектом назначения задано другое имя либо имя не задано.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">Предопределенный тип "{0}" должен быть структурой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'"new" невозможно использовать с типом кортежа. Вместо этого используйте литеральное выражение кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">Форма деконструирования "var (...)" не разрешает использовать конкретный тип для "var".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Невозможно определить класс или элемент, использующий кортежи, так как не удалось найти необходимый тип компилятора ({0}). Отсутствует ссылка?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">Невозможно явным образом добавить ссылку на "System.Runtime.CompilerServices.TupleElementNamesAttribute". Используйте синтаксис кортежа для определения имен кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">Дерево выражений не может содержать объявление переменной аргумента out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">Дерево выражений не может содержать отмену.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">Дерево выражений не может содержать оператор соответствия шаблону is.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">Дерево выражений не может содержать литерал кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">Дерево выражений не может содержать преобразование кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">Параметр /sourcelink поддерживается только при создании данных формата PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">Параметр /embed поддерживается только при создании PDB-файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">Недопустимый тип инструментирования: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">Синтаксис "var (...)" как lvalue зарезервирован.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">Ожидается "{" или ";" или "=&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">Выражение Throw в данном контексте запрещено.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">Объявление недопустимо в этом контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Цикл foreach должен объявлять собственные переменные итерации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">Имена элементов кортежа не разрешены в левой части деконструирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">Для приведения отрицательного значения следует заключить значение в круглые скобки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">Дерево выражений не может содержать выражение throw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">Недопустимое имя сборки: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">Чтобы тип "{0}" можно было использовать как AsyncMethodBuilder для типа "{1}", его свойство Task должно возвращать тип "{1}" вместо "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">Модуль "{0}" в сборке "{1}" перенаправляет тип "{2}" в несколько сборок: "{3}" и "{4}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">Запрещено использовать тип dynamic в шаблоне.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">Указанный режим документации не поддерживается или недопустим: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">Указанный тип исходного кода не поддерживается или недопустим: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">Указанная версия языка не поддерживается или недопустима: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Недопустимое имя символа предварительной обработки. "{0}" не является допустимым идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">Возможность "{0}" недоступна в C# 7.1. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">Компонент "{0}" недоступен в C# 7.2. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">Указанная версия языка "{0}" не может содержать начальные нули.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">Значение типа void нельзя назначить.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">"{0}" предназначен только для оценки и может быть изменен или удален в будущих обновлениях. Чтобы продолжить, скройте эту диагностику.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Тип предназначен только для оценки и может быть изменен или удален в будущих обновлениях. Чтобы продолжить, скройте эту диагностику.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}. Compiler path: '{2}'.</source>
        <target state="new">Compiler version: '{0}'. Language version: {1}. Compiler path: '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">async main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">Имя элемента кортежа "{0}" является выведенным. Для обращения к элементу по выведенному имени используйте версию языка {1} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">Кортеж не может содержать значение типа void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">Функция void or int, возвращающая точку входа, не может быть асинхронной</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">Выражение типа "{0}" не может быть обработано шаблоном типа "{1}" в C# {2}. Используйте версию языка {3} или более позднюю.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">Локальная функция "{0}" объявлена, но не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">Локальная функция объявлена, но не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="translated">Локальная функция "{0}" должна объявить тело, так как она не помечена как "static extern".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}': {3}</source>
        <target state="translated">Не удается прочитать отладочную информацию метода "{0}"' (токен 0x{1:X8}) из сборки "{2}": {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} не является допустимым выражением преобразования C#</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">Невозможно передать аргумент с динамическим типом в универсальную локальную функцию "{0}" с выводимыми аргументами типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">разделитель начальных цифр</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">Не используйте "{0}". Этот атрибут зарезервирован для использования компилятором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">Имя типа "{0}" зарезервировано для использования компилятором.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">Первый параметр "in" или "readonly" метода расширения "{0}" должен быть конкретным (неуниверсальным) типом значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">Поля экземпляров в структурах только для чтения должны быть доступны только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">Автоматически реализуемые свойства экземпляра в структурах только для чтения должны быть доступны только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">Подобные полям события не допускаются в структурах только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">ссылочные методы расширения</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">Невозможно преобразовать выражение stackalloc типа "{0}" в тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">Первый параметр метода расширения "ref" "{0}" должен иметь тип значения или универсальный тип, ограниченный структурой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">Входной параметр не может иметь атрибут Out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} не является допустимой операцией составного назначения C#</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">Выражение фильтра является константой "false", попробуйте удалить выражение catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">Выражение фильтра является константой "false"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">Выражение фильтра является константой "false", попробуйте удалить блок try-catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">Выражение фильтра является константой "false". </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">У __arglist не может быть аргумента типа void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">Условное выражение не может использоваться напрямую в интерполяции строк, так как интерполяция заканчивается на ":". Заключите условное выражение в скобки.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">Не используйте атрибут "System.Runtime.CompilerServices.FixedBuffer" для свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">Компонент "{0}" недоступен в C# 7.3. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">Ориентированные на поле атрибуты для автосвойств не поддерживаются в версии языка {0}. Используйте версию языка {1} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">Ориентированные на поле атрибуты для автосвойств не поддерживаются в этой версии языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">async streams</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">"{0}": тип, используемый в асинхронном операторе using, должен допускать реализовывать "System.IAsyncDisposable" или подходящий метод "DisposeAsync".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">Асинхронный оператор foreach требует, чтобы возвращаемый тип "{0}" для "{1}" имел соответствующий открытый метод "MoveNextAsync" и открытое свойство "Current".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">Асинхронный оператор foreach не может использоваться с переменными типа "{0}", так как он реализует создание нескольких экземпляров "{1}". Попробуйте выполнить приведение к созданию экземпляра определенного интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</source>
        <target state="translated">Операторы преобразования, равенства или неравенства, объявленные в интерфейсах, должны быть абстрактными или виртуальными</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">Целевая среда выполнения не поддерживает реализацию интерфейса по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">"{0}" не может реализовать член интерфейса "{1}" в типе "{2}", так как целевая среда выполнения не поддерживает реализацию интерфейса по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</source>
        <target state="translated">"{0}" не реализует элемент интерфейса "{1}". "{2}" не может неявно реализовать непубличный элемент в C# {3}. Используйте язык версии "{4}" или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">Член интерфейса "{0}" не имеет наиболее конкретной реализации. Ни "{1}", ни "{2}" не являются наиболее конкретными.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>