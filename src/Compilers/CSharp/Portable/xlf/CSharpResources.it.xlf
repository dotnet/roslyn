<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CallingConventionTypeIsInvalid">
        <source>Cannot use '{0}' as a calling convention modifier.</source>
        <target state="translated">Non è possibile usare '{0}' come modificatore di convenzione di chiamata.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallingConventionTypesRequireUnmanaged">
        <source>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</source>
        <target state="translated">Non è possibile '{0}' a meno che '{1}' non sia 'SignatureCallingConvention.Unmanaged'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">Non è possibile creare un tipo generico costruito a partire da un altro tipo generico costruito.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">Non è possibile creare un tipo generico costruito a partire da un tipo non generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractConversionNotInvolvingContainedType">
        <source>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</source>
        <target state="translated">La conversione definita dall'utente in un'interfaccia deve essere convertita da o in un parametro di tipo nel tipo di inclusione vincolato al tipo di inclusione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">'{0}': l'evento astratto non può usare la sintassi della funzione di accesso agli eventi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInIterator">
        <source>The '&amp;' operator cannot be used on parameters or local variables in iterator methods.</source>
        <target state="translated">L'operatore '&amp;' non può essere usato su parametri o variabili locali in metodi iteratore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfMethodGroupInExpressionTree">
        <source>'&amp;' on method groups cannot be used in expression trees</source>
        <target state="translated">Non è possibile usare '&amp;' su gruppi di metodi in alberi delle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfToNonFunctionPointer">
        <source>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</source>
        <target state="translated">Non è possibile convertire il gruppo di &amp;metodi '{0}' nel tipo di puntatore non a funzione '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AllowsClauseMustBeLast">
        <source>The 'allows' constraint clause must be the last constraint specified</source>
        <target state="translated">La clausola del vincolo 'allows' deve essere l'ultimo vincolo specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">Per usare '@$' invece di '$@' per una stringa verbatim interpolata, usare la versione '{0}' o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</source>
        <target state="translated">L'operatore '{0}' è ambiguo sugli operandi '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">Non è possibile applicare l'operatore '{0}' a 'default ' e all'operando di tipo '{1}' perché è un parametro di tipo non noto come tipo riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigExtension">
        <source>The extension resolution is ambiguous between the following members: '{0}' and '{1}'</source>
        <target state="new">The extension resolution is ambiguous between the following members: '{0}' and '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOperator">
        <source>Operator resolution is ambiguous between the following members: '{0}' and '{1}'</source>
        <target state="new">Operator resolution is ambiguous between the following members: '{0}' and '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver">
        <source>Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.</source>
        <target state="translated">L'identificatore '{0}' è ambiguo tra il tipo '{1}' e il parametro '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">Non è possibile usare un tipo riferimento nullable durante la creazione di oggetti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseRefLike">
        <source>Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Non è possibile usare il parametro '{0}' con tipo simile a ref all'interno di un metodo anonimo, di un'espressione lambda, di un'espressione di query o di una funzione locale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterCaptured">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member</source>
        <target state="translated">Metodi anonimi, espressioni lambda, espressioni di query e funzioni locali all'interno di uno struct non possono accedere al parametro del costruttore primario usato anche all'interno di un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseStructPrimaryConstructorParameterInMember">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter</source>
        <target state="translated">Metodi anonimi, espressioni lambda, espressioni di query e funzioni locali all'interno di un membro di istanza di uno struct non possono accedere al parametro del costruttore primario</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">I nomi di elemento non sono consentiti quando si definiscono criteri di ricerca tramite 'System.Runtime.CompilerServices.ITuple'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Non è consentito usare il tipo riferimento nullable '{0}?' in un'espressione as. Usare il tipo sottostante '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Non è assegnare un parametro del costruttore primario di un tipo di sola lettura, tranne che nel setter di sola inizializzazione del tipo o in un inizializzatore di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Non è possibile modificare i membri del parametro del costruttore primario '{0}' di un tipo di sola lettura, tranne che nel setter di sola inizializzazione del tipo o in un inizializzatore di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</source>
        <target state="translated">L'indicizzatore o la proprietà di sola inizializzazione '{0}' può essere assegnata solo in un inizializzatore di oggetto oppure in 'this' o 'base' in un costruttore di istanza o una funzione di accesso 'init'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrDependentTypeNotAllowed">
        <source>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</source>
        <target state="translated">Non è possibile usare il tipo '{0}' in questo contesto perché non può essere rappresentato nei metadati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrTypeArgCannotBeTypeVar">
        <source>'{0}': an attribute type argument cannot use type parameters</source>
        <target state="translated">'{0}': un argomento di tipo di attributo non può usare parametri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCannotBeAppliedManually">
        <source>'{0}' cannot be applied manually.</source>
        <target state="new">'{0}' cannot be applied manually.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">L'attributo '{0}' non è valido nelle funzioni di accesso a eventi. È valido solo nelle dichiarazioni di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesRequireParenthesizedLambdaExpression">
        <source>Attributes on lambda expressions require a parenthesized parameter list.</source>
        <target state="translated">Gli attributi nelle espressioni lambda richiedono un elenco di parametri tra parentesi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">La proprietà implementata automaticamente '{0}' non può essere contrassegnata come 'readonly' perché include una funzione di accesso 'set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">La funzione di accesso 'set' '{0}' implementata automaticamente non può essere contrassegnata come 'readonly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</source>
        <target state="translated">L'istruzione foreach asincrona non può funzionare con variabili di tipo '{0}' perché '{0}' non contiene una definizione di istanza o estensione pubblica idonea per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">L'istruzione foreach asincrona non può funzionare con variabili di tipo '{0}' perché '{0}' non contiene una definizione di istanza o estensione pubblica per '{1}'. Si intendeva 'foreach' invece di 'await foreach'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Uno dei parametri di un operatore binario deve essere il tipo che lo contiene o il relativo parametro di tipo vincolato ad esso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractEqualityOperatorSignature">
        <source>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</source>
        <target state="translated">Uno dei parametri di un operatore di uguaglianza o disuguaglianza dichiarato nell'interfaccia '{0}' deve essere un parametro di tipo in '{0}' vincolato a '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecRetType">
        <source>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</source>
        <target state="translated">Il tipo restituito per l'operatore ++ o -- deve corrispondere al tipo di parametro, essere derivato dal tipo di parametro oppure essere il parametro di tipo del tipo che lo contiene, a meno che il tipo di parametro non sia un parametro di tipo diverso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">Il tipo di parametro per l'operatore ++ o -- deve essere il tipo che lo contiene o il relativo parametro di tipo vincolato ad esso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</source>
        <target state="translated">Il primo operando di un operatore di spostamento sovraccaricato deve avere lo stesso tipo del tipo che lo contiene o del relativo parametro di tipo vincolato ad esso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractStaticMemberAccess">
        <source>A static virtual or abstract interface member can be accessed only on a type parameter.</source>
        <target state="translated">È possibile accedere a un membro di interfaccia statico virtuale o astratto solo su un parametro di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAbstractUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</source>
        <target state="translated">I parametri di un operatore unario deve essere il tipo che lo contiene o il relativo parametro di tipo vincolato ad esso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAllowByRefLikeEnumerator">
        <source>foreach statement cannot operate on enumerators of type '{0}' because it is a type parameter that allows ref struct and it is not known at compile time to implement IDisposable.</source>
        <target state="translated">L'istruzione foreach non può operare su enumeratori di tipo '{0}' perché è un parametro di tipo che consente il ref struct e non è noto in fase di compilazione per implementare IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRefLangVersion">
        <source>Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.</source>
        <target state="translated">Non è possibile passare l'argomento {0} con la parola chiave 'ref' nella versione del linguaggio {1}. Per passare gli argomenti 'ref' ai parametri 'in', eseguire l'aggiornamento alla versione del linguaggio {2} o versione successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryReadOnlySpanConcatenation">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</source>
        <target state="translated">Non è possibile applicare l'operatore '{0}' a operandi di tipo '{1}' e '{2}' che non sono rappresentazioni di UTF-8 byte</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
        <source>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerArgumentExpressionAttribute può essere applicato solo a parametri con valori predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCaseInSwitchArm">
        <source>A switch expression arm does not begin with a 'case' keyword.</source>
        <target state="translated">Un braccio dell'espressione switch non inizia con una parola chiave 'case'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCollectionArgumentsArgCount">
        <source>No overload for method '{0}' takes {1} 'with(...)' element arguments</source>
        <target state="new">No overload for method '{0}' takes {1} 'with(...)' element arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompoundAssignmentOpArgs">
        <source>Overloaded compound assignment operator '{0}' takes one parameter</source>
        <target state="new">Overloaded compound assignment operator '{0}' takes one parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">Non è possibile usare una raccolta di tipo dinamico in un'istruzione foreach asincrona</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the extended type.</source>
        <target state="new">One of the parameters of a binary operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionContainingType">
        <source>Extensions must be declared in a top-level, non-generic, static class</source>
        <target state="new">Extensions must be declared in a top-level, non-generic, static class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the extended type.</source>
        <target state="new">The parameter type for ++ or -- operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the extended type</source>
        <target state="new">The first operand of an overloaded shift operator must have the same type as the extended type</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the extended type.</source>
        <target state="new">The parameter of a unary operator must be the extended type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFieldTypeInRecord">
        <source>The type '{0}' may not be used for a field of a record.</source>
        <target state="translated">Il tipo '{0}' non può essere usato per un campo di un record.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerArgCount">
        <source>Function pointer '{0}' does not take {1} arguments</source>
        <target state="translated">Il puntatore a funzione '{0}' non accetta {1} argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFuncPointerParamModifier">
        <source>'{0}' cannot be used as a modifier on a function pointer parameter.</source>
        <target state="translated">Non è possibile usare '{0}' come modificatore in un parametro di puntatore a funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInheritanceFromRecord">
        <source>Only records may inherit from records.</source>
        <target state="translated">Solo i record possono ereditare dai record.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInitAccessor">
        <source>The 'init' accessor is not valid on static members</source>
        <target state="translated">La funzione di accesso 'init' non è valida nei membri statici</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonVirtualInterfaceMemberAccessOnAllowsRefLike">
        <source>A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.</source>
        <target state="translated">Impossibile accedere a un membro dell'interfaccia dell'istanza non virtuale in un parametro di tipo che consente ref struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">L'opzione '{0}' non è valida per /nullable. Deve essere 'disable', 'enable', 'warnings' o 'annotations'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableReferenceTypeInUsingAlias">
        <source>Using alias cannot be a nullable reference type.</source>
        <target state="translated">L'alias using non può essere un tipo riferimento nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">Non è possibile usare l'operatore typeof nel tipo riferimento nullable</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefaultOrNew">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">Non è possibile applicare l'operatore '{0}' all'operando '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">L'operando non è valido per i criteri di ricerca. È richiesto un valore ma è stato trovato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordBase">
        <source>Records may only inherit from object or another record</source>
        <target state="translated">I record possono ereditare solo dall'oggetto o da un altro record</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordMemberForPositionalParameter">
        <source>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</source>
        <target state="translated">Il membro di record '{0}' deve essere una proprietà di istanza leggibile o campo di tipo '{1}' per corrispondere al parametro posizionale '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefParameter">
        <source>Parameters of type '{0}' cannot be declared in async methods or async lambda expressions.</source>
        <target state="translated">Non è possibile dichiarare parametri di tipo '{0}' in metodi asincroni o espressioni lambda asincrone.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefInUsingAlias">
        <source>Using alias cannot be a 'ref' type.</source>
        <target state="translated">L'alias using non può essere di tipo 'ref'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpreadInCatchFilter">
        <source>Cannot use '..' spread operator in the filter expression of a catch clause</source>
        <target state="new">Cannot use '..' spread operator in the filter expression of a catch clause</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticAfterUnsafe">
        <source>'static' modifier must precede 'unsafe' modifier.</source>
        <target state="translated">Il modificatore 'static' deve precedere il modificatore 'unsafe'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">Errore di sintassi della riga di comando: '{0}' non è un valore valido per l'opzione '{1}'. Il valore deve essere espresso nel formato '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnsafeInUsingDirective">
        <source>Only a 'using static' or 'using alias' can be 'unsafe'.</source>
        <target state="translated">Solo 'using static' o 'using alias' può essere 'unsafe'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingStaticType">
        <source>'{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.</source>
        <target state="translated">'{0}' tipo non valido per 'using static'. È possibile usare solo una classe, una struttura, un'interfaccia, un'enumerazione, un delegato o uno spazio dei nomi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseType">
        <source>Inconsistent accessibility: type '{1}' is less accessible than class '{0}' </source>
        <target state="new">Inconsistent accessibility: type '{1}' is less accessible than class '{0}' </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInUnsafe">
        <source>Cannot use 'yield return' in an 'unsafe' block</source>
        <target state="translated">Non è possibile usare 'yield return' in un blocco 'unsafe'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BuilderAttributeDisallowed">
        <source>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</source>
        <target state="translated">L'attributo AsyncMethodBuilder non è consentito in metodi anonimi senza un tipo restituito esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToMember">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on this member.</source>
        <target state="translated">Non è possibile usare 'OverloadResolutionPriorityAttribute' per questo membro.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotApplyOverloadResolutionPriorityToOverride">
        <source>Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.</source>
        <target state="translated">Non è possibile usare 'OverloadResolutionPriorityAttribute' in un membro di override.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeConvertedToUtf8">
        <source>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</source>
        <target state="translated">Impossibile convertire la stringa di input nella rappresentazione di UTF-8 byte equivalente. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'{0}' non può essere reso nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotClone">
        <source>The receiver type '{0}' is not a valid record type and is not a struct type.</source>
        <target state="translated">Il tipo di ricevitore '{0}' non è un tipo di record valido e non è un tipo struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertAddressOfToDelegate">
        <source>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</source>
        <target state="translated">Non è possibile convertire il gruppo di &amp;metodi '{0}' nel tipo delegato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDynamicInvokeOnExpression">
        <source>Cannot perform a dynamic invocation on an expression with type '{0}'.</source>
        <target state="translated">Non è possibile eseguire una chiamata dinamica su un'espressione con tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferDelegateType">
        <source>The delegate type could not be inferred.</source>
        <target state="translated">Non è possibile dedurre il tipo di delegato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotMatchOnINumberBase">
        <source>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specific numeric type.</source>
        <target state="needs-review-translation">Non è possibile usare una costante numerica o un modello relazionale su '{0}' perché eredita da o estende 'INumberBase&lt;T&gt;'. Provare a usare un modello di tipo per limitare a un tipo numerico specifico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
        <source>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</source>
        <target state="translated">Non è possibile combinare la convenzione di chiamata 'managed' con identificatori di convenzione di chiamata non gestita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseFunctionPointerAsFixedLocal">
        <source>The type of a local declared in a fixed statement cannot be a function pointer type.</source>
        <target state="translated">Il tipo di una variabile locale dichiarata in un'istruzione fixed non può essere un tipo di puntatore a funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
        <source>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Non è possibile usare '{0}' come tipo {1} in un metodo con attributo 'UnmanagedCallersOnly'.</target>
        <note>1 is the localized word for 'parameter' or 'return'. UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_CannotUseReducedExtensionMethodInAddressOf">
        <source>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</source>
        <target state="translated">Non è possibile usare un metodo di estensione con un ricevitore come destinazione di un operatore '&amp;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseRefInUnmanagedCallersOnly">
        <source>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Non è possibile usare 'ref', 'in' o 'out' nella firma di un metodo con attributo 'UnmanagedCallersOnly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
        <source>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</source>
        <target state="translated">Gli argomenti di InterpolatedStringHandlerArgumentAttribute non possono fare riferimento al parametro in cui viene usato l'attributo.</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_CantChangeInitOnlyOnOverride">
        <source>'{0}' must match by init-only of overridden member '{1}'</source>
        <target state="translated">'{0}' deve corrispondere per sola inizializzazione del membro '{1}' di cui è stato eseguito l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturnType">
        <source>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</source>
        <target state="translated">Non è possibile convertire {0} nel tipo ' {1}' perché il tipo restituito non corrisponde al tipo restituito del delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">__arglist non può contenere un argomento passato da 'in' o 'out'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
        <source>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</source>
        <target state="translated">Questo costruttore deve aggiungere 'SetsRequiredMembers' perché è concatenato a un costruttore che ha tale attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOperatorNeedsMatch">
        <source>The operator '{0}' requires a matching non-checked version of the operator to also be defined</source>
        <target state="translated">L'operatore '{0}' richiede che sia definita anche una versione non controllata corrispondente dell’operatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassIsCombinedWithRefStruct">
        <source>Cannot allow ref structs for a type parameter known from other constraints to be a class</source>
        <target state="translated">Non è possibile consentire che i ref struct per un parametro di tipo noto da altri vincoli siano una classe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloneDisallowedInRecord">
        <source>Members named 'Clone' are disallowed in records.</source>
        <target state="translated">Nei record non sono consentiti membri denominati 'Clone'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotStatic">
        <source>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia statico '{1}'. '{2}' non può implementare il membro di interfaccia perché è di tipo statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberOperatorMismatch">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because one of them is not an operator.</source>
        <target state="new">'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because one of them is not an operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionArgumentsDynamicBinding">
        <source>'with(...)' element arguments cannot be dynamic</source>
        <target state="new">'with(...)' element arguments cannot be dynamic</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionArgumentsMustBeEmpty">
        <source>'with(...)' element for a read-only interface must be empty if present</source>
        <target state="new">'with(...)' element for a read-only interface must be empty if present</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionArgumentsMustBeFirst">
        <source>'with(...)' element must be the first element</source>
        <target state="new">'with(...)' element must be the first element</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionArgumentsNotSupportedForType">
        <source>'with(...)' elements are not supported for type '{0}'</source>
        <target state="new">'with(...)' elements are not supported for type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidMethodName">
        <source>The CollectionBuilderAttribute method name is invalid.</source>
        <target state="translated">Il nome del metodo CollectionBuilderAttribute non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeInvalidType">
        <source>The CollectionBuilderAttribute builder type must be a non-generic class or struct.</source>
        <target state="translated">Il tipo di compilatore CollectionBuilderAttribute deve essere una classe o uno struct non generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderAttributeMethodNotFound">
        <source>Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan&lt;{1}&gt;' and return type '{2}'.</source>
        <target state="translated">Non è stato possibile trovare un metodo accessibile '{0}' con la firma prevista: un metodo statico con un singolo parametro di tipo 'ReadOnlySpan&lt;{1}&gt;' e di tipo restituito '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionBuilderNoElementType">
        <source>'{0}' has a CollectionBuilderAttribute but no element type.</source>
        <target state="translated">'{0}' include CollectionBuilderAttribute ma nessun tipo di elemento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionEscape">
        <source>A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.</source>
        <target state="translated">Un'espressione di raccolta di tipo '{0}' non può essere usata in questo contesto perché potrebbe essere esposta al di fuori dell'ambito corrente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionImmutableArray">
        <source>This version of '{0}' cannot be used with collection expressions.</source>
        <target state="translated">Questa versione di '{0}' non può essere utilizzata con espressioni di raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingAdd">
        <source>Collection expression type '{0}' must have an instance or extension method 'Add' that can be called with a single argument.</source>
        <target state="translated">Il tipo di espressione della raccolta "{0}" deve avere un'istanza o un metodo di estensione "Add" da poter chiamare con un argomento singolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionMissingConstructor">
        <source>Collection expression type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Il tipo di espressione della raccolta deve avere un costruttore applicabile che può essere chiamato senza argomenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionNoTargetType">
        <source>There is no target type for the collection expression.</source>
        <target state="translated">Nessun tipo di destinazione per l'espressione di raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetNoElementType">
        <source>Collection expression target '{0}' has no element type.</source>
        <target state="translated">La destinazione dell'espressione di raccolta '{0}' non contiene alcun tipo di elemento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionExpressionTargetTypeNotConstructible">
        <source>Cannot initialize type '{0}' with a collection expression because the type is not constructible.</source>
        <target state="translated">Non è possibile inizializzare il tipo '{0}' con un'espressione di raccolta perché il tipo non è costruibile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitializerInfiniteChainOfAddCalls">
        <source>Collection initializer results in an infinite chain of instantiations of collection '{0}'.</source>
        <target state="translated">L'inizializzatore di raccolta genera una catena infinita di creazioni di istanze della raccolta '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionRefLikeElementType">
        <source>Element type of this collection may not be a ref struct or a type parameter allowing ref structs</source>
        <target state="new">Element type of this collection may not be a ref struct or a type parameter allowing ref structs</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilationUnitUnexpected">
        <source>A compilation unit cannot directly contain members such as fields, methods or properties</source>
        <target state="new">A compilation unit cannot directly contain members such as fields, methods or properties</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Il parametro di tipo '{1}' ha il vincolo 'managed'. Non è quindi possibile usare '{1}' come vincolo per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="translated">Per usare l'attributo Conditional, la funzione locale '{0}' deve essere 'static'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">Un'espressione di tipo '{0}' non può essere gestita da un criterio di tipo '{1}'. Usare la versione '{2}' o versioni successive del linguaggio per abbinare un tipo aperto a un criterio costante.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantValueOfTypeExpected">
        <source>A constant value of type '{0}' is expected</source>
        <target state="translated">È previsto un valore costante di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorMustInvokeBaseCopyConstructor">
        <source>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</source>
        <target state="translated">Un costruttore di copia in un record deve chiamare un costruttore di copia della base o un costruttore di oggetto senza parametri se il record eredita dall'oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyConstructorWrongAccessibility">
        <source>A copy constructor '{0}' must be public or protected because the record is not sealed.</source>
        <target state="translated">Un costruttore di copia '{0}' deve essere pubblico o protetto perché il record non è sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DataSectionStringLiteralHashCollision">
        <source>Cannot emit this string literal into the data section because it has XXHash128 collision with another string literal: {0}</source>
        <target state="new">Cannot emit this string literal into the data section because it has XXHash128 collision with another string literal: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">Il nome '{0}' non corrisponde al parametro '{1}' di 'Deconstruct' corrispondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructVariableCannotBeByRef">
        <source>A deconstruction variable cannot be declared as a ref local</source>
        <target state="translated">Una variabile di decostruzione non può essere dichiarata come variabile locale di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultConstraintOverrideOnly">
        <source>The 'default' constraint is valid on override and explicit interface implementation methods only.</source>
        <target state="translated">Il vincolo 'default' è valido solo in metodi di override e di implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Non è possibile incorporare il tipo '{0}' perché contiene un membro non astratto. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">Non esiste alcun tipo di destinazione per il valore letterale predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">Non è possibile usare un valore letterale predefinito 'default' come criterio. Usare un altro valore letterale, ad esempio '0' o 'null'. Per abbinare tutto, usare un criterio di rimozione '_'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeforePropertyPattern">
        <source>A variable designator must come after a property pattern.</source>
        <target state="new">A variable designator must come after a property pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DesignatorBeneathPatternCombinator">
        <source>A variable may not be declared within a 'not' or 'or' pattern.</source>
        <target state="translated">Non è possibile dichiarare una variabile all'interno di un criterio 'not' o 'or'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">Il criterio di rimozione non è consentito come etichetta case in un'istruzione switch. Usare 'case var _:' per un criterio di rimozione oppure 'case @_:' per una costante denominata '_'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseEqualityContract">
        <source>'{0}' does not override expected property from '{1}'.</source>
        <target state="translated">'{0}' non esegue l'override della proprietà prevista da '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideBaseMethod">
        <source>'{0}' does not override expected method from '{1}'.</source>
        <target state="translated">'{0}' non esegue l'override del metodo previsto da '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesNotOverrideMethodFromObject">
        <source>'{0}' does not override expected method from 'object'.</source>
        <target state="translated">'{0}' non esegue l'override del metodo previsto da 'object'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupReturnTypeMod">
        <source>A return type can only have one '{0}' modifier.</source>
        <target state="translated">Un tipo restituito può avere un solo modificatore '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">'{0}' è implementato più di una volta in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterceptor">
        <source>The indicated call is intercepted multiple times.</source>
        <target state="translated">La chiamata indicata viene intercettata più volte.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithDifferencesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</source>
        <target state="translated">'{0}' è già incluso nell'elenco di interfacce nel tipo '{2}' come '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">Operatore di eliminazione Null duplicato ('!')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">Non è possibile specificare i modificatori 'readonly' in entrambe le funzioni di accesso della proprietà o dell'indicizzatore '{0}'. Inserire invece un modificatore 'readonly' nella proprietà stessa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicDispatchToParamsCollection">
        <source>'{0}' is applicable only with expanded form of non-array params collection which is not supported during dynamic dispatch.</source>
        <target state="translated">'{0}' è applicabile solo con la forma espansa della raccolta di parametri non di matrice che non è supportata durante l'invio dinamico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">Un'istruzione non può iniziare con 'else'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingSymbol">
        <source>Cannot emit update; {0} '{1}' is missing.</source>
        <target state="translated">Non è possibile creare l'aggiornamento.  {0} '{1}' mancante.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateRequiresEmittingExplicitInterfaceImplementationNotSupportedByTheRuntime">
        <source>Update requires emitting explicit interface implementation, which is not supported by the runtime without restarting the application.</source>
        <target state="new">Update requires emitting explicit interface implementation, which is not supported by the runtime without restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EntryPointCannotBeUnmanagedCallersOnly">
        <source>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Non è possibile aggiungere ai punti di ingresso dell'applicazione l'attributo 'UnmanagedCallersOnly'.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_EqualityContractRequiresGetter">
        <source>Record equality contract property '{0}' must have a get accessor.</source>
        <target state="translated">La proprietà '{0}' del contratto di uguaglianza record deve contenere una funzione di accesso get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EqualityOperatorInPatternNotSupported">
        <source>The '==' operator is not supported in a pattern.</source>
        <target state="new">The '==' operator is not supported in a pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeVariable">
        <source>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">Non è possibile usare la variabile '{0}' in questo contesto perché potrebbe esporre variabili di riferimento all'esterno del relativo ambito di dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInterpolatedString">
        <source>Expected interpolated string</source>
        <target state="translated">Prevista stringa interpolata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplementationOfOperatorsMustBeStatic">
        <source>Explicit implementation of a user-defined operator '{0}' must be declared static</source>
        <target state="translated">L'implementazione esplicita di un operatore definito dall'utente '{0}' deve essere dichiarata come statica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceMemberReturnTypeMismatch">
        <source>'{0}': return type must be '{1}' to match implemented member '{2}'</source>
        <target state="new">'{0}': return type must be '{1}' to match implemented member '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceMemberTypeMismatch">
        <source>'{0}': type must be '{1}' to match implemented member '{2}'</source>
        <target state="new">'{0}': type must be '{1}' to match implemented member '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">L'applicazione esplicita di 'System.Runtime.CompilerServices.NullableAttribute' non è consentita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArrayOrCollection">
        <source>Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">Non usare 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Al suo posto, usare la parola chiave 'params'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMismatchInitOnly">
        <source>Accessors '{0}' and '{1}' should both be init-only or neither</source>
        <target state="translated">Il tipo di sola inizializzazione può essere specificato per entrambe le funzioni di accesso '{0}' e '{1}' o per nessuna di esse</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitRequiredMember">
        <source>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</source>
        <target state="translated">Non usare 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Usare la parola chiave 'obbligatorio' nei campi e nelle proprietà obbligatori.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitScopedRef">
        <source>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</source>
        <target state="translated">Non usare 'System.Runtime.CompilerServices.ScopedRefAttribute'. Usare invece la parola chiave 'scoped'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">Non è possibile usare l'espressione specificata in un'istruzione fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione Null di coalescenza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">L'albero delle espressioni non può contenere il valore '{0}' per lo struct ref o il tipo limitato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
        <source>An expression tree may not contain an access of static virtual or abstract interface member</source>
        <target state="translated">Un albero delle espressioni può non contenere un accesso del membro di interfaccia statico astratto o virtuale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsCollectionExpression">
        <source>An expression tree may not contain a collection expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione di raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsExtensionBasedConditionalLogicalOperator">
        <source>An expression tree may not contain '&amp;&amp;' or '||' operators that use extension user defined operators.</source>
        <target state="new">An expression tree may not contain '&amp;&amp;' or '||' operators that use extension user defined operators.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsExtensionPropertyAccess">
        <source>An expression tree may not contain an extension property access</source>
        <target state="new">An expression tree may not contain an extension property access</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione di indice from end ('^').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInlineArrayOperation">
        <source>An expression tree may not contain an inline array access or conversion</source>
        <target state="translated">Un albero delle espressioni non può contenere un accesso o una conversione di matrice inline</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
        <source>An expression tree may not contain an interpolated string handler conversion.</source>
        <target state="translated">Un albero delle espressioni non può contenere una conversione del gestore di stringhe interpolate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgumentOutOfPosition">
        <source>An expression tree may not contain a named argument specification out of position</source>
        <target state="new">An expression tree may not contain a named argument specification out of position</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternImplicitIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="translated">Un albero delle espressioni non può contenere un accesso a indicizzatore System.Index o System.Range di criterio</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione ('..').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">Un albero delle espressioni non può contenere un operatore == o != di tupla</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsWithExpression">
        <source>An expression tree may not contain a with-expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione with.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionBlockCollision">
        <source>This extension block collides with another extension block. They result in conflicting content-based type names in metadata, so must be in separate enclosing static classes.</source>
        <target state="new">This extension block collides with another extension block. They result in conflicting content-based type names in metadata, so must be in separate enclosing static classes.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionDisallowsMember">
        <source>This member is not allowed in an extension block</source>
        <target state="new">This member is not allowed in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionDisallowsName">
        <source>Extension declarations may not have a name.</source>
        <target state="new">Extension declarations may not have a name.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionParameterDisallowsDefaultValue">
        <source>The receiver parameter of an extension cannot have a default value</source>
        <target state="new">The receiver parameter of an extension cannot have a default value</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionParameterInStaticContext">
        <source>Static members cannot access the value of extension parameter '{0}'.</source>
        <target state="new">Static members cannot access the value of extension parameter '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionResolutionFailed">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension member '{1}' for receiver of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="new">'{0}' does not contain a definition for '{1}' and no accessible extension member '{1}' for receiver of type '{0}' could be found (are you missing a using directive or an assembly reference?)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionTypeNameDisallowed">
        <source>Types and aliases cannot be named 'extension'.</source>
        <target state="new">Types and aliases cannot be named 'extension'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'{0}': l'evento extern non può avere inizializzatori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">La funzionalità '{0}' è attualmente disponibile in anteprima e *non è supportata*. Per usare funzionalità in anteprima, scegliere la versione del linguaggio 'preview'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">La funzionalità '{0}' è sperimentale e non è supportata. Per abilitare, usare '/features:{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion10">
        <source>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 10.0. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion11">
        <source>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 11.0. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion12">
        <source>Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 12.0. Usare la versione del linguaggio {1} o versione successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion13">
        <source>Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 13.0. Usare la versione del linguaggio {1} o successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion14">
        <source>Feature '{0}' is not available in C# 14.0. Please use language version {1} or greater.</source>
        <target state="new">Feature '{0}' is not available in C# 14.0. Please use language version {1} or greater.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 8.0. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion9">
        <source>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 9.0. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">L'evento simile a campo '{0}' non può essere 'readonly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileLocalDuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}' in this file.</source>
        <target state="translated">Lo spazio dei nomi '{1}' contiene già una definizione per '{0}' in questo file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FilePathCannotBeConvertedToUtf8">
        <source>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</source>
        <target state="translated">Non è possibile utilizzare il tipo locale di file '{0}' perché il percorso del file contenitore non può essere convertito nella rappresentazione di byte UTF-8 equivalente. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedAndNormalNamespace">
        <source>Source file can not contain both file-scoped and normal namespace declarations.</source>
        <target state="translated">Il file di origine non può contenere sia dichiarazioni di spazio dei nomi normali che con ambito file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileScopedNamespaceNotBeforeAllMembers">
        <source>File-scoped namespace must precede all other members in a file.</source>
        <target state="translated">Lo spazio dei nomi con ambito file deve precedere tutti gli altri membri di un file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeBase">
        <source>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</source>
        <target state="translated">Impossibile utilizzare il tipo locale file '{0}' come tipo di base di tipo non locale '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeDisallowedInSignature">
        <source>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</source>
        <target state="translated">Impossibile utilizzare il tipo file-local '{0}' in una firma del membro nel tipo non locale di file '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNameDisallowed">
        <source>Types and aliases cannot be named 'file'.</source>
        <target state="translated">I tipi e gli alias non possono essere denominati 'file'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNested">
        <source>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</source>
        <target state="translated">Il tipo locale del file '{0}' deve essere definito in un tipo di primo livello; '{0}' è un tipo annidato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNoExplicitAccessibility">
        <source>File-local type '{0}' cannot use accessibility modifiers.</source>
        <target state="translated">Il tipo locale del file '{0}' non può usare modificatori di accessibilità.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileTypeNonUniquePath">
        <source>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</source>
        <target state="translated">Il tipo locale di file '{0}' deve essere dichiarato in un file con un percorso univoco. Il percorso '{1}' viene usato in più file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedFieldMustNotBeRef">
        <source>A fixed field must not be a ref field.</source>
        <target state="translated">Un campo fisso non deve essere un campo ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">L'istruzione foreach non può funzionare con variabili di tipo '{0}' perché '{0}' non contiene una definizione di istanza o estensione pubblica per '{1}'. Si intendeva 'await foreach' invece di 'foreach'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrMethMustBeStatic">
        <source>Cannot create a function pointer for '{0}' because it is not a static method</source>
        <target state="translated">Non è possibile creare un puntatore a funzione per '{0}' perché non è un metodo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FuncPtrRefMismatch">
        <source>Ref mismatch between '{0}' and function pointer '{1}'</source>
        <target state="translated">Modificatore di riferimento non corrispondente tra '{0}' e il puntatore a funzione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointerTypesInAttributeNotSupported">
        <source>Using a function pointer type in this context is not supported.</source>
        <target state="translated">L'uso di un tipo di puntatore a funzione in questo contesto non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionPointersCannotBeCalledWithNamedArguments">
        <source>A function pointer cannot be called with named arguments.</source>
        <target state="translated">Non è possibile chiamare un puntatore a funzione con argomenti denominati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
        <source>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</source>
        <target state="translated">L'interfaccia '{0}' non può essere usata come argomenti tipo. Il membro statico '{1}' non contiene un'implementazione più specifica nell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingInNamespace">
        <source>A global using directive cannot be used in a namespace declaration.</source>
        <target state="translated">Non è possibile usare una direttiva using globale in una dichiarazione dello spazio dei nomi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingOutOfOrder">
        <source>A global using directive must precede all non-global using directives.</source>
        <target state="translated">Una direttiva sull'utilizzo globale deve precedere tutte le direttiva non sull'uso non globale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalUsingStaticFileType">
        <source>File-local type '{0}' cannot be used in a 'global using static' directive.</source>
        <target state="translated">Non è possibile utilizzare il tipo file locale '{0}' in una direttiva 'global using static'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">Un'istruzione goto non può passare a una posizione che precede una dichiarazione using all'interno dello stesso blocco.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">Un'istruzione goto non può passare a una posizione successiva a una dichiarazione using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HiddenPositionalMember">
        <source>The positional member '{0}' found corresponding to this parameter is hidden.</source>
        <target state="translated">Il membro posizionale '{0}' trovato e corrispondente a questo parametro è nascosto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAtSequence">
        <source>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</source>
        <target state="translated">Sequenza di caratteri '@' non consentita. Una stringa o un identificatore verbatim può contenere un solo carattere '@' e una stringa non elaborata non può contenere alcun carattere.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">L'operatore di eliminazione non è consentito in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitConversionOperatorCantBeChecked">
        <source>An 'implicit' user-defined conversion operator cannot be declared checked</source>
        <target state="translated">Impossibile dichiarare controllato un operatore di conversione 'implicit' definito dall'utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare implicitamente un membro inaccessibile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">La chiamata dell'indicizzatore di indice implicito non può assegnare un nome all'argomento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationIllegalTargetType">
        <source>The type '{0}' may not be used as the target type of new()</source>
        <target state="translated">Non è possibile usare il tipo '{0}' come tipo di destinazione di new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNoTargetType">
        <source>There is no target type for '{0}'</source>
        <target state="translated">Non esiste alcun tipo di destinazione per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitObjectCreationNotValid">
        <source>Use of new() is not valid in this context</source>
        <target state="translated">Non è possibile usare new() in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">La chiamata dell'indicizzatore di intervallo implicito non può assegnare un nome all'argomento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedDefaultParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have a default value.</source>
        <target state="translated">Il parametro lambda tipizzato in modo implicito '{0}' non può avere un valore predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedParamsParameter">
        <source>Implicitly typed lambda parameter '{0}' cannot have the 'params' modifier.</source>
        <target state="new">Implicitly typed lambda parameter '{0}' cannot have the 'params' modifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableUsedInForbiddenZone">
        <source>Reference to an implicitly-typed variable '{0}' is not permitted in this location.</source>
        <target state="new">Reference to an implicitly-typed variable '{0}' is not permitted in this location.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">Non è possibile usare argomenti con il modificatore 'in' nelle espressioni inviate in modo dinamico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionParameterMustBeValueType">
        <source>The 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.</source>
        <target state="new">The 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InequalityOperatorInPatternNotSupported">
        <source>The '!=' operator is not supported in a pattern. Use 'not' to represent a negated pattern.</source>
        <target state="new">The '!=' operator is not supported in a pattern. Use 'not' to represent a negated pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritingFromRecordWithSealedToString">
        <source>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</source>
        <target state="translated">L'ereditarietà da un record con un 'Object.ToString' di tipo sealed non è supportata in C# {0}. Usare la versione '{1}' o successiva del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitCannotBeReadonly">
        <source>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</source>
        <target state="translated">Non è possibile contrassegnare le funzioni di accesso 'init' come 'readonly'. Contrassegnare '{0}' come readonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitInExtension">
        <source>'{0}': cannot declare init-only accessors in an extension block</source>
        <target state="new">'{0}': cannot declare init-only accessors in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayAttributeOnRecord">
        <source>Attribute 'System.Runtime.CompilerServices.InlineArray' cannot be applied to a record struct.</source>
        <target state="translated">Impossibile applicare l'attributo 'System.Runtime.CompilerServices.InlineArray' a uno struct di record.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayBadIndex">
        <source>Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.</source>
        <target state="translated">È possibile accedere agli elementi di un tipo matrice inline solo con un singolo argomento convertibile in modo implicito in 'int', 'System.Index' o 'System.Range'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToReadOnlySpanNotSupported">
        <source>Cannot convert expression to '{0}' because it may not be passed or returned by reference</source>
        <target state="translated">Non è possibile convertire l'espressione in '{0}' perché non può essere passata o restituita per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayConversionToSpanNotSupported">
        <source>Cannot convert expression to '{0}' because it is not an assignable variable</source>
        <target state="translated">Non è possibile convertire l'espressione in '{0}' perché non è una variabile assegnabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayForEachNotSupported">
        <source>foreach statement on an inline array of type '{0}' is not supported</source>
        <target state="translated">L'istruzione foreach in una matrice inline di tipo '{0}' non è supportata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayIndexOutOfRange">
        <source>Index is outside the bounds of the inline array</source>
        <target state="translated">L'indice non è compreso nei limiti della matrice inline</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InlineArrayUnsupportedElementFieldModifier">
        <source>Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.</source>
        <target state="translated">Il campo dell'elemento della matrice inline non può essere dichiarato come obbligatorio, di sola lettura, volatile o come buffer a dimensione fissa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberWithUnnamedExtensionsParameter">
        <source>'{0}': cannot declare instance members in an extension block with an unnamed receiver parameter</source>
        <target state="new">'{0}': cannot declare instance members in an extension block with an unnamed receiver parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceOperatorExtensionWrongReceiverType">
        <source>Cannot declare instance extension operator for a type that is not known to be a struct and is not known to be a class</source>
        <target state="new">Cannot declare instance extension operator for a type that is not known to be a struct and is not known to be a class</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceOperatorStructExtensionWrongReceiverRefKind">
        <source>Cannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter</source>
        <target state="new">Cannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstancePropertyInitializerInInterface">
        <source>Instance properties in interfaces cannot have initializers.</source>
        <target state="translated">Le proprietà di istanza nelle interfacce non possono avere inizializzatori.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptableMethodMustBeOrdinary">
        <source>Cannot intercept '{0}' because it is not an invocation of an ordinary member method.</source>
        <target state="translated">Non è possibile intercettare '{0}' perché non è una chiamata di un metodo membro normale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorArityNotCompatible">
        <source>Method '{0}' must be non-generic or have arity {1} to match '{2}'.</source>
        <target state="translated">Il metodo '{0}' deve essere non generico o avere un grado {1} per trovare la corrispondenza con '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotBeGeneric">
        <source>Method '{0}' must be non-generic to match '{1}'.</source>
        <target state="translated">Il metodo '{0}' deve essere non generico per corrispondere a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotInterceptNameof">
        <source>A nameof operator cannot be intercepted.</source>
        <target state="translated">Impossibile intercettare un operatore nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCannotUseUnmanagedCallersOnly">
        <source>An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.</source>
        <target state="translated">Un intercettore non può essere contrassegnato con 'UnmanagedCallersOnlyAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorCharacterOutOfRange">
        <source>The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.</source>
        <target state="translated">La riga specificata è di '{0}' caratteri, che è inferiore al numero di caratteri specificato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorContainingTypeCannotBeGeneric">
        <source>Method '{0}' cannot be used as an interceptor because its containing type has type parameters.</source>
        <target state="translated">Non è possibile usare il metodo '{0}' come intercettore perché il tipo contenitore include parametri di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorFilePathCannotBeNull">
        <source>Interceptor cannot have a 'null' file path.</source>
        <target state="translated">L'intercettore non può avere un percorso di file 'null'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorGlobalNamespace">
        <source>An interceptor cannot be declared in the global namespace.</source>
        <target state="translated">Non è possibile dichiarare un intercettore nello spazio dei nomi globale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineCharacterMustBePositive">
        <source>Line and character numbers provided to InterceptsLocationAttribute must be positive.</source>
        <target state="translated">I numeri di riga e di carattere specificati per InterceptsLocationAttribute devono essere positivi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorLineOutOfRange">
        <source>The given file has '{0}' lines, which is fewer than the provided line number '{1}'.</source>
        <target state="translated">Il file specificato contiene '{0}' righe, che sono inferiori al numero di riga specificato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMethodMustBeOrdinary">
        <source>An interceptor method must be an ordinary member method.</source>
        <target state="translated">Un metodo intercettore deve essere un metodo membro ordinario.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustHaveMatchingThisParameter">
        <source>Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.</source>
        <target state="translated">L'intercettore deve avere un parametro 'this' corrispondente al parametro '{0}' su '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustNotHaveThisParameter">
        <source>Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.</source>
        <target state="translated">L'intercettore non deve avere un parametro 'this' perché '{0}' non ha un parametro 'this'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorMustReferToStartOfTokenPosition">
        <source>The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?</source>
        <target state="translated">La riga e il numero di carattere specificati non fanno riferimento all'inizio del token '{0}'. Volevi usare la riga '{1}' e il carattere '{2}'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNameNotInvoked">
        <source>Possible method name '{0}' cannot be intercepted because it is not being invoked.</source>
        <target state="translated">Impossibile intercettare il possibile nome di metodo '{0}' perché non è stato richiamato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNonUniquePath">
        <source>Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.</source>
        <target state="translated">Non è possibile intercettare una chiamata nel file con percorso '{0}' perché questo percorso è presente in più file della compilazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorNotAccessible">
        <source>Cannot intercept call with '{0}' because it is not accessible within '{1}'.</source>
        <target state="translated">Non è possibile intercettare la chiamata con '{0}' perché non è accessibile in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilation">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'.</source>
        <target state="translated">Non è possibile intercettare: la compilazione non contiene un file con percorso '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPathNotInCompilationWithCandidate">
        <source>Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?</source>
        <target state="translated">Non è possibile intercettare: la compilazione non contiene un file con percorso '{0}'. Forse volevi usare il percorso '{1}'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorPositionBadToken">
        <source>The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.</source>
        <target state="translated">La riga e il numero di caratteri specificati non fanno riferimento a un nome di metodo intercettabile, ma al token '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorScopedMismatch">
        <source>Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.</source>
        <target state="translated">Non è possibile intercettare la chiamata a '{0}' con '{1}' a causa di una differenza nei modificatori 'scoped' o negli attributi '[UnscopedRef]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorSignatureMismatch">
        <source>Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.</source>
        <target state="translated">Impossibile intercettare il metodo '{0}' con l'intercettore '{1}' perché le firme non corrispondono.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptorsFeatureNotEnabled">
        <source>The 'interceptors' feature is not enabled in this namespace. Add '{0}' to your project.</source>
        <target state="translated">La funzionalità 'intercettori' non è abilitata in questo spazio dei nomi. Aggiungere '{0}' al progetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidFormat">
        <source>The data argument to InterceptsLocationAttribute is not in the correct format.</source>
        <target state="translated">Il formato dell'argomento dati di InterceptsLocationAttribute non è corretto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDataInvalidPosition">
        <source>The data argument to InterceptsLocationAttribute refers to an invalid position in file '{0}'.</source>
        <target state="translated">L'argomento dati di InterceptsLocationAttribute fa riferimento a una posizione non valida nel file '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationDuplicateFile">
        <source>Cannot intercept a call in file '{0}' because it is duplicated elsewhere in the compilation.</source>
        <target state="translated">Non è possibile intercettare una chiamata nel file '{0}' perché è duplicata in un'altra posizione della compilazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationFileNotFound">
        <source>Cannot intercept a call in file '{0}' because a matching file was not found in the compilation.</source>
        <target state="translated">Non è possibile intercettare una chiamata nel file '{0}' perché nella compilazione non è stato trovato un file corrispondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterceptsLocationUnsupportedVersion">
        <source>Version '{0}' of the interceptors format is not supported. The latest supported version is '1'.</source>
        <target state="translated">La versione '{0}' del formato degli intercettori non è supportata. L'ultima versione supportata è '1'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
        <source>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Il metodo '{0}' di 'UnmanagedCallersOnly' non può implementare il membro di interfaccia '{1}' nel tipo '{2}'</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">'{0}' non può implementare il membro di interfaccia '{1}' nel tipo '{2}' perché contiene un parametro __arglist</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">Si è verificato un errore interno nel compilatore C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
        <source>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</source>
        <target state="translated">Il formato di InterpolatedStringHandlerArgumentAttribute applicato al parametro '{0}' non è valido e non può essere interpretato. Costruire manualmente un'istanza di '{1}'.</target>
        <note>InterpolatedStringHandlerArgumentAttribute is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentDisallowed">
        <source>Interpolated string handler arguments are not allowed in this context.</source>
        <target state="new">Interpolated string handler arguments are not allowed in this context.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
        <source>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</source>
        <target state="translated">Il parametro '{0}' è un argomento per la conversione del gestore di stringhe interpolato nel parametro '{1}', ma l'argomento corrispondente viene specificato dopo l'espressione di stringa interpolata. Riordinare gli argomenti per spostare '{0}' prima di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
        <source>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</source>
        <target state="translated">Il parametro '{0}' non è specificato in modo esplicito, ma viene usato come argomento della conversione del gestore di stringhe interpolate nel parametro '{1}'. Specificare il valore di '{0}' prima di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
        <source>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</source>
        <target state="translated">Per la costruzione di un gestore di stringhe interpolate non è possibile usare dynamic. Costruire manualmente un'istanza di '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnInconsistent">
        <source>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</source>
        <target state="translated">Il tipo restituito del metodo del gestore di stringhe interpolate '{0}' è incoerente. Dovrebbe essere restituito '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringHandlerMethodReturnMalformed">
        <source>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</source>
        <target state="translated">Il formato del metodo di gestione delle stringhe interpolate '{0}' non è valido. Non restituisce 'void' o 'bool'.</target>
        <note>void and bool are keywords</note>
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
        <source>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</source>
        <target state="translated">Le conversioni di gestori di stringhe interpolate che fanno riferimento all'istanza indicizzata non possono essere utilizzate negli inizializzatori di membri dell'indicizzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExperimentalDiagID">
        <source>The diagnosticId argument to the 'Experimental' attribute must be a valid identifier</source>
        <target state="translated">L'argomento diagnosticId dell'attributo 'Experimental' deve essere un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportExtendedLayoutTypes">
        <source>The target runtime does not support extended layout types.</source>
        <target state="new">The target runtime does not support extended layout types.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExtensionParameterReference">
        <source>Cannot use extension parameter '{0}' in this context.</source>
        <target state="new">Cannot use extension parameter '{0}' in this context.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFuncPointerReturnTypeModifier">
        <source>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</source>
        <target state="translated">'{0}' non è un modificatore di tipo restituito di puntatore a funzione valido. I modificatori validi sono 'ref' e 'ref readonly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFunctionPointerCallingConvention">
        <source>'{0}' is not a valid calling convention specifier for a function pointer.</source>
        <target state="translated">'{0}' non è un identificatore di convenzione di chiamata valido per un puntatore a funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">Il nome dell'algoritmo hash non è valido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayFields">
        <source>Inline array struct must declare one and only one instance field.</source>
        <target state="translated">La struttura della matrice inline deve dichiarare un solo campo di istanza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLayout">
        <source>Inline array struct must not have explicit layout.</source>
        <target state="translated">La struttura di matrice inline non deve avere un layout esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInlineArrayLength">
        <source>Inline array length must be greater than 0.</source>
        <target state="translated">La lunghezza della matrice inline deve essere maggiore di 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not a valid parameter name from '{1}'.</source>
        <target state="translated">'{0}' non è un nome di parametro valido da '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierAfterScoped">
        <source>The '{0}' modifier cannot immediately follow the 'scoped' modifier.</source>
        <target state="new">The '{0}' modifier cannot immediately follow the 'scoped' modifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModifierForLanguageVersion">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">Il modificatore '{0}' non è valido per questo elemento in C# {1}. Usare la versione '{2}' o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameInSubpattern">
        <source>Identifier or a simple member access expected.</source>
        <target state="translated">È previsto un accesso a un membro semplice o a un identificatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">Creazione oggetto non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPrimaryConstructorParameterReference">
        <source>Cannot use primary constructor parameter '{0}' in this context.</source>
        <target state="translated">Non è possibile usare il parametro del costruttore primario '{0}' in questo contesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">Non è possibile specificare i modificatori 'readonly' nella proprietà o nell'indicizzatore '{0}' e nella relativa funzione di accesso. Rimuoverne uno.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">"L'identificatore del numero di dimensioni non è valido: è previsto ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUnmanagedCallersOnlyCallConv">
        <source>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</source>
        <target state="translated">'{0}' non è un tipo di convenzione di chiamata valido per 'UnmanagedCallersOnly'.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_InvalidWithReceiverType">
        <source>The receiver of a `with` expression must have a non-void type.</source>
        <target state="translated">Il ricevitore di un'espressione `with` deve avere un tipo non void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">Non è consentito usare il tipo riferimento nullable '{0}?' in un'espressione is-type. Usare il tipo sottostante '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">Un'espressione di tipo '{0}' non può mai corrispondere al criterio specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">Il metodo '{0}' con un blocco iteratore deve essere 'async' per restituire '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorRefLikeElementType">
        <source>Element type of an iterator may not be a ref struct or a type parameter allowing ref structs</source>
        <target state="translated">Il tipo di elemento di un iteratore non può essere uno struct di riferimento o un parametro di tipo che consente struct di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaExplicitReturnTypeVar">
        <source>The contextual keyword 'var' cannot be used as an explicit lambda return type</source>
        <target state="translated">Non è possibile usare la parola chiave contestuale 'var' come tipo restituito dell’espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaWithAttributesToExpressionTree">
        <source>A lambda expression with attributes cannot be converted to an expression tree</source>
        <target state="translated">Non è possibile convertire un'espressione lambda con attributi in un albero delle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">'{0}' non può implementare il membro di interfaccia '{1}' nel tipo '{2}' perché la funzionalità '{3}' non è disponibile in C# {4}. Usare la versione '{5}' o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContainsDifferentWhitespace">
        <source>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</source>
        <target state="translated">La riga contiene spazi vuoti diversi rispetto alla riga di chiusura del valore letterale stringa non elaborata: '{0}' rispetto a '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineDoesNotStartWithSameWhitespace">
        <source>Line does not start with the same whitespace as the closing line of the raw string literal.</source>
        <target state="translated">La riga non inizia con lo stesso spazio vuoto della riga di chiusura del valore letterale stringa non elaborata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveEndLessThanStart">
        <source>The #line directive end position must be greater than or equal to the start position</source>
        <target state="translated">La posizione finale della direttiva #line deve essere maggiore o uguale alla posizione iniziale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveInvalidValue">
        <source>The #line directive value is missing or out of range</source>
        <target state="translated">Il valore della direttiva #line manca oppure non è compreso nell'intervallo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineSpanDirectiveRequiresSpace">
        <source>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</source>
        <target state="translated">La direttiva #line span richiede uno spazio prima della prima parentesi, prima dell'offset dei caratteri e prima del nome del file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ListPatternRequiresLength">
        <source>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</source>
        <target state="translated">I criteri di elenco non possono essere utilizzati per un valore di tipo '{0}'. Non è stata trovata alcuna proprietà 'Length' o 'Count' appropriata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsExtensionParameter">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as an extension parameter</source>
        <target state="new">'{0}': a parameter, local variable, or local function cannot have the same name as an extension parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsExtensionTypeParameter">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameter</source>
        <target state="new">'{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsExtendedType">
        <source>'{0}': extension member names cannot be the same as their extended type</source>
        <target state="new">'{0}': extension member names cannot be the same as their extended type</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethFuncPtrMismatch">
        <source>No overload for '{0}' matches function pointer '{1}'</source>
        <target state="translated">Nessun overload per '{0}' corrisponde al puntatore a funzione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplAttributeAsyncCannotBeUsed">
        <source>'MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.</source>
        <target state="new">'MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.</target>
        <note>'MethodImplAttribute.Async' and 'async' are not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_MisplacedExtension">
        <source>An extension member syntax is disallowed in nested position within an extension member syntax</source>
        <target state="new">An extension member syntax is disallowed in nested position within an extension member syntax</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedRecord">
        <source>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</source>
        <target state="translated">Parola chiave 'record' imprevista. Si intendeva 'struct record' o 'classe record'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedSlicePattern">
        <source>Slice patterns may only be used once and directly inside a list pattern.</source>
        <target state="translated">I modelli di sezione possono essere usati solo una volta e direttamente all'interno di un modello di elenco.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MisplacedUnchecked">
        <source>Unexpected keyword 'unchecked'</source>
        <target state="translated">Parola chiave imprevista 'unchecked'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddressOf">
        <source>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</source>
        <target state="translated">Non è possibile convertire il gruppo di metodi nel puntatore a funzione. Manca un operatore '&amp;'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">Criterio mancante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModifierOnUnnamedReceiverParameter">
        <source>Cannot use modifiers on the unnamed receiver parameter of extension block</source>
        <target state="new">Cannot use modifiers on the unnamed receiver parameter of extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
        <source>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</source>
        <target state="translated">Non è possibile aggiungere all'inizializzatore di modulo l'attributo 'UnmanagedCallersOnly'.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
        <source>Module initializer method '{0}' must not be generic and must not be contained in a generic type</source>
        <target state="translated">Il metodo '{0}' dell'inizializzatore di modulo non deve essere generico e non deve essere contenuto in un tipo generico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
        <source>Module initializer method '{0}' must be accessible at the module level</source>
        <target state="translated">Il metodo '{0}' dell'inizializzatore di modulo deve essere accessibile a livello di modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeOrdinary">
        <source>A module initializer must be an ordinary member method</source>
        <target state="translated">Un inizializzatore di modulo deve essere un metodo membro normale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
        <source>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</source>
        <target state="translated">Il metodo '{0}' dell'inizializzatore di modulo deve essere statico e non virtuale, non deve contenere parametri e deve restituire 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">La stessa directory ('{0}') non può contenere più file di configurazione dell'analizzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">Non è possibile usare l'attributo [EnumeratorCancellation] in più parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleFileScopedNamespace">
        <source>Source file can only contain one file-scoped namespace declaration.</source>
        <target state="translated">Il file di origine può contenere solo una dichiarazione di spazio dei nomi con ambito file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleRecordParameterLists">
        <source>Only a single partial type declaration may have a parameter list</source>
        <target state="translated">Solo una dichiarazione parziale di singolo record può includere un elenco di parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForInlineArray">
        <source>An inline array access may not have a named argument specifier</source>
        <target state="translated">Un accesso a matrice inline non può includere un identificatore di argomento denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMember">
        <source>Extension members are not allowed as an argument to 'nameof'.</source>
        <target state="new">Extension members are not allowed as an argument to 'nameof'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">Non è possibile usare il vincolo 'new()' con il vincolo 'unmanaged'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintCannotHaveRequiredMembers">
        <source>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</source>
        <target state="translated">'{2}' non è in grado di soddisfare il vincolo 'new()' sul parametro '{1}' nel tipo generico o nel metodo '{0}' perché '{2}' contiene membri obbligatori.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
        <source>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</source>
        <target state="translated">Nuove linee all'interno di una stringa interpolata non verbatim non sono supportate in C# {0}. Usare la versione del linguaggio {1} o le versioni successive.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">'{0}': il tipo usato in un'istruzione using asincrona deve implementare 'System.IAsyncDisposable' o implementare un metodo 'DisposeAsync' adatto. Si intendeva 'using' invece di 'await using'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">'{0}': il tipo usato in un'istruzione using deve implementare 'System.IDisposable'. Si intendeva 'await using' invece di 'using'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerArgumentExpressionParam">
        <source>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Non è possibile applicare CallerArgumentExpressionAttribute perché non sono presenti conversioni standard dal tipo '{0}' al tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCopyConstructorInBaseType">
        <source>No accessible copy constructor found in base type '{0}'.</source>
        <target state="translated">Non è stato trovato alcun costruttore di copia accessibile nel tipo di base '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDelegateConstraint">
        <source>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</source>
        <target state="translated">Impossibile utilizzare la parola chiave 'delegate' come vincolo. Si intendeva 'System.Delegate'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEnumConstraint">
        <source>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</source>
        <target state="translated">Impossibile utilizzare la parola chiave 'enum' come vincolo. Si intendeva 'struct, System.Enum'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvTargetTypedConditional">
        <source>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</source>
        <target state="translated">L'espressione condizionale non è valida nella versione del linguaggio {0} perché non è stato trovato un tipo comune tra '{1}' e '{2}'. Per usare una conversione tipizzata come destinazione, eseguire l'aggiornamento alla versione {3} o a versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnUsing">
        <source>Modifiers cannot be placed on using declarations</source>
        <target state="translated">Non è possibile inserire modificatori nelle dichiarazioni using</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="translated">Non è stato possibile individuare la directory di output</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPrivateAPIInRecord">
        <source>Record member '{0}' must be private.</source>
        <target state="translated">Il membro del record '{0}' deve essere privato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonProtectedAPIInRecord">
        <source>Record member '{0}' must be protected.</source>
        <target state="translated">Il membro del record '{0}' deve essere protetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicAPIInRecord">
        <source>Record member '{0}' must be public.</source>
        <target state="translated">Il membro del record '{0}' deve essere pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonPublicParameterlessStructConstructor">
        <source>The parameterless struct constructor must be 'public'.</source>
        <target state="translated">Il costruttore struct senza parametri deve essere 'public'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughCloseBracesForRawString">
        <source>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</source>
        <target state="translated">L'interpolazione deve terminare con lo stesso numero di parentesi graffe di chiusura del numero di caratteri '$' con cui è iniziato il valore letterale stringa non elaborato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotEnoughQuotesForRawString">
        <source>Not enough quotes for raw string literal.</source>
        <target state="translated">Virgolette insufficienti per il valore letterale stringa non elaborato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
        <source>'{0}' is not an instance method, the receiver or extension receiver parameter cannot be an interpolated string handler argument.</source>
        <target state="translated">'{0}' non è un metodo di istanza. Il ricevitore non può essere un argomento del gestore di stringhe interpolate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableAPIInRecord">
        <source>'{0}' must allow overriding because the containing record is not sealed.</source>
        <target state="translated">'{0}' deve consentire l'override perché il record contenitore non è sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotRefStructConstraintNotSatisfied">
        <source>The type '{2}' may not be a ref struct or a type parameter allowing ref structs in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Il tipo '{2}' non può essere un ref struct o un parametro di tipo che consente ref struct perché possa essere utilizzato come parametro '{1}' nel tipo generico o nel metodo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullInvalidInterpolatedStringHandlerArgumentName">
        <source>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</source>
        <target state="translated">Null non è un nome di parametro valido. Per ottenere l'accesso al ricevitore di un metodo di istanza, usare la stringa vuota come nome del parametro.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">È previsto 'enable', 'disable' o 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">È previsto 'warnings', 'annotations' o la fine della direttiva</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">Valore '{1}' di '{0}' non valido per C# {2}. Usare la versione {3} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">Un parametro di tipo nullable deve essere noto per essere un tipo valore o un tipo riferimento non nullable, a meno che non venga usata la versione '{0}' o successiva del linguaggio. Provare a cambiare la versione del linguaggio o ad aggiungere un vincolo di tipo, 'class' o 'struct'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedTypeArgument">
        <source>Omitting the type argument is not allowed in the current context</source>
        <target state="translated">Nel contesto corrente non è possibile omettere l'argomento tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantBeChecked">
        <source>User-defined operator '{0}' cannot be declared checked</source>
        <target state="translated">Impossibile dichiarare controllato l'operatore '{0}' definito dall'utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInExtensionOfStaticClass">
        <source>An extension block extending a static class cannot contain user-defined operators</source>
        <target state="new">An extension block extending a static class cannot contain user-defined operators</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMismatchOnOverride">
        <source>'{0}': cannot override inherited member '{1}' because one of them is not an operator.</source>
        <target state="new">'{0}': cannot override inherited member '{1}' because one of them is not an operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustReturnVoid">
        <source>The return type for this operator must be void</source>
        <target state="new">The return type for this operator must be void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBePublic">
        <source>User-defined operator '{0}' must be declared public</source>
        <target state="new">User-defined operator '{0}' must be declared public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStaticAndPublic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="new">User-defined operator '{0}' must be declared static and public</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefReadonlyParam">
        <source>A ref readonly parameter cannot have the Out attribute.</source>
        <target state="translated">Un parametro ref readonly non può avere l'attributo Out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">Non è possibile dichiarare una variabile out come variabile locale ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideDefaultConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</source>
        <target state="translated">Il metodo '{0}' specifica un vincolo 'default' per il parametro di tipo '{1}', ma il parametro di tipo corrispondente '{2}' del metodo '{3}' sottoposto a override o implementato in modo esplicito è vincolato a un tipo riferimento a un tipo valore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideMustHaveRequired">
        <source>'{0}' must be required because it overrides required member '{1}'</source>
        <target state="translated">'{0}' deve essere obbligatorio perché esegue l’override del membro obbligatorio '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">Il metodo '{0}' specifica un vincolo 'class' per il parametro di tipo '{1}', ma il parametro di tipo corrispondente '{2}' del metodo '{3}' sottoposto a override o implementato in modo esplicito non è un tipo riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">Il metodo '{0}' specifica un vincolo 'struct' per il parametro di tipo '{1}', ma il parametro di tipo corrispondente '{2}' del metodo '{3}' sottoposto a override o implementato in modo esplicito non è un tipo valore che non ammette valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredFollowsIf">
        <source>'#:' directives cannot be after '#if' directive</source>
        <target state="new">'#:' directives cannot be after '#if' directive</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredFollowsToken">
        <source>'#:' directives cannot be after first token in file</source>
        <target state="new">'#:' directives cannot be after first token in file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPIgnoredNeedsFileBasedProgram">
        <source>'#:' directives can be only used in file-based programs ('-features:FileBasedProgram')</source>
        <target state="new">'#:' directives can be only used in file-based programs ('-features:FileBasedProgram')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPShebangInProjectBasedProgram">
        <source>'#!' directives can be only used in scripts or file-based programs</source>
        <target state="new">'#!' directives can be only used in scripts or file-based programs</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionConstructorDoesntInitializeRequiredMember">
        <source>Constructor '{0}' leaves required member '{1}' uninitialized.</source>
        <target state="translated">Il costruttore '{0}' lascia non inizializzato il membro richiesto '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExpressionTree">
        <source>An expression tree may not contain an expanded form of non-array params collection parameter.</source>
        <target state="translated">Un albero delle espressioni non può contenere un formato espanso di parametro di raccolta dei parametri non di matrice.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionExtensionAddMethod">
        <source>'{0}' does not contain a definition for a suitable instance 'Add' method</source>
        <target state="translated">'{0}' non contiene una definizione per un metodo 'Add' di istanza appropriato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionInfiniteChainOfConstructorCalls">
        <source>Creation of params collection '{0}' results in an infinite chain of invocation of constructor '{1}'.</source>
        <target state="translated">La creazione della raccolta di parametri '{0}' comporta una catena infinita di chiamate del costruttore '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCollectionMissingConstructor">
        <source>Non-array params collection type must have an applicable constructor that can be called with no arguments.</source>
        <target state="translated">Il tipo di raccolta dei parametri non di matrice deve avere un costruttore applicabile che può essere chiamato senza argomenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMemberCannotBeLessVisibleThanDeclaringMember">
        <source>Method '{0}' cannot be less visible than the member with params collection '{1}'.</source>
        <target state="translated">Il metodo '{0}' non può essere meno visibile del membro con raccolta parametri '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeCollection">
        <source>The params parameter must have a valid collection type</source>
        <target state="translated">Il parametro params deve avere un tipo di raccolta valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialConstructorInitializer">
        <source>'{0}': only the implementing declaration of a partial constructor can have an initializer</source>
        <target state="new">'{0}': only the implementing declaration of a partial constructor can have an initializer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialEventInitializer">
        <source>'{0}': partial event cannot have initializer</source>
        <target state="new">'{0}': partial event cannot have initializer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberAccessibilityDifference">
        <source>Both partial member declarations must have identical accessibility modifiers.</source>
        <target state="translated">I modificatori di accessibilità devono essere identici in entrambe le dichiarazioni di membro parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberCannotBeAbstract">
        <source>A partial member cannot have the 'abstract' modifier</source>
        <target state="translated">Un membro parziale non può contenere il modificatore 'abstract'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberDuplicateDefinition">
        <source>Partial member '{0}' may not have multiple defining declarations.</source>
        <target state="new">Partial member '{0}' may not have multiple defining declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberDuplicateImplementation">
        <source>Partial member '{0}' may not have multiple implementing declarations.</source>
        <target state="new">Partial member '{0}' may not have multiple implementing declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberInconsistentTupleNames">
        <source>Both partial member declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale '{0}' e '{1}' devono usare gli stessi nomi di elementi di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberMissingDefinition">
        <source>Partial member '{0}' must have a definition part.</source>
        <target state="new">Partial member '{0}' must have a definition part.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberMissingImplementation">
        <source>Partial member '{0}' must have an implementation part.</source>
        <target state="new">Partial member '{0}' must have an implementation part.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberOnlyInPartialClass">
        <source>A partial member must be declared within a partial type</source>
        <target state="translated">Un membro parziale deve essere dichiarato in un tipo parziale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberParamsDifference">
        <source>Both partial member declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale devono usare un parametro params, altrimenti nessuna delle due potrà usarlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberReadOnlyDifference">
        <source>Both partial member declarations must be readonly or neither may be readonly</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale devono essere di tipo readonly, altrimenti nessuna delle due potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberExtendedModDifference">
        <source>Both partial member declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale devono contenere combinazioni identiche di modificatori 'virtual', 'override', 'sealed' e 'new'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberRefReturnDifference">
        <source>Partial member declarations must have matching ref return values.</source>
        <target state="translated">Le dichiarazioni di membro parziale devono contenere valori restituiti di riferimento corrispondenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberTypeDifference">
        <source>Both partial member declarations must have the same type.</source>
        <target state="new">Both partial member declarations must have the same type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberUnsafeDifference">
        <source>Both partial member declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale devono essere di tipo unsafe, altrimenti nessuna delle due potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReturnTypeDifference">
        <source>Both partial method declarations must have the same return type.</source>
        <target state="translated">Il tipo restituito deve essere identico in entrambe le dichiarazioni di metodo parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
        <source>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</source>
        <target state="translated">Il metodo parziale '{0}' deve contenere una parte di implementazione perché include modificatori di accessibilità.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithExtendedModMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</source>
        <target state="translated">Il metodo parziale '{0}' deve contenere modificatori di accessibilità perché include un modificatore 'virtual', 'override', 'sealed', 'new' o 'extern'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</source>
        <target state="translated">Il metodo parziale '{0}' deve contenere modificatori di accessibilità perché include un tipo restituito non void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodWithOutParamMustHaveAccessMods">
        <source>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</source>
        <target state="translated">Il metodo parziale '{0}' deve contenere modificatori di accessibilità perché include parametri 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateDefinition">
        <source>A partial property may not have multiple defining declarations, and cannot be an auto-property.</source>
        <target state="translated">Una proprietà parziale non può avere più dichiarazioni di definizione e non può essere una proprietà automatica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateImplementation">
        <source>A partial property may not have multiple implementing declarations</source>
        <target state="translated">Una proprietà parziale non può avere più dichiarazioni di implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyDuplicateInitializer">
        <source>A partial property cannot have an initializer on both the definition and implementation.</source>
        <target state="translated">Una proprietà parziale non può avere un inizializzatore sia nella definizione che nell'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyInitMismatch">
        <source>Property accessor '{0}' must be '{1}' to match the definition part</source>
        <target state="translated">La funzione di accesso alle proprietà '{0}' deve essere '{1}' in modo che corrisponda alla parte della definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingAccessor">
        <source>Property accessor '{0}' must be implemented because it is declared on the definition part</source>
        <target state="translated">La funzione di accesso alle proprietà '{0}' deve essere implementata perché è dichiarata nella parte della definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingDefinition">
        <source>Partial property '{0}' must have a definition part.</source>
        <target state="translated">La proprietà parziale '{0}' deve avere una parte della definizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyMissingImplementation">
        <source>Partial property '{0}' must have an implementation part.</source>
        <target state="translated">La proprietà parziale '{0}' deve avere una parte di implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyRequiredDifference">
        <source>Both partial property declarations must be required or neither may be required</source>
        <target state="translated">Entrambe le dichiarazioni di proprietà parziale devono essere richieste, altrimenti nessuna delle due potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialPropertyUnexpectedAccessor">
        <source>Property accessor '{0}' does not implement any accessor declared on the definition part</source>
        <target state="translated">La funzione di accesso alle proprietà '{0}' non implementa alcuna funzione di accesso dichiarata nella parte della definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternSpanCharCannotBeStringNull">
        <source>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</source>
        <target state="translated">Una costante di tipo stringa 'null' non è supportata come criterio per ?{0}'. Usare invece una stringa vuota.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">I criteri di ricerca non sono consentiti per i tipi di puntatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">Il corpo di un metodo di iteratore asincrono deve contenere un'istruzione 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">Il corpo di un metodo di iteratore asincrono deve contenere un'istruzione 'yield'. Provare a rimuovere 'async' dalla dichiarazione del metodo o ad aggiungere un'istruzione 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">Con un criterio secondario di proprietà è richiesto un riferimento alla proprietà o al campo da abbinare, ad esempio '{{ Name: {0} }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInExtension">
        <source>'{0}': new protected member declared in an extension block</source>
        <target state="new">'{0}': new protected member declared in an extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringDelimiterOnOwnLine">
        <source>Raw string literal delimiter must be on its own line.</source>
        <target state="translated">Il delimitatore di valore letterale stringa non elaborato deve essere nella relativa riga.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringInVerbatimInterpolatedStrings">
        <source>Multi-line raw string literals are only allowed in verbatim interpolated strings.</source>
        <target state="translated">I valori letterali della stringa non elaborata su più righe sono consentiti solo in stringhe verbatim interpolate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringMustContainContent">
        <source>Multi-line raw string literals must contain at least one line of content.</source>
        <target state="translated">I valori letterali stringa non elaborati su più righe devono contenere almeno una riga di contenuto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RawStringNotInDirectives">
        <source>Raw string literals are not allowed in preprocessor directives.</source>
        <target state="translated">I valori letterali stringa non elaborati non sono consentiti nelle direttive del preprocessore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Non è possibile incorporare il tipo '{0}' perché contiene una nuova astrazione di un membro dell'interfaccia di base. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 'readonly' può essere usato su funzioni di accesso solo se la proprietà o l'indicizzatore include entrambi le funzioni di accesso get e set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReceiverParameterOnlyOne">
        <source>An extension container can have only one receiver parameter</source>
        <target state="new">An extension container can have only one receiver parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReceiverParameterSameNameAsTypeParameter">
        <source>'{0}': a receiver parameter cannot have the same name as an extension container type parameter</source>
        <target state="new">'{0}': a receiver parameter cannot have the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordAmbigCtor">
        <source>The primary constructor conflicts with the synthesized copy constructor.</source>
        <target state="translated">Il costruttore primario è in conflitto con il costruttore di copia sintetizzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordStructConstructorCallsDefaultConstructor">
        <source>A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</source>
        <target state="translated">Un costruttore dichiarato in uno “struct” con elenco di parametri deve avere un inizializzatore “this” che chiama il costruttore primario o un costruttore dichiarato in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Non è possibile assegnare '{1}' a '{0}' come ref perché l'ambito di escape di '{1}' è ridotto rispetto a quello di '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignReturnOnly">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">Non è possibile assegnare un riferimento '{1}' a '{0}' perché '{1}' può eseguire l'escape solo del metodo corrente tramite un'istruzione return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignValEscapeWider">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.</source>
        <target state="translated">Non è possibile ref-assign '{1}' a '{0}' perché '{1}' ha un ambito di escape del valore più ampio di '{0}' consentendo l'assegnazione tramite '{0}' di valori con ambiti di escape più ristretti rispetto a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionParameterMustBeValueTypeOrConstrainedToOne">
        <source>The 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.</source>
        <target state="new">The 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldCannotReferToRefStruct">
        <source>A ref field cannot refer to a ref struct.</source>
        <target state="translated">Un campo ref non può fare riferimento a un ref struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefFieldInNonRefStruct">
        <source>A ref field can only be declared in a ref struct.</source>
        <target state="translated">Un campo ref può essere dichiarato solo in uno struct ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalAcrossAwait">
        <source>A 'ref' local cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Non è possibile mantenere un 'ref' locale tra 'await' o 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref variable.</source>
        <target state="translated">La parte sinistra di un'assegnazione ref deve essere una variabile ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadOnlyWrongOrdering">
        <source>'readonly' modifier must be specified after 'ref'.</source>
        <target state="translated">È necessario specificare il modificatore 'readonly' dopo 'ref'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Non è possibile usare un parametro del costruttore primario come valore out o ref di un tipo di sola lettura, tranne che nel setter di sola inizializzazione del tipo o in un inizializzatore di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)</source>
        <target state="translated">Non è possibile usare i membri del parametro del costruttore primario '{0}' come valore out o ref di un tipo di sola lettura, tranne che nel setter di sola inizializzazione del tipo o in un inizializzatore di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter">
        <source>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Non è possibile restituire un parametro per riferimento '{0}' tramite un parametro ref; può essere restituito solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnOnlyParameter2">
        <source>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</source>
        <target state="translated">Non è possibile restituire per riferimento un membro del parametro '{0}' tramite un parametro ref; può essere restituito solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnPrimaryConstructorParameter">
        <source>Cannot return primary constructor parameter '{0}' by reference.</source>
        <target state="translated">Non è possibile restituire il parametro del costruttore primario '{0}' per riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter">
        <source>A primary constructor parameter of a readonly type cannot be returned by writable reference</source>
        <target state="translated">Un parametro del costruttore primario di un tipo di sola lettura non può essere restituito da un riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyPrimaryConstructorParameter2">
        <source>Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference</source>
        <target state="translated">I membri del parametro del costruttore primario '{0}' di un tipo di sola lettura non possono essere restituiti da un riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter">
        <source>Cannot return a parameter by reference '{0}' because it is scoped to the current method</source>
        <target state="translated">Non è possibile restituire un parametro per riferimento '{0}' perché ha come ambito il metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnScopedParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</source>
        <target state="translated">Non è possibile restituire per riferimento un membro del parametro '{0}' perché ha come ambito il metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningPropertiesCannotBeRequired">
        <source>Ref returning properties cannot be required.</source>
        <target state="translated">Il riferimento che restituisce le proprietà non può essere obbligatorio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructConstraintAlreadySpecified">
        <source>'ref struct' is already specified.</source>
        <target state="translated">'ref struct' è già specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' for ref struct '{2}'.</source>
        <target state="translated">'{0}' non può implementare il membro di interfaccia '{1}' per il ref struct '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RelationalPatternWithNaN">
        <source>Relational patterns may not be used for a floating-point NaN.</source>
        <target state="translated">Non è possibile usare i criteri relazionali per un valore NaN a virgola mobile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeHidden">
        <source>Required member '{0}' cannot be hidden by '{1}'.</source>
        <target state="translated">Il membro obbligatorio '{0}' non può essere nascosto da '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
        <source>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</source>
        <target state="translated">Il membro obbligatorio '{0}' non può essere meno visibile o avere un setter meno visibile del tipo contenitore '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSet">
        <source>Required member '{0}' must be set in the object initializer or attribute constructor.</source>
        <target state="translated">Il membro obbligatorio '{0}' deve essere impostato nell'inizializzatore di oggetto o nel costruttore dell’attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMemberMustBeSettable">
        <source>Required member '{0}' must be settable.</source>
        <target state="translated">Il membro obbligatorio '{0}' deve essere impostabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersBaseTypeInvalid">
        <source>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</source>
        <target state="translated">L'elenco dei membri obbligatori per il tipo di base '{0}' non è valido e non può essere interpretato. Per utilizzare questo costruttore, applicare l'attributo 'SetsRequiredMembers'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersInvalid">
        <source>The required members list for '{0}' is malformed and cannot be interpreted.</source>
        <target state="translated">L'elenco dei membri obbligatori per '{0}' non è valido e non può essere interpretato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredMembersMustBeAssignedValue">
        <source>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</source>
        <target state="translated">Al membro obbligatorio '{0}' deve essere assegnato un valore, non può utilizzare un membro annidato o un inizializzatore di insieme.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNameDisallowed">
        <source>Types and aliases cannot be named 'required'.</source>
        <target state="translated">I tipi e gli alias non possono essere denominati 'obbligatori'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmbeddedAttributeMustFollowPattern">
        <source>The type 'Microsoft.CodeAnalysis.EmbeddedAttribute' must be non-generic, internal, non-file, sealed, non-static, have a parameterless constructor, inherit from System.Attribute, and be able to be applied to any type.</source>
        <target state="needs-review-translation">Il tipo 'Microsoft.CodeAnalysis.EmbeddedAttribute' deve essere non generico, interno, sealed, non statico, avere un costruttore senza parametri, ereditare da System.Attribute e poter essere applicato a qualsiasi tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportByRefLikeGenerics">
        <source>Target runtime doesn't support by-ref-like generics.</source>
        <target state="translated">Il runtime di destinazione non supporta generics simili a by-ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
        <source>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': il runtime di destinazione non supporta tipi covarianti negli override. Il tipo deve essere '{2}' in modo da corrispondere al membro '{1}' di cui è stato eseguito l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
        <source>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': il runtime di destinazione non supporta tipi restituiti covarianti negli override. Il tipo restituito deve essere '{2}' in modo da corrispondere al membro '{1}' di cui è stato eseguito l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportInlineArrayTypes">
        <source>Target runtime doesn't support inline array types.</source>
        <target state="translated">Il runtime di destinazione non supporta i tipi di matrice inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">Il runtime di destinazione non supporta l'accessibilità 'protected', 'protected internal' o 'private protected' per un membro di un'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportRefFields">
        <source>Target runtime doesn't support ref fields.</source>
        <target state="translated">Il runtime di destinazione non supporta i campi di riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
        <source>Target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">Il runtime di destinazione non supporta membri astratti statici nelle interfacce.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</source>
        <target state="translated">'{0}' non può implementare il membro di interfaccia '{1}' nel tipo '{2}' perché il runtime di destinazione non supporta membri astratti statici nelle interfacce.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
        <source>The target runtime doesn't support extensible or runtime-environment default calling conventions.</source>
        <target state="translated">Il runtime di destinazione non supporta convenzioni di chiamata predefinite estendibili o dell'ambiente di runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedAfterInOutRefReadonly">
        <source>The 'scoped' modifier cannot come after an 'in', 'out', 'ref' or 'readonly' modifier.</source>
        <target state="new">The 'scoped' modifier cannot come after an 'in', 'out', 'ref' or 'readonly' modifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedDiscard">
        <source>The 'scoped' modifier cannot be used with discard.</source>
        <target state="translated">Non è possibile usare il modificatore 'scoped' con discard.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Il modificatore 'scoped' del parametro '{0}' non corrisponde al membro sottoposto a override o implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfPartial">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match partial definition.</source>
        <target state="translated">Il modificatore 'scoped' del parametro '{0}' non corrisponde alla definizione parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Il modificatore 'scoped' del parametro '{0}' non corrisponde all'elemento '{1}' di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedRefAndRefStructOnly">
        <source>The 'scoped' modifier can be used for refs and ref struct values only.</source>
        <target state="translated">Il modificatore 'scoped' può essere usato solo per i riferimenti e i valori ref struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScopedTypeNameDisallowed">
        <source>Types and aliases cannot be named 'scoped'.</source>
        <target state="translated">I tipi e gli alias non possono essere denominati 'con ambito'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
        <source>Required members are not allowed on the top level of a script or submission.</source>
        <target state="translated">I membri obbligatori non sono consentiti al primo livello di uno script o di un invio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedAPIInRecord">
        <source>'{0}' cannot be sealed because containing record is not sealed.</source>
        <target state="translated">'{0}' non può essere sealed perché il record contenitore non è sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignatureMismatchInRecord">
        <source>Record member '{0}' must return '{1}'.</source>
        <target state="translated">Il membro di record '{0}' deve restituire '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramIsEmpty">
        <source>At least one top-level statement must be non-empty.</source>
        <target state="translated">Almeno un'istruzione di primo livello deve essere non vuota.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
        <source>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</source>
        <target state="translated">In questo contesto non è possibile usare la variabile locale o la funzione locale '{0}' dichiarata in un'istruzione di primo livello.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
        <source>Only one compilation unit can have top-level statements.</source>
        <target state="translated">Le istruzioni di primo livello possono essere presenti solo in un'unica unità di compilazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SimpleProgramNotAnExecutable">
        <source>Program using top-level statements must be an executable.</source>
        <target state="translated">Il programma che usa istruzioni di primo livello deve essere un eseguibile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleInapplicableBinaryOperator">
        <source>Operator cannot be applied to operands of type '{0}' and '{1}'. The closest inapplicable candidate is '{2}'</source>
        <target state="new">Operator cannot be applied to operands of type '{0}' and '{1}'. The closest inapplicable candidate is '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleInapplicableUnaryOperator">
        <source>Operator cannot be applied to operand of type '{0}'. The closest inapplicable candidate is '{1}'</source>
        <target state="new">Operator cannot be applied to operand of type '{0}'. The closest inapplicable candidate is '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpreadMissingMember">
        <source>Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">L'operatore spread '..' non può operare su variabili di tipo '{0}' perché '{0}' non contiene un'istanza pubblica o una definizione di estensione per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAPIInRecord">
        <source>Record member '{0}' may not be static.</source>
        <target state="translated">Il membro di record '{0}' non può essere statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureThis">
        <source>A static anonymous function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Una funzione anonima statica non può contenere un riferimento a 'this' o 'base'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticAnonymousFunctionCannotCaptureVariable">
        <source>A static anonymous function cannot contain a reference to '{0}'.</source>
        <target state="translated">Una funzione anonima statica non può contenere un riferimento a '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">Una funzione locale statica non può contenere un riferimento a 'this' o 'base'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">Una funzione locale statica non può contenere un riferimento a '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">Il membro statico '{0}' non può essere contrassegnato come 'readonly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">è stato specificato l'argomento stdin '-', ma l'input non è stato reindirizzato dal flusso di input standard.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StringMustStartWithQuoteCharacter">
        <source>String must start with quote character: "</source>
        <target state="translated">La stringa deve iniziare con le virgolette: "</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructHasInitializersAndNoDeclaredConstructor">
        <source>A 'struct' with field initializers must include an explicitly declared constructor.</source>
        <target state="translated">Un elemento 'struct' con inizializzatori di campo deve includere un costruttore dichiarato in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutAndExtendedLayout">
        <source>Use of 'StructLayoutAttribute' and 'ExtendedLayoutAttribute' on the same type is not allowed.</source>
        <target state="new">Use of 'StructLayoutAttribute' and 'ExtendedLayoutAttribute' on the same type is not allowed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCyclePrimaryConstructorParameter">
        <source>Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Il parametro del costruttore primario struct '{0}' di tipo '{1}' causa un ciclo nel layout dello struct</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</source>
        <target state="translated">Il criterio non è raggiungibile. È già stato gestito da un elemento precedente dell'espressione switch oppure non è possibile trovare una corrispondenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</source>
        <target state="translated">Lo switch case on è raggiungibile. È già stato gestito da un case precedente oppure non è possibile trovare una corrispondenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">Non è stato trovato alcun tipo ottimale per l'espressione switch.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">L'espressione che gestisce lo switch deve essere racchiusa tra parentesi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SymbolDefinedInAssembly">
        <source>'{0}' is defined in assembly '{1}'.</source>
        <target state="translated">'{0}' è definito nell'assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCloseBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</source>
        <target state="translated">Il valore letterale stringa non elaborata interpolato non inizia con un numero di caratteri '$' sufficiente per consentire il contenuto di questo numero di parentesi graffe di chiusura consecutive.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyOpenBracesForRawString">
        <source>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</source>
        <target state="translated">Il valore letterale stringa non elaborato interpolato non inizia con un numero sufficiente di caratteri '$' per consentire questo numero di parentesi graffe di apertura consecutive come contenuto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyQuotesForRawString">
        <source>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</source>
        <target state="translated">Il valore letterale stringa non elaborato non inizia con un numero sufficiente di virgolette per consentire questo numero di virgolette consecutive come contenuto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings_RestartRequired">
        <source>Combined length of user strings used by the program exceeds allowed limit. Adding a string literal requires restarting the application.</source>
        <target state="new">Combined length of user strings used by the program exceeds allowed limit. Adding a string literal requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TopLevelStatementAfterNamespaceOrType">
        <source>Top-level statements must precede namespace and type declarations.</source>
        <target state="translated">Le istruzioni di primo livello devono precedere le dichiarazioni di tipo e di spazio dei nomi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">La sequenza di caratteri '...' è imprevista</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">Il nome '{0}' non identifica l'elemento di tupla '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">Le cardinalità dei tipi di tupla usati come operandi di un operatore == o != devono essere uguali, ma questo operatore presenta tipi di tupla con cardinalità {0} sulla sinistra e {1} sulla destra.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConstraintsMustBeUniqueAndFirst">
        <source>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</source>
        <target state="translated">I vincoli 'class', 'struct', 'unmanaged', 'notnull' e 'default' non possono essere combinati o duplicati e devono essere specificati per primi nell'elenco di vincoli.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeIsNotAnInterpolatedStringHandlerType">
        <source>'{0}' is not an interpolated string handler type.</source>
        <target state="translated">'{0}' non è un tipo di gestore di stringhe interpolate.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMustBePublic">
        <source>Type '{0}' must be public to be used as a calling convention.</source>
        <target state="translated">Il tipo '{0}' deve essere pubblico per poterlo usare come convenzione di chiamata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParameterSameNameAsExtensionParameter">
        <source>Type parameter '{0}' has the same name as an extension parameter</source>
        <target state="new">Type parameter '{0}' has the same name as an extension parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParameterSameNameAsExtensionTypeParameter">
        <source>Type parameter '{0}' has the same name as an extension container type parameter</source>
        <target state="new">Type parameter '{0}' has the same name as an extension container type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">La proprietà implementata automaticamente '{0}' deve essere assegnata completamente prima che il controllo sia restituito al chiamante. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Il campo '{0}' deve essere assegnato completamente prima che il controllo sia restituito al chiamante. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnderspecifiedExtension">
        <source>The type parameter `{0}` is not referenced by either the extension parameter or a parameter of this member</source>
        <target state="new">The type parameter `{0}` is not referenced by either the extension parameter or a parameter of this member</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentListInBaseTypeWithoutParameterList">
        <source>Cannot pass arguments to the base type without a parameter list on the type declaration.</source>
        <target state="new">Cannot pass arguments to the base type without a parameter list on the type declaration.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedParameterList">
        <source>Unexpected parameter list.</source>
        <target state="translated">Elenco parametri imprevisto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}', a cui è assegnato l'attributo 'UnmanagedCallersOnly', non può essere chiamato direttamente. Ottenere un puntatore a funzione per questo metodo.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
        <source>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</source>
        <target state="translated">'{0}', a cui è assegnato l'attributo 'UnmanagedCallersOnly', non può essere convertito in un tipo delegato. Ottenere un puntatore a funzione per questo metodo.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedRefSafetyRulesAttributeVersion">
        <source>'{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.</source>
        <target state="translated">'{0}' è definito in un modulo con una versione non riconosciuta di RefSafetyRulesAttribute. È previsto '11'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeInterfaceImplementation">
        <source>UnscopedRefAttribute cannot be applied to an interface implementation because implemented member '{0}' doesn't have this attribute.</source>
        <target state="translated">Non è possibile applicare UnscopedRefAttribute a un'implementazione dell'interfaccia perché il membro implementato '{0}' non dispone di questo attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedMemberTarget">
        <source>UnscopedRefAttribute can only be applied to struct or virtual interface instance methods and properties, and cannot be applied to constructors or init-only members.</source>
        <target state="translated">UnscopedRefAttribute può essere applicato solo ai metodi e alle proprietà dell'istanza di struct o di interfaccia virtuale e non può essere applicato a costruttori o membri solo init.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedRefAttributeUnsupportedTarget">
        <source>UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.</source>
        <target state="translated">Non è possibile applicare UnscopedRefAttribute a questo parametro perché è senza ambito per impostazione predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnscopedScoped">
        <source>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</source>
        <target state="translated">Impossibile applicare UnscopedRefAttribute a parametri con modificatore 'scoped'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCompilerFeature">
        <source>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</source>
        <target state="translated">'{0}' richiede la funzionalità del compilatore '{1}', che non è supportata da questa versione del compilatore C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedFeatureInRuntimeAsync">
        <source>Method '{0}' uses a feature that is not supported by runtime async currently. Opt the method out of runtime async by attributing it with 'System.Runtime.CompilerServices.RuntimeAsyncMethodGenerationAttribute(false)'.</source>
        <target state="new">Method '{0}' uses a feature that is not supported by runtime async currently. Opt the method out of runtime async by attributing it with 'System.Runtime.CompilerServices.RuntimeAsyncMethodGenerationAttribute(false)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRef">
        <source>Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member</source>
        <target state="translated">Non è possibile usare il parametro ref, out o in del costruttore primario '{0}' all'interno di un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefAny">
        <source>Cannot use primary constructor parameter of type '{0}' inside an instance member</source>
        <target state="translated">Non è possibile usare il parametro del costruttore primario di tipo '{0}' all'interno di un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedPrimaryConstructorParameterCapturingRefLike">
        <source>Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member</source>
        <target state="translated">Non è possibile usare il parametro del costruttore primario '{0}' con un tipo simile a ref all'interno di un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForListPattern">
        <source>List patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Non è possibile usare i modelli di elenco per un valore di tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedRawString">
        <source>Unterminated raw string literal.</source>
        <target state="translated">Valore letterale stringa senza terminazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Uso del campo probabilmente non assegnato '{0}'. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Utilizzo della proprietà implementata automaticamente probabilmente non assegnata '{0}'. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Impossibile utilizzare l'oggetto 'this' prima dell'assegnazione di tutti i relativi campi. Provare a eseguire l'aggiornamento alla versione del linguaggio '{0}' per impostare come predefiniti automaticamente i campi non assegnati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueParameterSameNameAsExtensionParameter">
        <source>'value': an automatically-generated parameter name conflicts with an extension parameter name</source>
        <target state="new">'value': an automatically-generated parameter name conflicts with an extension parameter name</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueParameterSameNameAsExtensionTypeParameter">
        <source>'value': an automatically-generated parameter name conflicts with an extension type parameter name</source>
        <target state="new">'value': an automatically-generated parameter name conflicts with an extension type parameter name</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableDeclarationNamedField">
        <source>In language version {0}, 'field' is a keyword within a property accessor. Rename the variable or use the identifier '@field' instead.</source>
        <target state="new">In language version {0}, 'field' is a keyword within a property accessor. Rename the variable or use the identifier '@field' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongArityAsyncReturn">
        <source>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</source>
        <target state="translated">È previsto un tipo restituito simile a un'attività generica, ma il tipo '{0}' trovato nell'attributo 'AsyncMethodBuilder' non è idoneo. Deve essere un tipo generico non associato di grado uno e il tipo che lo contiene (se presente) deve essere non generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing">
        <source>The using directive for '{0}' appeared previously as global using</source>
        <target state="translated">La direttiva using per '{0}' è già presente come using globale</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_DuplicateWithGlobalUsing_Title">
        <source>The using directive appeared previously as global using</source>
        <target state="translated">La direttiva using è già presente come using globale</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPattern">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPatternStackGuard">
        <source>The pattern is too complex to analyze for redundancy.</source>
        <target state="new">The pattern is too complex to analyze for redundancy.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPatternStackGuard_Title">
        <source>The pattern is too complex to analyze for redundancy.</source>
        <target state="new">The pattern is too complex to analyze for redundancy.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_RedundantPattern_Title">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ArrayAccess">
        <source>array access</source>
        <target state="translated">accesso all'array</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AsyncMethodBuilderOverride">
        <source>async method builder override</source>
        <target state="translated">override del generatore di metodi asincroni</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CollectionExpression">
        <source>collection expression</source>
        <target state="new">collection expression</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAllowsRefStructConstraint">
        <source>allows ref struct constraint</source>
        <target state="translated">consente il vincolo di struct di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoDefaultStructs">
        <source>auto default struct fields</source>
        <target state="translated">campi struct predefiniti in automatico</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCheckedUserDefinedOperators">
        <source>checked user-defined operators</source>
        <target state="translated">operatori definiti dall'utente controllati</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressionArguments">
        <source>collection expression arguments</source>
        <target state="new">collection expression arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionExpressions">
        <source>collection expressions</source>
        <target state="translated">espressioni di raccolta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCovariantReturnsForOverrides">
        <source>covariant returns</source>
        <target state="translated">tipi restituiti covarianti</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDiscards">
        <source>discards</source>
        <target state="translated">rimozioni</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDisposalPattern">
        <source>pattern-based disposal</source>
        <target state="translated">eliminazione basata su criteri</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPropertyPatterns">
        <source>extended property patterns</source>
        <target state="translated">criteri di proprietà estesa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensions">
        <source>extensions</source>
        <target state="new">extensions</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFieldKeyword">
        <source>field keyword</source>
        <target state="translated">parola chiave campo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileScopedNamespace">
        <source>file-scoped namespace</source>
        <target state="translated">spazio dei nomi con ambito file</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFileTypes">
        <source>file types</source>
        <target state="translated">tipi di file</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFirstClassSpan">
        <source>first-class Span types</source>
        <target state="translated">tipi Span di prima classe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenericAttributes">
        <source>generic attributes</source>
        <target state="translated">attributi generici</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalUsing">
        <source>global using directive</source>
        <target state="translated">direttiva using globale</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitIndexerInitializer">
        <source>implicit indexer initializer</source>
        <target state="translated">inizializzatore indicizzatore implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitObjectCreation">
        <source>target-typed object creation</source>
        <target state="translated">creazione di oggetti con tipo di destinazione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImprovedInterpolatedStrings">
        <source>interpolated string handlers</source>
        <target state="translated">gestori di stringhe interpolate</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInferredDelegateType">
        <source>inferred delegate type</source>
        <target state="translated">tipo di delegato dedotto</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInlineArrays">
        <source>inline arrays</source>
        <target state="translated">matrici inline</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInstanceMemberInNameof">
        <source>instance member in 'nameof'</source>
        <target state="translated">membro di istanza in 'nameof'</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaAttributes">
        <source>lambda attributes</source>
        <target state="translated">attributi lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaOptionalParameters">
        <source>lambda optional parameters</source>
        <target state="translated">parametri facoltativi lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaParamsArray">
        <source>lambda params array</source>
        <target state="translated">matrice di parametri lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaReturnType">
        <source>lambda return type</source>
        <target state="translated">tipo restituito dell'espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureListPattern">
        <source>list pattern</source>
        <target state="translated">modello di elenco</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLockObject">
        <source>Lock object</source>
        <target state="translated">Blocca oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNewLinesInInterpolations">
        <source>newlines in interpolations</source>
        <target state="translated">nuove linee nelle interpolazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullConditionalAssignment">
        <source>null conditional assignment</source>
        <target state="new">null conditional assignment</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOverloadResolutionPriority">
        <source>overload resolution priority</source>
        <target state="translated">priorità di risoluzione dell'overload</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParameterlessStructConstructors">
        <source>parameterless struct constructors</source>
        <target state="translated">costruttori struct senza parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParamsCollections">
        <source>params collections</source>
        <target state="translated">raccolte parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialEventsAndConstructors">
        <source>partial events and constructors</source>
        <target state="new">partial events and constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePositionalFieldsInRecords">
        <source>positional fields in records</source>
        <target state="translated">campi posizionali nei record</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrimaryConstructors">
        <source>primary constructors</source>
        <target state="translated">costruttori primari</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRawStringLiterals">
        <source>raw string literals</source>
        <target state="translated">valori letterali stringa non elaborati</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecordStructs">
        <source>record structs</source>
        <target state="translated">struct di record</target>
        <note>'record structs' is not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFields">
        <source>ref fields</source>
        <target state="translated">campi ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReadonlyParameters">
        <source>ref readonly parameters</source>
        <target state="translated">parametri di sola lettura ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructInterfaces">
        <source>ref struct interfaces</source>
        <target state="translated">interfacce ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefUnsafeInIteratorAsync">
        <source>ref and unsafe in async and iterator methods</source>
        <target state="translated">ref e unsafe nei metodi asincroni e iteratori</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelaxedShiftOperator">
        <source>relaxed shift operator</source>
        <target state="translated">operatore di spostamento rilassato</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRequiredMembers">
        <source>required members</source>
        <target state="translated">membri obbligatori</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSealedToStringInRecord">
        <source>sealed ToString in record</source>
        <target state="translated">ToString sealed nel record</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSimpleLambdaParameterModifiers">
        <source>simple lambda parameter modifiers</source>
        <target state="new">simple lambda parameter modifiers</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStringEscapeCharacter">
        <source>string escape character</source>
        <target state="translated">carattere di escape stringa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStructFieldInitializers">
        <source>struct field initializers</source>
        <target state="translated">inizializzatori di campo struct</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnboundGenericTypesInNameof">
        <source>unbound generic types in nameof operator</source>
        <target state="translated">tipi generici non collegati nell'operatore nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnsignedRightShift">
        <source>unsigned right shift</source>
        <target state="translated">spostamento a destra senza segno</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUserDefinedCompoundAssignmentOperators">
        <source>user-defined compound assignment operators</source>
        <target state="new">user-defined compound assignment operators</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUtf8StringLiterals">
        <source>UTF-8 string literals</source>
        <target state="translated">Valori letterali stringa UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingTypeAlias">
        <source>using type alias</source>
        <target state="translated">Alias di tipo using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnAnonymousTypes">
        <source>with on anonymous types</source>
        <target state="translated">con tipi anonimi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAbstractMembersInInterfaces">
        <source>static abstract members in interfaces</source>
        <target state="translated">membri astratti statici nelle interfacce</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureWithOnStructs">
        <source>with on structs</source>
        <target state="translated">con struct</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSpanCharConstantPattern">
        <source>pattern matching ReadOnly/Span&lt;char&gt; on constant string</source>
        <target state="translated">criterio corrispondente a ReadOnly/Span&lt;char&gt; su stringa costante</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Missing">
        <source>&lt;missing&gt;</source>
        <target state="translated">&lt;missing&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PointerElementAccess">
        <source>pointer element access</source>
        <target state="translated">accesso all'elemento puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ARRAY">
        <source>array</source>
        <target state="translated">matrice</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_DYNAMIC">
        <source>dynamic</source>
        <target state="translated">dinamico</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FUNCTION_POINTER">
        <source>function pointer</source>
        <target state="translated">Puntatore funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_POINTER">
        <source>pointer</source>
        <target state="translated">indicatore di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas">
        <source>Compiling requires binding the lambda expression at least {0} times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">La compilazione richiede l'associazione dell'espressione lambda almeno {0}volte. È consigliabile dichiarare l'espressione lambda con tipi di parametro espliciti oppure, se la chiamata al metodo contenitore è generica, provare a usare argomenti di tipo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_TooManyBoundLambdas_Title">
        <source>Compiling requires binding the lambda expression many times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.</source>
        <target state="translated">La compilazione richiede l'associazione dell'espressione lambda molte volte. È consigliabile dichiarare l'espressione lambda con tipi di parametro espliciti oppure, se la chiamata al metodo contenitore è generica, provare a usare argomenti di tipo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISpreadOperationIsNotCSharpSpread">
        <source>{0} is not a valid C# spread operation</source>
        <target state="translated">{0} non è un'operazione estensione C# valida</target>
        <note />
      </trans-unit>
      <trans-unit id="NodeIsNotAwaitUsingDeclaration">
        <source>'node' is not an 'await using' declaration</source>
        <target state="new">'node' is not an 'await using' declaration</target>
        <note>node and await using are not localizable</note>
      </trans-unit>
      <trans-unit id="NodeIsNotAwaitUsingStatement">
        <source>'node' is not an 'await using' statement</source>
        <target state="new">'node' is not an 'await using' statement</target>
        <note>node and await using are not localizable</note>
      </trans-unit>
      <trans-unit id="ParameterRequiresTypeOrIdentifier">
        <source>ParameterSyntax requires either a type or an identifier.</source>
        <target state="new">ParameterSyntax requires either a type or an identifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AccessorDoesNotUseBackingField">
        <source>The '{0}' accessor of property '{1}' should use 'field' because the other accessor is using it.</source>
        <target state="translated">La funzione di accesso '{0}' della proprietà '{1}' deve usare 'field' perché è utilizzata dall'altra funzione di accesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AccessorDoesNotUseBackingField_Title">
        <source>Property accessor should use 'field' because the other accessor is using it.</source>
        <target state="translated">La funzione di accesso delle proprietà deve usare 'field' perché è in uso dall'altra funzione di accesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">L'operatore '&amp;' non deve essere usato su parametri o variabili locali in metodi asincroni.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AddressOfInAsync_Title">
        <source>The '&amp;' operator should not be used on parameters or local variables in async methods.</source>
        <target state="translated">L'operatore '&amp;' non deve essere usato su parametri o variabili locali in metodi asincroni.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">L'assembly '{0}' che contiene il tipo '{1}' fa riferimento a .NET Framework, che non è supportato.</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">L'assembly caricato fa riferimento a .NET Framework, che non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler">
        <source>Analyzer assembly '{0}' cannot be used because it references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="needs-review-translation">L'assembly dell'analizzatore '{0}' fa riferimento alla versione '{1}' del compilatore, che è più recente della versione attualmente in esecuzione '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesNewerCompiler_Title">
        <source>Analyzer assembly cannot be used because it references a newer version of the compiler than the currently running version.</source>
        <target state="needs-review-translation">L'assembly dell'analizzatore fa riferimento alla versione del compilatore, che è più recente della versione attualmente in esecuzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn">
        <source>Argument {0} should be passed with the 'in' keyword</source>
        <target state="translated">L'argomento {0} deve essere passato con la parola chiave 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedIn_Title">
        <source>Argument should be passed with the 'in' keyword</source>
        <target state="translated">L'argomento deve essere passato con la parola chiave 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn">
        <source>Argument {0} should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">L'argomento {0} deve essere passato con la parola chiave 'ref' o 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArgExpectedRefOrIn_Title">
        <source>Argument should be passed with 'ref' or 'in' keyword</source>
        <target state="translated">L'argomento deve essere passato con la parola chiave 'ref' o 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef">
        <source>The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Il modificatore 'ref' per l'argomento {0} corrispondente al parametro 'in' equivale a 'in'. Provare a usare 'in'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadArgRef_Title">
        <source>The 'ref' modifier for an argument corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.</source>
        <target state="translated">Il modificatore 'ref' per un argomento corrispondente al parametro 'in' equivale a 'in'. Provare a usare 'in'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">È necessario specificare il parametro di attributo 'SizeConst'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByValArraySizeConstRequired_Title">
        <source>Attribute parameter 'SizeConst' must be specified.</source>
        <target state="translated">È necessario specificare il parametro di attributo 'SizeConst'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto. È applicato con un nome di parametro non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
        <source>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</source>
        <target state="translated">CallerArgumentExpressionAttribute viene applicato con un nome di parametro non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto perché è autoreferenziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
        <source>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro non avrà alcun effetto perché è autoreferenziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerArgumentExpressionAttribute non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
        <source>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</source>
        <target state="translated">CallerArgumentExpressionAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerMemberNameAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
        <source>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</source>
        <target state="translated">CallerArgumentExpressionAttribute non avrà alcun effetto. CallerMemberNameAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Il parametro '{0}' viene acquisito nello stato del tipo di inclusione e il relativo valore viene utilizzato anche per inizializzare un campo, una proprietà o un evento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterInFieldInitializer_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.</source>
        <target state="translated">Il parametro viene acquisito nello stato del tipo di inclusione e il relativo valore viene utilizzato anche per inizializzare un campo, una proprietà o un evento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase">
        <source>Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Il parametro '{0}' viene catturato nello stato del tipo di inclusione e il relativo valore viene passato anche al costruttore di base. Il valore potrebbe essere catturato anche dalla classe di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CapturedPrimaryConstructorParameterPassedToBase_Title">
        <source>Parameter is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.</source>
        <target state="translated">Il parametro viene catturato nello stato del tipo di inclusione e il relativo valore viene passato anche al costruttore di base. Il valore potrebbe essere catturato anche dalla classe di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">L'espressione di raccolta di tipo '{0}' può comportare allocazioni di heap impreviste. Provare a creare in modo esplicito una matrice, quindi a convertirla in '{0}' per rendere esplicita l'allocazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">L'espressione di raccolta può comportare allocazioni di heap impreviste. Provare a creare in modo esplicito una matrice, quindi a convertirla nel tipo finale per rendere esplicita l'allocazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate">
        <source>Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.</source>
        <target state="translated">L'espressione di raccolta di tipo '{0}' può comportare allocazioni di heap impreviste a causa dell'uso di spread '..'. Provare a creare in modo esplicito una matrice, quindi a convertirla in '{0}' per rendere esplicita l'allocazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CollectionExpressionRefStructSpreadMayAllocate_Title">
        <source>Collection expression may incur unexpected heap allocations due to use of '..' spreads. Consider explicitly creating an array, then converting to the final type to make the allocation explicit.</source>
        <target state="translated">L'espressione di raccolta può comportare allocazioni di heap impreviste a causa dell'uso di spread '..'. Provare a creare in modo esplicito una matrice, quindi a convertirla nel tipo finale per rendere esplicita l'allocazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow">
        <source>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Con l’operazione può verificarsi un overflow '{0} 'in fase di esecuzione. Usare la sintassi 'unchecked' per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CompileTimeCheckedOverflow_Title">
        <source>The operation may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Con l’operazione può verificarsi un overflow in fase di esecuzione. Usare la sintassi 'unchecked' per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Un valore di tipo 'System.Threading.Lock' convertito in un tipo diverso userà probabilmente un blocco basato su monitoraggio non intenzionale nell'istruzione 'lock'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingLock_Title">
        <source>A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.</source>
        <target state="translated">Un valore di tipo 'System.Threading.Lock' convertito in un tipo diverso userà probabilmente un blocco basato su monitoraggio non intenzionale nell'istruzione 'lock'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers">
        <source>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</source>
        <target state="translated">Il confronto dei puntatori a funzione potrebbe produrre un risultato imprevisto perché i puntatori alla stessa funzione possono essere distinti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoNotCompareFunctionPointers_Title">
        <source>Do not compare function pointer values</source>
        <target state="translated">Non confrontare valori del puntatore a funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference">
        <source>Analyzer reference '{0}' specified multiple times</source>
        <target state="translated">Il riferimento '{0}' dell'analizzatore è stato specificato più volte</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateAnalyzerReference_Title">
        <source>Analyzer reference specified multiple times</source>
        <target state="translated">Riferimento analizzatore specificato più volte</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</source>
        <target state="translated">Un risultato di un'espressione stackalloc di tipo '{0}' in questo contesto può essere esposto all'esterno del metodo contenitore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeStackAlloc_Title">
        <source>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</source>
        <target state="translated">Un risultato di un'espressione stackalloc di questo tipo in questo contesto può essere esposto all'esterno del metodo contenitore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable">
        <source>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">L'uso della variabile '{0}' in questo contesto può esporre le variabili a cui si fa riferimento all'esterno del relativo ambito di dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EscapeVariable_Title">
        <source>Use of variable in this context may expose referenced variables outside of their declaration scope</source>
        <target state="translated">L'uso di variabili in questo contesto potrebbe esporre le variabili a cui si fa riferimento al di fuori dell'ambito della dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExperimentalWithMessage">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates: '{1}'. Suppress this diagnostic to proceed.</source>
        <target state="translated">"{0}" viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri: "{1}". Eliminare questa diagnostica per continuare.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExperimentalWithMessage_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Type viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri. Elimina questa diagnostica per continuare.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous">
        <source>In language version {0}, the 'field' keyword binds to a synthesized backing field for the property. To avoid generating a synthesized backing field, and to refer to the existing member, use 'this.field' or '@field' instead.</source>
        <target state="translated">Nella versione del linguaggio {0}, la parola chiave 'field' è associata a un campo di supporto sintetizzato per la proprietà. Per evitare di generare un campo di supporto sintetizzato e fare riferimento al membro esistente, utilizzare 'this.field' o '@field'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldIsAmbiguous_Title">
        <source>The 'field' keyword binds to a synthesized backing field for the property.</source>
        <target state="translated">La parola chiave 'field' è associata a un campo di supporto sintetizzato per la proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">L'operatore di conversione della matrice inline non verrà usato per la conversione dell’espressione del tipo dichiarante.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayConversionOperatorNotUsed_Title">
        <source>Inline array conversion operator will not be used for conversion from expression of the declaring type.</source>
        <target state="translated">L'operatore di conversione della matrice inline non verrà usato per la conversione dell’espressione del tipo dichiarante.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">L'indicizzatore di matrice inline non verrà usato per l'espressione di accesso agli elementi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayIndexerNotUsed_Title">
        <source>Inline array indexer will not be used for element access expression.</source>
        <target state="translated">L'indicizzatore di matrice inline non verrà usato per l'espressione di accesso agli elementi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">La funzionalità del linguaggio 'Matrici inline' non è supportata per un tipo di matrice inline che non è valido come argomento di tipo o che ha un tipo di elemento non valido come argomento di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArrayNotSupportedByLanguage_Title">
        <source>'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.</source>
        <target state="translated">La funzionalità del linguaggio 'Matrici inline' non è supportata per un tipo di matrice inline che non è valido come argomento di tipo o che ha un tipo di elemento non valido come argomento di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Il metodo 'Slice' della matrice inline non verrà usato per l'espressione di accesso agli elementi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InlineArraySliceNotUsed_Title">
        <source>Inline array 'Slice' method will not be used for element access expression.</source>
        <target state="translated">Il metodo 'Slice' della matrice inline non verrà usato per l'espressione di accesso agli elementi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro '{0}' non corrisponde al parametro corrispondente '{1}' nel membro nascosto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_HidingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in hidden member.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro non corrisponde al parametro corrispondente nel membro nascosto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch">
        <source>Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.</source>
        <target state="translated">Intercettazione di una chiamata a '{0}' con l'intercettore '{1}', ma le firme non corrispondono.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptorSignatureMismatch_Title">
        <source>Signatures of interceptable and interceptor methods do not match.</source>
        <target state="translated">Le firme dei metodi intercettabili e intercettori non corrispondono.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptsLocationAttributeUnsupportedSignature">
        <source>'InterceptsLocationAttribute(string, int, int)' is not supported. Move to 'InterceptableLocation'-based generation of these attributes instead. (https://github.com/dotnet/roslyn/issues/72133)</source>
        <target state="translated">'InterceptsLocationAttribute(string, int, int)' non è supportato. Passare alla generazione di questi attributi basata su 'InterceptableLocation'. (https://github.com/dotnet/roslyn/issues/72133)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterceptsLocationAttributeUnsupportedSignature_Title">
        <source>'InterceptsLocationAttribute(string, int, int)' is not supported. Move to 'InterceptableLocation'-based generation of these attributes instead. (https://github.com/dotnet/roslyn/issues/72133)</source>
        <target state="translated">'InterceptsLocationAttribute(string, int, int)' non è supportato. Passare alla generazione di questi attributi basata su 'InterceptableLocation'. (https://github.com/dotnet/roslyn/issues/72133)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">InterpolatedStringHandlerArgument non ha alcun effetto se viene applicato ai parametri lambda e verrà ignorato nel sito di chiamata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
        <source>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</source>
        <target state="translated">InterpolatedStringHandlerArgument non ha alcun effetto se viene applicato ai parametri lambda e verrà ignorato nel sito di chiamata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName">
        <source>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Il nome del tipo '{0}' contiene solo caratteri ascii minuscoli. Tali nomi possono diventare riservati per la lingua.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowerCaseTypeName_Title">
        <source>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</source>
        <target state="translated">Il nome del tipo contiene solo caratteri ascii minuscoli. Tali nomi possono diventare riservati per la lingua.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</source>
        <target state="translated">Prende l'indirizzo di, ottiene le dimensioni di o dichiara un puntatore a un tipo gestito ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ManagedAddr_Title">
        <source>This takes the address of, gets the size of, or declares a pointer to a managed type</source>
        <target state="translated">Prende l'indirizzo di, ottiene le dimensioni di o dichiara un puntatore a un tipo gestito</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel">
        <source>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Conversione del gruppo di metodi '{0}' nel tipo non delegato '{1}'. Si intendeva richiamare il metodo?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MethGrpToNonDel_Title">
        <source>Converting method group to non-delegate type</source>
        <target state="translated">Conversione del gruppo di metodi in un tipo non delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">I rami dell'operatore condizionale di riferimento fanno riferimento a variabili con ambiti di dichiarazione incompatibili</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MismatchedRefEscapeInTernary_Title">
        <source>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</source>
        <target state="translated">I rami dell'operatore condizionale di riferimento fanno riferimento a variabili con ambiti di dichiarazione incompatibili</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' non corrisponde al membro implementato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnInterceptor_Title">
        <source>Nullability of reference types in type of parameter doesn't match interceptable method.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al metodo intercettabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor">
        <source>Nullability of reference types in return type doesn't match interceptable method '{0}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnInterceptor_Title">
        <source>Nullability of reference types in return type doesn't match interceptable method.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al metodo intercettabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired">
        <source>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">Al membro obbligatorio '{0}' non deve essere attribuito 'ObsoleteAttribute' a meno che il tipo contenitore sia obsoleto o che tutti i costruttori siano obsoleti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteMembersShouldNotBeRequired_Title">
        <source>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</source>
        <target state="translated">I membri con attributo 'ObsoleteAttribute' non devono essere obbligatori a meno che il tipo contenitore sia obsoleto o che tutti i costruttori siano obsoleti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch">
        <source>Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.</source>
        <target state="translated">Il parametro {0} ha il valore predefinito '{1:10}' nell'espressione lambda ma '{2:10}' nel tipo delegato di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalParamValueMismatch_Title">
        <source>The default parameter value does not match in the target delegate type.</source>
        <target state="translated">Il valore del parametro predefinito non corrisponde al tipo delegato di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro '{0}' non corrisponde al parametro corrispondente '{1}' nel membro sovrascritto o implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverridingDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in overridden or implemented member.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro non corrisponde al parametro corrispondente nel membro sovrascritto o implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull">
        <source>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</source>
        <target state="translated">Il parametro '{0}' deve avere un valore non Null quando viene terminato perché il parametro '{1}' è non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterNotNullIfNotNull_Title">
        <source>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</source>
        <target state="translated">Il parametro deve avere un valore non Null quando viene terminato perché il parametro a cui fa riferimento NotNullIfNotNull è non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
        <source>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.</source>
        <target state="translated">Il parametro '{0}' è indicato dopo '{1}' nell'elenco di parametri, ma viene usato come argomento per le conversioni del gestore di stringhe interpolate. Al chiamante verrà richiesto di riordinare i parametri con argomenti denominati nel sito di chiamata. Provare a inserire il parametro del gestore di stringhe interpolate dopo tutti gli argomenti interessati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
        <source>Parameter to interpolated string handler conversion occurs after handler parameter</source>
        <target state="translated">Il parametro per la conversione del gestore di stringhe interpolate si trova dopo il parametro del gestore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly">
        <source>Parameter {0} has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">Il parametro {0} contiene un modificatore di parametri in lambda ma non nel tipo delegato di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamsArrayInLambdaOnly_Title">
        <source>Parameter has params modifier in lambda but not in target delegate type.</source>
        <target state="translated">Il parametro contiene un modificatore di parametri in lambda ma non nel tipo delegato di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMemberSignatureDifference">
        <source>Partial member declarations '{0}' and '{1}' have signature differences.</source>
        <target state="new">Partial member declarations '{0}' and '{1}' have signature differences.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMemberSignatureDifference_Title">
        <source>Partial member declarations have signature differences.</source>
        <target state="new">Partial member declarations have signature differences.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase">
        <source>Primary constructor parameter '{0}' is shadowed by a member from base.</source>
        <target state="translated">Il parametro del costruttore primario '{0}' è ombreggiato da un membro della base.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrimaryConstructorParameterIsShadowedAndNotPassedToBase_Title">
        <source>Primary constructor parameter is shadowed by a member from base</source>
        <target state="translated">Il parametro del costruttore primario è nascosto da un membro della base</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode">
        <source>'{0}' defines 'Equals' but not 'GetHashCode'</source>
        <target state="translated">'{0}' definisce 'Equals' ma non 'GetHashCode'</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="WRN_RecordEqualsWithoutGetHashCode_Title">
        <source>Record defines 'Equals' but not 'GetHashCode'.</source>
        <target state="translated">Il record definisce 'Equals' ma non 'GetHashCode'.</target>
        <note>'GetHashCode' and 'Equals' are not localizable.</note>
      </trans-unit>
      <trans-unit id="IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
        <source>Mixed declarations and expressions in deconstruction</source>
        <target state="translated">Dichiarazioni ed espressioni miste nella decostruzione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference">
        <source>Partial method declarations '{0}' and '{1}' have signature differences.</source>
        <target state="translated">Le dichiarazioni di metodo parziali '{0}' e '{1}' presentano differenze di firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PartialMethodTypeDifference_Title">
        <source>Partial method declarations have signature differences.</source>
        <target state="translated">Le dichiarazioni di metodo parziali presentano differenze di firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Il nome di tipi e alias non deve essere 'record'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecordNamedDisallowed_Title">
        <source>Types and aliases should not be named 'record'.</source>
        <target state="translated">Il nome di tipi e alias non deve essere 'record'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RedundantPattern">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RedundantPattern_Title">
        <source>The pattern is redundant.</source>
        <target state="new">The pattern is redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">Questo riferimento assegna '{1}' a '{0}' ma '{1}' ha un ambito di escape più ristretto di '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignNarrower_Title">
        <source>This ref-assigns a value that has a narrower escape scope than the target.</source>
        <target state="translated">In questo modo viene assegnato con ref un valore con un ambito di escape più ristretto rispetto alla destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</source>
        <target state="translated">Questo tipo di riferimento assegna '{1}' a '{0}' ma '{1}' può solo eseguire l'escape del metodo corrente tramite un'istruzione return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignReturnOnly_Title">
        <source>This ref-assigns a value that can only escape the current method through a return statement.</source>
        <target state="translated">In questo modo viene assegnato un valore che può eseguire l'escape del metodo corrente solo tramite un'istruzione return.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider">
        <source>This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.</source>
        <target state="translated">Questo riferimento assegna '{1}' a '{0}' ma '{1}' ha un ambito di escape del valore più ampio di '{0}' consentendo l'assegnazione tramite '{0}' di valori con ambiti di escape più ristretti rispetto a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefAssignValEscapeWider_Title">
        <source>This ref-assigns a value that has a wider value escape scope than the target allowing assignment through the target of values with narrower escapes scopes.</source>
        <target state="translated">Questa funzione assegna un valore che ha un ambito di escape più ampio di quello del target, consentendo l'assegnazione attraverso il target di valori con ambiti di escape più ristretti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable">
        <source>Argument {0} should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">L'argomento {0} deve essere una variabile perché viene passato a un parametro 'ref readonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyNotVariable_Title">
        <source>Argument should be a variable because it is passed to a 'ref readonly' parameter</source>
        <target state="translated">L'argomento deve essere una variabile perché viene passato a un parametro 'ref readonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue">
        <source>A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Per il parametro 'ref readonly' viene specificato un valore predefinito '{0}', ma 'ref readonly' deve essere usato solo per i riferimenti. Provare a dichiarare il parametro come 'in'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReadonlyParameterDefaultValue_Title">
        <source>A default value is specified for 'ref readonly' parameter, but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.</source>
        <target state="translated">Per il parametro 'ref readonly' viene specificato un valore predefinito, ma 'ref readonly' deve essere usato solo per i riferimenti. Provare a dichiarare il parametro come 'in'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal">
        <source>This returns local '{0}' by reference but it is not a ref local</source>
        <target state="translated">In questo modo viene restituito il valore locale '{0}' per riferimento, ma non è un riferimento locale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2">
        <source>This returns a member of local '{0}' by reference but it is not a ref local</source>
        <target state="translated">Viene restituito un membro di '{0}' locale per riferimento, ma non è un ref locale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal2_Title">
        <source>This returns a member of local by reference but it is not a ref local</source>
        <target state="translated">In questo modo viene restituito un membro locale per riferimento, ma non è un riferimento locale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnLocal_Title">
        <source>This returns local by reference but it is not a ref local</source>
        <target state="translated">Restituisce local per riferimento, ma non è un ref locale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal">
        <source>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">'{0}' locale viene restituito per riferimento ma è stato inizializzato su un valore che non può essere restituito dal riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2">
        <source>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Un membro di '{0}' viene restituito dal riferimento ma è stato inizializzato su un valore che non può essere restituito dal riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal2_Title">
        <source>A member is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Un membro viene restituito dal riferimento ma è stato inizializzato su un valore che non può essere restituito dal riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnNonreturnableLocal_Title">
        <source>Local is returned by reference but was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Locale viene restituito dal riferimento ma è stato inizializzato su un valore che non può essere restituito dal riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter">
        <source>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Viene restituito un parametro per riferimento '{0}' tramite un parametro ref; ma può essere restituito in modo sicuro solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2">
        <source>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Viene restituito per riferimento un membro del parametro '{0}' tramite un parametro ref; ma può essere restituito in modo sicuro solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter2_Title">
        <source>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">Viene restituito per riferimento un membro di parametro tramite un parametro ref; ma può essere restituito in modo sicuro solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnOnlyParameter_Title">
        <source>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</source>
        <target state="translated">In questo modo viene restituito un parametro ref tramite un parametro di riferimento. ma può essere restituito in modo sicuro solo in un'istruzione return</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter">
        <source>This returns a parameter by reference '{0}' but it is not a ref parameter</source>
        <target state="translated">Viene restituito un parametro per riferimento '{0}' ma non è un parametro ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2">
        <source>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</source>
        <target state="translated">Restituisce per riferimento un membro del parametro '{0}' che non è un parametro ref o out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter2_Title">
        <source>This returns by reference a member of parameter that is not a ref or out parameter</source>
        <target state="translated">Restituisce per riferimento un membro di parametro che non è un parametro ref o out</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnParameter_Title">
        <source>This returns a parameter by reference but it is not a ref parameter</source>
        <target state="translated">Restituisce un parametro per riferimento, ma non è un parametro ref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter">
        <source>This returns a parameter by reference '{0}' but it is scoped to the current method</source>
        <target state="translated">Viene restituito un parametro per riferimento '{0}' ma l'ambito è impostato sul metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2">
        <source>This returns by reference a member of parameter '{0}' that is scoped to the current method</source>
        <target state="translated">Viene restituito per riferimento un membro del parametro '{0}' con ambito al metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter2_Title">
        <source>This returns by reference a member of parameter that is scoped to the current method</source>
        <target state="translated">Viene restituito per riferimento un membro del parametro con ambito al metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnScopedParameter_Title">
        <source>This returns a parameter by reference but it is scoped to the current method</source>
        <target state="translated">In questo modo viene restituito un parametro per riferimento, ma l'ambito è limitato al metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Il membro struct restituisce 'questo' o altri membri di istanza per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefReturnStructThis_Title">
        <source>Struct member returns 'this' or other instance members by reference</source>
        <target state="translated">Il membro struct restituisce 'questo' o altri membri di istanza per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull">
        <source>Return value must be non-null because parameter '{0}' is non-null.</source>
        <target state="translated">Il valore restituito deve essere non Null perché il parametro '{0}' è non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnNotNullIfNotNull_Title">
        <source>Return value must be non-null because parameter is non-null.</source>
        <target state="translated">Il valore restituito deve essere non Null perché il parametro è non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</source>
        <target state="translated">Il modificatore 'scoped' del parametro '{0}' non corrisponde al membro sottoposto a override o implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
        <source>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</source>
        <target state="translated">Il modificatore 'scoped' del parametro non corrisponde al membro sottoposto a override o implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget">
        <source>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</source>
        <target state="translated">Il modificatore 'scoped' del parametro '{0}' non corrisponde all'elemento '{1}' di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ScopedMismatchInParameterOfTarget_Title">
        <source>The 'scoped' modifier of parameter doesn't match target.</source>
        <target state="translated">Il modificatore 'scoped' del parametro non corrisponde alla destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</source>
        <target state="translated">L'espressione switch non gestisce alcuni valori del relativo tipo di input (non è esaustiva) che interessa un valore di enumerazione senza nome. Ad esempio, il criterio '{0}' non è coperto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
        <source>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</source>
        <target state="translated">L'espressione switch non gestisce alcuni valori del relativo tipo di input (non è esaustiva) che interessa un valore di enumerazione senza nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SyncAndAsyncEntryPoints">
        <source>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</source>
        <target state="translated">Il metodo '{0}' non verrà usato come punto di ingresso perché è stato trovato un punto di ingresso sincrono '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotFound">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">Il tipo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedArgumentList">
        <source>Unexpected argument list.</source>
        <target state="translated">Elenco di argomenti imprevisto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedOrMissingConstructorInitializerInRecord">
        <source>A constructor declared in a type with parameter list must have 'this' constructor initializer.</source>
        <target state="translated">Un costruttore dichiarato in un record con elenco di parametri deve includere l'inizializzatore di costruttore 'this'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVarianceStaticMember">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</source>
        <target state="translated">Varianza non valida: il parametro di tipo '{1}' deve essere {3} valido in '{0}' a meno che non venga usata la versione '{4}' o successiva del linguaggio. '{1}' è {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">'{0}': non è possibile specificare sia una classe constraint che il vincolo 'unmanaged'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
        <source>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</source>
        <target state="translated">I metodi attribuiti con 'UnmanagedCallersOnly' non possono avere parametri di tipo generico e non possono essere dichiarati in un tipo generico.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyRequiresStatic">
        <source>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</source>
        <target state="translated">'UnmanagedCallersOnly' può essere applicato solo a metodi ordinari statici, non astratti e non virtuali, o a funzioni locali statiche.</target>
        <note>UnmanagedCallersOnly is not localizable.</note>
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Il tipo '{2}' deve essere un tipo valore che non ammette i valori Null, unitamente a tutti i campi a ogni livello di annidamento, per poter essere usato come parametro '{1}' nel tipo o metodo generico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedCallingConvention">
        <source>The calling convention of '{0}' is not supported by the language.</source>
        <target state="translated">La convenzione di chiamata di '{0}' non è supportata dal linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTypeForRelationalPattern">
        <source>Relational patterns may not be used for a value of type '{0}'.</source>
        <target state="translated">Non è possibile usare i criteri relazionali per un valore di tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">Non è possibile usare una variabile using direttamente in una sezione di switch; provare a usare le parentesi graffe. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">Per fare riferimento a un tipo, non è consentito usare la sintassi 'var' per un criterio, ma in questo '{0}' è incluso nell'ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">Non è possibile dichiarare enumerazioni, classi e strutture in un'interfaccia che contiene un parametro di tipo 'in' o 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongFuncPtrCallingConvention">
        <source>Calling convention of '{0}' is not compatible with '{1}'.</source>
        <target state="translated">La convenzione di chiamata di '{0}' non è compatibile con '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">Per la corrispondenza del tipo di tupla '{0}' sono richiesti '{1}' criteri secondari, ma ne sono presenti '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Il nome file '{0}' è vuoto, contiene caratteri non validi, include una specifica di unità senza percorso assoluto oppure è troppo lungo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AddressOfMethodGroup">
        <source>&amp;method group</source>
        <target state="translated">gruppo di &amp;metodi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.

                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0 or higher) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.
-skipanalyzers[+|-]           Skip execution of diagnostic analyzers.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-sdkpath:&lt;path&gt;         Path used to search for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
-generatedfilesout:&lt;dir&gt;      Place files generated during compilation in the
                              specified directory.
-reportivts[+|-]                    Output information on all IVTs granted to this
                              assembly by all dependencies, and annotate foreign assembly
                              accessibility errors with what assembly they came from.
</source>
        <target state="needs-review-translation">
                             Opzioni del Compilatore Visual C#

                       - FILE DI OUTPUT -
-out:&lt;file&gt;                    Specifica il nome del file di output (impostazione predefinita: nome di base di
                              file con classe principale o primo file)
-target:exe                     Consente di compilare un eseguibile della console (impostazione predefinita) (forma
                              breve: -t:exe)
-target:winexe               Crea un eseguibile di Windows (forma breve:
                              -t:winexe)
-target:library                Consente di compilare una libreria (forma breve: -t:library)
target:module               Compila un modulo che può essere aggiunto ad altro
                              assembly (forma breve: -t:module)
-target:appcontainerexe        Consente di creare un eseguibile di Appcontainer (forma breve:
                              -t:appcontainerexe)
-target:winmdobj               Consente di compilare un file intermedio Windows Runtime che
                              viene utilizzato da WinMDExp (forma breve: -t:winmdobj)
-doc:&lt;file&gt;                       Genera un file di documentazione XML per generare
-refout:&lt;file&gt;                    Output dell'assembly di riferimento da generare
-platform:&lt;string&gt;                Limita le piattaforme in cui è possibile eseguire questo codice su x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred o
                              anycpu. Il valore predefinito è anycpu.

                       - FILE DI INPUT -
-recurse:&lt;wildcard&gt;               Include tutti i file presenti nella directory corrente e
                              nelle relative sottodirectory in base alle specifiche dei
                              caratteri jolly
-reference:&lt;alias&gt;=&lt;file&gt;      Metadati di riferimento dai file di assembly specificati
                              usando l'alias specificato (forma breve: -r)
/reference:&lt;file list&gt;      Metadati di riferimento dai file di assembly
                              specificati. (Forma breve: -r)
-addmodule:&lt; list&gt;         Collega i moduli specificati in questo assembly
-link:&lt;file_list&gt;                 Incorpora metadati dai file dell'assembly di interoperabilità
                              specificato. (Forma breve: -r)
-analyzer:&lt;file_list&gt;             Esegue gli analizzatori dall'assembly
                              Forma breve: -a
-additionalfile:&lt;file list&gt;       File aggiuntivi che non influiscono direttamente sulla generazione
                              del codice ma possono essere usati dagli analizzatori per produrre
                              errori o avvisi.
-embed                        Incorpora tutti i file di origine nel file PDB portabile.
-embed:&lt;file list&gt;             Incorporare file specifici nel PDB.

                       - RISORSE -
-win32res:&lt;file&gt;              Specifica un file di risorse Win32 (.res)
-win32icon:&lt;file&gt;             Usa questa icona per l'output
-win32manifest:&lt;file&gt;          Specifica un file manifesto Win32 (con estensione xml)
-nowin32manifest             Non include il manifesto Win32 predefinito
/resource:&lt;resinfo&gt;         Incorpora la risorsa specificata. (Forma breve: -res)
-linkresource:&lt;resinfo&gt;       Collega la risorsa specificata a questo assembly
                              (Forma breve: -linkres) Dove il formato resinfo
                              è &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - GENERAZIONE DEL CODICE -
-debug[+|-]                       Crea le informazioni di debug.
-debug:{full|pdbonly|portable|embedded}
                              Specificare il tipo di debug ('full' è l'impostazione predefinita,
                              'portable' è un formato multipiattaforma,
                              'embedded' è un formato multipiattaforma incorporato in
                              DLL o EXE di destinazione.
-optimize[+|-]                Abilita le ottimizzazioni (forma breve: -o)
-deterministic                    Produce un assembly deterministico
                              (che include GUID e timestamp della versione del modulo)
-refonly                          Produce un assembly di riferimento al posto dell'output principale
-instrument:TestCoverage          Produce un assembly instrumentato per raccogliere
                              informazioni sulla copertura
-sourcelink:&lt;file&gt;                Informazioni sul collegamento all'origine da incorporare nel file PDB.

                       - ERRORI E AVVISI -
-warnaserror[+|-]                 Segnala tutti gli avvisi come errori.
-warnaserror[+|-]:&lt;warn list&gt;Segnala determinati avvisi come errori
                              (usare "nullable" per tutti gli avvisi del supporto dei valori null)
-warn:&lt;n&gt;                    Imposta il livello di avviso (0 o superiore) (forma breve: -w)
-nowarn:&lt;warn list&gt;           Disabilita messaggi di avviso specifici
                              (usare "nullable" per tutti gli avvisi del supporto dei valori null)
-ruleset:&lt;file&gt;                   Consente di specificare un file di set di regole che disabilita
                              diagnostica specifica.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Consente di specificare un file in cui registrare la diagnostica
                              del compilatore e dell'analizzatore
                              sarif_version:{1|2|2.1} L'impostazione predefinita è 1. 2 e 2.1
                              si riferiscono entrambi a SARIF versione 2.1.0.
-reportanalyzer                   Restituisce informazioni aggiuntive dell'analizzatore, ad
                              esempio il tempo di esecuzione.
-skipanalyzers[+|-]               Ignora l'esecuzione degli analizzatori diagnostici.

                       - LINGUAGGIO -
-checked[+|-]                 Generare controlli dell'overflow
-unsafe[+|-]                 Consenti codice 'non sicuro'
-define:&lt;symbol_list&gt;             Dichiara simboli di compilazione (forma
                              breve: -d)
-langversion:?                Visualizza i valori consentiti per la versione del linguaggio
-langversion:&lt;string&gt;             Consente di specificare la versione del linguaggio, ad esempio
                              `latest` (ultima versione che include versioni secondarie)
                              `default` (uguale a `latest`),
                              `latestmajor` (ultima versione che include versioni secondarie)
                              `preview` (versione più recente, incluse le funzionalità nell'anteprima non supportata),
                              o versioni specifiche come `6` o `7.1`
-nullable[+|-]                 Specificare l'opzione di contesto che ammette i valori Null enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specifica l'opzione di contesto che ammette i valori Null enable|disable|warnings|annotations.

                       - SICUREZZA -
-delaysign[+|-]                   Ritarda la firma dell'assembly usando solo la parte pubblica della
                              della chiave con nome sicuro.
-publicsign[+|-]                  Firma pubblicamente l'assembly usando solo la parte pubblica
                              della chiave con nome sicuro.
-keyfile:&lt;file&gt;                   Consente di specificare un file di chiave con nome sicuro.
-keycontainer:&lt;string&gt;            Consente di specificare un contenitore di chiavi con nome sicuro.
-highentropyva[+|-]               Abilita ASLR a entropia elevata.

                       - VARIE -
@&lt;file&gt;                       Legge il file di risposta per ulteriori opzioni
/help                       Visualizza questo messaggio relativo all'uso. La forma breve è ?
-nologo                       Non visualizza il messaggio di copyright del compilatore
-noconfig                         Non include automaticamente il file CSC.RSP.
-parallel[+|-]                    Compilazione simultanea.
-version                          Visualizza il numero di versione del compilatore ed esce.

                       - AVANZATE -
-baseaddress:&lt;address&gt;        Indirizzo di base della libreria da compilare
-checksumalgorithm:&lt;alg&gt;          Consente di specificare l'algoritmo per calcolare il checksum
                              del file di origine archiviato nel file PDB. I valori supportati sono:
                              SHA1 o SHA256 (impostazione predefinita).
-codepage:&lt;n&gt;                 Specifica la tabella codici da utilizzare per l'apertura dei file
                              di origine
-utf8output                   Messaggi del compilatore di output nella codifica UTF-8
-main:&lt;type&gt;                  Specifica il tipo contenente il punto di ingresso
                              (ignora tutti gli altri possibili punti di ingresso) (forma
                              breve: -m)
-fullpaths                     Il compilatore genera percorsi completi
-filealign:&lt;n&gt;                Consente di specificare l'allineamento usato per le sezioni del
                              file di output.
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Consente di specificare un mapping per i nomi di percorso di origine
                              visualizzati dal compilatore.
--pdb:&lt;file&gt;                   Specifica il nome del file di informazioni di debug (impostazione predefinita:
                              nome del file di output con estensione pdb)
--errorendlocation             Riga di output e colonna della posizione finale di
                              ogni di errore
-preferreduilang                  Consente di specificare il nome del linguaggio di output preferito.
-nosdkpath                        Disabilita la ricerca di assembly di librerie standard nel percorso predefinito dell'SDK.
-nostdlib[+|-]                 Omette i riferimenti alle librerie standard (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Consente di specificare la versione dell'assembly
-lib:&lt;file list&gt;               Specifica directory aggiuntive in cui cercare
                              riferimenti
-errorreport:&lt;string&gt;         Consente di specificare come gestire gli errori interni del compilatore:
                              prompt, invio, coda o nessuno. L'impostazione predefinita è
                              coda.
-appconfig:&lt;file&gt;             Specifica un file di configurazione dell'applicazione
                              contenente le impostazioni di associazione dell'assembly
-moduleassemblyname:&lt;string&gt;  Nome dell'assembly di cui farà parte questo
                              modulo
-modulename:&lt;string&gt;           Specifica il nome del modulo di origine
-generatedfilesout:&lt;dir&gt;          Inserisce i file generati durante la compilazione nella
                              directory specificata.
-reportivts[+|-]                  Restituisce informazioni su tutti i tipi di I/O concessi a questo
                              assembly da tutte le dipendenze e annota gli errori di accessibilità dell'assembly esterno
                              da cui provengono.
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">implementazione di interfaccia predefinita</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">disposable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">stringhe verbatim interpolate alternative</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAndPattern">
        <source>and pattern</source>
        <target state="translated">criterio and</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">using asincrono</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">assegnazione di coalescenza</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureConstantInterpolatedStrings">
        <source>constant interpolated strings</source>
        <target state="translated">stringhe interpolate costanti</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultTypeParameterConstraint">
        <source>default type parameter constraints</source>
        <target state="translated">vincoli di parametro di tipo predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">vincoli di tipo generico delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">vincoli di tipo generico enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">dichiarazione di variabili di espressione in query e inizializzatori di membri</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtendedPartialMethods">
        <source>extended partial methods</source>
        <target state="translated">metodi parziali estesi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">istruzione fixed estendibile</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetAsyncEnumerator">
        <source>extension GetAsyncEnumerator</source>
        <target state="translated">GetAsyncEnumerator dell'estensione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionGetEnumerator">
        <source>extension GetEnumerator</source>
        <target state="translated">GetEnumerator dell'estensione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="translated">funzioni locali extern</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFunctionPointers">
        <source>function pointers</source>
        <target state="translated">puntatori a funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">operatore di indice</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">indicizzazione di buffer fissi mobili</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInitOnlySetters">
        <source>init-only setters</source>
        <target state="translated">setter di sola inizializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="translated">attributi di funzione locale</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">parametri di rimozione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureMemberNotNull">
        <source>MemberNotNull attribute</source>
        <target state="translated">Attributo MemberNotNull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleInitializers">
        <source>module initializers</source>
        <target state="translated">inizializzatori di modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">shadowing dei nomi nelle funzioni annidate</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNativeInt">
        <source>native-sized integers</source>
        <target state="translated">Integer di dimensioni native</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">stackalloc in espressioni annidate</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">vincolo di tipo generico notnull</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotPattern">
        <source>not pattern</source>
        <target state="translated">criterio not</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPointerConstantPattern">
        <source>null pointer constant pattern</source>
        <target state="translated">criterio per costante puntatore Null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">tipi riferimento nullable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">funzionalità obsoleta nella funzione di accesso proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOrPattern">
        <source>or pattern</source>
        <target state="translated">criterio or</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureParenthesizedPattern">
        <source>parenthesized pattern</source>
        <target state="translated">criterio tra parentesi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">azione di avviso enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">operatore di intervallo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">membri readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecords">
        <source>records</source>
        <target state="translated">record</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">criteri ricorsivi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">espressione condizionale ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">variabili ciclo for ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">variabili di iterazione foreach ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">riassegnazione ref</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRelationalPattern">
        <source>relational pattern</source>
        <target state="translated">criterio relazionale</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">inizializzatore stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticAnonymousFunction">
        <source>static anonymous function</source>
        <target state="translated">funzione anonima statica</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">funzioni locali statiche</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;espressione switch&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTargetTypedConditional">
        <source>target-typed conditional expression</source>
        <target state="translated">espressione condizionale con tipo di destinazione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">uguaglianza tuple</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypePattern">
        <source>type pattern</source>
        <target state="translated">criterio di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">parametri di tipo senza vincoli nell'operatore Null di coalescenza</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">tipi costruiti non gestiti</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">vincoli di tipo generico unmanaged</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">dichiarazioni using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
        <source>variance safety for static interface members</source>
        <target state="translated">sicurezza della varianza per i membri di interfaccia statici</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">vincoli per i metodi di override e di implementazione esplicita dell'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Parameter">
        <source>parameter</source>
        <target state="translated">parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Return">
        <source>return</source>
        <target state="translated">restituito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;espressione throw&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(Posizione del simbolo relativo all'errore precedente)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(Posizione del simbolo relativo all'avviso precedente)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TopLevelStatements">
        <source>top-level statements</source>
        <target state="translated">istruzioni di primo livello</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> Il formato XML non è valido. Non è possibile includere il file "{0}" </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> Non è stato possibile inserire alcuni o tutti gli XML inclusi </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Il tag di inclusione non è valido </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> Elemento corrispondente non trovato per il seguente tag di inclusione </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">Manca l'attributo file</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">Manca l'attributo path</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;spazio dei nomi globale&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">generics</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">metodi anonimi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">modulo come un identificatore di destinazione dell'attributo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">qualificatore di alias dello spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">buffer a dimensione fissa</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">classi statiche</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">struct di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">tipi parziali</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">funzione asincrona</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">opzione su tipo booleano</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">gruppo di metodi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">metodo anonimo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">raccolta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">modificatori di accesso sulle proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">alias extern</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">iteratori</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">operatore predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">valore letterale predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">tipi nullable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">criteri di ricerca</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">funzione di accesso alla proprietà del corpo dell'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">costruttore e decostruttore del corpo dell'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">espressione throw</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">matrice tipizzata in modo implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">variabile locale tipizzata in modo implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">tipi anonimi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">proprietà implementate automaticamente</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">proprietà implementate automaticamente di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">inizializzatore di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">inizializzatore di raccolta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">espressione di query</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">metodo di estensione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">metodo parziale</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">campo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">elemento</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">etichetta</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">evento</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">Using Alias</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">alias extern</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">costruttore</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">variabile di iterazione foreach</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">variabile fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">variabile using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">controvariante</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">in controvarianza</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">covariante</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">in covarianza</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">in invarianza</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">dinamico</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">argomento denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">parametro facoltativo</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">filtro eccezioni</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">varianza dei tipi</target>
        <note />
      </trans-unit>
      <trans-unit id="NotSameNumberParameterTypesAndRefKinds">
        <source>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</source>
        <target state="translated">Sono stati specificati {0} tipi di parametro e {1} tipi di modificatore ref di parametro. Queste matrici devono avere la stessa lunghezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutIsNotValidForReturn">
        <source>'RefKind.Out' is not a valid ref kind for a return type.</source>
        <target state="translated">'RefKind.Out' non è un tipo di modificatore ref valido per un tipo restituito.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">L'elemento SyntaxTree non fa parte della compilazione</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">L'elemento SyntaxTree non fa parte della compilazione, di conseguenza non può essere rimosso</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">Il nome '_' fa riferimento alla costante e non al criterio di eliminazione. Usare 'var _' per eliminare il valore oppure '@_' per fare riferimento a una costante in base a tale nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">Non usare '_' per una costante di case.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked">
        <source>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Con il valore di costante '{0}' può verificarsi un overflow di '{1}' in fase di esecuzione. Usare la sintassi 'unchecked' per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstOutOfRangeChecked_Title">
        <source>Constant value may overflow at runtime (use 'unchecked' syntax to override)</source>
        <target state="translated">Con il valore di costante può verificarsi un overflow in fase di esecuzione. Usare la sintassi 'unchecked' per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Conversione del valore letterale Null o di un possibile valore Null in un tipo che non ammette i valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">Conversione del valore letterale Null o di un possibile valore Null in un tipo che non ammette i valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Un possibile valore Null non può essere usato per un tipo contrassegnato con [NotNull] o [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">Un possibile valore Null non può essere usato per un tipo contrassegnato con [NotNull] o [DisallowNull]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">Nel metodo '{0}' manca l'annotazione `[DoesNotReturn]` per la corrispondenza del membro implementato o di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="translated">Nel metodo manca l'annotazione `[DoesNotReturn]` per la corrispondenza del membro implementato o di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">'{0}' è già inclusa nell'elenco di interfacce nel tipo '{1}' con diverso supporto dei valori Null per i tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">L'interfaccia è già inclusa nell'elenco di interfacce con diverso supporto dei valori Null per i tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Il generatore '{0}' non è riuscito a generare l'origine. Non contribuirà quindi all'output ed è possibile che si verifichino errori di compilazione. Eccezione di tipo '{1}' con messaggio '{2}'.
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">Il generatore non è riuscito a generare l'origine.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'.
{3}</source>
        <target state="translated">Non è stato possibile inizializzare il generatore '{0}'. Non contribuirà quindi all'output ed è possibile che si verifichino errori di compilazione. Eccezione di tipo '{1}' con messaggio '{2}'.
{3}</target>
        <note>{0} is the name of the generator that failed.
{1} is the type of exception that was thrown.
{2} is the message in the exception.
{3} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">Non è stato possibile inizializzare il generatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">L'espressione specificata corrisponde sempre alla costante fornita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">L'espressione specificata corrisponde sempre alla costante fornita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">L'espressione specificata corrisponde sempre al criterio specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesPattern_Title">
        <source>The given expression always matches the provided pattern.</source>
        <target state="translated">L'espressione specificata corrisponde sempre al criterio specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">L'espressione specificata non corrisponde mai al criterio fornito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">L'espressione specificata non corrisponde mai al criterio fornito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">La chiamata a un membro '{0}' non readonly da un membro 'readonly' comporta una copia esplicita di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">La chiamata a un membro non readonly da un membro 'readonly' comporta una copia esplicita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways">
        <source>An expression of type '{0}' always matches the provided pattern.</source>
        <target state="translated">Un'espressione di tipo '{0}' corrisponde sempre al criterio specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsPatternAlways_Title">
        <source>The input always matches the provided pattern.</source>
        <target state="translated">L'input corrisponde sempre al criterio specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">Il nome '_' fa riferimento al tipo '{0}' e non al criterio di eliminazione. Usare '@_' per il tipo oppure 'var _' per eliminare.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">Non usare '_' per fare riferimento al tipo in un'espressione is-type.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull">
        <source>Member '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Il membro '{0}' deve avere un valore non Null quando viene terminato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember">
        <source>Member '{0}' cannot be used in this attribute.</source>
        <target state="translated">Non è possibile usare il membro '{0}' in questo attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullBadMember_Title">
        <source>Member cannot be used in this attribute.</source>
        <target state="translated">Non è possibile usare il membro in questo attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen">
        <source>Member '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Il membro '{0}' deve avere un valore non Null quando viene terminato con '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNullWhen_Title">
        <source>Member must have a non-null value when exiting in some condition.</source>
        <target state="translated">Il membro deve avere un valore non Null quando viene terminato in determinate condizioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberNotNull_Title">
        <source>Member must have a non-null value when exiting.</source>
        <target state="translated">Il membro deve avere un valore non Null quando viene terminato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">L'annotazione per i tipi riferimento nullable deve essere usata solo nel codice in un contesto di annotations '#nullable'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">L'annotazione per i tipi riferimento nullable deve essere usata solo nel codice all'interno di un contesto di annotazioni '#nullable'. Il codice generato automaticamente richiede una direttiva '#nullable' esplicita nell'origine.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">L'annotazione per i tipi riferimento nullable deve essere usata solo nel codice all'interno di un contesto di annotazioni '#nullable'. Il codice generato automaticamente richiede una direttiva '#nullable' esplicita nell'origine.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">L'annotazione per i tipi riferimento nullable deve essere usata solo nel codice in un contesto di annotations '#nullable'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Non è possibile convertire il valore letterale Null in tipo riferimento che non ammette i valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Non è possibile convertire il valore letterale Null in tipo riferimento che non ammette i valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">Possibile argomento di riferimento Null per il parametro '{0}' in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">Possibile argomento di riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">Possibile assegnazione di riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">Possibile assegnazione di riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">L'inizializzatore di oggetto o di raccolta dereferenzia in modo implicito il membro Null '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">L'inizializzatore di oggetto o di raccolta dereferenzia in modo implicito il membro Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Dereferenziamento di un possibile riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">Dereferenziamento di un possibile riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">Possibile restituzione di riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">Possibile restituzione di riferimento Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Non è possibile usare l'argomento di tipo '{0}' per il parametro '{2}' di tipo '{1}' in '{3}' a causa delle differenze nel supporto dei valori Null dei tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">Non è possibile usare l'argomento di tipo '{0}' come output del tipo '{1}' per il parametro '{2}' in '{3}' a causa delle differenze nel supporto dei valori Null dei tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Non è possibile usare l'argomento come output per il parametro a causa delle differenze nel supporto dei valori Null dei tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">Non è possibile usare l'argomento per il parametro a causa delle differenze nel supporto dei valori Null dei tipi riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel valore di tipo '{0}' non corrisponde al tipo di destinazione '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel valore non corrisponde al tipo di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">Il supporto dei valori Null nei vincoli per il parametro di tipo '{0}' del metodo '{1}' non corrisponde ai vincoli per il parametro di tipo '{2}' del metodo di interfaccia '{3}'. Provare a usare un'implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">Il supporto dei valori Null nei vincoli del parametro di tipo non corrisponde ai vincoli per il parametro di tipo nel metodo di interfaccia implementato in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">Le dichiarazioni di metodo parziali di '{0}' contengono un supporto dei valori Null incoerente nei vincoli per il parametro di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">Le dichiarazioni di metodo parziali contengono un supporto dei valori Null incoerente nei vincoli per il parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nell'identificatore di interfaccia esplicito non corrisponde all'interfaccia implementata dal tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nell'identificatore di interfaccia esplicito non corrisponde all'interfaccia implementata dal tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. Il supporto dei valori Null dei tipi riferimento nell'interfaccia implementata dal tipo di base non corrisponde.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">Il tipo non implementa il membro di interfaccia. Il supporto dei valori Null dei tipi riferimento nell'interfaccia implementata dal tipo di base non corrisponde.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' di '{1}' non corrisponde al delegato di destinazione '{2}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al delegato di destinazione, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' non corrisponde al membro implementato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al membro implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' di '{1}' non corrisponde al membro implementato in modo implicito '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al membro implementato in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' non corrisponde alla dichiarazione di metodo parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde alla dichiarazione di metodo parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito di '{0}' non corrisponde al delegato di destinazione '{1}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al delegato di destinazione, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito di '{0}' non corrisponde al membro implementato in modo implicito '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde alla dichiarazione di metodo parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
        <source>Nullability of reference types in return type doesn't match partial method declaration.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde alla dichiarazione di metodo parziale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo non corrisponde al membro implementato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo non corrisponde al membro implementato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di '{0}' non corrisponde al membro implementato in modo implicito '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo non corrisponde al membro implementato in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo non corrisponde al membro di cui è stato eseguito l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel metodo o nel tipo generico '{0}'. Il supporto dei valori Null dell'argomento di tipo '{3}' non corrisponde al tipo di vincolo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">Non è possibile usare il tipo come parametro di tipo nel tipo generico o nel metodo. Il supporto dei valori Null dell'argomento tipo non corrisponde al tipo di vincolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">Non è possibile usare il tipo '{2}' come parametro di tipo '{1}' nel tipo generico o nel metodo '{0}'. Il supporto dei valori Null dell'argomento tipo '{2}' non corrisponde al vincolo 'notnull'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">Non è possibile usare il tipo come parametro di tipo nel tipo generico o nel metodo. Il supporto dei valori Null dell'argomento tipo non corrisponde al vincolo 'notnull'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">Non è possibile usare il tipo '{2}' come parametro di tipo '{1}' nel tipo generico o nel metodo '{0}'. Il supporto dei valori Null dell'argomento tipo '{2}' non corrisponde al vincolo 'class'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">Non è possibile usare il tipo come parametro di tipo nel tipo generico o nel metodo. Il supporto dei valori Null dell'argomento tipo non corrisponde al vincolo 'class'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Il tipo valore nullable non può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Il tipo valore nullable non può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">Il parametro out '{0}' deve essere assegnato prima che il controllo lasci il metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamUnassigned_Title">
        <source>An out parameter must be assigned to before control leaves the method</source>
        <target state="translated">È necessario assegnare un parametro out prima che il controllo esca dal metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting with '{1}'.</source>
        <target state="translated">Il parametro '{0}' deve avere un valore non Null quando viene terminato con '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting in some condition.</source>
        <target state="translated">Il parametro deve avere un valore non Null quando viene terminato in determinate condizioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull">
        <source>Parameter '{0}' must have a non-null value when exiting.</source>
        <target state="translated">Il parametro '{0}' deve avere un valore non Null quando viene terminato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterDisallowsNull_Title">
        <source>Parameter must have a non-null value when exiting.</source>
        <target state="translated">Il parametro deve avere un valore non Null quando viene terminato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': i tipi statici non possono essere usati come parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterIsStaticClass_Title">
        <source>Static types cannot be used as parameters</source>
        <target state="translated">I tipi statici non possono essere usati come parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion">
        <source>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</source>
        <target state="translated">A causa della precedenza, non è possibile usare l'operatore '{0}' in questo punto. Usare le parentesi per evitare ambiguità.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrecedenceInversion_Title">
        <source>Operator cannot be used here due to precedence.</source>
        <target state="translated">A causa della precedenza, non è possibile usare l'operatore in questo punto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</source>
        <target state="translated">'{0}' non implementa il criterio '{1}'. '{2}' non è un metodo di estensione o istanza pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternNotPublicOrNotInstance_Title">
        <source>Type does not implement the collection pattern; member is is not a public instance or extension method.</source>
        <target state="translated">Il tipo non implementa il criterio di raccolta. Il membro non è un metodo di estensione o istanza pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': i tipi statici non possono essere usati come tipi restituiti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeIsStaticClass_Title">
        <source>Static types cannot be used as return types</source>
        <target state="translated">I tipi statici non possono essere usati come tipi restituiti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Un metodo contrassegnato con [DoesNotReturn] non deve essere terminare normalmente.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">Un metodo contrassegnato con [DoesNotReturn] non deve essere terminare normalmente.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">Il secondo operando di un operatore 'is' o 'as' non può essere di tipo statico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticInAsOrIs_Title">
        <source>The second operand of an 'is' or 'as' operator may not be a static type</source>
        <target state="translated">Il secondo operando di un operatore 'is' o 'as' non può essere un tipo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">L'espressione switch non gestisce tutti i possibili valori del relativo tipo di input (non è esaustiva). Ad esempio, il criterio '{0}' non è coperto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</source>
        <target state="translated">L'espressione switch non gestisce alcuni input Null (non è esaustiva). Ad esempio, il criterio '{0}' non è coperto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
        <source>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">L'espressione switch non gestisce alcuni input Null (non è esaustiva). Ad esempio, il criterio '{0}' non è coperto. Un criterio con una clausola 'when' potrebbe però corrispondere a questo valore.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">L'espressione switch non gestisce alcuni input Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">L'espressione switch non gestisce alcuni input Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</source>
        <target state="translated">L'espressione switch non gestisce tutti i possibili valori del relativo tipo di input (non è esaustiva). Ad esempio, il criterio '{0}' non è coperto. Un criterio con una clausola 'when' potrebbe però corrispondere a questo valore.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">L'espressione switch non gestisce tutti i possibili valori del relativo tipo di input (non è esaustiva).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">L'espressione switch non gestisce tutti i possibili valori del relativo tipo di input (non è esaustiva).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness">
        <source>Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro '{0}' non corrisponde al parametro corrispondente '{1}' nella destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TargetDifferentRefness_Title">
        <source>Reference kind modifier of parameter doesn't match the corresponding parameter in target.</source>
        <target state="translated">Il modificatore del tipo di riferimento del parametro non corrisponde al parametro corrispondente nella destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">Il valore generato può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">Il valore generato può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' non corrisponde al membro implementato '{1}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al membro implementato, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro '{0}' di '{1}' non corrisponde al membro implementato in modo implicito '{2}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo di parametro non corrisponde al membro implementato in modo implicito, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null del tipo del parametro '{0}' non corrisponde al membro di cui è stato eseguito l'override, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null del tipo del parametro non corrisponde al membro di cui è stato eseguito l'override, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato '{0}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito di '{0}' non corrisponde al membro implementato in modo implicito '{1}', probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null dei tipi riferimento nel tipo restituito non corrisponde al membro implementato in modo implicito, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null del tipo restituito non corrisponde al membro di cui è stato eseguito l'override, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</source>
        <target state="translated">Il supporto dei valori Null del tipo restituito non corrisponde al membro di cui è stato eseguito l'override, probabilmente a causa degli attributi del supporto dei valori Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Il nome dell'elemento di tupla '{0}' viene ignorato perché nell'altra parte dell'operatore == o != di tupla è specificato un nome diverso o non è specificato alcun nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">Il nome dell'elemento di tupla viene ignorato perché nell'altra parte dell'operatore == o != di tupla è specificato un nome diverso o non è specificato alcun nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">Il nome del parametro di tipo '{0}' è uguale a quello del parametro di tipo del metodo esterno '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">Il tipo del parametro di tipo è lo stesso del parametro di tipo del metodo esterno.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalRefField">
        <source>Field '{0}' is never ref-assigned to, and will always have its default value (null reference)</source>
        <target state="translated">Il campo '{0}' non è mai assegnato come riferimento e avrà sempre il valore predefinito (riferimento Null)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalRefField_Title">
        <source>Field is never ref-assigned to, and will always have its default value (null reference)</source>
        <target state="translated">Il campo non è mai assegnato come riferimento e avrà sempre il valore predefinito (riferimento Null)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion">
        <source>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il controllo viene restituito al chiamante prima che la proprietà implementata automaticamente '{0}' sia assegnata in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertySupportedVersion_Title">
        <source>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il controllo viene restituito al chiamante prima che la proprietà implementata automaticamente sia assegnata in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">La proprietà implementata automaticamente '{0}' deve essere assegnata completamente prima che il controllo sia restituito al chiamante. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
        <source>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Una proprietà implementata automaticamente deve essere assegnata completamente prima che il controllo sia restituito al chiamante. Provare ad aggiornare la versione del linguaggio per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion">
        <source>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il controllo viene restituito al chiamante prima che il campo '{0}' sia assegnato in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisSupportedVersion_Title">
        <source>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il controllo viene restituito al chiamante prima che il campo sia assegnato in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion">
        <source>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Il campo '{0}' deve essere assegnato completamente prima che il controllo sia restituito al chiamante. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedThisUnsupportedVersion_Title">
        <source>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</source>
        <target state="translated">I campi di uno struct devono essere completamente assegnati in un costruttore prima che il controllo sia restituito al chiamante. Provare ad aggiornare la versione del linguaggio per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Conversione unboxing di un possibile valore Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">Conversione unboxing di un possibile valore Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">L'attributo EnumeratorCancellationAttribute applicato al parametro '{0}' non avrà alcun effetto. L'attributo ha effetto solo su un parametro di tipo CancellationToken in un metodo di iteratore asincrono che restituisce IAsyncEnumerable</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">L'attributo EnumeratorCancellationAttribute non avrà alcun effetto. L'attributo ha effetto solo su un parametro di tipo CancellationToken in un metodo di iteratore asincrono che restituisce IAsyncEnumerable</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">L'elemento '{0}' di iteratore asincrono include uno o più parametri di tipo 'CancellationToken', ma nessuno di essi è decorato con l'attributo 'EnumeratorCancellation', di conseguenza il parametro del token di annullamento restituito dall'elemento 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' generato non verrà utilizzato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">Il membro di iteratore asincrono include uno o più parametri di tipo 'CancellationToken', ma nessuno di essi è decorato con l'attributo 'EnumeratorCancellation', di conseguenza il parametro del token di annullamento restituito dall'elemento 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' generato non verrà utilizzato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableBackingField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier, or declaring the {0} as nullable, or safely handling the case where 'field' is null in the 'get' accessor.</source>
        <target state="translated">L'elemento {0} '{1}' che non ammette i valori Null deve contenere un valore non Null all'uscita dal costruttore. Prendere in considerazione l'aggiunta del modificatore 'required' o la dichiarazione come {0} che ammette i valori Null, oppure l'aggiunta di attributi '[field: MaybeNull, AllowNull]'.</target>
        <note>Similar diagnostic message as 'WRN_UninitializedNonNullableField'</note>
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableBackingField_Title">
        <source>Non-nullable property must contain a non-null value when exiting constructor. Consider adding the 'required' modifier, or declaring the property as nullable, or safely handling the case where 'field' is null in the 'get' accessor.</source>
        <target state="translated">La proprietà che non ammette i valori Null deve contenere un valore non Null all'uscita dal costruttore. Provare ad aggiungere il modificatore 'required', a dichiarare la proprietà come che ammette i valori Null, oppure ad aggiungere gli attributi '[field: MaybeNull, AllowNull]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring the {0} as nullable.</source>
        <target state="translated">L'elemento {0} '{1}' non nullable deve contenere un valore non Null all'uscita dal costruttore. Prendere in considerazione l'aggiunta del modificatore 'required' o la dichiarazione di {0} come nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.</source>
        <target state="translated">Il campo non nullable deve contenere un valore non Null all'uscita dal costruttore. Prendere in considerazione l'aggiunta del modificatore 'required' o la dichiarazione come nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter">
        <source>Parameter '{0}' is unread.</source>
        <target state="translated">Il parametro '{0}' non è stato letto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadPrimaryConstructorParameter_Title">
        <source>Parameter is unread.</source>
        <target state="translated">Il parametro non è stato letto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter">
        <source>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Il parametro '{0}' non è stato letto. Si è dimenticato di usarlo per inizializzare la proprietà con tale nome?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreadRecordParameter_Title">
        <source>Parameter is unread. Did you forget to use it to initialize the property with that name?</source>
        <target state="translated">Il parametro non è stato letto. Si è dimenticato di usarlo per inizializzare la proprietà con tale nome?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnscopedRefAttributeOldRules">
        <source>UnscopedRefAttribute is only valid in C# 11 or later or when targeting net7.0 or later.</source>
        <target state="translated">UnscopedRefAttribute è valido solo in C# 11 o versioni successive o se destinato a net7.0 o versione successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnscopedRefAttributeOldRules_Title">
        <source>UnscopedRefAttribute is only valid in C# 11 or later or when targeting net7.0 or later.</source>
        <target state="translated">UnscopedRefAttribute è valido solo in C# 11 o versioni successive o se destinato a net7.0 o versione successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Uso della variabile locale '{0}' non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Uso del campo '{0}' probabilmente non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion">
        <source>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il campo '{0}' viene letto prima di essere assegnato in modo esplicito, determinando un’assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldSupportedVersion_Title">
        <source>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">Il campo viene letto prima di essere assegnato in modo esplicito, determinando un’assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion">
        <source>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</source>
        <target state="translated">Uso del campo probabilmente non assegnato '{0}'. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationFieldUnsupportedVersion_Title">
        <source>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</source>
        <target state="translated">Uso di un campo probabilmente non assegnato. Provare ad aggiornare la versione della lingua per impostare automaticamente il campo come predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationField_Title">
        <source>Use of possibly unassigned field</source>
        <target state="translated">Uso del campo probabilmente non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Uso del parametro out '{0}' non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationOut_Title">
        <source>Use of unassigned out parameter</source>
        <target state="translated">Uso del parametro out non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Uso della proprietà implementata automaticamente '{0}' probabilmente non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion">
        <source>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">La proprietà implementata automaticamente '{0}' viene letta prima di essere assegnata in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertySupportedVersion_Title">
        <source>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</source>
        <target state="translated">La proprietà implementata automaticamente viene letta prima di essere assegnata in modo esplicito, determinando un'assegnazione implicita precedente di 'default'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion">
        <source>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</source>
        <target state="translated">Utilizzo della proprietà implementata automaticamente probabilmente non assegnata '{0}'. Provare a eseguire l'aggiornamento alla versione del linguaggio '{1}' per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationPropertyUnsupportedVersion_Title">
        <source>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</source>
        <target state="translated">Utilizzo di proprietà implementata automaticamente probabilmente non assegnata. Provare ad aggiornare la versione del linguaggio per impostare automaticamente la proprietà come predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationProperty_Title">
        <source>Use of possibly unassigned auto-implemented property</source>
        <target state="translated">Uso della proprietà implementata automaticamente probabilmente non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField">
        <source>Ref field '{0}' should be ref-assigned before use.</source>
        <target state="translated">Il campo ref '{0}' deve essere assegnato come riferimento prima dell'uso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationRefField_Title">
        <source>Ref field should be ref-assigned before use.</source>
        <target state="translated">Il campo ref deve essere assegnato come riferimento prima dell'uso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">L'oggetto 'this' viene letto prima che tutti i relativi campi siano stati assegnati, determinando le assegnazioni implicite precedenti di 'default' ai campi non esplicitamente assegnati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisSupportedVersion_Title">
        <source>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</source>
        <target state="translated">L'oggetto 'this' viene letto prima che tutti i relativi campi siano stati assegnati, determinando le assegnazioni implicite precedenti di 'default' ai campi non esplicitamente assegnati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion">
        <source>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</source>
        <target state="translated">Impossibile utilizzare l'oggetto 'this' prima dell'assegnazione di tutti i relativi campi. Provare a eseguire l'aggiornamento alla versione del linguaggio '{0}' per impostare come predefiniti automaticamente i campi non assegnati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolationThisUnsupportedVersion_Title">
        <source>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</source>
        <target state="translated">Impossibile utilizzare l'oggetto 'this' in un costruttore prima che siano stati assegnati tutti i suoi campi. Provare ad aggiornare la versione del linguaggio per impostare automaticamente come predefiniti i campi non assegnati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseDefViolation_Title">
        <source>Use of unassigned local variable</source>
        <target state="translated">Uso della variabile locale non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}' viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WindowsExperimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">Type viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">Non è possibile usare il carattere o i caratteri '{0}' in questa posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">In un commento è stato usata sintassi errata.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">All'interno di un riferimento di entità è stato trovato un carattere non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">È previsto '&gt;' o '/&gt;' come tag di chiusura '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">Era previsto un identificatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">Il carattere Unicode non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">Lo spazio vuoto non è consentito in questa posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">Non è possibile usare il carattere '&lt;' in un valore di attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">Manca il segno di uguale tra l'attributo e il valore di attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">Riferimento a un'entità '{0}' non definita.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">Era previsto un valore letterale di tipo stringa, ma non sono state trovate virgolette inglesi aperte.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">Mancano le virgolette inglesi chiuse per il valore letterale di tipo stringa.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">Non è possibile usare virgolette non ASCII per racchiudere valori letterali di tipo stringa.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">Il tag finale non era previsto in questa posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">Il tag finale '{0}' non corrisponde al tag iniziale '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">È previsto un tag finale per l'elemento '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">Manca lo spazio vuoto obbligatorio.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">Il carattere non è previsto in questa posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">La stringa letterale ']]&gt;' non è consentita nel contenuto dell'elemento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">L'attributo '{0}' è duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">Il file di metadati '{0}' non è stato trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">I riferimenti ai metadati non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">Non è possibile aprire il file di metadati '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Il tipo '{0}' è definito in un assembly di cui manca il riferimento. Aggiungere un riferimento all'assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">Il tipo '{0}' è definito in un modulo che non è stato ancora aggiunto. È necessario aggiungere il modulo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">Non è possibile scrivere nel file di output '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">Nel programma è definito più di un punto di ingresso. Compilare con /main per specificare il tipo contenente il punto di ingresso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">Non è possibile applicare l'operatore '{0}' a operandi di tipo '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">Divisione per la costante zero</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">Non è possibile applicare l'indicizzazione con [] a un'espressione di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">Il numero di indici in [] è errato. Il numero previsto è {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">Non è possibile applicare l'operatore '{0}' all'operando di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">La parola chiave 'this' non può essere utilizzata in una proprietà statica, in un metodo statico o nell'inizializzatore di un campo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">La parola chiave 'this' non è disponibile nel contesto corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'{0}' non può essere un punto di ingresso perché la firma è errata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">Il metodo non può essere un punto di ingresso perché la firma è errata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">Non è possibile convertire in modo implicito il tipo '{0}' in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">Non è possibile convertire il tipo '{0}' in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">Non è possibile convertire il valore costante '{0}' in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">L'operatore '{0}' è ambiguo su operandi di tipo '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">L'operatore '{0}' è ambiguo su un operando di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">Un parametro out non può avere l'attributo In</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">Non è possibile convertire Null in '{0}' perché è un tipo valore che non ammette i valori Null</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">Non è possibile convertire il tipo '{0}' in '{1}' tramite una conversione di riferimenti, una conversione boxing, una conversione unboxing, una conversione wrapping o una conversione del tipo Null</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">Si è verificato un errore imprevisto durante la scrittura delle informazioni di debug - '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo restituito '{1}' è meno accessibile del metodo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo parametro '{1}' è meno accessibile del metodo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo di campo '{1}' è meno accessibile del campo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo di proprietà '{1}' è meno accessibile della proprietà '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo di indicizzatore restituito '{1}' è meno accessibile dell'indicizzatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer or property '{0}'</source>
        <target state="needs-review-translation">Accessibilità incoerente: il tipo parametro '{1}' è meno accessibile dell'indicizzatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo restituito '{1}' è meno accessibile dell'operatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo parametro '{1}' è meno accessibile dell'operatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo restituito '{1}' è meno accessibile del delegato '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo parametro '{1}' è meno accessibile del delegato '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">Accessibilità incoerente: la classe base '{1}' è meno accessibile della classe '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">Accessibilità incoerente: l'interfaccia di base '{1}' è meno accessibile dell'interfaccia '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': la proprietà dell'evento deve avere entrambe le funzioni di accesso add e remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'{0}': l'evento deve essere di un tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">L'evento '{0}' non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">L'evento non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'{0}': l'evento di istanza nell'interfaccia non può avere inizializzatori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">L'evento '{0}' può essere specificato solo sul lato sinistro di += o di -= (tranne quando è usato dall'interno del tipo '{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">Per l'implementazione esplicita dell'interfaccia di un evento è necessario utilizzare la sintassi della funzione di accesso agli eventi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'{0}': non è possibile eseguire l'override. '{1}' non è un evento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">Una funzione di accesso add o remove deve avere un corpo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'{0}': l'evento astratto non può avere inizializzatori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">Il nome di assembly '{0}' è riservato e non può essere usato come riferimento in una sessione interattiva</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">Il nome dell'enumeratore '{0}' è riservato e non può essere usato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">L'operatore as deve essere usato con un tipo riferimento o con un tipo che ammette i valori Null ('{0}' è un tipo valore che non ammette i valori Null)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">Il suffisso 'l' è facilmente confondibile con il numero '1': per maggiore chiarezza utilizzare 'L'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">Il suffisso 'l' è facilmente confondibile con il numero '1'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">L'evento '{0}' può essere specificato solo sul lato sinistro di += o di -=</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">Vincoli non consentiti su dichiarazioni non generiche</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">La dichiarazione del parametro di tipo deve essere un identificatore anziché un tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">Il tipo '{1}' riserva già un membro denominato '{0}' con gli stessi tipi di parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">Il nome di parametro '{0}' è un duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">Lo spazio dei nomi '{1}' contiene già una definizione per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">Il tipo '{0}' contiene già una definizione per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">Il nome '{0}' non esiste nel contesto corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">Il nome '{0}' non esiste nel contesto corrente. Probabilmente manca un riferimento all'assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'{0}' è un riferimento ambiguo tra '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">La direttiva using per '{0}' è già presente in questo spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">La direttiva using è già presente in questo spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">Il modificatore '{0}' non è valido per questo elemento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">Sono presenti più modificatori di protezione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'{0}' nasconde il membro ereditato '{1}'. Se questo comportamento è intenzionale, usare la parola chiave new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">Il membro nasconde il membro ereditato. Manca la parola chiave new</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">È stata dichiarata una variabile con lo stesso nome di una variabile in un tipo di base, tuttavia non è stata usata la parola chiave new. Questo avviso informa l'utente che è necessario usare new. La variabile viene dichiarata come se nella dichiarazione fosse stata usata la parola chiave new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">Il membro '{0}' non nasconde un membro accessibile. La parola chiave new non è obbligatoria.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">Il membro non nasconde un membro ereditato. La parola chiave new non è obbligatoria</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">La valutazione del valore della costante per '{0}' implica una definizione circolare</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">Il tipo '{1}' definisce già un membro denominato '{0}' con gli stessi tipi di parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member cannot be marked as '{0}'</source>
        <target state="translated">Un membro statico non può essere contrassegnato come '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">Un membro '{0}' contrassegnato come override non può essere contrassegnato come new o virtual</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'{0}' nasconde il membro ereditato '{1}'. Per consentire al membro corrente di eseguire l'override di tale implementazione, aggiungere la parola chiave override; altrimenti aggiungere la parola chiave new.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">Il membro nasconde il membro ereditato. Manca la parola chiave override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'{0}': non sono stati trovati metodi appropriati per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields, methods or statements</source>
        <target state="translated">Uno spazio dei nomi non può contenere direttamente membri come campi, metodi o istruzioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'{0}' non contiene una definizione per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'{0}' è {1} ma è usato come {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'{0}' è un '{1}', che non è un costrutto valido nel contesto specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">È necessario un riferimento all'oggetto per la proprietà, il metodo o il campo non statico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">La chiamata è ambigua tra i seguenti metodi o proprietà: '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'{0}' non è accessibile a causa del livello di protezione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">Nessun overload per '{0}' corrisponde al delegato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">È necessario un oggetto di un tipo convertibile in '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">Poiché '{0}' restituisce un valore nullo, una parola chiave di restituzione non deve essere seguita da un'espressione di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">In questo ambito è già definita una funzione o una variabile locale denominata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">La parte sinistra di un'assegnazione deve essere una variabile, una proprietà o un indicizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'{0}': un costruttore statico non deve avere parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">L'espressione da assegnare a '{0}' deve essere costante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'{0}' è di tipo '{1}'. Il campo const di un tipo riferimento diverso da stringa può essere inizializzato solo con Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">Non è possibile dichiarare in questo ambito una variabile locale o un parametro denominato '{0}' perché tale nome viene usato in un ambito locale di inclusione per definire una variabile locale o un parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">Una direttiva using dello spazio dei nomi può essere applicata solo a spazi dei nomi. '{0}' è un tipo, non uno spazio dei nomi. Provare a usare una direttiva 'using static'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">Una direttiva 'using static' può essere applicata solo a tipi. '{0}' è uno spazio dei nomi, non un tipo. Provare a usare una direttiva 'using namespace'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">Non è possibile usare una direttiva 'using static' per dichiarare un alias</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">Non esiste alcun ciclo di inclusione all'esterno del quale interrompere o continuare</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">L'etichetta '{0}' è un duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">Per il tipo '{0}' non sono definiti costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract type or interface '{0}'</source>
        <target state="translated">Non è possibile creare un'istanza dell'interfaccia o del tipo astratto '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">È necessario specificare un valore nel campo const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base type dependency involving '{0}' and '{1}'</source>
        <target state="translated">Dipendenza circolare del tipo di base che interessa '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">Il delegato '{0}' non ha un costruttore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">È previsto il nome di un metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">È previsto un valore costante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">L'espressione switch o l'etichetta case deve essere un tipo bool, char, string, integrale, enum o un tipo nullable corrispondente in C# 6 e versioni precedenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">L'istruzione switch contiene più usi di maiuscole/minuscole con il valore di etichetta '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">La sintassi goto case è valida soltanto all'interno di un'istruzione switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">Non è possibile usare la proprietà o l'indicizzatore '{0}' in questo contesto perché manca la funzione di accesso get</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">Il tipo rilevato o generato deve derivare da System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">L'utilizzo dell'istruzione throw senza argomenti non è consentito all'esterno di una clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">Il controllo non può lasciare il corpo di una clausola finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">L'etichetta '{0}' è la replica di un'altra etichetta con lo stesso nome in un ambito contenuto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">L'etichetta '{0}' non esiste nell'ambito dell'istruzione goto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">Una clausola catch precedente rileva già tutte le eccezioni del tipo this o super ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">L'espressione di filtro è una costante 'true'. Provare a rimuovere il filtro</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">L'espressione di filtro è una costante 'true'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'{0}': non tutti i percorsi del codice restituiscono un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">È stato rilevato codice non raggiungibile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">È stato rilevato codice non raggiungibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">Il controllo non può passare da un'etichetta case ('{0}') a un'altra</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">Non è stato fatto riferimento a questa etichetta</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">Non è stato fatto riferimento a questa etichetta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">Uso della variabile locale '{0}' non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">La variabile '{0}' è dichiarata, ma non viene mai usata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">La variabile è dichiarata, ma non viene mai usata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">Il campo '{0}' non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">Il campo non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">Uso del campo '{0}' probabilmente non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">Uso della proprietà implementata automaticamente '{0}' probabilmente non assegnata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">Non è possibile determinare il tipo di espressione condizionale perché '{0}' e '{1}' sono reciprocamente convertibili in modo implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">Non è possibile determinare il tipo di espressione condizionale perché non esiste conversione implicita tra '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">È necessaria una classe base per il riferimento 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">Utilizzo della parola chiave 'base' non valido in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">Non è possibile accedere al membro '{0}' con un riferimento all'istanza. Qualificarlo con un nome di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">Il parametro out '{0}' deve essere assegnato prima che il controllo lasci il metodo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">L'identificatore del numero di dimensioni non è valido: è previsto ',' o ']'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'{0}' non può essere di tipo extern e dichiarare un corpo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'{0}' non può essere di tipo extern e contenere un inizializzatore di costruttore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'{0}' non può essere contemporaneamente di tipo extern e abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">Il tipo del parametro di costruttore di attributo '{0}' è '{1}' che però non è un tipo di parametro di attributo valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">L'argomento di un attributo deve essere un'espressione costante, un'espressione typeof o un'espressione per la creazione di matrici di un tipo di parametro dell'attributo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">Il parametro di costruttore di attributo '{0}' è facoltativo, ma non sono stati specificati valori di parametro predefiniti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">L'espressione specificata è sempre del tipo fornito ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'L'espressione specificata dell'espressione 'is' è sempre del tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">L'espressione specificata non è mai del tipo fornito ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'L'espressione specificata dell'espressione 'is' non è mai del tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'{0}' non è un tipo riferimento richiesto dall'istruzione lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">L'utilizzo di null non è valido in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">In questo contesto non è possibile usare il valore letterale predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">Il costrutto __arglist è valido solo all'interno di un metodo con argomenti variabili</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">L'operatore * o -&gt; deve essere applicato a un puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">Un puntatore deve essere indicizzato da un solo valore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">Se si usa '{0}' come valore out o ref oppure se ne accetta l'indirizzo, potrebbe verificarsi un'eccezione in fase di esecuzione perché è un campo di una classe con marshalling per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">Se si usa come valore out o ref un campo di una classe con marshalling per riferimento oppure se ne accetta l'indirizzo, può verificarsi un'eccezione in fase di esecuzione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Impossibile effettuare un'assegnazione a un campo statico in sola lettura (tranne che in un costruttore statico o in un inizializzatore di variabile)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Non è possibile usare un campo di sola lettura statico come valore out o ref (tranne che in un costruttore statico)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Non è possibile assegnare un valore alla proprietà o all'indicizzatore '{0}' perché è di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">È possibile usare come istruzione solo le espressioni di assegnazione, chiamata, incremento, decremento, attesa e nuovo oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">Con foreach il tipo restituito '{0}' di '{1}' deve essere associato a un metodo 'MoveNext' pubblico e a una proprietà 'Current' pubblica appropriati</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">Sono consentite solo 65534 variabili locali, incluse quelle generate dal compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Impossibile chiamare un membro di base astratto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A non ref-returning property or indexer may not be used as an out or ref value</source>
        <target state="translated">Una proprietà o un indicizzatore che non restituisce ref non possono essere usati come valori out o ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">Non è possibile accettare l'indirizzo di un tipo gestito ('{0}'), recuperarne la dimensione o dichiarare un puntatore a esso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">Il tipo di una variabile locale dichiarata in un'istruzione fixed deve essere un puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">Occorre specificare un inizializzatore nella dichiarazione di un'istruzione fixed o using</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">Non è possibile accettare l'indirizzo dell'espressione data</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">È possibile accettare l'indirizzo di un'espressione unfixed solo all'interno dell'inizializzatore di un'istruzione fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">Impossibile utilizzare l'istruzione fixed per accettare l'indirizzo di un'espressione già di tipo fixed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">Puntatori e buffer a dimensione fissa possono essere usati solo in un contesto unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">Il tipo restituito dell'operatore True o False deve essere booleano</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">L'operatore '{0}' richiede che sia definito anche un operatore '{1}' corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">Per essere usato come operatore di corto circuito, un operatore logico definito dall'utente ('{0}') deve avere lo stesso tipo restituito e gli stessi tipi di parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">Per poter usare '{0}' come operatore di corto circuito, il tipo dichiarante '{1}' deve definire l'operatore True e l'operatore False</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">La variabile '{0}' è assegnata, ma il suo valore non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">La variabile è assegnata, ma il suo valore non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">Operazione in overflow in fase di compilazione in modalità checked</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">Il valore costante '{0}' non può essere convertito in '{1}'. Usare la sintassi 'unchecked' per eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">Un metodo con vararg non può essere generico, non può essere in un tipo generico né contenere una matrice di parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">Un'espressione __arglist può trovarsi solo all'interno di una chiamata o di un'espressione new</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">Il codice di tipo unsafe è ammesso solo se si compila con /unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">Ambiguità tra '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">In un'istruzione foreach sono necessari sia il tipo che l'identificatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a parameter list</source>
        <target state="translated">Un parametro params deve essere l'ultimo parametro in un elenco di parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">'{0}' non ha una dimensione predefinita, quindi sizeof può essere usato solo in un contesto di tipo unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">Il tipo o il nome dello spazio dei nomi '{0}' non esiste nello spazio dei nomi '{1}'. Probabilmente manca un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">Un inizializzatore di campo non può fare riferimento alla proprietà, al metodo o al campo non statico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'{0}' non può essere sealed perché non è un override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'{0}': non è possibile eseguire l'override del membro ereditato '{1}' perché è sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">L'operazione è indefinita sui puntatori a void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">L'attributo Conditional non è valido per '{0}' perché è un metodo di override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">is' o 'as' non valido per tipi puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">Impossibile chiamare direttamente i distruttori e object.Finalize. Provare a chiamare IDisposable.Dispose se disponibile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">Il nome di tipo o di spazio dei nomi '{0}' non è stato trovato. Probabilmente manca una direttiva using o un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">Impossibile utilizzare dimensioni negative con stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">Non è possibile creare matrici con dimensioni negative</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">Non eseguire l'override di object.Finalize. Fornire un distruttore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base type Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">Non chiamare direttamente il metodo Finalize del tipo di base. Viene chiamato automaticamente dal distruttore.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">Indicizzazione di una matrice con indice negativo. Gli indici di matrice iniziano sempre da zero</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">Indicizzazione di una matrice con un indice negativo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">È probabile che il confronto dei riferimenti non sia intenzionale. Per confrontare i valori, eseguire il cast dell'espressione di sinistra sul tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">Possibile confronto non intenzionale dei riferimenti. Eseguire il cast del lato sinistro</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">È probabile che il confronto dei riferimenti non sia intenzionale. Per confrontare i valori, eseguire il cast dell'espressione di destra sul tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">Possibile confronto non intenzionale dei riferimenti. Eseguire il cast del lato destro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">La parte destra dell'assegnazione di un'istruzione fixed non può essere un'espressione cast</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">stackalloc non può essere usato in un blocco catch o finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a parameter list</source>
        <target state="translated">Un parametro __arglist deve essere l'ultimo parametro in un elenco di parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">Manca il modificatore parziale nella dichiarazione di tipo '{0}'. È presente un'altra dichiarazione parziale di questo tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' devono essere costituite solo da classi, classi di record, struct di record o interfacce</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' contengono modificatori di accessibilità in conflitto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' non devono specificare classi base diverse</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' devono avere gli stessi nomi di parametro di tipo nello stesso ordine</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' contengono vincoli incoerenti per il parametro di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">Non è possibile convertire in modo implicito il tipo '{0}' in '{1}'. È presente una conversione esplicita. Probabilmente manca un cast.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', 'event', an instance constructor name, or a method or property return type.</source>
        <target state="needs-review-translation">Il modificatore 'partial' può trovarsi solo immediatamente prima di 'class', 'record', 'struct', 'interface' o del tipo restituito di un metodo o di una proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base type dependency.</source>
        <target state="translated">Il tipo importato '{0}' non è valido perché contiene una dipendenza circolare del tipo di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">Uso del parametro out '{0}' non assegnato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">Impossibile specificare la dimensione della matrice in una dichiarazione di variabile. Provare a inizializzare con un'espressione 'new'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">Non è possibile usare la proprietà o l'indicizzatore '{0}' in questo contesto perché la funzione di accesso get non è accessibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">Non è possibile usare la proprietà o l'indicizzatore '{0}' in questo contesto perché la funzione di accesso set è inaccessibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">Il modificatore di accessibilità della funzione di accesso '{0}' deve essere più restrittivo della proprietà o dell'indicizzatore '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">Non è possibile specificare i modificatori di accessibilità per entrambe le funzioni di accesso della proprietà o dell'indicizzatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': i modificatori di accessibilità per le funzioni di accesso possono essere usati solo se la proprietà o l'indicizzatore ha entrambe le funzioni di accesso get e set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' è di tipo non pubblico</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'{0}' non implementa il modello '{1}'. '{2}' è ambiguo con '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">Il tipo non implementa il modello di raccolta. I membri sono ambigui</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'{0}' non implementa il modello '{1}'. La firma di '{2}' è errata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">Il tipo non implementa il modello di raccolta. La firma del membro è errata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">L'accesso a Friend è stato concesso da '{0}', ma la chiave pubblica dell'assembly di output ('{1}') non corrisponde a quella specificata dall'attributo InternalsVisibleTo nell'assembly che ha concesso l'accesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">L'accesso a Friend è stato concesso da '{0}', ma lo stato di firma del nome sicuro dell'assembly di output non corrisponde a quello dell'assembly che ha concesso l'accesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">Non è stato definito nessun ordine tra i campi in più dichiarazioni di struct parziale '{0}'. Per specificare un ordine, tutti i campi dell'istanza devono essere inclusi nella stessa dichiarazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">In più dichiarazioni della struct parziale non è stato definito nessun ordinamento tra campi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">Il tipo '{0}' non può essere dichiarato come const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">Non è possibile creare un'istanza del tipo di variabile '{0}' perché non include il vincolo new()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">L'uso del tipo generico {1} '{0}' richiede argomenti di tipo {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">Il tipo '{0}' non può essere usato come argomento di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">Non è possibile usare {1} '{0}' con argomenti di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} '{0}' non generico non può essere usato con argomenti di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'{2}' deve essere un tipo non astratto con un costruttore pubblico senza parametri per poter essere usato come parametro '{1}' nel tipo o nel metodo generico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel metodo o nel tipo generico '{0}'. Non esistono conversioni implicite di riferimenti da '{3}' a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel metodo o nel tipo generico '{0}'. Il tipo nullable '{3}' non soddisfa il vincolo di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel tipo o metodo generico '{0}'. Il tipo nullable '{3}' non soddisfa il vincolo di '{1}'. I tipi nullable non soddisfano i vincoli di interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel metodo o nel tipo generico '{0}'. Non esistono conversioni boxing o conversioni di parametri di tipo da '{3}' a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">Non è possibile usare il tipo '{3}' come parametro di tipo '{2}' nel metodo o nel tipo generico '{0}'. Non esistono conversioni boxing da '{3}' a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">Il nome di parametro '{0}' è in conflitto con un nome di parametro generato automaticamente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">Il nome di tipo o di spazio dei nomi '{0}' non è stato trovato nello spazio dei nomi globale. Probabilmente manca un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last restrictive constraint specified</source>
        <target state="translated">Il vincolo new() deve essere l'ultimo vincolo specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'{0}': un punto di ingresso non può essere generico o essere incluso in un tipo generico</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">Un punto di ingresso non può essere generico o essere incluso in un tipo generico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">Non è possibile convertire il valore Null nel parametro di tipo '{0}' perché potrebbe essere un tipo valore che non ammette i valori Null. Provare a usare 'default({0})'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">Il vincolo '{0}' è duplicato per il parametro di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">Il vincolo di tipo classe '{0}' deve precedere gli altri vincoli</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'Il tipo restituito di '{1} {0}' è errato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">Riferimenti non corrispondenti tra '{0}' e il delegato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">È già stata specificata una clausola di vincolo per il parametro di tipo '{0}'. Tutti i vincoli per un parametro di tipo devono essere specificati in un'unica clausola where.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">Non è possibile dedurre gli argomenti di tipo per il metodo '{0}' dall'utilizzo. Provare a specificare gli argomenti di tipo in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'{0}': il nome di un parametro, di una variabile locale o di una funzione locale non può essere uguale a quello di un parametro di tipo del metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">Non è possibile usare il parametro di tipo '{0}' con l'operatore 'as' perché non ha vincoli di tipo classe, né un vincolo 'class'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">Il campo '{0}' è assegnato, ma il suo valore non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">Il campo è assegnato, ma il suo valore non viene mai usato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">L'attributo '{0}' è valido solo in un indicizzatore che non sia una dichiarazione esplicita di un membro di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'{0}': un argomento di attributo non può usare parametri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'{0}': non è possibile fornire argomenti quando si crea un'istanza di un tipo di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract type cannot be sealed or static</source>
        <target state="translated">'{0}': un tipo astratto non può essere sealed o static</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">Riferimento ambiguo nell'attributo cref: '{0}'. Verrà usato '{1}', ma è anche possibile che corrisponda ad altri overload, tra cui '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">Riferimento ambiguo nell'attributo cref</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'{0}': un riferimento a un campo volatile non verrà considerato volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">Un riferimento a un campo volatile non verrà considerato volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">Un campo volatile non deve in genere essere usato come valore out o ref dal momento che non verrà considerato come volatile. Esistono eccezioni a questo comportamento, ad esempio quando si chiama un'API con interlock.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">'{1}' ha l'attributo ComImport, pertanto '{0}' deve essere extern o abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'{0}': una classe con l'attributo ComImport non può specificare una classe base</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">I vincoli per il parametro di tipo '{0}' del metodo '{1}' devono corrispondere ai vincoli per il parametro di tipo '{2}' del metodo di interfaccia '{3}'. Provare a usare un'implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">I nomi di elementi di tupla nella firma del metodo '{0}' devono corrispondere a quelli del metodo di interfaccia '{1}' (incluso nel tipo restituito).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">Il nome di tipo '{0}' non esiste nel tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">Non è possibile convertire il gruppo di metodi '{0}' nel tipo non delegato '{1}'. Si intendeva richiamare il metodo?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">L'alias extern '{0}' non è stato specificato in un'opzione /reference</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">Non è possibile usare l'alias '{0}' con '::' perché l'alias fa riferimento a un tipo. Usare '.'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">L'alias '{0}' non è stato trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">Il tipo '{1}' esiste sia in '{0}' che in '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">Lo spazio dei nomi '{1}' in '{0}' è in conflitto con il tipo '{3}' in '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">Lo spazio dei nomi '{1}' in '{0}' è in conflitto con il tipo importato '{3}' in '{2}'. Verrà usato lo spazio dei nomi definito in '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">Lo spazio dei nomi è in conflitto con il tipo importato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Il tipo '{1}' in '{0}' è in conflitto con il tipo importato '{3}' in '{2}'. Verrà usato il tipo definito in '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">Il tipo è in conflitto con il tipo importato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">Il tipo '{1}' in '{0}' è in conflitto con lo spazio dei nomi importato '{3}' in '{2}'. Verrà usato il tipo definito in '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">Il tipo è in conflitto con lo spazio dei nomi importato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">Il tipo '{1}' in '{0}' è in conflitto con lo spazio dei nomi '{3}' in '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">Una dichiarazione di alias extern deve precedere tutti gli altri elementi definiti nello spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">Si consiglia di non assegnare il nome 'global' a un alias perché 'global::' fa sempre riferimento allo spazio dei nomi globale e non a un alias</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">È consigliabile non assegnare il nome 'global' a un alias</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a type cannot be both static and sealed</source>
        <target state="translated">'{0}': un tipo non può essere sia statico che sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'{0}': le proprietà astratte non possono avere funzioni di accesso private</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">Errore di sintassi: è previsto un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">Non è possibile modificare il risultato di una conversione unboxing</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">L'istruzione foreach non può funzionare con '{0}'. Si intendeva richiamare '{0}'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">Il tipo restituito per l'operatore ++ o -- deve essere uguale o derivare dal tipo che lo contiene</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'{0}': non è possibile specificare sia una classe constraint che il vincolo 'class' o 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">Non è possibile usare il vincolo 'new()' con il vincolo 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Il tipo '{2}' deve essere un tipo riferimento per poter essere usato come parametro '{1}' nel metodo o nel tipo generico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">Il tipo '{2}' deve essere un tipo valore che non ammette i valori Null per poter essere usato come parametro '{1}' nel metodo o nel tipo generico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">Dipendenza di vincolo circolare che interessa '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">Il parametro di tipo '{0}' eredita i vincoli in conflitto '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">Il parametro di tipo '{1}' ha il vincolo 'struct'. Non è quindi possibile usare '{1}' come vincolo per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">Le conversioni '{0}' e '{1}' definite dall'utente durante la conversione da '{2}' a '{3}' sono ambigue</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">Il risultato dell'espressione è sempre 'null' di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">Il risultato dell'espressione è sempre 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">Non è possibile restituire 'this' per riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.</source>
        <target state="translated">Non è possibile utilizzare il costruttore dell'attributo '{0}' perché contiene parametri 'in' o 'ref readonly'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">I vincoli per i metodi di override e di implementazione esplicita dell'interfaccia sono ereditati dal metodo base, quindi non possono essere specificati direttamente, ad eccezione di un vincolo 'class' o 'struct'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">I membri ereditati '{0}' e '{1}' hanno la stessa firma nel tipo '{2}', pertanto non possono essere sottoposti a override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">La valutazione dell'espressione costante decimale non è riuscita</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">Il confronto con il valore Null di tipo '{0}' restituisce sempre 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">Il confronto con il valore Null di tipo struct restituisce sempre 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">L'introduzione di un metodo 'Finalize' può interferire con la chiamata di un distruttore. Si desiderava dichiarare un distruttore?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">L'introduzione di un metodo 'Finalize' può interferire con la chiamata di un distruttore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">Questo avviso viene visualizzato quando si crea una classe con un metodo la cui firma è public virtual void Finalize.

Se si usa tale classe come classe base e se la classe di derivazione definisce un distruttore, il distruttore eseguirà l'override del metodo Finalize della classe base e non di Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'{0}' non deve contenere un parametro params perché '{1}' non ne ha</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">Il valore 'goto case' non è convertibile in modo implicito nel tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">Il valore 'goto case' non è convertibile in modo implicito nel tipo switch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">Il metodo '{0}' non può implementare la funzione di accesso di interfaccia '{1}' per il tipo '{2}'. Usare un'implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Il risultato dell'espressione è sempre '{0}' perché un valore di tipo '{1}' non è mai uguale a 'null' di tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Il risultato dell'espressione è sempre lo stesso perché un valore di questo tipo non è mai uguale a 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">Il risultato dell'espressione è sempre '{0}' perché un valore di tipo '{1}' non è mai uguale a 'null' di tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">Il risultato dell'espressione è sempre lo stesso perché un valore di questo tipo non è mai uguale a 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">L'implementazione esplicita dell'interfaccia '{0}' corrisponde a più membri di interfaccia. Il membro di interfaccia scelto dipende dall'implementazione. Provare a usare un'implementazione non esplicita.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">L'implementazione dell'interfaccia esplicita corrisponde a più di un membro di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'{0}' non può dichiarare un corpo perché è contrassegnato come abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'{0}' deve dichiarare un corpo perché non è contrassegnato come abstract, extern o partial</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'{0}' non può essere contemporaneamente di tipo abstract e sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">L'elemento {0} astratto '{1}' non può essere contrassegnato come virtual</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">La costante '{0}' non può essere contrassegnata come static</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'{0}': non è possibile eseguire l'override. '{1}' non è una funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'{0}': non è possibile eseguire l'override del membro ereditato '{1}' perché non è contrassegnato come virtual, abstract o override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'{0}': non è possibile cambiare i modificatori di accesso quando viene eseguito l'override di '{1}' del membro ereditato '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'{0}': non è possibile cambiare i nomi di elementi di tupla quando viene eseguito l'override del membro ereditato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': il tipo restituito deve essere '{2}' in modo che corrisponda al membro '{1}' sottoposto a override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'{0}' non può derivare dal tipo sealed '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract type '{1}'</source>
        <target state="translated">'{0}' è di tipo astratto ma è contenuto nel tipo non astratto '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'{0}': un costruttore statico non può avere una chiamata esplicita al costruttore 'this' o 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'{0}': i modificatori di accesso non sono consentiti su costruttori statici</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">Il costruttore '{0}' non può chiamare se stesso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">Il costruttore '{0}' non può chiamare se stesso tramite un altro costruttore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">'{0}' non ha una classe base e non può chiamare un costruttore base</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Il tipo predefinito '{0}' non è definito né importato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">Il tipo predefinito '{0}' non è definito né importato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeAmbiguous">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">Il tipo predefinito '{0}' è dichiarato in più assembly di riferimento: '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'{0}': le struct non possono chiamare costruttori della classe base</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">Il membro struct '{0}' di tipo '{1}' causa un ciclo nel layout della struct</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">Le interfacce non possono contenere campi di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">Le interfacce non possono contenere costruttori di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">Il tipo '{0}' nell'elenco di interfacce non è un'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'{0}' è già presente nell'elenco delle interfacce</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' è già incluso nell'elenco di interfacce nel tipo '{2}' con nomi di elementi di tupla diversi, come '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">L'interfaccia ereditata '{1}' causa un ciclo nella gerarchia delle interfacce di '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'{0}' nasconde il membro astratto ereditato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'{0}' non implementa il membro astratto ereditato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">La classe System.Object non può avere una classe base o implementare un'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'{0}' nella dichiarazione esplicita dell'interfaccia non è un'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">Nella dichiarazione di interfaccia esplicita '{0}' non è stato trovato tra i membri dell'interfaccia implementabili</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'{0}': il tipo che lo contiene non implementa l'interfaccia '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</source>
        <target state="translated">'{0}': la dichiarazione esplicita dell'interfaccia può essere dichiarata sono in una classe, un record, uno struct o un'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'{0}': i nomi dei membri non possono essere uguali a quelli del tipo di inclusione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'{0}': il valore dell'enumeratore è troppo grande per il tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'{0}': non è possibile eseguire l'override. '{1}' non è una proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'{0}': non è possibile eseguire l'override perché '{1}' non ha una funzione di accesso get di cui eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'{0}': non è possibile eseguire l'override perché '{1}' non ha di una funzione di accesso set di cui eseguire l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'{0}': la proprietà o l'indicizzatore non può avere un tipo void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'{0}': la proprietà o l'indicizzatore deve avere almeno una funzione di accesso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed type '{1}'</source>
        <target state="translated">'{0}' è un nuovo membro virtuale nel tipo sealed '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'{0}' aggiunge una funzione di accesso non trovata nel membro di interfaccia '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">Nell'implementazione esplicita dell'interfaccia '{0}' manca la funzione di accesso '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'{0}': non sono consentite conversioni definite dall'utente da o verso un'interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base type are not allowed</source>
        <target state="translated">'{0}': le conversioni definite dall'utente da o verso un tipo di base non sono consentite</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived type are not allowed</source>
        <target state="translated">'{0}': le conversioni definite dall'utente da o verso un tipo derivato non sono consentite</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot convert a type to itself</source>
        <target state="translated">L'operatore definito dall'utente non può convertire un tipo in se stesso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">La conversione definita dall'utente deve eseguire la conversione verso o da un tipo di inclusione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">Conversione definita dall'utente duplicata nel tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">Il tipo di parametro per l'operatore ++ o -- deve essere il tipo che lo contiene</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">Il parametro di un operatore unario deve essere il tipo che lo contiene</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">Uno dei parametri di un operatore binario deve essere il tipo che lo contiene</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type</source>
        <target state="translated">Il primo operando di un operatore di spostamento sovraccaricato deve avere lo stesso tipo del tipo contenitore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">Le enumerazioni non possono contenere costruttori espliciti senza parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}': non è possibile eseguire l'override di '{1}' perché non è supportato dal linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'{0}' non è supportato dal linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'{0}': non è possibile chiamare in modo esplicito l'operatore o la funzione di accesso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'{0}': non è possibile fare riferimento a un tipo con un'espressione. Provare con '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of type</source>
        <target state="translated">Il nome del distruttore deve corrispondere al nome del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">Solo i tipi classe possono contenere distruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">Lo spazio dei nomi '{1}' contiene una definizione in conflitto con l'alias '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">L'alias '{0}' è in conflitto con la definizione di {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</source>
        <target state="translated">L'attributo Conditional non è valido per '{0}' perché è l'implementazione di un costruttore, distruttore, espressione lambda, operatore o interfaccia esplicita</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">L'attributo Conditional non è valido per '{0}' perché il tipo restituito non è void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">L'attributo '{0}' è duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">L'attributo '{0}' è duplicato in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">L'attributo Conditional non è valido per i membri di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">Gli operatori definiti dall'utente non possono restituire void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'{0}': le conversioni definite dall'utente nel o dal tipo dinamico non sono consentite</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">Il valore specificato per l'argomento dell'attributo '{0}' non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">Il parametro non è valido per il tipo non gestito specificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">È necessario specificare il parametro di attributo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">È necessario specificare il parametro di attributo '{0}' o '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">Il tipo non gestito '{0}' non è valido per i campi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">Il tipo non gestito '{0}' è valido solo per i campi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">L'attributo '{0}' non è valido in questo tipo di dichiarazione. È valido solo in dichiarazioni di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">La costante a virgola mobile non è inclusa nell'intervallo di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">L'attributo Guid deve essere specificato con l'attributo ComImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">Il valore dell'argomento di attributo denominato '{0}' non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'extern' that is either 'static' or an extension member</source>
        <target state="needs-review-translation">L'attributo DllImport deve essere specificato in un metodo contrassegnato come 'static' ed 'extern'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="translated">Non è possibile applicare l'attributo DllImport a un metodo generico o contenuto in un tipo o un metodo generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">Il campo o la proprietà non può essere di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">La proprietà di campo o implementata automaticamente non può essere di tipo '{0}' a meno che non sia un membro di istanza di uno struct ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">Gli elementi di una matrice non possono essere di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'{0}' è obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Il tipo o il membro è obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'{0}' non è una classe Attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'{0}' non è un argomento di attributo denominato valido. Gli argomenti di attributo denominati devono essere campi che non siano di sola lettura, statici o costanti oppure proprietà di lettura/scrittura che siano pubbliche e non statiche.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' è obsoleto: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">Il tipo o il membro è obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}' è obsoleto: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">Gli indicizzatori non possono avere tipi void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'{0}': i membri virtuali o astratti non possono essere privati</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">Solo espressioni di inizializzazione di matrice possono essere utilizzate per assegnare a tipi matrice. Provare a utilizzare un'espressione new.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">Gli inizializzatori di matrice possono essere usati solo in un inizializzatore di campo o di variabile. Provare a usare un'espressione new.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">'{0}': il campo dell'istanza nei tipi contrassegnati con StructLayout(LayoutKind.Explicit) deve contenere un attributo FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">Il metodo, la funzione di accesso o l'operatore '{0}' è contrassegnato come esterno e non include attributi. Provare ad aggiungere un attributo DllImport per specificare l'implementazione esterna.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">Il metodo, la funzione di accesso o l'operatore è contrassegnato come esterno ed è privo di attributi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed type</source>
        <target state="translated">'{0}': il nuovo membro protetto è stato dichiarato nel tipo sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed type</source>
        <target state="translated">Il nuovo membro protetto è stato dichiarato nel tipo sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">Il membro condizionale '{0}' non può implementare il membro di interfaccia '{1}' nel tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">ref e out non sono validi in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">L'argomento dell'attributo '{0}' deve essere un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">L'attributo FieldOffset può essere usato solo in membri di tipo contrassegnati con StructLayout(LayoutKind.Explicit)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">L'uso dell'attributo FieldOffset non è consentito nei campi static o const</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">L'attributo '{0}' è valido solo in classi derivate da System.Attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">L'istruzione vuota è probabilmente errata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">L'istruzione vuota è probabilmente errata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'L'argomento di attributo denominato '{0}' è duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'{0}' non può derivare dalla classe speciale '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">Impossibile specificare l'attributo DefaultMember in un tipo contenente un indicizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'{0}' è un tipo non supportato dal linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">Non è possibile assegnare un valore diverso al campo '{0}'. Il valore predefinito è {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">Non è possibile assegnare al campo un valore diverso da quello predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">Il dichiaratore di matrice è errato: per dichiarare una matrice gestita, l'identificatore del numero di dimensioni deve precedere l'identificatore della variabile. Per dichiarare un campo buffer a dimensione fissa, usare la parola chiave fixed prima del tipo di campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">Il confronto con la costante integrale è inutile. La costante non è inclusa nell'intervallo del tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">Il confronto con la costante integrale è inutile. La costante non è inclusa nell'intervallo del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">Non è possibile applicare la classe Attribute '{0}' perché è astratta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'{0}' non è un argomento di attributo denominato valido perché non è un tipo di parametro di attributo valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">Manca il membro '{0}.{1}', necessario per il compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' non è una posizione valida dell'attributo per questa dichiarazione. Le posizioni valide degli attributi sono '{1}'. Tutti gli attributi in questo blocco verranno ignorati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">Non è una posizione valida dell'attributo per questa dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}' non è una posizione riconosciuta dell'attributo. Le posizioni valide degli attributi sono '{1}'. Tutti gli attributi in questo blocco verranno ignorati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">Non è una posizione di attributo riconosciuta</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' esegue l'override di Object.Equals(object o) ma non esegue l'override di Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">Il tipo esegue l'override di Object.Equals(object o) ma non esegue l'override di Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'{0}' definisce l'operatore == o l'operatore != ma non esegue l'override di Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">Il tipo definisce l'operatore == o l'operatore != ma non esegue l'override di Object.Equals(object o)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}' definisce l'operatore == o l'operatore != ma non esegue l'override di Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">Il tipo definisce l'operatore == o l'operatore != ma non esegue l'override di Object.GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">Non è possibile specificare l'attributo Out in un parametro ref senza specificare anche l'attributo In.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'{0}' non può definire un elemento {1} in rapporto di overload che differisce solo per i modificatori di parametro '{2}' e '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">Non è possibile convertire in modo implicito il valore letterale di tipo double nel tipo '{1}'. Usare un suffisso '{0}' per creare un valore letterale di questo tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">L'assegnazione nell'espressione condizionale è sempre costante. Si intendeva utilizzare == invece di = ?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">L'assegnazione nell'espressione condizionale è sempre costante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'{0}': in struct è stato dichiarato il nuovo membro protetto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">Due indicizzatori hanno nomi diversi. L'attributo IndexerName deve essere usato con lo stesso nome in ogni indicizzatore all'interno di un tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">Una classe con l'attributo ComImport non può avere un costruttore definito dall'utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">Il campo non può essere di tipo void</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">Il membro '{0}' esegue l'override del membro obsoleto '{1}'. Aggiungere l'attributo Obsolete a '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">Il membro esegue l'override del membro obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">Non è possibile usare System.Void da C#. Usare typeof(void) per ottenere l'oggetto di tipo void</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">L'operatore OR bit per bit viene usato su un operando con segno esteso. Prima di usarlo, provare a eseguire il cast su un tipo più piccolo e senza segno</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">Operatore OR bit per bit usato su un operando con segno esteso</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">Il compilatore ha ampliato ed esteso con segno in modo implicito una variabile, usando quindi il valore risultante in un'operazione OR bit per bit. Questa operazione potrebbe causare comportamenti imprevisti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'{0}': un campo volatile non può essere di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'{0}': un campo non può essere sia volatile che di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">Il modificatore 'abstract' non è valido nei campi. Provare a utilizzare una proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}' non può implementare '{1}' perché non è supportato dal linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'L'implementazione esplicita del metodo '{0}' non può implementare '{1}' perché è una funzione di accesso</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'L'interfaccia '{0}' contrassegnata con 'CoClassAttribute' non è contrassegnata con 'ComImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">L'interfaccia contrassegnata con 'CoClassAttribute' non è contrassegnata con 'ComImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">Il membro condizionale '{0}' non può avere un parametro out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">La funzione di accesso '{0}' non può implementare il membro di interfaccia '{1}' per il tipo '{2}'. Usare un'implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">Il qualificatore di alias '::' dello spazio dei nomi viene sempre risolto in un tipo o in uno spazio dei nomi e non è pertanto valido in questa posizione. Si consiglia di utilizzare '.'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">Non è possibile derivare da '{0}' perché è un parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">Parametro di tipo '{0}' duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">Il parametro di tipo '{0}' ha lo stesso nome del parametro del tipo outer '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">Il parametro di tipo ha lo stesso nome del parametro del tipo outer</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">Il parametro di tipo '{0}' ha lo stesso nome del tipo che lo contiene o del metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'{0}' non può implementare sia '{1}' che '{2}' perché potrebbero unificarsi per alcune sostituzioni di parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">'{1}' non definisce il parametro di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'{0}' non è un vincolo valido. Un tipo usato come vincolo deve essere un'interfaccia, una classe non sealed o un parametro di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">Il vincolo non può essere la classe speciale '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo di vincolo '{1}' è meno accessibile di '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">Non è possibile eseguire la ricerca di membri non virtuali in '{0}' perché è un parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">Il tipo vincolo non è valido. Un tipo usato come vincolo deve essere un'interfaccia, una classe non sealed o un parametro di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'{0}': non è possibile dichiarare i membri di istanza in una classe statica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'{1}' non può derivare dalla classe statica '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">Le classi statiche non possono avere costruttori di istanze</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">Le classi statiche non possono contenere distruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">Non è possibile creare un'istanza della classe statica '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">La classe statica '{0}' non può derivare dal tipo '{1}'. Le classi statiche devono derivare dall'oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'{0}': le classi statiche non possono implementare interfacce</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'{0}': le classi statiche non possono contenere operatori definiti dall'utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">Non è possibile convertire nel tipo statico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'{0}': non si possono usare classi statiche come vincoli</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'{0}': i tipi statici non possono essere usati come argomenti di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'{0}': gli elementi di matrice non possono essere di tipo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'{0}': non è possibile dichiarare indicizzatori in una classe statica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': i tipi statici non possono essere usati come parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': i tipi statici non possono essere usati come tipi restituiti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">Non è possibile dichiarare una variabile di tipo statico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">L'utilizzo dell'istruzione throw senza argomenti non è consentito in una clausola finally annidata all'interno della clausola catch di inclusione più vicina</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}' non è un identificatore di formato valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">È probabile che l'assegnazione all'elemento '{0}' locale, che rappresenta l'argomento di un'istruzione using o lock, non sia corretta. La chiamata Dispose o lo sblocco verrà eseguito sul valore originale dell'elemento locale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">È probabile che l'assegnazione alla variabile locale, che rappresenta l'argomento di un'istruzione using o lock, non sia corretta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">Il tipo '{0}' è definito in questo assembly, ma per esso è specificato un server d'inoltro dei tipi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">Non è possibile inoltrare il tipo '{0}' perché è un tipo annidato di '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">Il server d'inoltro del tipo '{0}' nell'assembly '{1}' causa un ciclo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">L'opzione /moduleassemblyname può essere specificata solo durante la compilazione del tipo di destinazione di 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Il riferimento all'assembly '{0}' non è valido e non può essere risolto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">Tipo non valido specificato come argomento dell'attributo TypeForwardedTo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia istanza '{1}'. '{2}' non può implementare il membro di interfaccia perché è di tipo statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare un membro di interfaccia perché non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare '{1}' perché non ha il tipo restituito corrispondente di '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'TypeForwardedToAttribute è duplicato in '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">Il corpo di una query deve terminare con una clausola select o group</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">È prevista la parola chiave contestuale 'on'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">È prevista la parola chiave contestuale 'equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">È prevista la parola chiave contestuale 'by'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">Dichiaratore di membro di tipo anonimo non valido. I membri di tipo anonimo devono essere dichiarati con una assegnazione membro, nome semplice o accesso ai membri.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">Dichiaratore di membro di inizializzatore non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">Utilizzo non coerente dei parametri lambda: i parametri devono essere tutti di tipo esplicito o implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberNotExplicit">
        <source>A partial member may not explicitly implement an interface member</source>
        <target state="translated">Un membro parziale non può implementare in modo esplicito un membro di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">Entrambe le dichiarazioni di metodo parziale devono essere metodi di estensione, altrimenti nessuna delle due potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">Un metodo parziale non può avere più dichiarazioni di definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">Un metodo parziale non può avere più dichiarazioni di implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">Non sono state trovate dichiarazioni di definizione per la dichiarazione di implementazione del metodo parziale '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">Le dichiarazioni di metodo parziali di '{0}' contengono vincoli incoerenti per il parametro di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">Non è possibile creare il delegato dal metodo '{0}' perché è un metodo parziale senza una dichiarazione di implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMemberStaticDifference">
        <source>Both partial member declarations must be static or neither may be static</source>
        <target state="translated">Entrambe le dichiarazioni di membro parziale devono essere statiche, altrimenti nessuna delle due potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">Non è possibile usare negli alberi delle espressioni metodi parziali contenenti solo una dichiarazione di definizione o metodi condizionali rimossi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">Il membro obsoleto '{0}' esegue l'override del membro non obsoleto '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">Il membro obsoleto esegue l'override del membro non obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">Il nome completo per '{0}' è troppo lungo per le informazioni di debug. Compilare senza l'opzione '/debug'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">Il nome completo è troppo lungo per le informazioni di debug</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">Non è possibile assegnare {0} a una variabile tipizzata in modo implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">Le variabili tipizzate in modo implicito devono essere inizializzate</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">Le variabili tipizzate in modo implicito non possono avere più dichiaratori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">Non è possibile inizializzare una variabile locale tipizzata in modo implicito con un inizializzatore di matrici</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">Le variabili locali tipizzate in modo implicito non possono essere di tipo fisso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">Le variabili tipizzate in modo implicito non possono essere costanti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">Il costruttore '{0}' è contrassegnato come esterno</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">Il costruttore è contrassegnato come esterno</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">La parola chiave contestuale 'var' può essere specificata solo all'interno di una dichiarazione di variabile locale o in codice script</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">Impossibile trovare il tipo migliore per la matrice tipizzata in modo implicito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">Non è possibile assegnare '{0}' alla proprietà di tipo anonimo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">L'albero delle espressioni non può contenere un accesso di base</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">L'albero delle espressioni non può contenere un operatore di assegnazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">Un tipo anonimo non può avere più proprietà con lo stesso nome</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">Non è possibile convertire un'espressione lambda con il corpo di un'istruzione in un albero delle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">Non è possibile convertire un'espressione lambda in un albero delle espressioni in cui l'argomento '{0}' del tipo non è un tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">Impossibile utilizzare il tipo anonimo in un'espressione costante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">Il primo operando di un operatore 'is' o 'as' non può essere un'espressione lambda, un metodo anonimo o un gruppo di metodi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">Il primo operando di un operatore 'as' non può essere un valore letterale di tupla senza un tipo naturale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">L'albero delle espressioni non può contenere un inizializzatore di matrici multidimensionali</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">Manca l'argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">Non è possibile usare la variabile locale '{0}' prima che sia dichiarata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">Il tipo di '{0}' non può essere dedotto perché il relativo inizializzatore fa riferimento in modo diretto o indiretto alla definizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">Non è possibile usare la variabile locale '{0}' prima che sia dichiarata. La dichiarazione della variabile locale nasconde il campo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere un operatore di coalescenza con un valore letterale Null o predefinito nella parte sinistra</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">È previsto un identificatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">È previsto un punto e virgola (;)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">Errore di sintassi. È previsto '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">Il modificatore '{0}' è duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">La funzione di accesso alla proprietà è già definita</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">È previsto il tipo byte, sbyte, short, ushort, int, uint, long o ulong</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">Sequenza di escape non riconosciuta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">Nuova riga nella costante</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">Il valore letterale carattere è vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">Troppi caratteri nel valore letterale carattere</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Numero non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">È prevista una funzione di accesso get o set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">È previsto un tipo oggetto, stringa o classe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">È previsto un argomento denominato dell'attributo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Le clausole catch non possono seguire la clausola catch generale di un'istruzione try</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">È prevista la parola chiave 'this' o 'base'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">È previsto un operatore unario che supporti l'overload</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">È previsto un operatore binario che supporti l'overload</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">La costante integrale è troppo grande</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">È prevista la definizione del tipo o dello spazio dei nomi oppure la fine del file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">È prevista una definizione di membro, un'istruzione o la fine del file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">Un'istruzione incorporata non può essere una dichiarazione o un'istruzione con etichetta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">È prevista la direttiva per il preprocessore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">È previsto un commento su una sola riga o la fine riga</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">È previsto il segno )</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">È prevista la direttiva #endif</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">La direttiva per il preprocessore è imprevista</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#error: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">direttiva #warning</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">È previsto un tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">Impossibile definire o annullare la definizione dei simboli del preprocessore dopo il primo token nel file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">Non è possibile usare #r dopo il primo token del file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">Trovata la fine del file, era previsto '*/'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">È stato rilevato un marcatore di conflitti di merge</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">Non usare refout quando si usa refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">Non è possibile compilare i moduli .NET quando si usa /refout o /refonly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">È previsto un operatore che supporti l'overload</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">È prevista la direttiva #endregion</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">Valore letterale stringa non completo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">Le direttive per il preprocessore devono trovarsi all'inizio di una riga</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">È previsto un identificatore, mentre '{1}' è una parola chiave</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">È previsto il segno { o un punto e virgola (;)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">Impossibile utilizzare più di un tipo nelle istruzioni for, using, fixed e nelle dichiarazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">È prevista una funzione di accesso add o remove</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Il carattere '{0}' è imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">Token '{0}' imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'{0}': le classi statiche non possono contenere membri protetti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">Una clausola catch precedente rileva già tutte le eccezioni. Verrà eseguito il wrapping di tutti gli oggetti generati diversi da un'eccezione in System.Runtime.CompilerServices.RuntimeWrappedException.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">Una clausola catch precedente rileva già tutte le eccezioni</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">Questo avviso viene visualizzato quando per un blocco catch() non è stato specificato un tipo di eccezione dopo un blocco catch (System.Exception e). L'avviso indica che il blocco catch() non rileverà alcuna eccezione.

Un blocco catch() dopo un blocco catch (System.Exception e) può rilevare eccezioni non CLS se RuntimeCompatibilityAttribute è impostato su false nel file AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Se questo attributo non è impostato in modo esplicito su false, verrà eseguito il wrapping di tutte le eccezioni non CLS rilevate come Exception per consentire al blocco catch (System.Exception e) di rilevarle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">L'operando di un operatore di incremento o decremento deve essere una variabile, una proprietà o un indicizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">'{0}' non contiene una definizione di '{1}' e non è stato trovato alcun metodo di estensione accessibile '{1}' che accetta un primo argomento di tipo '{0}'. Probabilmente manca una direttiva using o un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'{0}' non contiene una definizione di '{1}' e non è stato trovato alcun metodo di estensione '{1}' che accetta un primo argomento di tipo '{0}'. Probabilmente manca una direttiva using per '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">Il metodo '{0}' ha un modificatore di parametro 'this' che non si trova nel primo parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> Non è possibile usare il modificatore di parametro '{0}' con '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The receiver parameter of an extension cannot be of type '{0}'</source>
        <target state="needs-review-translation">Il primo parametro di un metodo di estensione non può essere di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">Non è possibile usare una matrice di parametri con il modificatore 'this' in un metodo di estensione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">Il metodo di estensione deve essere statico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">Il metodo di estensione deve essere definito in una classe statica non generica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">Un parametro può avere un solo modificatore '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">I metodi di estensione devono essere definiti in una classe statica di primo livello, mentre {0} è una classe annidata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="needs-review-translation">Non è possibile definire un nuovo metodo di estensione perché non è stato trovato il tipo '{0}' richiesto dal compilatore. Probabilmente manca un riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">Non usare 'System.Runtime.CompilerServices.ExtensionAttribute'. Usare la parola chiave 'this'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">Non usare 'System.Runtime.CompilerServices.DynamicAttribute'. Usare la parola chiave 'dynamic'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">Non è possibile eseguire l'invio dinamico richiesto della chiamata al costruttore perché la chiamata fa parte di un inizializzatore del costruttore. Provare a eseguire il cast degli argomenti dinamici.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">Non è possibile usare il metodo di estensione '{0}' definito nel tipo di valore '{1}' per creare delegati</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">Nessun overload del metodo '{0}' accetta {1} argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">Argomento {0}: non è possibile convertire da '{1}' a '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">Non è possibile aprire il file di origine '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">Non è possibile collegare i file di risorse durante la compilazione di un modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">L'identificatore di risorsa '{0}' è già stato usato in questo assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">Ogni risorsa e ogni modulo collegato devono avere un nome file univoco. Il nome file '{0}' è specificato più di una volta in questo assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">Il file di riferimento '{0}' non è un assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">Un valore out o ref deve essere una variabile assegnabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">La parola chiave 'base' non è disponibile in un metodo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">La parola chiave 'base' non è disponibile nel contesto corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">È previsto il segno }</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">È previsto il segno {</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'È previsto 'in'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">Espressione per il preprocessore non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in a member declaration</source>
        <target state="needs-review-translation">Il token '{0}' nella dichiarazione del membro di classe, record, struct o interfaccia non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">Il metodo deve avere un tipo restituito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">Il tipo di base non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">Il blocco switch è vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">Il blocco switch è vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">È previsto un blocco catch o finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">'{0}' non è un termine valido nell'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires an argument list or (), [], or {} after type</source>
        <target state="translated">Un'espressione new richiede un elenco di argomenti oppure (), [] o {} dopo il tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">Gli elementi definiti in uno spazio dei nomi non possono essere dichiarati in modo esplicito come private, protected, protected internal o private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">È previsto il segno ; oppure = (non è possibile specificare gli argomenti del costruttore nella dichiarazione)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">La clausola using deve precedere tutti gli altri elementi definiti nello spazio dei nomi ad eccezione delle dichiarazioni di alias extern</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">L'operatore binario di overload '{0}' accetta due parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">L'operatore unario di overload '{0}' accetta un parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">Tipo parametro 'void' non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">Using Alias '{0}' è già presente nello spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">Non è possibile accedere al membro protetto '{0}' tramite un qualificatore di tipo '{1}'. Il qualificatore deve essere di tipo '{2}' o derivato da esso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'Non è possibile aggiungere '{0}' a questo assembly perché è già un assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">La proprietà, l'indicizzatore o l'evento '{0}' non è supportato dal linguaggio. Provare a chiamare direttamente i metodi della funzione di accesso '{1}' o '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">La proprietà, l'indicizzatore o l'evento '{0}' non è supportato dal linguaggio. Provare a chiamare direttamente il metodo della funzione di accesso '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">Non è possibile usare la parola chiave 'void' in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">Gli indicizzatori devono avere almeno un parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">L'identificatore del tipo matrice, [], deve trovarsi prima del nome del parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">La dichiarazione non è valida. Usare '{0} operator &lt;tipo distruttore&gt; (...'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Non è stato trovato l'elemento '{0}' specificato per il metodo Main</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</source>
        <target state="translated">L'elemento '{0}' specificato per il metodo Main deve essere una classe, un record, un'interfaccia o uno struct non generico valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">'{0}' non contiene un metodo 'Main' statico appropriato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">Per gli output senza origine occorre specificare l'opzione /out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">Sono state specificate opzioni in conflitto: file di risorse Win32; manifesto Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">Sono state specificate opzioni in conflitto: file di risorse Win32; icona Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">Si è verificato un errore durante la lettura della risorsa '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">Si è verificato un errore durante la scrittura nel file di documentazione XML: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">Il formato XML del commento XML è errato - '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">Il formato XML del commento XML è errato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">Il commento XML contiene un tag param duplicato per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">Il commento XML contiene un tag param duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Il commento XML ha un tag param per '{0}', ma non esiste nessun parametro con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">Il commento XML ha un tag param, ma non esiste nessun parametro con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">Il commento XML in '{1}' ha un tag paramref per '{0}', ma non esiste nessun parametro con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">Il commento XML ha un tag paramref, ma non esiste nessun parametro con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">Il parametro '{0}', diversamente da altri parametri, non contiene tag param corrispondenti nel commento XML per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">Il parametro, diversamente da altri parametri, non contiene tag param corrispondenti nel commento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">Il commento XML contiene l'attributo cref '{0}' che non è stato possibile risolvere</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">Il commento XML contiene l'attributo cref che non è stato possibile risolvere</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">In un'espressione stackalloc occorre specificare [] dopo il tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">Il numero di riga specificato per la direttiva #line manca o non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">È previsto un nome file tra virgolette, un commento su una sola riga o la fine riga</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">È previsto un nome file racchiuso tra virgolette</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">#r è consentito solo negli script</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</source>
        <target state="translated">L'istruzione foreach non può funzionare con variabili di tipo '{0}' perché '{0}' non contiene una definizione di istanza o estensione pubblica per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">Il tipo non è valido per il parametro {0} nell'attributo cref del commento XML: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">Il tipo non è valido per il parametro nell'attributo cref del commento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Tipo restituito non valido nell'attributo cref del commento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">Tipo restituito non valido nell'attributo cref del commento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Si è verificato un errore durante la lettura delle risorse Win32 - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">Il commento XML contiene l'attributo cref '{0}' che è sintatticamente errato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">Il commento XML contiene l'attributo cref che è sintatticamente errato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">Il modificatore del membro '{0}' deve precedere il nome e il tipo del membro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">Per la creazione della matrice occorre specificare la dimensione della matrice o l'inizializzatore della matrice</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Il commento XML non si trova in un elemento di linguaggio valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">Il commento XML non si trova in un elemento di linguaggio valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">Non è possibile includere il frammento XML '{1}' del file '{0}' - {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">Non è possibile includere il frammento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">L'elemento di inclusione XML non è valido - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">L'elemento di inclusione XML non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">Manca il commento XML per il tipo o il membro '{0}' visibile pubblicamente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">Manca il commento XML per il tipo o il membro visibile pubblicamente</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">È stata specificata l'opzione /doc del compilatore, ma per uno o più costrutti non sono disponibili commenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">Nel file dei commenti incluso è presente codice XML in formato non corretto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">Nel file dei commenti incluso è presente codice XML in formato errato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">Il delegato '{0}' non accetta argomenti {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">Non è possibile inserire un punto e virgola dopo un blocco di metodo o di funzione di accesso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>The return type of a method, delegate, or function pointer cannot be '{0}'</source>
        <target state="translated">Il tipo restituito di un metodo, delegato o puntatore a funzione non può essere '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">Compilazione annullata dall'utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">Non è possibile creare il riferimento alla variabile di tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">Non è possibile assegnare a '{0}' perché è di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">Non è possibile usare '{0}' come valore out o ref perché è di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">L'attributo RequiredAttribute non è consentito per i tipi C#</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">Non è possibile inserire modificatori nelle dichiarazioni delle funzioni di accesso agli eventi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">Non è possibile dichiarare il parametro params come {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">Non è possibile modificare il valore restituito di '{0}' perché non è una variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">La classe wrapper '{0}' della coclasse gestita per l'interfaccia '{1}' non è stata trovata. Probabilmente manca un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</source>
        <target state="translated">'{0}' è ambiguo tra '{1}' e '{2}'. Usare '@{0}' oppure includere in modo esplicito il suffisso 'Attribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">Non è possibile passare l'argomento {0} con la parola chiave '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">L'opzione '{0}' esegue l'override dell'attributo '{1}' specificato in un file di origine o in un modulo aggiunto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">L'opzione esegue l'override dell'attributo specificato in un file di origine o in un modulo aggiunto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">Questo avviso viene visualizzato se gli attributi di assembly AssemblyKeyFileAttribute o AssemblyKeyNameAttribute rilevati nell'origine sono in conflitto con l'opzione della riga di comando /keyfile o /keycontainer oppure con il nome del file di chiave o con il contenitore di chiavi specificato in Proprietà progetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">L'opzione '{0}' non è valida per /langversion. Usare '/langversion:?' per ottenere l'elenco dei valori supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">Non è possibile creare il delegato con '{0}' perché il delegato o un metodo di cui esegue l'override ha un attributo Conditional</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">Non è possibile creare il file temporaneo - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">L'argomento {0} deve essere passato con la parola chiave '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">Non è possibile usare l'istruzione yield all'interno di un metodo anonimo o di un'espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">Non è possibile restituire un valore da un iteratore. Usare l'istruzione yield return per restituire un valore o l'istruzione yield break per terminare l'iterazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">Gli iteratori non possono avere parametri in, out o ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">Il corpo di '{0}' non può essere un blocco iteratore perché '{1}' non è un tipo interfaccia iteratore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">Impossibile eseguire la produzione nel corpo di una clausola finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">Impossibile produrre un valore nel corpo di un blocco try con una clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">Dopo yield return è prevista l'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">Non è possibile usare il parametro ref, out o in '{0}' all'interno di un metodo anonimo, di un'espressione lambda, di un'espressione di query o di una funzione locale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">Impossibile produrre un valore nel corpo di una clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">Il controllo non può lasciare il corpo di un metodo anonimo o di un'espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">La direttiva #pragma non è stata riconosciuta</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">La direttiva #pragma non è stata riconosciuta</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">È previsto 'disable' o 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">Dopo l'avviso della direttiva #pragma è previsto 'disable' o 'restore'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">Non è possibile ripristinare l'avviso 'CS{0}' perché è stato disabilitato a livello globale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">Non è possibile ripristinare l'avviso perché è stato disabilitato a livello globale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">__arglist non è consentito nell'elenco dei parametri degli iteratori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have pointer type parameters</source>
        <target state="translated">Gli iteratori non possono avere parametri di tipo puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">La firma della classe wrapper '{0}' della coclasse gestita per l'interfaccia '{1}' non è valida per il nome della classe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">L'istruzione foreach non può funzionare con variabili di tipo '{0}' perché implementa più creazioni di un'istanza di '{1}'. Provare a eseguire il cast su una creazione di un'istanza di interfaccia specifica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">In un campo buffer a dimensione fissa, l'identificatore della dimensione della matrice deve trovarsi dopo il nome del campo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">I campi buffer a dimensione fissa possono essere membri solo di struct</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">Non tutti i percorsi del codice restituiscono un valore in {0} di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">La funzionalità '{0}' non fa parte della specifica del linguaggio C# standard ISO e potrebbe non essere accettata da altri compilatori</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">La funzionalità non fa parte della specifica del linguaggio C# standard ISO e potrebbe non essere accettata da altri compilatori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">È prevista la parola chiave, l'identificatore o la stringa dopo l'identificatore verbatim: @</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Non è possibile usare un campo di sola lettura come valore out o ref (tranne che in un costruttore)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">Non è possibile usare i membri del campo di sola lettura '{0}' come valore out o ref (tranne che in un costruttore)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</source>
        <target state="translated">Non è possibile assegnare un valore a un campo di sola lettura, tranne che in un costruttore o un setter di sola inizializzazione del tipo in cui è definito il campo o in un inizializzatore di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">Non è possibile modificare i membri del campo di sola lettura '{0}' (tranne che in un costruttore o in un inizializzatore di variabile)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">Non è possibile usare {0} '{1}' come valore ref o out perché è una variabile di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">Non è possibile usare i membri di {0} '{1}' come valore ref o out perché è una variabile di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Non è possibile assegnare '{1}' a {0} o usarlo come lato destro di un'assegnazione di riferimento perché è una variabile readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</source>
        <target state="translated">Non è possibile assegnare '{1}' a un membro di {0} o usarlo come lato destro di un'assegnazione di riferimento perché è una variabile readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">Non è possibile restituire {0} '{1}' per riferimento scrivibile perché è una variabile di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">Non è possibile restituire i membri di {0} '{1}' per riferimento scrivibile perché è una variabile di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">Non è possibile effettuare un'assegnazione a campi del campo statico di sola lettura '{0}' (tranne che in un costruttore statico o in un inizializzatore di variabile)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">Non è possibile usare i campi del campo di sola lettura statico '{0}' come valore out o ref (tranne che in un costruttore statico)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">Non è possibile modificare i membri di '{0}' perché è '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Non è possibile usare i campi di '{0}' come valore out o ref perché è '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">Non è possibile assegnare a '{0}' perché è '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">Non è possibile usare '{0}' come valore out o ref perché è '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}. Vedere anche l'errore CS{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">Override di un errore con un avviso</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">Il compilatore genera questo avviso quando esegue l'override di un errore con un avviso. Per informazioni sul problema, cercare il codice errore indicato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">Non è possibile convertire {0} nel tipo '{1}' perché non è un tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">Non è possibile convertire {0} nel tipo '{1}' perché i tipi di parametro non corrispondono ai tipi di parametro del delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">Non è possibile convertire '{0}' nel tipo delegato previsto perché alcuni dei tipi restituiti nel blocco non sono convertibili in modo implicito nel tipo restituito del delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than '{1}'</source>
        <target state="translated">Poiché si tratta di un metodo asincrono, l'espressione restituita deve essere di tipo '{0}' anziché '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">Non è possibile convertire il metodo async {0} nel tipo delegato '{1}'. Un metodo async {0} può restituire un valore nullo, Task o Task&lt;T&gt;, nessuno dei quali è convertibile in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">Il tipo di buffer a dimensione fissa deve essere uno dei seguenti: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float o double</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">Il buffer a dimensione fissa di lunghezza {0} e di tipo '{1}' è troppo grande</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">La lunghezza dei buffer a dimensione fissa deve essere maggiore di zero</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">Impossibile utilizzare buffer a dimensione fissa contenuti in espressioni unfixed. Provare a utilizzare l'istruzione fixed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">L'attributo '{0}' non è valido nelle funzioni di accesso a proprietà o eventi. È valido solo nelle dichiarazioni di '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">Il percorso di ricerca '{0}' specificato in '{1}' non è valido - '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">Il percorso di ricerca specificato non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">__arglist non è valido in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">params non è valido in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">Una dichiarazione di spazio dei nomi non può avere modificatori o attributi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">L'opzione '{0}' non è valida per /platform. Specificare anycpu, x86, Itanium, arm, arm64 o x64</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.</source>
        <target state="translated">I metodi anonimi, le espressioni lambda, le espressioni di query e le funzioni locali all'interno delle strutture non possono accedere ai membri di istanza di 'this'. Provare a copiare 'this' in una variabile locale all'esterno del metodo anonimo, dell'espressione lambda, dell'espressione di query o della funzione locale e usare tale variabile locale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must implement 'System.IDisposable'.</source>
        <target state="translated">'{0}': il tipo usato in un'istruzione using deve implementare 'System.IDisposable'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">Il parametro {0} deve essere dichiarato con la parola chiave '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">Il parametro {0} non deve essere dichiarato con la parola chiave '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">Il parametro {0} è dichiarato come tipo '{1}{2}', ma deve essere '{3}{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">L'alias extern non è valido per '/reference'. '{0}' non è un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">L'opzione dell'alias di riferimento non è valida: '{0}='. Manca il nome file</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">Non è possibile ridefinire l'alias extern globale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">Il riferimento al tipo '{0}' dichiara di essere definito in questo assembly, ma non è definito nell'origine né nei moduli aggiunti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">Il riferimento al tipo '{0}' dichiara di essere definito in '{1}', ma non è stato trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">Il tipo predefinito '{0}' è definito in più assembly nell'alias globale. Verrà usata la definizione contenuta in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">Il tipo predefinito è definito in più assembly nell'alias globale</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">Questo errore si verifica quando in due assembly viene trovato un tipo di sistema predefinito, come System.Int32. Questa situazione può verificarsi, ad esempio, se si fa riferimento a mscorlib o a System.Runtime.dll da due punti diversi, nel tentativo di eseguire due versioni affiancate di .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">Non è possibile accettare e usare gli indirizzi dell'elemento '{0}' locale o dei rispettivi membri all'interno di un metodo anonimo o di un'espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Limite di 16.707.565 righe rappresentabili nel PDB superato nel file di origine: le informazioni di debug non saranno corrette</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">Limite di 16.707.565 righe rappresentabili nel PDB superato nel file di origine: le informazioni di debug non saranno corrette</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">Non è possibile convertire il blocco di metodi anonimi senza elenco parametri nel tipo delegato '{0}' perché contiene uno o più parametri out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">L'attributo '{0}' è valido solo per metodi o classi Attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">L'accesso a un membro di '{0}' potrebbe causare un'eccezione in fase di esecuzione perché è un campo di una classe con marshalling per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">L'accesso a un membro in un campo di una classe con marshalling per riferimento potrebbe causare un'eccezione in fase di esecuzione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">Questo avviso viene visualizzato quando prova a chiamare un metodo, una proprietà o un indicizzatore su un membro di una classe derivante da MarshalByRefObject e tale membro è un tipo valore. Il marshalling degli oggetti che ereditano da MarshalByRefObject viene in genere effettuato per riferimento in un dominio applicazione. Qualora un codice provi ad accedere direttamente al membro di tipo valore di tale oggetto in un dominio applicazione, si verificherà un'eccezione in fase di esecuzione. Per risolvere il problema, copiare innanzitutto il membro in una variabile locale e chiamare il metodo su tale variabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">Numero non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">Numero non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">Sintassi #pragma checksum non valida: dovrebbe essere #pragma checksum "nomefile" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">La sintassi del checksum della direttiva #pragma non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">È previsto un commento su una sola riga o la fine riga</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">Dopo la direttiva #pragma è previsto un commento su una sola riga o la fine riga</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">Sono stati specificati valori di checksum diversi per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">Sono stati assegnati valori di checksum diversi alla direttiva #pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">Il riferimento all'assembly '{0}' non è valido e non può essere risolto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">Il riferimento all'assembly non è valido e non può essere risolto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">Questo avviso indica che un attributo, ad esempio InternalsVisibleToAttribute, non è stato specificato correttamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Se il riferimento all'assembly '{0}' usato da '{1}' corrisponde all'identità '{2}' di '{3}', potrebbe essere necessario fornire i criteri di runtime</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Il riferimento all'assembly verrà considerato come corrispondente all'identità</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">I due assembly differiscono per versione e/o numero di versione. Per consentire l'unifocazione, è necessario specificare le direttive nel file config dell'applicazione e specificare il nome sicuro corretto di un assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">Se il riferimento all'assembly '{0}' usato da '{1}' corrisponde all'identità '{2}' di '{3}', potrebbe essere necessario fornire i criteri di runtime</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">Il riferimento all'assembly verrà considerato come corrispondente all'identità</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">I due assembly differiscono per versione e/o numero di versione. Per consentire l'unifocazione, è necessario specificare le direttive nel file config dell'applicazione e specificare il nome sicuro corretto di un assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">Sono stati importati più assembly con identità equivalenti: '{0}' e '{1}'. Rimuovere uno dei riferimenti duplicati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">Un assembly con lo stesso nome semplice '{0}' è già stato importato. Provare a rimuovere uno dei riferimenti, ad esempio '{1}', oppure firmarli per consentire l'affiancamento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">L'assembly '{0}' con identità '{1}' usa '{2}' la cui versione è successiva a quella dell'assembly '{3}' a cui viene fatto riferimento con identità '{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">L'accesso ai buffer a dimensione fissa è consentito solo tramite variabili locali o campi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">Il commento XML contiene un tag typeparam duplicato per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">Il commento XML contiene un tag typeparam duplicato</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Il commento XML ha un tag typeparam per '{0}', ma non esiste nessun parametro di tipo con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">Il commento XML ha un tag typeparam, ma non esiste nessun parametro di tipo con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">Il commento XML in '{1}' ha un tag typeparamref per '{0}', ma non esiste nessun parametro di tipo con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">Il commento XML ha un tag paramref, ma non esiste nessun parametro di tipo con questo nome</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">Il parametro di tipo '{0}', diversamente da altri parametri di tipo, non contiene tag typeparam corrispondenti nel commento XML per '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">Il parametro di tipo, diversamente da altri parametri di tipo, non contiene tag typeparam corrispondenti nel commento XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': il tipo deve essere '{2}' in modo che corrisponda al membro '{1}' sottoposto a override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">Non utilizzare l'attributo 'System.Runtime.CompilerServices.FixedBuffer'. Utilizzare il modificatore di campo 'fixed'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">Assegnazione fatta alla stessa variabile. Si intendeva assegnare qualcos'altro?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">Assegnazione fatta alla stessa variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">Confronto effettuato con la stessa variabile. Si intendeva confrontare qualcos'altro?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">Confronto effettuato con la stessa variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">Si è verificato un errore durante l'apertura del file di risorse Win32 '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">L'espressione determinerà sempre un'eccezione System.NullReferenceException perché il valore predefinito di '{0}' è Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">L'espressione determinerà sempre un'eccezione System.NullReferenceException perché il valore predefinito del tipo è Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">La classe '{0}' non può contenere più classi base: '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">La classe base '{0}' deve precedere le interfacce</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">Il commento XML contiene l'attributo cref '{0}' che fa riferimento a un parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">Il commento XML contiene l'attributo cref che fa riferimento a un parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Il riferimento all'assembly Friend {0} non è valido. Nelle dichiarazioni InternalsVisibleTo non è possibile specificare la versione, le impostazioni cultura, il token di chiave pubblica o l'architettura del processore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Il riferimento {0} all'assembly Friend non è valido. Gli assembly firmati con nome sicuro devono specificare una chiave pubblica nelle rispettive dichiarazioni InternalsVisibleTo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">Non è possibile associare il delegato a '{0}' perché è un membro di 'System.Nullable&lt;T&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'{0}' non contiene un costruttore che accetta argomenti {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">Gli attributi di modulo e assembly devono precedere tutti gli altri elementi definiti in un file ad eccezione delle clausole using e delle dichiarazioni di alias extern</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">È prevista l'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">La versione {0} non è valida per /subsystemversion. La versione deve essere 6.02 o successiva per ARM o AppContainerExe e 4.00 o successiva negli altri casi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">Il metodo di interoperabilità incorporato '{0}' contiene un corpo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be zero or greater</source>
        <target state="translated">Il livello di avviso deve essere maggiore o uguale a zero</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">L'opzione '{0}' non è valida per /debug. Specificare 'portable', 'embedded', 'full' o 'pdbonly'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">L'opzione '{0}' non è valida. La visibilità della risorsa deve essere 'public' o 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">Il tipo dell'argomento dell'attributo DefaultParameterValue deve corrispondere al tipo del parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">L'argomento di tipo '{0}' non è applicabile per l'attributo DefaultParameterValue</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">Inizializzazione del membro '{0}' duplicata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">Non è possibile inizializzare il membro '{0}'. Non è un campo o una proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">Non è possibile assegnare la proprietà o il campo statico '{0}' in un inizializzatore di oggetti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Non è possibile assegnare i membri del campo di sola lettura '{0}' di tipo '{1}' con un inizializzatore di oggetto perché è di un tipo di valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">Non è possibile assegnare i membri della proprietà '{0}' di tipo '{1}' con un inizializzatore di oggetto perché è di un tipo valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">Non è possibile usare il tipo unsafe '{0}' nella creazione di oggetti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">L'inizializzatore di elementi non può essere vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">La firma per l'elemento inizializzatore nella migliore corrispondenza del metodo di overload per '{0}' non è corretta. Il metodo Add inizializzabile deve essere un metodo di istanza accessibile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">Non è possibile inizializzare il tipo '{0}' con un inizializzatore di raccolta perché non implementa 'System.Collections.IEnumerable'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">L'opzione /win32manifest per il modulo verrà ignorata perché si applica solo agli assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">L'opzione /win32manifest per il modulo verrà ignorata perché si applica solo agli assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'{0}' non contiene una definizione per '{1}' e il miglior overload '{2}' del metodo di estensione richiede un ricevitore di tipo '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">La variabile di intervallo '{0}' è già stata dichiarata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">La variabile di intervallo '{0}' è in conflitto con una dichiarazione precedente di '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">Non è possibile assegnare {0} a una variabile di intervallo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">Non è stata trovata un'implementazione del modello di query per il tipo di origine '{0}'. '{1}' non è presente. Provare a specificare in modo esplicito il tipo della variabile di intervallo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</source>
        <target state="translated">Non è stata trovata alcuna implementazione del modello di query per il tipo di origine '{0}'. '{1}' non è presente. Mancano i riferimenti all'assembly richiesti oppure una direttiva using per 'System.Linq'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">Non è stata trovata un'implementazione di un modello di query per il tipo di origine '{0}'. '{1}' non è presente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Il nome '{0}' non si trova nell'ambito a sinistra di 'equals'. Provare a invertire le espressioni ai lati di 'equals'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">Il nome '{0}' non si trova nell'ambito a destra di 'equals'. Provare a invertire le espressioni ai lati di 'equals'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">Non è possibile passare la variabile di intervallo '{0}' come parametro out o ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">Sono state trovate più implementazioni del modello di query per il tipo di origine '{0}'. Chiamata ambigua a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Il tipo di una delle espressioni nella clausola {0} non è corretto. L'inferenza del tipo non è riuscita nella chiamata a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">Il tipo dell'espressione nella clausola {0} non è corretto. L'inferenza del tipo non è riuscita nella chiamata a '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">Un'espressione di tipo '{0}' non è consentita in una clausola from successiva in un'espressione di query con tipo di origine '{1}'. L'inferenza del tipo non è riuscita nella chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">Un albero delle espressioni non può contenere un'operazione di puntatore unsafe</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione di metodo anonimo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">Non è possibile convertire un'espressione di metodo anonimo in un albero delle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">Non è possibile assegnare la variabile di intervallo '{0}'. È di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">La variabile di intervallo '{0}' non può avere lo stesso nome di un parametro di tipo del metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">Impossibile utilizzare la parola chiave contestuale 'var' in una dichiarazione di variabile di intervallo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">Il miglior metodo Add di overload '{0}' per l'inizializzatore di raccolta presenta alcuni argomenti non validi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere un parametro in, out o ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere un metodo con argomenti variabili</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">Non è possibile usare la migliore corrispondenza '{0}' del metodo di overload per l'elemento inizializzatore di raccolta. I metodi 'Add' dell'inizializzatore di raccolta non possono avere parametri out o ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">Non è possibile usare come metodo il membro non richiamabile '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">Il membro '{0}' implementa il membro di interfaccia '{1}' nel tipo '{2}'. In fase di esecuzione sono presenti più corrispondenze del membro di interfaccia. Il metodo che verrà chiamato dipende dall'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">Il membro implementa il membro di interfaccia con più corrispondenze in fase di esecuzione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">Questo avviso può essere visualizzato quando due metodi di interfaccia si differenziano solo per il fatto che un determinato parametro sia contrassegnato con ref o con out. È consigliabile modificare il codice per evitare la visualizzazione di questo avviso perché non è ovvio o garantito quale metodo venga effettivamente chiamato in fase di esecuzione.

Anche in C# viene fatta distinzione tra out e ref, in CLR questi metodi sono considerati uguali. Quando si decide il metodo che implementa l'interfaccia, in CLR ne viene semplicemente scelto uno.

Impostare il compilatore in modo tale da distinguere i metodi, ad esempio assegnando loro nomi diversi o specificando un parametro aggiuntivo per uno di essi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</source>
        <target state="translated">Il membro '{1}' esegue l'override di '{0}'. In fase di esecuzione sono presenti più candidati per l'override. Il metodo che verrà chiamato dipende dall'implementazione. Usare un runtime più recente.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">Il membro esegue l'override del membro di base con più candidati di override in fase di esecuzione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">Le espressioni dell'inizializzatore di oggetto e di raccolta non possono essere applicate a un'espressione di creazione del delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'{0}' è di tipo '{1}'. Il tipo specificato in una dichiarazione di costante deve essere sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, enum-type o reference-type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">Il file di origine '{0}' non è stato trovato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">Il file di origine '{0}' è specificato più volte</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">Il file di origine è specificato più volte</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">Manca la specifica del file per l'opzione '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">Errore nella sintassi della riga di comando: manca '{0}' per l'opzione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Opzione non riconosciuta: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">Non sono stati specificati file di origine.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">Non sono stati specificati file di origine</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">È previsto uno script (file con estensione csx) ma non ne è stato specificato nessuno</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">Si è verificato un errore durante l'apertura del file di risposta '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- {1}</source>
        <target state="translated">Non è possibile aprire '{0}' per la scrittura -- {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">'{0}' non è un numero di base dell'immagine valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'{0}' è un file binario e non un file di testo</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">La tabella codici '{0}' non è valida o non è installata</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">L'algoritmo '{0}' non è supportato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">Non è possibile specificare /main se si compila un modulo o una libreria</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">Il tipo di destinazione non è valido per /target. È necessario specificare 'exe', 'winexe', 'library' o 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">L'opzione /noconfig è stata ignorata perché è stata specificata in un file di risposta</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">L'opzione /noconfig è stata ignorata perché è stata specificata in un file di risposta</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">L'allineamento '{0}' della sezione del file non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">Nome di output non valido: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">Formato delle informazioni di debug non valido: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'La sintassi 'id#' non è più supportata. Usare '$id'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nome non valido per un simbolo di pre-elaborazione. '{0}' non è un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">Nome non valido per un simbolo di pre-elaborazione. Non è un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">Non è possibile creare il nome di file breve '{0}' se esiste già un nome di file lungo con lo stesso nome di file breve</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">Un'opzione /reference che dichiara un alias extern può avere un solo nome di file. Per specificare più alias o nomi di file, utilizzare più opzioni /reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">Errore nella sintassi della riga di comando: manca ':&lt;numero&gt;' per l'opzione '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">L'opzione /pdb richiede che venga specificata anche l'opzione /debug</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere una chiamata COM con argomenti privi di ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">Errore nella sintassi della riga di comando: il formato del GUID '{0}' non è valido per l'opzione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">Errore nella sintassi della riga di comando: manca il GUID per l'opzione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">I metodi con argomenti variabili non sono conformi alle specifiche CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">I metodi con argomenti variabili non sono conformi alle specifiche CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">Il tipo dell'argomento '{0}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">Il tipo dell'argomento non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">Il tipo restituito di '{0}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">Il tipo restituito non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">Il tipo '{0}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">Il tipo non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">Una variabile public, protected o protected internal deve essere di tipo conforme a CLS (Common Language Specification).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">L'identificatore '{0}' che differisce solo per l'uso di caratteri maiuscoli o minuscoli non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">L'identificatore che differisce solo per l'uso di caratteri maiuscoli o minuscoli non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Il metodo di overload '{0}' che differisce solo per out o ref o per numero di dimensioni della matrice non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">Il metodo di overload, che differisce solo per out o ref o per numero di dimensioni della matrice, non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Il metodo di overload '{0}' che differisce solo per i tipi matrice senza nome non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">Il metodo di overload, che differisce solo per i tipi matrice senza nome, non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">Questo errore si verifica quando si usa un metodo di overload che accetta una matrice irregolare e le firme del metodo si differenziano solo per il tipo di elemento della matrice. Per evitare questo errore, provare a usare una matrice rettangolare invece di una irregolare, aggiungere un parametro in modo da evitare ambiguità nella chiamata della funzione oppure rinominare uno o più metodi di overload. In alternativa, se la compatibilità con CLS non è necessaria, rimuovere l'attributo CLSCompliantAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">L'identificatore '{0}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">L'identificatore non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}': il tipo di base '{1}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">Il tipo di base non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">In un assembly contrassegnato come conforme a CLS (Common Language Specification) è stato specificato un tipo di base non conforme a CLS. Rimuovere l'attributo che contrassegna l'assembly come conforme a CLS oppure l'attributo che indica il tipo come non conforme a CLS.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'{0}': le interfacce compatibili con CLS devono avere solo membri conformi a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">Le interfacce compatibili con CLS devono contenere solo membri conformi a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'{0}': solo i membri conformi a CLS possono essere di tipo abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">Solo i membri conformi a CLS possono essere di tipo abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Per abilitare il controllo di conformità a CLS, è necessario specificare l'attributo CLSCompliant nell'assembly, non nel modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">Per abilitare il controllo di conformità a CLS, è necessario specificare l'attributo CLSCompliant nell'assembly, non nel modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">I moduli aggiunti devono essere contrassegnati con l'attributo CLSCompliant per corrispondere all'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">I moduli aggiunti devono essere contrassegnati con l'attributo CLSCompliant per corrispondere all'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'{0}' non può essere contrassegnato come conforme a CLS perché l'assembly non ha un attributo CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Il tipo o il membro non può essere contrassegnato come conforme a CLS perché l'assembly non ha un attributo CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'{0}' non ha costruttori accessibili che usano solo tipi conformi a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">Il tipo non contiene costruttori accessibili che usano solo tipi conformi a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">L'utilizzo di matrici come argomenti di attributi non è conforme alle specifiche CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">L'utilizzo di matrici come argomenti di attributi non è conforme alle specifiche CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Impossibile specificare l'attributo CLSCompliant su un modulo che differisce dall'attributo CLSCompliant sull'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">Impossibile specificare l'attributo CLSCompliant su un modulo che differisce dall'attributo CLSCompliant sull'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'Non è possibile contrassegnare '{0}' come conforme a CLS perché è un membro del tipo non conforme a CLS '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">Non è possibile contrassegnare il tipo come conforme a CLS perché è un membro del tipo non conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">Il controllo di conformità a CLS non verrà eseguito in '{0}' perché non è visibile all'esterno dell'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">Il controllo di conformità a CLS non verrà eseguito perché non è visibile all'esterno dell'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'{0}' non necessita di un attributo CLSCompliant perché l'assembly non ha un attributo CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">Il tipo o il membro non necessita di un attributo CLSCompliant perché l'assembly non ha un attributo CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">L'attributo CLSCompliant non ha significato quando applicato a parametri. Provare ad applicarlo al metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">L'attributo CLSCompliant non ha significato quando applicato a parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">L'attributo CLSCompliant non ha significato quando applicato a tipi restituiti. Provare ad applicarlo al metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">L'attributo CLSCompliant non ha significato quando applicato a tipi restituiti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">Il tipo di vincolo '{0}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">Il tipo di vincolo non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">Il campo conforme a CLS '{0}' non può essere volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">Il campo conforme a CLS non può essere volatile</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}' non è conforme a CLS perché l'interfaccia di base '{1}' non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">Il tipo non è conforme a CLS perché l'interfaccia di base non è conforme a CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">Con 'await' il tipo {0} deve essere associato a un metodo 'GetAwaiter' appropriato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">Non è possibile attendere '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">Con 'await' il tipo restituito '{0}' di '{1}.GetAwaiter()' deve essere associato a membri 'IsCompleted', 'OnCompleted' e 'GetResult' appropriati e implementare 'INotifyCompletion' o 'ICriticalNotifyCompletion'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">Con 'await' il tipo '{0}' deve essere associato a un metodo 'GetAwaiter' appropriato. Manca una direttiva using per 'System'?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">Non è possibile attendere 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'Non è possibile usare 'await' come identificatore all'interno di un metodo asincrono o di un'espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'{0}' non implementa '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression</source>
        <target state="translated">Poiché '{0}' è un metodo asincrono che restituisce '{1}', una parola chiave di restituzione non deve essere seguita da un'espressione di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">Il tipo restituito di un metodo asincrono deve essere void, Task, Task&lt;T&gt;, un tipo simile a Task, IAsyncEnumerable&lt;T&gt; o IAsyncEnumerator&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">Non è possibile restituire un'espressione di tipo 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">__arglist non è consentito nell'elenco di parametri di metodi asincroni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>Instance of type '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Non è possibile mantenere l'istanza di tipo '{0}' tra i limiti 'await' o 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have pointer type parameters</source>
        <target state="translated">I metodi asincroni non possono avere parametri di tipo puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">I metodi asincroni non possono avere parametri in, our o ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">L'operatore 'await' può essere usato solo quando è contenuto in un metodo o un'espressione lambda contrassegnata con il modificatore 'async'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">L'operatore 'await' può essere usato solo all'interno di un {0} asincrono. Contrassegnare questo {0} con il modificatore 'async'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">L'operatore 'await' può essere usato solo all'interno di un metodo asincrono. Provare a contrassegnare questo metodo con il modificatore 'async' e modificare il tipo restituito su 'Task&lt;{0}&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">L'operatore 'await' può essere usato solo all'interno di un metodo asincrono. Provare a contrassegnare questo metodo con il modificatore 'async' e modificare il tipo restituito su 'Task'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">Non è possibile includere un elemento await nel corpo di una clausola finally</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">Non è possibile includere un elemento await in una clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">Non è possibile includere un elemento await nell'espressione di filtro di una clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">Non è possibile includere un elemento await nel corpo di un'istruzione lock</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">Non è possibile usare l'operatore 'await' in un inizializzatore di variabile script statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">Non è possibile attendere in un contesto non sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">Il modificatore 'async' può essere usato solo nei metodi con un corpo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">Non è possibile applicare l'attributo di sicurezza '{0}' a un metodo Async</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">I metodi asincroni non sono consentiti in un'interfaccia, una classe o una struttura che ha l'attributo 'SecurityCritical' o 'SecuritySafeCritical'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">È possibile usare l'operatore 'await' solo in espressioni di query all'interno della prima espressione di raccolta della clausola 'from' iniziale o all'interno dell'espressione di raccolta di una clausola 'join'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">Non è possibile attendere la chiamata, pertanto l'esecuzione del metodo corrente continuerà prima del completamento della chiamata. Provare ad applicare l'operatore 'await' al risultato della chiamata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">Non è possibile attendere la chiamata, pertanto l'esecuzione del metodo corrente continuerà prima del completamento della chiamata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">Il metodo corrente chiama un metodo asincrono che restituisce un elemento Task o Task&lt;TResult&gt; e non applica l'operatore await al risultato. La chiamata al metodo asincrono avvia un'attività asincrona. Dal momento, però, che non viene applicato alcun operatore await, l'esecuzione del programma continua senza attendere il completamento dell'attività. Nella maggior parte dei casi questo non è il comportamento previsto. In genere, altri aspetti del metodo chiamante dipendono dai risultati della chiamata o è almeno previsto che il metodo chiamato venga completato prima del termine del metodo che contiene la chiamata.

Un aspetto ugualmente importante è costituito dalla gestione delle eccezioni generate nel metodo asincrono chiamato. Un'eccezione generata in un metodo che restituisce un elemento Task o Task&lt;TResult&gt; viene archiviata nell'attività restituita. Se non si attende l'attività o si verifica esplicitamente la presenza di eccezioni, l'eccezione viene persa. Se si attende l'attività, l'eccezione viene nuovamente generata.

Come procedura consigliata, è consigliabile attendere sempre la chiamata.

È opportuno eliminare l'avviso solo se si è certi che non si vuole attendere il completamento della chiamata asincrona e che il metodo chiamato non genera alcuna eccezione. In tal caso, è possibile eliminare l'avviso assegnando il risultato dell'attività della chiamata a una variabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'Non è possibile applicare 'MethodImplOptions.Synchronized' a un metodo asincrono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Non è possibile applicare CallerLineNumberAttribute perché non sono disponibili conversioni standard dal tipo '{0}' al tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Non è possibile applicare CallerFilePathAttribute perché non sono presenti conversioni standard dal tipo '{0}' al tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">Non è possibile applicare CallerMemberNameAttribute perché non sono disponibili conversioni standard dal tipo '{0}' al tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute può essere applicato solo a parametri con valori predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute può essere applicato solo a parametri con valori predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute può essere applicato solo a parametri con valori predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute applicato al parametro '{0}' non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">L'elemento CallerFilePathAttribute applicato al parametro '{0}' non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">L'elemento CallerFilePathAttribute non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute applicato al parametro '{0}' non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute non avrà alcun effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">Il programma non contiene un metodo 'Main' statico appropriato per un punto di ingresso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">È previsto un inizializzatore di matrice di lunghezza '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">È previsto un inizializzatore di matrice annidato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">Il modificatore di varianza non è valido. Si possono specificare come varianti solo i parametri di tipo interfaccia o delegato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">Uso imprevisto di un nome con alias</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">Uso imprevisto di un nome generico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">Uso imprevisto di un nome generico non associato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">Espressioni e istruzioni possono essere usate solo in un corpo del metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">Un accesso a matrice non può includere un identificatore di argomento denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">I parametri predefiniti non sono validi in questo contesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">Si è verificato un errore durante l'apertura del file icona {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">Si è verificato un errore durante l'apertura del file manifesto Win32 {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Si è verificato un errore durante la compilazione delle risorse Win32 - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">I parametri facoltativi devono trovarsi dopo tutti i parametri obbligatori</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">Non è possibile ereditare l'interfaccia '{0}' con i parametri di tipo specificato perché in tal caso il metodo '{1}' conterrebbe overload diversi solo in ref e out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">Le dichiarazioni parziali di '{0}' devono avere gli stessi nomi di parametro di tipo e modificatori di varianza nello stesso ordine</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">Varianza non valida: il parametro di tipo '{1}' deve essere {3} valido in '{0}'. '{1}' è {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'{0}': non è possibile derivare dal tipo dinamico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'{0}': non è possibile implementare un'interfaccia dinamica '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">Il vincolo non può essere il tipo dinamico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">Il vincolo non può essere un tipo dinamico '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">Non sono stati trovati uno o più tipi necessari per compilare un'espressione dinamica. Probabilmente manca un riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">Il nome '{0}' supera la lunghezza massima consentita nei metadati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">Gli attributi non sono validi in questo contesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'extern alias' non è valido in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">L'uso di '{0}' per la verifica della compatibilità con '{1}' corrisponde in sostanza alla verifica della compatibilità con '{2}' e verrà completato per tutti i valori non Null</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">L'uso di 'is' per la verifica della compatibilità con 'dynamic' corrisponde in sostanza alla verifica della compatibilità con 'Object'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">Non è possibile usare 'yield' nel codice script di primo livello</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">Non è possibile dichiarare lo spazio dei nomi nel codice script</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">Gli attributi di assembly e modulo non sono consentiti in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">Il delegato '{0}' non ha metodi Invoke oppure ha un metodo Invoke con un tipo restituito o tipi di parametro non supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global code; ignoring '{0}' entry point.</source>
        <target state="translated">Il punto di ingresso del programma è codice globale. Il punto di ingresso '{0}' verrà ignorato.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global code; ignoring entry point</source>
        <target state="translated">Il punto di ingresso del programma è codice globale. Il punto di ingresso verrà ignorato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">Accessibilità incoerente: il tipo di evento '{1}' è meno accessibile di '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">Le specifiche di argomenti denominati devono trovarsi dopo tutti gli argomenti fissi specificati. Usare la versione {0} o versioni successive del linguaggio per consentire argomenti denominati non finali.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">In una chiamata dinamica le specifiche di argomenti denominati devono trovarsi dopo tutti gli argomenti fissi specificati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Il miglior overload per '{0}' non ha un parametro denominato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">Il delegato '{0}' non ha un parametro denominato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">Non è possibile specificare più volte l'argomento denominato '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">L'argomento denominato '{0}' specifica un parametro per il quale è già stato fornito un argomento posizionale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">L'argomento denominato '{0}' viene usato nella posizione errata ma è seguito da un argomento non denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">Impossibile specificare un valore di parametro predefinito insieme a DefaultParameterAttribute o OptionalAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">Il valore di parametro predefinito per '{0}' deve essere una costante in fase di compilazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">Un parametro out o ref non può avere un valore predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">Impossibile specificare un valore predefinito per il parametro 'this'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter collection</source>
        <target state="translated">Impossibile specificare un valore predefinito per una raccolta di parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">Non è possibile usare un valore di tipo '{0}' come parametro predefinito. Non sono disponibili conversioni standard nel tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">Non è possibile usare un valore di tipo '{0}' come parametro predefinito per il parametro nullable '{1}' perché '{0}' non è un tipo semplice</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'{0}' è di tipo '{1}'. Un valore di parametro predefinito di un tipo riferimento non stringa può essere inizializzato solo con Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Il valore predefinito specificato per il parametro '{0}' non avrà effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">Il valore predefinito specificato non avrà effetto perché si applica a un membro usato in contesti che non consentono argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">Si è verificato un errore durante la firma dell'output con la chiave pubblica del file '{0}' - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">Si è verificato un errore durante la firma dell'output con la chiave pubblica del contenitore '{0}' - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">Non è possibile usare l'operatore typeof nel tipo dinamico</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">Un albero delle espressioni non può contenere un'operazione dinamica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">Le espressioni lambda asincrone non possono essere convertite in alberi delle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Non è possibile definire una classe o un membro che usa 'dynamic' perché non è stato trovato il tipo '{0}' richiesto dal compilatore. Probabilmente manca un riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">Non è possibile passare Null per il nome assembly Friend</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">Nel file di chiave '{0}' manca la chiave privata necessaria per la firma</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">È stata specificata la firma pubblica per la quale è necessaria una chiave pubblica, che però non è stata specificata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">La firma pubblica non è supportata per gli elementi netmodule.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">È stata specificata la firma ritardata per la quale è necessaria una chiave pubblica che però non è stata specificata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">È stata specificata la firma ritardata per la quale è necessaria una chiave pubblica che però non è stata specificata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">La stringa di versione specificata '{0}' non è conforme al formato richiesto: principale[.secondaria[.build[.revisione]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">La stringa di versione specificata '{0}' contiene caratteri jolly e questo non è compatibile con il determinismo. Rimuovere i caratteri jolly dalla stringa di versione o disabilitare il determinismo per questa compilazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">La stringa di versione specificata '{0}' non è conforme al formato richiesto: principale.secondaria.build.revisione (senza caratteri jolly)</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">La stringa di versione specificata '{0}' non è conforme al formato consigliato: principale.secondaria.build.revisione</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">La stringa di versione specificata non è conforme al formato consigliato: principale.secondaria.build.revisione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">I file eseguibili non possono essere assembly satellite. Il campo relativo alle impostazioni cultura deve essere sempre vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</source>
        <target state="translated">Non è stato specificato alcun argomento corrispondente al parametro obbligatorio '{0}' di '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">L'opzione '{0}' della riga di comando non è ancora implementata ed è stata ignorata.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">L'opzione della riga di comando non è ancora implementata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">Non è stato possibile creare il modulo '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Non è possibile usare la variabile locale fissa '{0}' in un metodo anonimo, in un'espressione lambda o in un'espressione di query</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">L'albero delle espressioni non può contenere una specifica di argomento denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">Un albero delle espressioni non può contenere una chiamata che usa argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">L'albero delle espressioni non può contenere una proprietà indicizzata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">La proprietà indicizzata '{0}' include argomenti non facoltativi che devono essere specificati</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">La proprietà indicizzata '{0}' deve includere tutti argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">L'istanza di tipo '{0}' non può essere usata all'interno di una funzione annidata, un'espressione di query, un blocco iteratore o un metodo asincrono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">Il primo argomento di un attributo di sicurezza deve essere un elemento SecurityAction valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">L'attributo di sicurezza '{0}' ha un valore SecurityAction '{1}' non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">Il valore '{0}' di SecurityAction non è valido per gli attributi di sicurezza applicati a un assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">Il valore '{0}' di SecurityAction non è valido per gli attributi di sicurezza applicati a un tipo o a un metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">Il valore '{0}' di SecurityAction non è valido per l'attributo PrincipalPermission</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">Un albero delle espressioni non può contenere '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">Non è possibile risolvere il percorso del file '{0}' specificato per l'argomento denominato '{1}' per l'attributo PermissionSet</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">Si è verificato un errore durante la lettura del file '{0}' specificato per l'argomento denominato '{1}' per l'attributo PermissionSet: '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">Il nome di tipo '{0}' non è stato trovato nello spazio dei nomi globale. Il tipo è stato inoltrato all'assembly '{1}'. Provare ad aggiungere un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">Il nome di tipo '{0}' non è stato trovato nello spazio dei nomi '{1}'. Il tipo è stato inoltrato all'assembly '{2}'. Provare ad aggiungere un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">Il nome di tipo '{0}' non è stato trovato. Il tipo è stato inoltrato all'assembly '{1}'. Provare ad aggiungere un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">Gli assembly '{0}' e '{1}' fanno riferimento agli stessi metadati ma solo uno è un riferimento collegato (specificato con l'opzione /link). Provare a rimuovere uno dei riferimenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">Il miglior metodo Add di overload '{0}' per l'elemento inizializzatore di raccolta è obsoleto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Il miglior metodo Add di overload per l'elemento inizializzatore di raccolta è obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Il miglior metodo Add di overload '{0}' per l'elemento inizializzatore di raccolta è obsoleto. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">Il miglior metodo Add di overload per l'elemento inizializzatore di raccolta è obsoleto</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">Il miglior metodo Add di overload '{0}' per l'elemento inizializzatore di raccolta è obsoleto. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">L'attributo di sicurezza '{0}' non è valido in questo tipo di dichiarazione. Gli attributi di sicurezza sono validi solo in dichiarazioni di metodo, assembly e tipi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">Non è possibile usare un'espressione di tipo '{0}' come argomento per un'operazione inviata dinamicamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">Non è possibile usare un'espressione lambda come argomento per un'operazione inviata dinamicamente senza prima eseguire il cast a un tipo di albero delle espressioni o di delegato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">Non è possibile usare un metodo di gruppo come argomento per un'operazione inviata dinamicamente. Si intendeva richiamare il metodo?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">Non è possibile eseguire l'invio dinamico richiesto della chiamata al metodo '{0}' perché fa parte di un'espressione di accesso di base. Provare a eseguire il cast degli argomenti dinamici o a eliminare l'accesso di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">Non sono consentite espressioni di query sul tipo di origine 'dynamic' o con una sequenza di join di tipo 'dynamic'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">L'accesso all'indicizzatore deve essere inviato dinamicamente. Tuttavia, non è possibile perché fa parte di un'espressione di accesso di base. Provare a eseguire il cast degli argomenti dinamici o a eliminare l'accesso di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">La chiamata al metodo '{0}' inviata in modo dinamico potrebbe non riuscire in fase di esecuzione perché uno o più overload applicabili sono metodi condizionali.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">La chiamata inviata in modo dinamico potrebbe non riuscire in fase di esecuzione perché uno o più overload applicabili sono metodi condizionali</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">'{0}' non contiene alcun metodo applicabile denominato '{1}' ma apparentemente include un metodo di estensione con tale nome. I metodi di estensione non possono essere inviati dinamicamente. Provare a eseguire il cast degli argomenti dinamici o a chiamare il metodo di estensione senza la relativa sintassi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">CallerMemberNameAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerMemberNameAttribute non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">CallerMemberNameAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerMemberNameAttribute non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">CallerFilePathAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerFilePathAttribute non avrà alcun effetto. CallerLineNumberAttribute ne eseguirà l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must not be an interface and must define operator '{1}'.</source>
        <target state="needs-review-translation">L'espressione deve essere convertibile in modo implicito in un valore booleano oppure il relativo tipo '{0}' deve definire l'operatore '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'{0}' non può implementare '{1}' perché '{2}' è un evento Windows Runtime e '{3}' è un evento .NET normale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">Non è possibile incorporare il tipo di interoperabilità '{0}'. Usare l'interfaccia applicabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Non è possibile incorporare il tipo '{0}' perché è un tipo annidato. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Non è possibile incorporare il tipo '{0}' perché contiene un argomento generico. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">Lo struct di interoperabilità incorporato '{0}' può contenere solo campi di istanza pubblici.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Un evento Windows Runtime non può essere passato come parametro out o ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">Nell'interfaccia di origine '{0}' manca il metodo '{1}' necessario per incorporare l'evento '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">L'interfaccia '{0}' contiene un'interfaccia di origine non valida che è necessaria per incorporare l'evento '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">Non è possibile incorporare il tipo di interoperabilità '{0}' perché manca l'attributo obbligatorio '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">Non è possibile incorporare i tipi di interoperabilità dall'assembly '{0}' perché manca l'attributo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">Non è possibile incorporare i tipi di interoperabilità dall'assembly '{0}' perché manca l'attributo '{1}' o '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">Non è possibile incorporare il tipo di interoperabilità '{0}' trovato negli assembly '{1}' e '{2}'. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su False.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">L'incorporamento del tipo di interoperabilità '{0}' dall'assembly '{1}' causa un conflitto di nomi nell'assembly corrente. Provare a impostare la proprietà 'Incorpora tipi di interoperabilità' su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">È stato creato un riferimento all'assembly di interoperabilità '{0}' incorporato a causa di un riferimento indiretto a tale assembly creato dall'assembly '{1}'. Provare a modificare la proprietà 'Incorpora tipi di interoperabilità' in uno degli assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">È stato creato un riferimento all'assembly di interoperabilità incorporato a causa di un riferimento indiretto a tale assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">Per aggiungere un riferimento a un assembly, è stato usato /link (proprietà Incorpora tipi di interoperabilità impostata su True). Questo parametro indica al compilatore di incorporare le informazioni sui tipi di interoperabilità da tale assembly. Il compilatore non è però in grado di incorporare tali informazioni dall'assembly perché anche un altro assembly a cui viene fatto riferimento fa riferimento a tale assembly tramite /reference (proprietà Incorpora tipi di interoperabilità impostata su False).

Per incorporare le informazioni sui tipi di interoperabilità per entrambi gli assembly, usare /link per i riferimenti ai singoli assembly (impostare la proprietà Incorpora tipi di interoperabilità su True).

Per rimuovere l'avviso, è invece possibile usare /reference (impostare la proprietà Incorpora tipi di interoperabilità su False). In questo caso, le informazioni sui tipi di interoperabilità verranno fornite da un assembly di interoperabilità primario.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">Non è possibile usare il tipo '{0}' dell'assembly '{1}' tra limiti di assembly perché contiene un argomento tipo generico che corrisponde a un tipo di interoperabilità incorporato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">Il tipo di interoperabilità corrispondente al tipo di interoperabilità incorporato '{0}' non è stato trovato. Probabilmente manca un riferimento all'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">Il nome modulo '{0}' memorizzato in '{1}' deve corrispondere al relativo nome di file.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">Nome di modulo non valido: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">Il valore di '{0}' non è valido: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath deve essere assoluto.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">L'attributo '{0}' del modulo '{1}' verrà ignorato e verrà usata l'istanza presente nell'origine</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">L'attributo verrà ignorato e verrà usata l'istanza presente nell'origine</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">L'attributo '{0}' specificato in un file di origine è in conflitto con l'opzione '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">Un buffer fisso può avere una sola dimensione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">L'assembly '{0}' al quale si fa riferimento non ha un nome sicuro.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">L'assembly di riferimento non ha un nome sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">La chiave pubblica di firma specificata in AssemblySignatureKeyAttribute non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Il tipo '{0}' esportato dal modulo '{1}' è in conflitto con il tipo dichiarato nel modulo primario di questo assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Il tipo '{0}' esportato dal modulo '{1}' è in conflitto con il tipo '{2}' esportato dal modulo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">Il tipo inoltrato '{0}' è in conflitto con il tipo dichiarato nel modulo primario di questo assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">Il tipo '{0}' inoltrato all'assembly '{1}' è in conflitto con il tipo '{2}' inoltrato all'assembly '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">Il tipo '{0}' inoltrato all'assembly '{1}' è in conflitto con il tipo '{2}' esportato dal modulo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">Le impostazioni cultura dell'assembly '{0}' al quale si fa riferimento sono diverse da '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">Le impostazioni cultura dell'assembly di riferimento sono diverse</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">Un assembly agnostico non può avere un modulo '{0}' specifico del processore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">L'assembly e il modulo '{0}' non possono essere destinati a processori diversi.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">L'assembly '{0}' a cui si fa riferimento ha come destinazione un processore diverso.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">L'assembly di riferimento ha come destinazione un processore diverso</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">Si è verificato un errore di crittografia durante la creazione di hash.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">Manca il riferimento al netmodule '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">Il modulo '{0}' è già definito in questo assembly. Ogni modulo deve avere un nome di file univoco.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">Non è possibile leggere il file di configurazione '{0}' - '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">Non è possibile continuare perché la modifica include un riferimento a un tipo incorporato: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">Il membro '{0}' aggiunto durante la sessione di debug corrente è accessibile solo dall'interno dell'assembly '{1}' in cui viene dichiarato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">Non è possibile specificare contemporaneamente le opzioni di compilazione '{0}' e '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">I metadati del netmodule collegato devono fornire un'immagine PE completa: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred può essere usato solo con /t:exe, /t:winexe e /t:appcontainerexe</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;elenco percorsi&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;testo&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">operatore di propagazione Null</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">metodo con corpo di espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">proprietà con corpo di espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">indicizzatore con corpo di espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">inizializzatore di proprietà automatica</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;spazio dei nomi&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">variabili locali e valori restituiti per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">riferimenti di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">struct ref</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">Compilazione (C#): </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">Il nodo Syntax non è compreso nell'albero della sintassi</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Per offrire una qualifica minima del tipo, è necessario specificare Position.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">Per offrire una qualifica minima del tipo, è necessario specificare SyntaxTreeSemanticModel.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">Non è possibile fare riferimento alla compilazione di tipo '{0}' dalla compilazione di {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">L'albero della sintassi è già presente</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">L'invio può includere solo codice script.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">L'invio può avere al massimo un albero della sintassi.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">l'albero deve avere un nodo radice con SyntaxKind.CompilationUnit</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">L'argomento di tipo non può essere Null</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">Il numero di argomenti di tipo è errato</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">Conflitto tra nomi per il nome {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions contiene una combinazione di opzioni non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">elementi: non deve essere vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Usare Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier o Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier per creare token di identificatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Usare Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal per creare token letterali di tipo carattere.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Usare Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal per creare token letterali di tipo numerico.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">Questo metodo può essere usato solo per creare token - {0} non è un tipo di token.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">Il parametro generico corrisponde alla definizione mentre dovrebbe essere il riferimento {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">È stato chiamato GetDeclarationName per un nodo di dichiarazione che può contenere più dichiarazioni di variabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">Position non è compreso nell'albero della sintassi con full span {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">Il nome del linguaggio '{0}' non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">Il nome del linguaggio non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">L'accesso al membro identificatore trasparente non è riuscito per il campo '{0}' di '{1}'. I dati su cui eseguire la query implementano il modello di query?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">Il parametro ha più valori predefiniti distinct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">Il campo ha più valori costanti distinct.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">Negli attributi cref è necessario qualificare i tipi annidati di tipi generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">Negli attributi cref è necessario qualificare i tipi annidati di tipi generici</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">Non è un simbolo di C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">Direttiva Using non necessaria.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">Alias extern non usato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">Gli elementi non possono essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">variabile di ambiente LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">opzione /LIB</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">opzione /REFERENCEPATH</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">la directory non esiste</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">il percorso è troppo lungo o non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">Non è stato trovato un valore per RuntimeMetadataVersion. Non è presente un assembly che contiene System.Object oppure tramite le opzioni non è stato specificato un valore per RuntimeMetadataVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">Non sono stati trovati valori per RuntimeMetadataVersion</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">È previsto un elemento SemanticModel {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">espressione lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 1. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 2. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 3. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 4. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 5. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 6. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 7.0. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'experimental'</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">La posizione deve essere inclusa nello span dell'albero della sintassi.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">Il nodo della sintassi da prevedere non può appartenere a un albero della sintassi della compilazione corrente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">Il concatenamento del modello semantico speculativo non è supportato. È necessario creare un modello speculativo dal modello ParentModel non speculativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Compilatore Microsoft (R) Visual C#</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} versione {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Versioni del linguaggio supportate:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'{0}': una classe con l'attributo ComImport non può specificare inizializzatori di campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">Il nome locale '{0}' è troppo lungo per for PDB. Provare ad abbreviarlo oppure a compilare senza /debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">Il nome locale è troppo lungo per PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">La funzione anonima convertita in un delegato che restituisce un valore nullo non può restituire un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a '{0}' returning delegate cannot return a value</source>
        <target state="translated">L'espressione lambda asincrona convertita in un delegato che restituisce '{0}' non può restituire un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">Non è possibile creare un'istanza dell'analizzatore {0} da {1} : {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">Non è possibile creare un'istanza dell'analizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">L'assembly {0} non contiene analizzatori.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">L'assembly non contiene analizzatori</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">Non è possibile caricare l'assembly dell'analizzatore {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">Non è possibile caricare l'assembly dell'analizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">Alcuni tipi nell'assembly dell'analizzatore {0} verranno ignorati a causa di un'eccezione ReflectionTypeLoadException: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">Si è verificato un errore durante la lettura del file del set di regole {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">Si è verificato un errore durante la lettura delle informazioni di debug per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">L'operazione ha causato un overflow dello stack.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">È previsto un identificatore o un valore letterale.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">È previsto un identificatore o un valore letterale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties, or properties that use the 'field' keyword, can have initializers.</source>
        <target state="translated">Solo le proprietà implementate automaticamente o le proprietà che usano la parola chiave 'field' possono avere inizializzatori.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">Le proprietà implementate automaticamente devono avere funzioni di accesso get.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">Le proprietà implementate automaticamente devono sostituire tutte le funzioni di accesso della proprietà sostituita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">Non è possibile creare le informazioni di debug per un testo di origine senza codifica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">Non è possibile specificare sia corpi di blocchi che corpi di espressioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">Control non può uscire dall'opzione dall'etichetta case finale ('{0}')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere un operatore di propagazione Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere un inizializzatore di dizionario.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">Un metodo Add di estensione non è supportato per un inizializzatore di raccolta in un'espressione lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">operatore nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">inizializzatore di dizionario</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">Manca il delimitatore '}' di chiusura per l'espressione interpolata che inizia con '{'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">Espressione troppo lunga o complessa per essere compilata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">L'espressione non ha un nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">Non è possibile usare l'espressione secondaria in un argomento di nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">Un nome qualificato da alias non è un'espressione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">In un gruppo di metodi non sono consentiti parametri di tipo usati come argomento di 'nameof'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">È previsto SearchCriteria.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">Le stringhe delle impostazioni cultura dell'assembly potrebbero non contenere caratteri NUL incorporati.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">stringhe interpolate</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">await in blocchi catch e blocchi finally</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">valori letterali binari</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">separatori di cifra</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">funzioni locali</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">In una stringa interpolata è necessario specificare il carattere di escape di un carattere '{0}' raddoppiandolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">In una stringa interpolata è possibile specificare il carattere di escape di un carattere '{0}' raddoppiando '{0}{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">Un identificatore di formato non può contenere uno spazio vuoto finale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">Identificatore di formato vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">Un assembly di riferimento '{0}' contiene un errore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">È prevista l'istruzione di dichiarazione o l'espressione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">Come argomento di 'nameof' non sono consentiti gruppi di metodi di estensione.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">La grandezza del valore di allineamento {0} è maggiore di {1} e può comportare la creazione di una stringa formattata di grandi dimensioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">Alias extern non usato</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">Direttiva using non necessaria</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">Ignora il caricamento dei tipi nell'assembly dell'analizzatore che non riescono a causa di un'eccezione ReflectionTypeLoadException</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">La grandezza del valore di allineamento è tale da comportare la creazione di una stringa formattata di grandi dimensioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">La lunghezza della costante di stringa risultante dalla concatenazione supera il valore di System.Int32.MaxValue. Provare a dividere la stringa in più costanti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">La tupla deve contenere almeno due elementi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">Il punto di ingresso del debug deve essere una definizione di un metodo nella compilazione corrente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load è consentito solo negli script</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">Non è possibile usare #load dopo il primo token del file</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">Il file non è stato trovato.</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">L'elemento SyntaxTree deriva da una direttiva #load e non può essere rimosso o sostituito direttamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">I riferimenti al file di origine non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">Il formato dell'opzione pathmap non è corretto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">Il valore letterale reale non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">Le proprietà implementate automaticamente non possono essere restituite per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">Le proprietà che vengono restituite per riferimento devono contenere una funzione di accesso get</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">Le proprietà che vengono restituite per riferimento non possono contenere funzioni di accesso set</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">'{0}' deve corrispondere per riferimento al valore restituito del membro '{1}' di cui è stato eseguito l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">I valori restituiti per riferimento possono essere usati solo in metodi che vengono restituiti per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">I valori restituiti per valore possono essere usati solo in metodi che vengono restituiti per valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">L'espressione restituita deve essere di tipo '{0}' perché questo metodo viene restituito per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare '{1}' perché non contiene il valore restituito corrispondente per riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">Il corpo di '{0}' non può essere un blocco iteratore perché '{0}' viene restituito per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">Non è possibile convertire in alberi delle espressioni le espressioni lambda che vengono restituite per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">Un'espressione lambda dell'albero delle espressioni non può contenere una chiamata a un metodo, a una proprietà o a un indicizzatore che viene restituito per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">Non è possibile usare un'espressione in questo contesto perché non può essere passata o restituita per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Non è possibile restituire '{0}' per riferimento perché è stato inizializzato con un valore che non può essere restituito per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">Non è possibile restituire un membro di '{0}' per riferimento perché è stato inizializzato con un valore che non può essere restituito per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">Non è possibile restituire la variabile di intervallo '{0}' per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">Un campo di sola lettura non può restituito per riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">Non è possibile restituire un campo di sola lettura statico per riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">I membri del campo di sola lettura '{0}' non possono essere restituiti per riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">Non è possibile restituire i campi del campo di sola lettura statico '{0}' per riferimento scrivibile</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref parameter</source>
        <target state="translated">Non è possibile restituire un parametro '{0}' per riferimento perché non è un parametro ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">Non è possibile restituire per riferimento un membro del parametro '{0}' perché non è un parametro ref o out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Non è possibile restituire la variabile locale '{0}' per riferimento perché non è una variabile locale ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">Non è possibile restituire un membro della variabile locale '{0}' per riferimento perché non è una variabile locale ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">I membri struct non possono restituire 'this' o altri membri di istanza per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">Non è possibile usare l'espressione in questo contesto perché potrebbe esporre indirettamente variabili all'esterno del relativo ambito di dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Non è possibile usare un risultato di '{0}' in questo contesto perché potrebbe esporre variabili cui viene fatto riferimento dal parametro '{1}' all'esterno dell'ambito della dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Non è possibile usare un membro del risultato di '{0}' in questo contesto perché potrebbe esporre variabili cui viene fatto riferimento dal parametro '{1}' all'esterno dell'ambito di dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">Questa combinazione di argomenti di '{0}' non è consentita perché potrebbe esporre variabili cui viene fatto riferimento dal parametro '{1}' all'esterno dell'ambito della dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">I rami di un operatore condizionale ref non possono fare riferimento a variabili con ambiti di dichiarazione incompatibili</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">Non è possibile usare un risultato di un'espressione a stackalloc di tipo '{0}' in questo contesto perché potrebbe essere esposta all'esterno del metodo che la contiene</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">Non è possibile inizializzare una variabile per valore con un riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">Non è possibile inizializzare una variabile per riferimento con un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">L'espressione deve essere di tipo '{0}' perché verrà assegnata per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">Una dichiarazione di una variabile per riferimento deve contenere un inizializzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">Non è possibile usare la variabile locale ref '{0}' in un metodo anonimo, in un'espressione lambda o in un'espressione di query</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.</source>
        <target state="translated">Non è possibile mantenere un riferimento restituito da una chiamata a '{0}' oltre il limite 'await' o 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'Non è possibile usare 'await' in un'espressione contenente un operatore condizionale ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">Entrambi i valori dell'operatore condizionale devono essere valori ref, altrimenti nessuno potrà esserlo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">L'espressione deve essere di tipo '{0}' per essere uguale al valore ref alternativo</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">Un albero delle espressioni non può contenere un riferimento a una funzione locale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">Non è possibile passare l'argomento con tipo dinamico al parametro params '{0}' della funzione locale '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">L'albero della sintassi deve essere creato da un invio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals or try the EXPERIMENTAL feature flag 'experimental-data-section-string-literals'.</source>
        <target state="translated">La lunghezza combinata delle stringhe utente usate dal programma supera il limite consentito. Provare a ridurre l'uso dei valori letterali stringa o provare il flag di funzionalità SPERIMENTALE "experimental-data-section-string-literals".</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</source>
        <target state="translated">Non è consentito usare il tipo nullable '{0}?' in un criterio. Usare il tipo sottostante '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">Si è verificato un errore durante la scrittura del file di output: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">I nomi di elementi di tupla devono essere univoci.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">Il nome di elemento di tupla '{0}' è consentito solo alla posizione {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">Il nome di elemento di tupla '{0}' non è consentito in nessuna posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">Il membro '{0}' non è stato trovato nel tipo '{1}' dell'assembly '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">tuple</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">Non sono stati trovati metodi di estensione o istanze di 'Deconstruct' idonee per il tipo '{0}', con {1} parametri out e un tipo restituito void.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">L'assegnazione di decostruzione richiede un'espressione con un tipo sul lato destro.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">L'espressione switch deve essere un valore. È stato trovato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">Un'espressione di tipo '{0}' non può essere gestita da un criterio di tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">L'attributo '{0}' viene ignorato quando si specifica la firma pubblica.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">L'attributo viene ignorato quando si specifica la firma pubblica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">L'opzione '{0}' deve essere un percorso assoluto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">Non è possibile convertire la tupla con {0} elementi nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">dichiarazione di variabile out</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">Non è possibile dedurre il tipo della variabile out '{0}' tipizzata in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">Non è possibile dedurre il tipo della variabile di decostruzione '{0}' tipizzata in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">Non è possibile dedurre il tipo della variabile discard tipizzata in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">Non è possibile decostruire una tupla di '{0}' elementi in '{1}' variabili.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">Non è possibile decostruire oggetti dinamici.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">La decostruzione deve contenere almeno due variabili.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">Il nome dell'elemento di tupla '{0}' viene ignorato perché nel tipo di destinazione '{1}' è specificato un nome diverso o non è specificato alcun nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">Il nome dell'elemento di tupla viene ignorato perché nella destinazione di assegnazione è specificato un nome diverso o non è specificato alcun nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">Il tipo predefinito '{0}' deve essere uno struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'Non è possibile usare 'new' con il tipo tupla. Usare un'espressione letterale di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">Nel form di decostruzione 'var (...)' non è consentito un tipo specifico per 'var'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">Non è possibile definire una classe o un membro che usa tuple perché non è stato trovato il tipo '{0}' richiesto dal compilatore. Probabilmente manca un riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">Non è possibile fare riferimento a 'System.Runtime.CompilerServices.TupleElementNamesAttribute' in modo esplicito. Usare la sintassi della tupla per definire i nomi di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">Un albero delle espressioni non può contenere una dichiarazione di variabile argomento out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">Un albero delle espressioni non può contenere una funzionalità discard.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">Un albero delle espressioni non può contenere un operatore dei criteri di ricerca 'is'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">Un albero delle espressioni non può contenere un valore letterale di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">Un albero delle espressioni non può contenere una conversione di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">L'opzione /sourcelink è supportata solo quando si crea il file PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">L'opzione /embed è supportata solo quando si crea un file PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">Il tipo di strumentazione non è valido: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">La sintassi 'var (...)' come lvalue è riservata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">È previsto { oppure ; o =&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">Un'espressione throw non è consentita in questo contesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">Una dichiarazione non è consentita in questo contesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">Un ciclo foreach deve dichiarare le relative variabili di iterazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">Nella parte sinistra di una decostruzione non sono consentiti nomi di elemento di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">Per eseguire il cast di un valore negativo, è necessario racchiuderlo tra parentesi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">Un albero delle espressioni non può contenere un'espressione throw.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">Il nome di assembly {0} non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">La proprietà Task del tipo '{0}' da usare come elemento AsyncMethodBuilder per il tipo '{1}' deve restituire il tipo '{1}' invece di '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">Il modulo '{0}' nell'assembly '{1}' inoltra il tipo '{2}' a più assembly '{3}' e '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">Non è consentito usare il tipo 'dynamic' in un criterio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">La modalità di documentazione specificata non è supportata o non è valida: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">Il tipo del codice sorgente specificato non è supportato o non è valido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">La versione del linguaggio specificata non è supportata o non è valida: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">Nome non valido per un simbolo di pre-elaborazione. '{0}' non è un identificatore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 7.1. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile C# 7.2. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">La versione specificata '{0}' del linguaggio non può contenere zeri iniziali</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">Non è possibile assegnare un valore di tipo 'void'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">'{0}' viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri. Elimina questa diagnostica per continuare.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.</source>
        <target state="translated">Type viene usato solo a scopo di valutazione e potrebbe essere modificato o rimosso in aggiornamenti futuri. Elimina questa diagnostica per continuare.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}. Compiler path: '{2}'.</source>
        <target state="new">Compiler version: '{0}'. Language version: {1}. Compiler path: '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">principale asincrono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">Il nome '{0}' dell'elemento di tupla è dedotto. Usare la versione {1} o una versione successiva del linguaggio per accedere a un elemento in base al relativo nome dedotto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">Una tupla non può contenere un valore di tipo 'void'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">Un punto di ingresso che restituisce void o int non può essere asincrono</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">Un'espressione di tipo '{0}' non può essere gestita da un criterio di tipo '{1}' in C# {2}. Usare la versione {3} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">La funzione locale '{0}' è dichiarata, ma non viene mai usata</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">La funzione locale è dichiarata, ma non viene mai usata</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="translated">La funzione locale '{0}' deve dichiarare un corpo perché non è contrassegnata come 'static extern'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}': {3}</source>
        <target state="translated">Non è possibile leggere le informazione di debug del metodo '{0}' (token 0x{1:X8}) dall'assembly '{2}': {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0} non è un'espressione di conversione C# valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">Non è possibile passare l'argomento di tipo dinamico alla funzione locale generica '{0}' con argomenti di tipo dedotti.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">separatore di cifra iniziale</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">Non usare '{0}' perché è riservato al compilatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">Il nome di tipo '{0}' è riservato al compilatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">Il primo parametro 'in' o 'ref readonly' del metodo di estensione '{0}' deve essere un tipo di valore concreto (non generico).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">I campi di istanza di struct di sola lettura devono essere di sola lettura.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">Tutte le proprietà di istanza implementate automaticamente in struct di sola lettura devono essere di sola lettura.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">Nelle struct di sola lettura non sono consentiti eventi simili a campi.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">metodi di estensione ref</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">Non è possibile eseguire la conversione di un'espressione stackalloc di tipo '{0}' nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">Il primo parametro di un metodo di estensione 'ref' '{0}' deve essere un tipo valore o un tipo generico vincolato a struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">Un parametro in non può avere l'attributo Out.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0} non è un'operazione valida di assegnazione composta C#</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">L'espressione di filtro è una costante 'false'. Provare a rimuovere la clausola catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">L'espressione di filtro è una costante 'false'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">L'espressione di filtro è una costante 'false'. Provare a rimuovere il blocco try-catch</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">L'espressione di filtro è una costante 'false'. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">__arglist non può contenere un argomento di tipo void</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">Non è possibile usare un'espressione condizionale in un'interpolazione di stringa perché l'interpolazione termina con ':'. Racchiudere tra parentesi l'espressione condizionale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">Non usare l'attributo 'System.Runtime.CompilerServices.FixedBuffer' su una proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in C# 7.3. Usare la versione {1} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">Gli attributi destinati a campi su proprietà automatiche non sono supportati nella versione {0} del linguaggio. Usare la versione {1} o superiore.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">Gli attributi destinati a campi su proprietà automatiche non sono supportati in questa versione del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">flussi asincroni</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">'{0}': il tipo usato in un'istruzione using asincrona deve implementare 'System.IAsyncDisposable' o implementare un metodo 'DisposeAsync' adatto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">Con l'istruzione foreach asincrona il tipo restituito '{0}' di '{1}' deve essere associato a un metodo 'MoveNextAsync' pubblico e a una proprietà 'Current' pubblica appropriati</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">L'istruzione foreach asincrona non può funzionare con variabili di tipo '{0}' perché implementa più creazioni di un'istanza di '{1}'. Provare a eseguire il cast su una creazione di un'istanza di interfaccia specifica</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</source>
        <target state="translated">Gli operatori di conversione, uguaglianza o disuguaglianza dichiarati nelle interfacce devono essere astratti o virtuali</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">Il runtime di destinazione non supporta l'implementazione di interfaccia predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">'{0}' non può implementare il membro di interfaccia '{1}' nel tipo '{2}' perché il runtime di destinazione non supporta l'implementazione di interfaccia predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</source>
        <target state="translated">'{0}' non implementa il membro di interfaccia '{1}'. '{2}' non può implementare in modo implicito un membro non pubblico in C# {3}. Usare la versione '{4}' o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">Il membro di interfaccia '{0}' non contiene un'implementazione più specifica. Né '{1}' né '{2}' sono più specifiche.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>