<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../CSharpResources.resx">
    <body>
      <trans-unit id="CannotCreateConstructedFromConstructed">
        <source>Cannot create constructed generic type from another constructed generic type.</source>
        <target state="translated">다른 생성된 제네릭 형식에서 생성된 제네릭 형식을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotCreateConstructedFromNongeneric">
        <source>Cannot create constructed generic type from non-generic type.</source>
        <target state="translated">제네릭이 아닌 형식에서 생성된 제네릭 형식을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventHasAccessors">
        <source>'{0}': abstract event cannot use event accessor syntax</source>
        <target state="translated">'{0}': 추상 이벤트는 이벤트 접근자 구문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AltInterpolatedVerbatimStringsNotAvailable">
        <source>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</source>
        <target state="translated">보간된 축자 문자열에 '$@' 대신 '@$'를 사용하려면 언어 버전 '{0}' 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnUnconstrainedDefault">
        <source>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</source>
        <target state="translated">'{0}' 연산자는 참조 형식인 것으로 알려지지 않은 형식 매개 변수이므로 'default' 및 '{1}' 형식의 피연산자에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnnotationDisallowedInObjectCreation">
        <source>Cannot use a nullable reference type in object creation.</source>
        <target state="translated">nullable 참조 형식은 개체를 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNameInITuplePattern">
        <source>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</source>
        <target state="translated">'System.Runtime.CompilerServices.ITuple'을 통한 패턴 일치 시 요소 이름은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</source>
        <target state="translated">식에 nullable 참조 형식 '{0}'을(를) 사용하는 것은 올바르지 않습니다. 대신 기본 형식 '{0}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnEventAccessor">
        <source>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">이벤트 접근자에서 '{0}' 특성이 유효하지 않습니다. 이 특성은 '{1}' 선언에만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyWithSetterCantBeReadOnly">
        <source>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</source>
        <target state="translated">'set' 접근자가 포함되어 있으므로 자동 구현 속성 '{0}'을(를) 'readonly'로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoSetterCantBeReadOnly">
        <source>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">자동 구현 'set' 접근자 '{0}'을(를) 'readonly'로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMember">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance definition for '{1}'</source>
        <target state="translated">'{0}' 형식 변수에서 비동기 foreach 문을 수행할 수 없습니다. '{0}'에는 '{1}'의 적합한 공용 인스턴스 정의가 없기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitForEachMissingMemberWrongAsync">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</source>
        <target state="translated">'{0}' 형식 변수에서 비동기 foreach 문을 수행할 수 없습니다. '{0}'에는 '{1}'의 공용 인스턴스 정의가 없기 때문입니다. 'await foreach' 대신 'foreach'를 사용하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicAwaitForEach">
        <source>Cannot use a collection of dynamic type in an asynchronous foreach</source>
        <target state="translated">비동기 foreach에는 동적 형식 컬렉션을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableContextOption">
        <source>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</source>
        <target state="translated">/nullable의 '{0}' 옵션이 잘못되었습니다. 'disable', 'enable', 'warnings' 또는 'annotations'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullableTypeof">
        <source>The typeof operator cannot be used on a nullable reference type</source>
        <target state="translated">typeof 연산자는 nullable 참조 형식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPatternExpression">
        <source>Invalid operand for pattern match; value required, but found '{0}'.</source>
        <target state="translated">패턴 일치에 대한 피연산자가 잘못되었습니다. 값이 필요하지만 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">명령줄 구문 오류: '{0}'은(는) '{1}' 옵션에 유효한 값이 아닙니다. 값은 '{2}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseInOrOutInArglist">
        <source>__arglist cannot have an argument passed by 'in' or 'out'</source>
        <target state="translated">__arglist는 'in' 또는 'out'으로 전달되는 인수를 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithUnmanagedCon">
        <source>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">형식 매개 변수 '{1}'에 'unmanaged' 제약 조건이 있으므로 '{1}'은(는) '{0}'에 대한 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnLocalFunction">
        <source>Local function '{0}' must be 'static' in order to use the Conditional attribute</source>
        <target state="new">Local function '{0}' must be 'static' in order to use the Conditional attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantPatternVsOpenType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</source>
        <target state="translated">'{0}' 형식의 식은 '{1}' 형식의 패턴으로 처리할 수 없습니다. 언어 버전 '{2}' 이상을 사용하여 개방형 형식과 상수 패턴을 일치시키세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructParameterNameMismatch">
        <source>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</source>
        <target state="translated">'{0}' 이름이 해당 'Deconstruct' 매개 변수 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">'{0}' 형식에는 비추상 멤버가 있으므로 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정해보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNoTargetType">
        <source>There is no target type for the default literal.</source>
        <target state="translated">기본 리터럴의 대상 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPattern">
        <source>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</source>
        <target state="translated">기본 리터럴 'default'가 패턴으로 유효하지 않습니다. 다른 리터럴(예: '0' 또는 'null')을 적절하게 사용하세요. 모두 일치시키려면 무시 패턴 '_'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardPatternInSwitchStatement">
        <source>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</source>
        <target state="translated">무시 패턴은 switch 문의 case 레이블로 사용할 수 없습니다. 무시 패턴에 대해 'case var _:'을 사용하거나 이름이 '_'인 상수에 대해 'case @_:'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateExplicitImpl">
        <source>'{0}' is explicitly implemented more than once.</source>
        <target state="translated">'{0}'은(는) 두 번 이상 명시적으로 구현됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNullSuppression">
        <source>Duplicate null suppression operator ('!')</source>
        <target state="translated">중복 null 비표시 오류(Suppression) 연산자('!')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</source>
        <target state="translated">'{0}' 속성 또는 인덱서의 두 접근자에 'readonly' 한정자를 지정할 수 없습니다. 대신 속성 자체에 'readonly' 한정자를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseCannotStartStatement">
        <source>'else' cannot start a statement.</source>
        <target state="translated">'else'로 문을 시작할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitNullableAttribute">
        <source>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</source>
        <target state="translated">'System.Runtime.CompilerServices.NullableAttribute'의 명시적 적용은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprCannotBeFixed">
        <source>The given expression cannot be used in a fixed statement</source>
        <target state="translated">fixed 문에서는 지정된 식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainNullCoalescingAssignment">
        <source>An expression tree may not contain a null coalescing assignment</source>
        <target state="translated">식 트리에는 null 병합 할당을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeCantContainRefStruct">
        <source>Expression tree cannot contain value of ref struct or restricted type '{0}'.</source>
        <target state="translated">식 트리에는 ref struct 값 또는 제한된 형식 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsFromEndIndexExpression">
        <source>An expression tree may not contain a from-end index ('^') expression.</source>
        <target state="new">An expression tree may not contain a from-end index ('^') expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPatternIndexOrRangeIndexer">
        <source>An expression tree may not contain a pattern System.Index or System.Range indexer access</source>
        <target state="new">An expression tree may not contain a pattern System.Index or System.Range indexer access</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsRangeExpression">
        <source>An expression tree may not contain a range ('..') expression.</source>
        <target state="new">An expression tree may not contain a range ('..') expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsSwitchExpression">
        <source>An expression tree may not contain a switch expression.</source>
        <target state="translated">식 트리에는 switch 식이 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleBinOp">
        <source>An expression tree may not contain a tuple == or != operator</source>
        <target state="translated">식 트리에는 튜플 == 또는 != 연산자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternEventInitializer">
        <source>'{0}': extern event cannot have initializer</source>
        <target state="translated">'{0}': extern 이벤트에는 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureInPreview">
        <source>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</source>
        <target state="translated">'{0}' 기능은 현재 미리 보기로 제공되며 *지원되지 않습니다*. 미리 보기 기능을 사용하려면 '미리 보기' 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsExperimental">
        <source>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</source>
        <target state="translated">기능 '{0}'은(는) 실험적이며 지원되지 않습니다. 사용하도록 설정하려면 '/features:{1}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">'{0}' 기능은 C# 8.0에서 사용할 수 없습니다. 언어 버전 {1} 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion8_0">
        <source>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</source>
        <target state="translated">'{0}' 기능은 C# 8.0에서 사용할 수 없습니다. 언어 버전 {1} 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldLikeEventCantBeReadOnly">
        <source>Field-like event '{0}' cannot be 'readonly'.</source>
        <target state="translated">필드와 유사한 이벤트 '{0}'이(가) 'readonly'일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMemberWrongAsync">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</source>
        <target state="translated">'{0}' 형식 변수에서 foreach 문을 수행할 수 없습니다. '{0}'에는 '{1}'의 공용 인스턴스 정의가 없기 때문입니다. 'foreach' 대신 'await foreach'를 사용하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToBackwardJumpOverUsingVar">
        <source>A goto cannot jump to a location before a using declaration within the same block.</source>
        <target state="translated">goto는 동일한 블록 내의 using 선언 앞 위치로 이동할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GoToForwardJumpOverUsingVar">
        <source>A goto cannot jump to a location after a using declaration.</source>
        <target state="translated">goto는 using 선언 뒤 위치로 이동할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalSuppression">
        <source>The suppression operator is not allowed in this context</source>
        <target state="translated">이 컨텍스트에서는 비표시 오류(Suppression) 연산자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitIndexIndexerWithName">
        <source>Invocation of implicit Index Indexer cannot name the argument.</source>
        <target state="translated">암시적 인덱스 인덱서 호출로 인수 이름을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitRangeIndexerWithName">
        <source>Invocation of implicit Range Indexer cannot name the argument.</source>
        <target state="translated">암시적 범위 인덱서 호출로 인수 이름을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InDynamicMethodArg">
        <source>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</source>
        <target state="translated">동적으로 디스패치된 식에서 'in' 한정자가 있는 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedImplicitlyByVariadic">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</source>
        <target state="translated">'{0}'은(는) __arglist 매개 변수가 있으므로 '{2}' 형식의 인터페이스 멤버 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InternalError">
        <source>Internal error in the C# compiler.</source>
        <target state="translated">C# 컴파일러의 내부 오류입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">잘못된 해시 알고리즘 이름: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidObjectCreation">
        <source>Invalid object creation</source>
        <target state="translated">잘못된 개체 만들기</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyReadOnlyMods">
        <source>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</source>
        <target state="translated">'{0}' 속성 또는 인덱서 및 해당 접근자 둘 다에 'readonly' 한정자를 지정할 수 없습니다. 둘 중 하나를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStackAllocArray">
        <source>"Invalid rank specifier: expected ']'</source>
        <target state="translated">잘못된 차수 지정자입니다. ']'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNullableType">
        <source>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</source>
        <target state="translated">is-type 식에 nullable 참조 형식 '{0}?'을(를) 사용하는 것은 올바르지 않습니다. 대신 기본 형식 '{0}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsPatternImpossible">
        <source>An expression of type '{0}' can never match the provided pattern.</source>
        <target state="translated">'{0}' 형식의 식은 제공된 패턴과 일치할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorMustBeAsync">
        <source>Method '{0}' with an iterator block must be 'async' to return '{1}'</source>
        <target state="translated">{1}'을(를) 반환하려면 반복기 블록이 있는 '{0}' 메서드가 '비동기'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPattern">
        <source>Pattern missing</source>
        <target state="translated">패턴이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">분석기 구성 파일 여러 개가 동일한 디렉터리('{0}')에 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEnumeratorCancellationAttributes">
        <source>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</source>
        <target state="translated">[EnumeratorCancellation] 특성은 여러 매개 변수에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithUnmanaged">
        <source>The 'new()' constraint cannot be used with the 'unmanaged' constraint</source>
        <target state="translated">new()' 제약 조건은 'unmanaged' 제약 조건과 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDispWrongAsync">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</source>
        <target state="translated">'{0}': 비동기 using 문에 사용된 형식은 암시적으로 'System.IAsyncDisposable'로 변환할 수 있거나 적합한 'DisposeAsync' 메서드를 구현해야 합니다. 'await using' 대신 'using'을 사용하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDispWrongAsync">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</source>
        <target state="translated">'{0}': using 문에 사용된 형식은 암시적으로 'System.IDisposable'로 변환할 수 있어야 합니다. 'using' 대신 'await using'을 사용하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoOutputDirectory">
        <source>Output directory could not be determined</source>
        <target state="new">Output directory could not be determined</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstraintMustBeFirst">
        <source>The 'notnull' constraint must come before any other constraints</source>
        <target state="translated">'notnull' 제약 조건은 다른 모든 제약 조건보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveQualifierExpected">
        <source>Expected 'enable', 'disable', or 'restore'</source>
        <target state="translated">'enable', 'disable' 또는 'restore'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDirectiveTargetExpected">
        <source>Expected 'warnings', 'annotations', or end of directive</source>
        <target state="translated">'warnings', 'annotations' 또는 지시문의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableOptionNotAvailable">
        <source>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</source>
        <target state="translated">C# {2}의 '{0}' 값 '{1}'이(가) 잘못되었습니다. 언어 버전 '{3}' 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableUnconstrainedTypeParameter">
        <source>A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.</source>
        <target state="translated">값 형식 또는 null을 허용하지 않는 참조 형식이 되려면 nullable 형식 매개 변수를 알려야 합니다. 'class', 'struct' 또는 형식 제약 조건 추가를 고려하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutVariableCannotBeByRef">
        <source>An out variable cannot be declared as a ref local</source>
        <target state="translated">출력 변수는 참조 로컬로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideRefConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</source>
        <target state="translated">'{0}' 메서드는 형식 매개 변수 '{1}'의 'class' 제약 조건을 지정하지만 재정의되었거나 명시적으로 구현된 '{3}' 메서드의 해당 형식 매개 변수 '{2}'이(가) 참조 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideValConstraintNotSatisfied">
        <source>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</source>
        <target state="translated">'{0}' 메서드는 형식 매개 변수 '{1}'의 'struct' 제약 조건을 지정하지만 재정의되었거나 명시적으로 구현된 '{3}' 메서드의 해당 형식 매개 변수 '{2}'이(가) null을 허용하지 않는 값 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodReadOnlyDifference">
        <source>Both partial method declarations must be readonly or neither may be readonly</source>
        <target state="translated">두 부분 메서드(Partial method) 선언 모두 readonly이거나 readonly가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerTypeInPatternMatching">
        <source>Pattern-matching is not permitted for pointer types.</source>
        <target state="translated">포인터 형식에 대해 패턴 일치가 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYield">
        <source>The body of an async-iterator method must contain a 'yield' statement.</source>
        <target state="translated">비동기 반복기 메서드의 본문에는 'yield' 문이 포함되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
        <source>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</source>
        <target state="translated">비동기 반복기 메서드의 본문에는 'yield' 문이 포함되어야 합니다. 메서드 선언에서 'async'를 제거하거나 'yield' 문을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyPatternNameMissing">
        <source>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</source>
        <target state="translated">속성 하위 패턴은 일치시킬 속성 또는 필드에 대한 참조가 필요합니다(예: '{{ Name: {0} }}')</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">'{0}' 형식에는 기본 인터페이스 멤버의 재추상화가 있으므로 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyModMissingAccessor">
        <source>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 속성 또는 인덱서에 get 접근자와 set 접근자가 둘 다 있는 경우에만 접근자에 'readonly'를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignNarrower">
        <source>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</source>
        <target state="translated">'{1}'을(를) '{0}'에 참조 할당할 수 없습니다. '{1}'이(가) '{0}'보다 이스케이프 범위가 좁기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLocalOrParamExpected">
        <source>The left-hand side of a ref assignment must be a ref local or parameter.</source>
        <target state="translated">참조 할당의 왼쪽은 참조 로컬 또는 매개 변수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</source>
        <target state="translated">대상 런타임이 인터페이스 멤버의 'protected', 'protected internal' 또는 'private protected' 접근성을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleElementPositionalPatternRequiresDisambiguation">
        <source>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</source>
        <target state="translated">단일 요소 분해 패턴은 명확성을 위해 다른 구문이 필요합니다. 닫는 괄호 ')' 뒤에 무시 항목 지정자 '_'을 추가하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureThis">
        <source>A static local function cannot contain a reference to 'this' or 'base'.</source>
        <target state="translated">정적 로컬 함수는 'this' 또는 'base'에 대한 참조를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticLocalFunctionCannotCaptureVariable">
        <source>A static local function cannot contain a reference to '{0}'.</source>
        <target state="translated">정적 로컬 함수는 '{0}'에 대한 참조를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberCantBeReadOnly">
        <source>Static member '{0}' cannot be marked 'readonly'.</source>
        <target state="translated">정적 멤버 '{0}'을(를) 'readonly'로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="new">stdin argument '-' is specified, but input has not been redirected from the standard input stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchArmSubsumed">
        <source>The pattern has already been handled by a previous arm of the switch expression.</source>
        <target state="translated">패턴이 switch 식의 이전 arm에 의해 이미 처리되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchCaseSubsumed">
        <source>The switch case has already been handled by a previous case.</source>
        <target state="translated">Switch case가 이전 case에서 이미 처리되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionNoBestType">
        <source>No best type was found for the switch expression.</source>
        <target state="translated">switch 식에 적합한 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchGoverningExpressionRequiresParens">
        <source>Parentheses are required around the switch governing expression.</source>
        <target state="translated">식을 제어하는 switch 주위에 괄호가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TripleDotNotAllowed">
        <source>Unexpected character sequence '...'</source>
        <target state="translated">예기치 않은 '...' 문자 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNameMismatch">
        <source>The name '{0}' does not identify tuple element '{1}'.</source>
        <target state="translated">'{0}' 이름은 '{1}' 튜플 요소를 식별하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleSizesMismatchForBinOps">
        <source>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</source>
        <target state="translated">== 또는 != 연산자의 피연산자로 사용되는 튜플 형식에는 일치하는 카디널리티가 있어야 합니다. 하지만 이 연산자는 왼쪽에 {0}, 오른쪽에 {1} 카디널리티 형식의 튜플이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</source>
        <target state="translated">'{0}': constraint 클래스와 'unmanaged' 제약 조건을 둘 다 지정할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintMustBeFirst">
        <source>The 'unmanaged' constraint must come before any other constraints</source>
        <target state="translated">'unmanaged' 제약 조건은 다른 모든 제약 조건보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">제네릭 형식 또는 메서드 '{0}'에서 모든 중첩 수준의 모든 필드와 함께 '{2}' 형식을 '{1}' 매개 변수로 사용하려면 해당 형식이 null을 허용하지 않는 값 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingVarInSwitchCase">
        <source>A using variable cannot be used directly within a switch section (consider using braces). </source>
        <target state="translated">using 변수를 switch 섹션 내에 직접 사용할 수 없습니다. 중괄호를 사용하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarMayNotBindToType">
        <source>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</source>
        <target state="translated">패턴의 'var' 구문은 형식 참조가 허용되지 않지만 '{0}'은(는) 여기서 범위 내에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</source>
        <target state="translated">'in' 또는 'out' 형식 매개 변수가 있는 인터페이스에서 열거형, 클래스, 구조체를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WrongNumberOfSubpatterns">
        <source>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</source>
        <target state="translated">튜플 형식 '{0}'을(를) 일치시키려면 '{1}' 하위 패턴이 필요하지만 '{2}' 하위 패턴이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">{0}' 파일 이름이 비어 있거나, 잘못된 문자가 있거나, 절대 경로가 없는 드라이브 사양이 있거나, 너무 깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_CSCHelp">
        <source>
                             Visual C# Compiler Options

                       - OUTPUT FILES -
-out:&lt;file&gt;                   Specify output file name (default: base name of
                              file with main class or first file)
-target:exe                   Build a console executable (default) (Short
                              form: -t:exe)
-target:winexe                Build a Windows executable (Short form:
                              -t:winexe)
-target:library               Build a library (Short form: -t:library)
-target:module                Build a module that can be added to another
                              assembly (Short form: -t:module)
-target:appcontainerexe       Build an Appcontainer executable (Short form:
                              -t:appcontainerexe)
-target:winmdobj              Build a Windows Runtime intermediate file that
                              is consumed by WinMDExp (Short form: -t:winmdobj)
-doc:&lt;file&gt;                   XML Documentation file to generate
-refout:&lt;file&gt;                Reference assembly output to generate
-platform:&lt;string&gt;            Limit which platforms this code can run on: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred, or
                              anycpu. The default is anycpu.

                       - INPUT FILES -
-recurse:&lt;wildcard&gt;           Include all files in the current directory and
                              subdirectories according to the wildcard
                              specifications
-reference:&lt;alias&gt;=&lt;file&gt;     Reference metadata from the specified assembly
                              file using the given alias (Short form: -r)
-reference:&lt;file list&gt;        Reference metadata from the specified assembly
                              files (Short form: -r)
-addmodule:&lt;file list&gt;        Link the specified modules into this assembly
-link:&lt;file list&gt;             Embed metadata from the specified interop
                              assembly files (Short form: -l)
-analyzer:&lt;file list&gt;         Run the analyzers from this assembly
                              (Short form: -a)
-additionalfile:&lt;file list&gt;   Additional files that don't directly affect code
                              generation but may be used by analyzers for producing
                              errors or warnings.
-embed                        Embed all source files in the PDB.
-embed:&lt;file list&gt;            Embed specific files in the PDB.

                       - RESOURCES -
-win32res:&lt;file&gt;              Specify a Win32 resource file (.res)
-win32icon:&lt;file&gt;             Use this icon for the output
-win32manifest:&lt;file&gt;         Specify a Win32 manifest file (.xml)
-nowin32manifest              Do not include the default Win32 manifest
-resource:&lt;resinfo&gt;           Embed the specified resource (Short form: -res)
-linkresource:&lt;resinfo&gt;       Link the specified resource to this assembly
                              (Short form: -linkres) Where the resinfo format
                              is &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                       - CODE GENERATION -
-debug[+|-]                   Emit debugging information
-debug:{full|pdbonly|portable|embedded}
                              Specify debugging type ('full' is default,
                              'portable' is a cross-platform format,
                              'embedded' is a cross-platform format embedded into
                              the target .dll or .exe)
-optimize[+|-]                Enable optimizations (Short form: -o)
-deterministic                Produce a deterministic assembly
                              (including module version GUID and timestamp)
-refonly                      Produce a reference assembly in place of the main output
-instrument:TestCoverage      Produce an assembly instrumented to collect
                              coverage information
-sourcelink:&lt;file&gt;            Source link info to embed into PDB.
 
                       - ERRORS AND WARNINGS -
-warnaserror[+|-]             Report all warnings as errors
-warnaserror[+|-]:&lt;warn list&gt; Report specific warnings as errors
                              (use "nullable" for all nullability warnings)
-warn:&lt;n&gt;                     Set warning level (0-4) (Short form: -w)
-nowarn:&lt;warn list&gt;           Disable specific warning messages
                              (use "nullable" for all nullability warnings)
-ruleset:&lt;file&gt;               Specify a ruleset file that disables specific
                              diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]
                              Specify a file to log all compiler and analyzer
                              diagnostics.
                              sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                              both mean SARIF version 2.1.0.
-reportanalyzer               Report additional analyzer information, such as
                              execution time.

                       - LANGUAGE -
-checked[+|-]                 Generate overflow checks
-unsafe[+|-]                  Allow 'unsafe' code
-define:&lt;symbol list&gt;         Define conditional compilation symbol(s) (Short
                              form: -d)
-langversion:?                Display the allowed values for language version
-langversion:&lt;string&gt;         Specify language version such as
                              `latest` (latest version, including minor versions),
                              `default` (same as `latest`),
                              `latestmajor` (latest version, excluding minor versions),
                              `preview` (latest version, including features in unsupported preview),
                              or specific versions like `6` or `7.1`
-nullable[+|-]                Specify nullable context option enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Specify nullable context option enable|disable|warnings|annotations.

                       - SECURITY -
-delaysign[+|-]               Delay-sign the assembly using only the public
                              portion of the strong name key
-publicsign[+|-]              Public-sign the assembly using only the public
                              portion of the strong name key
-keyfile:&lt;file&gt;               Specify a strong name key file
-keycontainer:&lt;string&gt;        Specify a strong name key container
-highentropyva[+|-]           Enable high-entropy ASLR

                       - MISCELLANEOUS -
@&lt;file&gt;                       Read response file for more options
-help                         Display this usage message (Short form: -?)
-nologo                       Suppress compiler copyright message
-noconfig                     Do not auto include CSC.RSP file
-parallel[+|-]                Concurrent build.
-version                      Display the compiler version number and exit.

                       - ADVANCED -
-baseaddress:&lt;address&gt;        Base address for the library to be built
-checksumalgorithm:&lt;alg&gt;      Specify algorithm for calculating source file
                              checksum stored in PDB. Supported values are:
                              SHA1 or SHA256 (default).
-codepage:&lt;n&gt;                 Specify the codepage to use when opening source
                              files
-utf8output                   Output compiler messages in UTF-8 encoding
-main:&lt;type&gt;                  Specify the type that contains the entry point
                              (ignore all other possible entry points) (Short
                              form: -m)
-fullpaths                    Compiler generates fully qualified paths
-filealign:&lt;n&gt;                Specify the alignment used for output file
                              sections
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              Specify a mapping for source path names output by
                              the compiler.
-pdb:&lt;file&gt;                   Specify debug information file name (default:
                              output file name with .pdb extension)
-errorendlocation             Output line and column of the end location of
                              each error
-preferreduilang              Specify the preferred output language name.
-nosdkpath                    Disable searching the default SDK path for standard library assemblies.
-nostdlib[+|-]                Do not reference standard library (mscorlib.dll)
-subsystemversion:&lt;string&gt;    Specify subsystem version of this assembly
-lib:&lt;file list&gt;              Specify additional directories to search in for
                              references
-errorreport:&lt;string&gt;         Specify how to handle internal compiler errors:
                              prompt, send, queue, or none. The default is
                              queue.
-appconfig:&lt;file&gt;             Specify an application configuration file
                              containing assembly binding settings
-moduleassemblyname:&lt;string&gt;  Name of the assembly which this module will be
                              a part of
-modulename:&lt;string&gt;          Specify the name of the source module
</source>
        <target state="needs-review-translation">
                             Visual C# 컴파일러 옵션

                       - 출력 파일 -
-out:&lt;파일&gt;                   출력 파일 이름을 지정합니다(기본값: 주 클래스가
                             있는 파일 또는 첫 번째 파일의 기본 이름).
-target:exe                  콘솔 실행 파일을 빌드합니다(기본값). 
                             (약식: -t:exe)
-target:winexe               Windows 실행 파일을 빌드합니다.
                             (약식: -t:winexe)
-target:library              라이브러리를 빌드합니다. (약식: -t:library)
-target:module               다른 어셈블리에 추가할 수 있는 모듈을
                             빌드합니다. (약식: -t:module)
-target:appcontainerexe      Appcontainer 실행 파일을 빌드합니다.
                             (약식: -t:appcontainerexe)
-target:winmdobj             WinMDExp에서 사용되는 Windows 런타임 중간
                             파일을 빌드합니다. (약식: -t:winmdobj)
-doc:&lt;파일&gt;                   생성할 XML 문서 파일입니다.
-refout:&lt;파일&gt;                생성할 참조 어셈블리 출력입니다.
-platform:&lt;문자열&gt;             이 코드를 실행할 수 있는 플랫폼을 x86,
                             Itanium, x64, arm, arm64, anycpu32bitpreferred 또는
                             anycpu로 제한합니다. 기본값은 anycpu입니다.

                       - 입력 파일 -
-recurse:&lt;와일드카드&gt;           와일드카드 지정에 따라 현재 디렉터리와
                             하위 디렉터리에 있는 모든 파일을
                             포함합니다.
-reference:&lt;별칭&gt;=&lt;파일&gt;       지정한 어셈블리 파일의 메타데이터를 지정된 별칭으로
                             참조합니다. (약식: -r)
-reference:&lt;파일 목록&gt;         지정한 어셈블리 파일의 메타데이터를
                             참조합니다. (약식: -r)
-addmodule:&lt;파일 목록&gt;         지정한 모듈을 이 어셈블리에 연결합니다.
-link:&lt;파일 목록&gt;              지정된 interop 어셈블리 파일의 메타데이터를
                             포함합니다. (약식: -l)
-analyzer:&lt;파일 목록&gt;          이 어셈블리에서 분석기를 실행합니다.
                             (약식: -a)
-additionalfile:&lt;파일 목록&gt;    코드 생성에 직접 영향을 주지 않지만 오류 또는
                             경고 생성을 위해 분석기에서 사용될 수 있는
                             추가 파일입니다.
-embed                       PDB에 모든 소스 파일을 포함합니다.
-embed:&lt;파일 목록&gt;             PDB에 특정 파일을 포함합니다.

                       - 리소스 -
-win32res:&lt;파일&gt;              Win32 리소스 파일(.res)을 지정합니다.
-win32icon:&lt;파일&gt;             이 아이콘을 출력에 사용합니다.
-win32manifest:&lt;파일&gt;         Win32 매니페스트 파일(.xml)을 지정합니다.
-nowin32manifest             기본 Win32 매니페스트를 포함하지 않습니다.
-resource:&lt;resinfo&gt;          지정한 리소스를 포함합니다. (약식: -res)
-linkresource:&lt;resinfo&gt;      지정한 리소스를 이 어셈블리에 연결합니다.
                             (약식: -linkres) 여기서, resinfo 형식은
                             &lt;파일&gt;[,&lt;문자열 이름&gt;[,public|private]]입니다.

                       - 코드 생성 -
-debug[+|-]                   디버깅 정보를 내보냅니다.
-debug:{full|pdbonly|portable|embedded}
                              디버깅 형식을 지정합니다. 기본값은 'full'이고,
                              'portable'은 플랫폼 간 형식이며,
                              'embedded'는 대상 .dll 또는 .exe에 포함된
                              플랫폼 간 형식입니다.
-optimize[+|-]                최적화를 사용하도록 설정합니다. (약식: -o)
-deterministic                결정적 어셈블리를 생성합니다(모듈
                              버전 GUID 및 타임스탬프 포함).
-refonly                      주 출력 대신 참조 어셈블리를 생성합니다.
-instrument:TestCoverage      검사 정보를 수집하기 위해 계측한
                              어셈블리를 생성합니다.
-sourcelink:&lt;파일&gt;             PDB에 포함할 소스 링크 정보입니다.

                       - 오류 및 경고 -
-warnaserror[+|-]             모든 경고를 오류로 보고합니다.
-warnaserror[+|-]:&lt;경고 목록&gt;   특정 경고를 오류로 보고합니다.
-warn:&lt;n&gt;                     경고 수준(0~4)을 설정합니다. (약식: -w)
-nowarn:&lt;경고 목록&gt;             특정 경고 메시지를 사용하지 않도록 설정합니다.
-ruleset:&lt;파일&gt;                특정 진단을 사용하지 않도록 하는 규칙 집합
                              파일을 지정합니다.
-errorlog:&lt;파일&gt;[,version=&lt;sarif_version&gt;]
                              모든 컴파일러 및 분석기 진단을 기록할 파일을
                              지정합니다.
                              sarif_version:{1|2|2.1} 기본값 1. 2와 2.1은 모두
                              SARIF 버전 2.1.0을 의미합니다.
-reportanalyzer               추가 분석기 정보(예: 실행 시간)를
                              보고합니다.

                       - 언어 -
-checked[+|-]                 오버플로 검사를 생성합니다.
-unsafe[+|-]                  'unsafe' 코드를 허용합니다.
-define:&lt;기호 목록&gt;             조건부 컴파일 기호를 정의합니다. 
                              (약식: -d)
-langversion:?                언어 버전에 허용되는 값을 표시합니다.
-langversion:&lt;문자열&gt;           언어 버전을
                              'latest'(최신 버전, 부 버전 포함),
                              'default'('latest'와 같음),
                              'latestmajor'(최신 버전, 부 버전 제외),
                              'preview'(최신 버전, 지원되지 않는 미리 보기의 기능 포함)
                              또는 특정 버전(예: '6' 또는 '7.1')으로 지정합니다.
-nullable[+|-]                nullable 컨텍스트 옵션 enable|disable을 지정합니다.
-nullable:{enable|disable|warnings|annotations}
                              nullable 컨텍스트 옵션 enable|disable|warnings|annotations를 지정합니다.

                       - 보안 -
-delaysign[+|-]               강력한 이름 키의 공개 부분만 사용하여
                              어셈블리 서명을 연기합니다.
-publicsign[+|-]              강력한 이름 키의 공개 부분만 사용하여
                              어셈블리를 공개 서명합니다.
-keyfile:&lt;파일&gt;                강력한 이름 키 파일을 지정합니다.
-keycontainer:&lt;문자열&gt;          강력한 이름 키 컨테이너를 지정합니다.
-highentropyva[+|-]           높은 엔트로피 ASLR을 사용하도록 설정합니다.

                       - 기타 -
@&lt;파일&gt;                        추가 옵션에 대한 지시 파일을 읽습니다.
-help                         사용법 메시지를 표시합니다. (약식: -?)
-nologo                       컴파일러 저작권 메시지를 표시하지 않습니다.
-noconfig                     CSC.RSP 파일을 자동으로 포함하지 않습니다.
-parallel[+|-]                동시 빌드입니다.
-version                      컴파일러 버전 번호를 표시하고 종료합니다.

                       - 고급 -
-baseaddress:&lt;주소&gt;            빌드할 라이브러리의 기준 주소입니다.
-checksumalgorithm:&lt;alg&gt;      PDB에 저장된 소스 파일 체크섬을
                              계산하기 위한 알고리즘을 지정합니다. 지원되는 값은
                              SHA1 또는 SHA256(기본값)입니다.
-codepage:&lt;n&gt;                 소스 파일을 열 때 사용할 코드 페이지를
                              지정합니다.
-utf8output                   컴파일러 메시지를 UTF-8 인코딩으로 출력합니다.
-main:&lt;형식&gt;                   진입점이 포함된 형식을 지정합니다(다른
                              모든 가능한 진입점 무시). 
                              (약식: -m)
-fullpaths                    컴파일러가 정규화된 경로를 생성합니다.
-filealign:&lt;n&gt;                출력 파일 섹션에 사용되는 맞춤을
                              지정합니다.
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                              컴파일러에서 출력된 소스 경로 이름에 대한 매핑을
                              지정합니다.
-pdb:&lt;파일&gt;                    디버그 정보 파일 이름을 지정합니다(기본값:
                              확장명이 .pdb인 출력 파일 이름).
-errorendlocation             각 오류의 끝 위치에 해당하는 줄과
                              열을 출력합니다.
-preferreduilang              기본 출력 언어 이름을 지정합니다.
-nosdkpath                    기본 SDK 경로에서 표준 라이브러리 어셈블리를 검색하지 않도록 설정합니다.
-nostdlib[+|-]                표준 라이브러리(mscorlib.dll)를 참조하지 않습니다.
-subsystemversion:&lt;문자열&gt;      이 어셈블리의 하위 시스템 버전을 지정합니다.
-lib:&lt;파일 목록&gt;                참조를 위해 검색할 추가 디렉터리를
                              지정합니다.
-errorreport:&lt;문자열&gt;           내부 컴파일러 오류를 처리하는 방법을
                              prompt, send, queue 또는 none으로 지정합니다. 기본값은
                              queue입니다.
-appconfig:&lt;파일&gt;              어셈블리 바인딩 설정을 포함하는
                              애플리케이션 구성 파일을 지정합니다.
-moduleassemblyname:&lt;문자열&gt;    이 모듈이 속할 어셈블리의
                              이름입니다.
-modulename:&lt;문자열&gt;            소스 모듈의 이름을 지정합니다.
</target>
        <note>Visual C# Compiler Options</note>
      </trans-unit>
      <trans-unit id="IDS_DefaultInterfaceImplementation">
        <source>default interface implementation</source>
        <target state="translated">기본 인터페이스 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Disposable">
        <source>disposable</source>
        <target state="translated">삭제 가능</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAltInterpolatedVerbatimStrings">
        <source>alternative interpolated verbatim strings</source>
        <target state="translated">대체 보간된 축자 문자열</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncUsing">
        <source>asynchronous using</source>
        <target state="translated">비동기 using</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCoalesceAssignmentExpression">
        <source>coalescing assignment</source>
        <target state="translated">병합 할당</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDelegateGenericTypeConstraint">
        <source>delegate generic type constraints</source>
        <target state="translated">대리자 제네릭 형식 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureEnumGenericTypeConstraint">
        <source>enum generic type constraints</source>
        <target state="translated">열거형 제네릭 형식 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionVariablesInQueriesAndInitializers">
        <source>declaration of expression variables in member initializers and queries</source>
        <target state="translated">멤버 이니셜라이저 및 쿼리에서 식 변수 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensibleFixedStatement">
        <source>extensible fixed statement</source>
        <target state="translated">확장 가능한 fixed 문</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternLocalFunctions">
        <source>extern local functions</source>
        <target state="new">extern local functions</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexOperator">
        <source>index operator</source>
        <target state="translated">인덱스 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIndexingMovableFixedBuffers">
        <source>indexing movable fixed buffers</source>
        <target state="translated">이동 가능한 고정 버퍼 인덱싱</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctionAttributes">
        <source>local function attributes</source>
        <target state="new">local function attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambdaDiscardParameters">
        <source>lambda discard parameters</source>
        <target state="translated">람다 무시 항목 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameShadowingInNestedFunctions">
        <source>name shadowing in nested functions</source>
        <target state="translated">중첩된 함수의 이름 섀도잉</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNestedStackalloc">
        <source>stackalloc in nested expressions</source>
        <target state="translated">중첩 식의 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNotNullGenericTypeConstraint">
        <source>notnull generic type constraint</source>
        <target state="translated">notnull 제네릭 형식 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullableReferenceTypes">
        <source>nullable reference types</source>
        <target state="translated">nullable 참조 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObsoleteOnPropertyAccessor">
        <source>obsolete on property accessor</source>
        <target state="translated">속성 접근자에서 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragmaWarningEnable">
        <source>warning action enable</source>
        <target state="translated">경고 작업 enable</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRangeOperator">
        <source>range operator</source>
        <target state="translated">범위 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyMembers">
        <source>readonly members</source>
        <target state="translated">읽기 전용 멤버</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRecursivePatterns">
        <source>recursive patterns</source>
        <target state="translated">재귀 패턴</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefConditional">
        <source>ref conditional expression</source>
        <target state="translated">ref 조건식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefFor">
        <source>ref for-loop variables</source>
        <target state="translated">ref for 루프 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefForEach">
        <source>ref foreach iteration variables</source>
        <target state="translated">ref foreach 반복 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefReassignment">
        <source>ref reassignment</source>
        <target state="translated">ref 다시 할당</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStackAllocInitializer">
        <source>stackalloc initializer</source>
        <target state="translated">stackalloc 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticLocalFunctions">
        <source>static local functions</source>
        <target state="translated">정적 로컬 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchExpression">
        <source>&lt;switch expression&gt;</source>
        <target state="translated">&lt;switch 식&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTupleEquality">
        <source>tuple equality</source>
        <target state="translated">튜플 같음</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
        <source>unconstrained type parameters in null coalescing operator</source>
        <target state="translated">null 병합 연산자의 비제한 형식 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedConstructedTypes">
        <source>unmanaged constructed types</source>
        <target state="translated">비관리형 생성된 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUnmanagedGenericTypeConstraint">
        <source>unmanaged generic type constraints</source>
        <target state="translated">unmanaged 제네릭 형식 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingDeclarations">
        <source>using declarations</source>
        <target state="translated">using 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_NULL">
        <source>&lt;null&gt;</source>
        <target state="translated">&lt;null&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OverrideWithConstraints">
        <source>constraints for override and explicit interface implementation methods</source>
        <target state="translated">재정의 및 명시적 인터페이스 구현 메서드에 대한 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ThrowExpression">
        <source>&lt;throw expression&gt;</source>
        <target state="translated">&lt;Throw 식&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDERROR">
        <source>(Location of symbol related to previous error)</source>
        <target state="translated">(이전 오류와 관련된 기호 위치)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_RELATEDWARNING">
        <source>(Location of symbol related to previous warning)</source>
        <target state="translated">(이전 경고와 관련된 기호 위치)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED">
        <source>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</source>
        <target state="translated">&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLIGNORED2">
        <source> Badly formed XML file "{0}" cannot be included </source>
        <target state="translated"> 잘못된 형식의 XML 파일 "{0}"을(를) 포함할 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLFAILEDINCLUDE">
        <source> Failed to insert some or all of included XML </source>
        <target state="translated"> 포함된 XML의 일부 또는 전부를 삽입하지 못했습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLBADINCLUDE">
        <source> Include tag is invalid </source>
        <target state="translated"> Include 태그가 잘못되었습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLNOINCLUDE">
        <source> No matching elements were found for the following include tag </source>
        <target state="translated"> 다음 include 태그와 짝이 맞는 요소를 찾을 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEFILE">
        <source>Missing file attribute</source>
        <target state="translated">파일 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_XMLMISSINGINCLUDEPATH">
        <source>Missing path attribute</source>
        <target state="translated">path 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_GlobalNamespace">
        <source>&lt;global namespace&gt;</source>
        <target state="translated">&lt;전역 네임스페이스&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGenerics">
        <source>generics</source>
        <target state="translated">제네릭</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonDelegates">
        <source>anonymous methods</source>
        <target state="translated">무명 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureModuleAttrLoc">
        <source>module as an attribute target specifier</source>
        <target state="translated">모듈(특성 대상 지정자)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureGlobalNamespace">
        <source>namespace alias qualifier</source>
        <target state="translated">네임스페이스 별칭 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureFixedBuffer">
        <source>fixed size buffers</source>
        <target state="translated">고정 크기 버퍼</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePragma">
        <source>#pragma</source>
        <target state="translated">#pragma</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureStaticClasses">
        <source>static classes</source>
        <target state="translated">정적 클래스</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyStructs">
        <source>readonly structs</source>
        <target state="translated">읽기 전용 구조체</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialTypes">
        <source>partial types</source>
        <target state="translated">부분 형식(Partial Type)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsync">
        <source>async function</source>
        <target state="translated">비동기 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureSwitchOnBool">
        <source>switch on boolean type</source>
        <target state="translated">부울 형식으로 전환</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MethodGroup">
        <source>method group</source>
        <target state="translated">메서드 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AnonMethod">
        <source>anonymous method</source>
        <target state="translated">무명 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Lambda">
        <source>lambda expression</source>
        <target state="translated">람다 식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Collection">
        <source>collection</source>
        <target state="translated">컬렉션</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePropertyAccessorMods">
        <source>access modifiers on properties</source>
        <target state="translated">속성에 대한 액세스 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExternAlias">
        <source>extern alias</source>
        <target state="translated">extern 별칭</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureIterators">
        <source>iterators</source>
        <target state="translated">반복기</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefault">
        <source>default operator</source>
        <target state="translated">기본 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDefaultLiteral">
        <source>default literal</source>
        <target state="translated">기본 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePrivateProtected">
        <source>private protected</source>
        <target state="translated">private protected</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullable">
        <source>nullable types</source>
        <target state="translated">nullable 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePatternMatching">
        <source>pattern matching</source>
        <target state="translated">패턴 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedAccessor">
        <source>expression body property accessor</source>
        <target state="translated">식 본문 속성 접근자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedDeOrConstructor">
        <source>expression body constructor and destructor</source>
        <target state="translated">식 본문 생성자 및 소멸자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureThrowExpression">
        <source>throw expression</source>
        <target state="translated">Throw 식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitArray">
        <source>implicitly typed array</source>
        <target state="translated">암시적으로 형식화된 배열</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureImplicitLocal">
        <source>implicitly typed local variable</source>
        <target state="translated">암시적으로 형식화된 지역 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAnonymousTypes">
        <source>anonymous types</source>
        <target state="translated">익명 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoImplementedProperties">
        <source>automatically implemented properties</source>
        <target state="translated">자동으로 구현된 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadonlyAutoImplementedProperties">
        <source>readonly automatically implemented properties</source>
        <target state="translated">자동으로 구현된 읽기 전용 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureObjectInitializer">
        <source>object initializer</source>
        <target state="translated">개체 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureCollectionInitializer">
        <source>collection initializer</source>
        <target state="translated">컬렉션 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureQueryExpression">
        <source>query expression</source>
        <target state="translated">쿼리 식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExtensionMethod">
        <source>extension method</source>
        <target state="translated">확장 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeaturePartialMethod">
        <source>partial method</source>
        <target state="translated">부분 메서드(Partial Method)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_METHOD">
        <source>method</source>
        <target state="translated">메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYPE">
        <source>type</source>
        <target state="translated">형식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_NAMESPACE">
        <source>namespace</source>
        <target state="translated">네임스페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_FIELD">
        <source>field</source>
        <target state="translated">필드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_PROPERTY">
        <source>property</source>
        <target state="translated">속성</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_UNKNOWN">
        <source>element</source>
        <target state="translated">요소</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_VARIABLE">
        <source>variable</source>
        <target state="translated">변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_LABEL">
        <source>label</source>
        <target state="translated">레이블</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EVENT">
        <source>event</source>
        <target state="translated">이벤트</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_TYVAR">
        <source>type parameter</source>
        <target state="translated">형식 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_ALIAS">
        <source>using alias</source>
        <target state="translated">using 별칭</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_EXTERNALIAS">
        <source>extern alias</source>
        <target state="translated">extern 별칭</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_SK_CONSTRUCTOR">
        <source>constructor</source>
        <target state="translated">생성자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FOREACHLOCAL">
        <source>foreach iteration variable</source>
        <target state="translated">foreach 반복 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FIXEDLOCAL">
        <source>fixed variable</source>
        <target state="translated">fixed 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_USINGLOCAL">
        <source>using variable</source>
        <target state="translated">using 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariant">
        <source>contravariant</source>
        <target state="translated">반공변(contravariant)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Contravariantly">
        <source>contravariantly</source>
        <target state="translated">반공변(contravariant) 방식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariant">
        <source>covariant</source>
        <target state="translated">공변(covariant)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Covariantly">
        <source>covariantly</source>
        <target state="translated">공변(covariant) 방식</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Invariantly">
        <source>invariantly</source>
        <target state="translated">불변(invariantly)</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDynamic">
        <source>dynamic</source>
        <target state="translated">동적</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNamedArgument">
        <source>named argument</source>
        <target state="translated">명명된 인수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOptionalParameter">
        <source>optional parameter</source>
        <target state="translated">선택적 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExceptionFilter">
        <source>exception filter</source>
        <target state="translated">예외 필터</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTypeVariance">
        <source>type variance</source>
        <target state="translated">형식 가변성(variance)</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFound">
        <source>SyntaxTree is not part of the compilation</source>
        <target state="translated">SyntaxTree는 컴파일의 일부가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree is not part of the compilation, so it cannot be removed</source>
        <target state="translated">SyntaxTree는 컴파일의 일부가 아니므로 제거할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore">
        <source>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</source>
        <target state="translated">'_' 이름은 상수를 참조하며, 무시 패턴은 참조하지 않습니다. 'var _'을 사용하여 값을 무시하거나 '@_'을 사용하여 해당 이름별 상수를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CaseConstantNamedUnderscore_Title">
        <source>Do not use '_' for a case constant.</source>
        <target state="translated">case 상수에 '_'을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">null 리터럴 또는 가능한 null 값을 null을 허용하지 않는 형식으로 변환하는 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConvertingNullableToNonNullable_Title">
        <source>Converting null literal or possible null value to non-nullable type.</source>
        <target state="translated">null 리터럴 또는 가능한 null 값을 null을 허용하지 않는 형식으로 변환하는 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">[NotNull] 또는 [DisallowNull]로 표시된 형식에는 가능한 null 값을 사용하지 못할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
        <source>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</source>
        <target state="translated">[NotNull] 또는 [DisallowNull]로 표시된 형식에는 가능한 null 값을 사용하지 못할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch">
        <source>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="new">Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DoesNotReturnMismatch_Title">
        <source>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</source>
        <target state="new">Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
        <source>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</source>
        <target state="translated">'{0}'은(는) 다른 참조 형식 Null 허용 여부를 사용하는 '{1}' 형식에 대한 인터페이스 목록에 이미 나열되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
        <source>Interface is already listed in the interface list with different nullability of reference types.</source>
        <target state="translated">인터페이스가 다른 참조 형식 Null 허용 여부를 사용하는 인터페이스 목록에 이미 나열되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">지정한 식은 항상 제공한 상수와 일치합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionAlwaysMatchesConstant_Title">
        <source>The given expression always matches the provided constant.</source>
        <target state="translated">지정한 식은 항상 제공한 상수와 일치합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">지정한 식은 제공한 패턴과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GivenExpressionNeverMatchesPattern_Title">
        <source>The given expression never matches the provided pattern.</source>
        <target state="translated">지정한 식은 제공한 패턴과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember">
        <source>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</source>
        <target state="translated">'readonly' 멤버에서 readonly 멤버가 아닌 '{0}' 멤버를 호출하면 '{1}'의 암시적 복사본이 생성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitCopyInReadOnlyMember_Title">
        <source>Call to non-readonly member from a 'readonly' member results in an implicit copy.</source>
        <target state="translated">'readonly' 멤버에서 readonly 멤버가 아닌 멤버를 호출하면 암시적 복사본이 생성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore">
        <source>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</source>
        <target state="translated">'_' 이름은 '{0}' 형식을 참조하며, 무시 패턴은 참조하지 않습니다. 형식에 '@_'을 사용하거나, 무시하려면 'var _'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsTypeNamedUnderscore_Title">
        <source>Do not use '_' to refer to the type in an is-type expression.</source>
        <target state="translated">'_'을 사용하여 is-type 식의 형식을 참조하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">nullable 참조 형식에 대한 주석은 코드에서 '#nullable' 주석 컨텍스트 내에만 사용되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Nullable 참조 형식에 대한 주석은 '#nullable' 주석 컨텍스트 내의 코드에서만 사용해야 합니다. 자동 생성된 코드에는 소스에 명시적 '#nullable' 지시문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</source>
        <target state="translated">Nullable 참조 형식에 대한 주석은 '#nullable' 주석 컨텍스트 내의 코드에서만 사용해야 합니다. 자동 생성된 코드에는 소스에 명시적 '#nullable' 지시문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingNonNullTypesContextForAnnotation_Title">
        <source>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</source>
        <target state="translated">nullable 참조 형식에 대한 주석은 코드에서 '#nullable' 주석 컨텍스트 내에만 사용되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Null 리터럴을 null을 허용하지 않는 참조 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullAsNonNullable_Title">
        <source>Cannot convert null literal to non-nullable reference type.</source>
        <target state="translated">Null 리터럴을 null을 허용하지 않는 참조 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument">
        <source>Possible null reference argument for parameter '{0}' in '{1}'.</source>
        <target state="translated">'{1}'의 매개 변수 '{0}'에 대한 가능한 null 참조 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceArgument_Title">
        <source>Possible null reference argument.</source>
        <target state="translated">가능한 null 참조 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment">
        <source>Possible null reference assignment.</source>
        <target state="translated">가능한 null 참조 할당입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceAssignment_Title">
        <source>Possible null reference assignment.</source>
        <target state="translated">가능한 null 참조 할당입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer">
        <source>Object or collection initializer implicitly dereferences possibly null member '{0}'.</source>
        <target state="translated">개체 또는 컬렉션 이니셜라이저가 가능한 null 멤버 '{0}'을(를) 암시적으로 역참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceInitializer_Title">
        <source>Object or collection initializer implicitly dereferences possibly null member.</source>
        <target state="translated">개체 또는 컬렉션 이니셜라이저가 가능한 null 멤버를 암시적으로 역참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">가능한 null 참조의 역참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReceiver_Title">
        <source>Dereference of a possibly null reference.</source>
        <target state="translated">가능한 null 참조의 역참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn">
        <source>Possible null reference return.</source>
        <target state="translated">가능한 null 참조 반환입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullReferenceReturn_Title">
        <source>Possible null reference return.</source>
        <target state="translated">가능한 null 참조 반환입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument">
        <source>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">참조 형식의 null 허용 여부 차이로 인해 '{3}'에서 '{1}' 형식 '{2}' 매개 변수에 대해 '{0}' 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput">
        <source>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</source>
        <target state="translated">참조 형식의 null 허용 여부 차이로 인해 '{3}'에서 '{2}' 매개 변수의 '{1}' 형식 출력으로 '{0}' 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgumentForOutput_Title">
        <source>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">참조 형식의 null 허용 여부 차이로 인해 매개 변수의 출력으로 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInArgument_Title">
        <source>Argument cannot be used for parameter due to differences in the nullability of reference types.</source>
        <target state="translated">참조 형식의 null 허용 여부 차이로 인해 매개 변수에 대해 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment">
        <source>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</source>
        <target state="translated">'{0}' 형식의 값에 있는 참조 형식 Null 허용 여부가 '{1}' 대상 형식과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInAssignment_Title">
        <source>Nullability of reference types in value doesn't match target type.</source>
        <target state="translated">값에 있는 참조 형식 Null 허용 여부가 대상 형식과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
        <source>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">'{1}' 메서드의 '{0}' 형식 매개 변수에 대한 제약 조건의 Null 허용 여부가 '{3}' 인터페이스 메서드의 '{2}' 형식 매개 변수에 대한 제약 조건과 일치하지 않습니다. 명시적 인터페이스 구현을 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
        <source>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</source>
        <target state="translated">형식 매개 변수에 대한 제약 조건의 Null 허용 여부가 암시적으로 구현된 인터페이스 메서드의 형식 매개 변수에 대한 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
        <source>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</source>
        <target state="translated">'{0}'의 부분 메서드(Partial method) 선언의 형식 매개 변수 '{1}'에 대한 제약 조건에 Null 허용 여부가 일관되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
        <source>Partial method declarations have inconsistent nullability in constraints for type parameter</source>
        <target state="translated">부분 메서드(Partial method) 선언의 형식 매개 변수에 대한 제약 조건에 Null 허용 여부가 일관되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">명시적 인터페이스 지정자의 참조 형식 Null 허용 여부가 형식에 의해 구현된 인터페이스와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
        <source>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</source>
        <target state="translated">명시적 인터페이스 지정자의 참조 형식 Null 허용 여부가 형식에 의해 구현된 인터페이스와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase">
        <source>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다. 기본 형식에 의해 구현된 인터페이스의 참조 형식 Null 허용 여부가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
        <source>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</source>
        <target state="translated">형식은 인터페이스 멤버를 구현하지 않습니다. 기본 형식에 의해 구현된 인터페이스의 참조 형식 Null 허용 여부가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}'.</source>
        <target state="translated">'{1}'의 '{0}' 매개 변수 형식에 있는 참조 형식 Null 허용 여부가 '{2}' 대상 대리자와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in type of parameter doesn't match the target delegate.</source>
        <target state="translated">매개 변수 형식에 있는 참조 형식 Null 허용 여부가 대상 대리자와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</source>
        <target state="translated">'{0}' 매개 변수 형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter doesn't match implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implemented member.</source>
        <target state="translated">매개 변수 형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</source>
        <target state="translated">'{1}'의 '{0}' 매개 변수 형식에 있는 참조 형식의 Null 허용 여부가 암시적으로 구현된 멤버 '{2}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in type of parameter doesn't match implicitly implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</source>
        <target state="translated">매개 변수 형식에 있는 참조 형식 Null 허용 여부가 암시적으로 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</source>
        <target state="translated">'{0}' 매개 변수 형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverrideBecauseOfAttributes">
        <source>Type of parameter '{0}' doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Type of parameter '{0}' doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverrideBecauseOfAttributes_Title">
        <source>Type of parameter doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Type of parameter doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
        <source>Nullability of reference types in type of parameter doesn't match overridden member.</source>
        <target state="translated">매개 변수 형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial">
        <source>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</source>
        <target state="translated">'{0}' 매개 변수 형식에 있는 참조 형식 Null 허용 여부가 부분 메서드(Partial Method) 선언과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
        <source>Nullability of reference types in type of parameter doesn't match partial method declaration.</source>
        <target state="translated">매개 변수 형식에 있는 참조 형식 Null 허용 여부가 부분 메서드(Partial Method) 선언과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
        <source>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}'.</source>
        <target state="translated">'{0}'의 반환 형식에 있는 참조 형식 Null 허용 여부가 '{1}' 대상 대리자와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
        <source>Nullability of reference types in return type doesn't match the target delegate.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 대상 대리자와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}'.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버 '{0}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in return type doesn't match implemented member '{0}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implemented member '{0}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in return type doesn't match implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implemented member.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' 반환 형식에 있는 참조 형식의 Null 허용 여부가 암시적으로 구현된 멤버 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementationBecauseOfAttributes">
        <source>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementationBecauseOfAttributes_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member because of nullability attributes.</source>
        <target state="new">Nullability of reference types in return type doesn't match implicitly implemented member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in return type doesn't match implicitly implemented member.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 암시적으로 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverrideBecauseOfAttributes">
        <source>Return type doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Return type doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverrideBecauseOfAttributes_Title">
        <source>Return type doesn't match overridden member because of nullability attributes.</source>
        <target state="new">Return type doesn't match overridden member because of nullability attributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
        <source>Nullability of reference types in return type doesn't match overridden member.</source>
        <target state="translated">반환 형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation">
        <source>Nullability of reference types in type doesn't match implemented member '{0}'.</source>
        <target state="translated">형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버 '{0}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implemented member.</source>
        <target state="translated">형식에 있는 참조 형식 Null 허용 여부가 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation">
        <source>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</source>
        <target state="translated">'{0}' 형식에 있는 참조 형식의 Null 허용 여부가 암시적으로 구현된 멤버 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
        <source>Nullability of reference types in type doesn't match implicitly implemented member.</source>
        <target state="translated">형식에 있는 참조 형식 Null 허용 여부가 암시적으로 구현된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeOnOverride_Title">
        <source>Nullability of reference types in type doesn't match overridden member.</source>
        <target state="translated">형식에 있는 참조 형식 Null 허용 여부가 재정의된 멤버와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</source>
        <target state="translated">'{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}' 형식 인수의 Null 허용 여부가 '{1}' 제약 조건 형식과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</source>
        <target state="translated">형식은 제네릭 형식 또는 메서드에서 형식 매개 변수로 사용할 수 없습니다. 형식 인수의 Null 허용 여부가 제약 조건 형식과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</source>
        <target state="translated">'{2}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{1}' 형식 매개 변수로 사용할 수 없습니다. '{2}' 형식 인수의 Null 허용 여부가 'notnull' 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</source>
        <target state="translated">형식은 제네릭 형식 또는 메서드에서 형식 매개 변수로 사용할 수 없습니다. 형식 인수의 Null 허용 여부가 'notnull' 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
        <source>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</source>
        <target state="translated">'{2}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{1}' 형식 매개 변수로 사용할 수 없습니다. '{2}' 형식 인수의 Null 허용 여부가 'class' 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
        <source>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</source>
        <target state="translated">형식은 제네릭 형식 또는 메서드에서 형식 매개 변수로 사용할 수 없습니다. 형식 인수의 Null 허용 여부가 'class' 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull">
        <source>Nullable value type may be null.</source>
        <target state="translated">Nullable 값 형식이 null일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NullableValueTypeMayBeNull_Title">
        <source>Nullable value type may be null.</source>
        <target state="translated">Nullable 값 형식이 null일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull">
        <source>Parameter '{0}' may not have a null value when exiting with '{1}'.</source>
        <target state="translated">'{1}'(으)로 종료할 때 '{0}' 매개 변수에 null 값을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParameterConditionallyDisallowsNull_Title">
        <source>Parameter may not have a null value when exiting in some condition.</source>
        <target state="translated">일부 조건으로 종료할 때 매개 변수에 null 값을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">[DoesNotReturn]으로 표시된 메서드는 반환하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShouldNotReturn_Title">
        <source>A method marked [DoesNotReturn] should not return.</source>
        <target state="translated">[DoesNotReturn]으로 표시된 메서드는 반환하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 식에서 입력 형식의 가능한 값을 모두 처리하지는 않습니다(전체 아님).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull">
        <source>The switch expression does not handle some null inputs (it is not exhaustive).</source>
        <target state="translated">switch 식은 일부 null 입력을 처리하지 않습니다(전체 아님).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustiveForNull_Title">
        <source>The switch expression does not handle some null inputs.</source>
        <target state="translated">switch 식은 일부 null 입력을 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SwitchExpressionNotExhaustive_Title">
        <source>The switch expression does not handle all possible values of its input type (it is not exhaustive).</source>
        <target state="translated">switch 식에서 입력 형식의 가능한 값을 모두 처리하지는 않습니다(전체 아님).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull">
        <source>Thrown value may be null.</source>
        <target state="translated">Throw된 값이 null일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ThrowPossibleNull_Title">
        <source>Thrown value may be null.</source>
        <target state="translated">Throw된 값이 null일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) 튜플 == 또는 != 연산자의 반대쪽에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleBinopLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</source>
        <target state="translated">튜플 요소 이름은(는) 튜플 == 또는 != 연산자의 반대쪽에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</source>
        <target state="translated">'{0}' 형식 매개 변수가 외부 메서드 '{1}'의 형식 매개 변수와 이름이 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
        <source>Type parameter has the same type as the type parameter from outer method.</source>
        <target state="translated">형식 매개 변수가 외부 메서드의 형식 매개 변수와 형식이 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">가능한 null 값을 unboxing합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnboxPossibleNull_Title">
        <source>Unboxing a possibly null value.</source>
        <target state="translated">가능한 null 값을 unboxing합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage">
        <source>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">'{0}' 매개 변수에 적용된 EnumeratorCancellationAttribute는 영향을 주지 않습니다. 이 특성은 IAsyncEnumerable을 반환하는 비동기 반복기 메서드에 있는 CancellationToken 형식의 매개 변수에만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
        <source>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</source>
        <target state="translated">EnumeratorCancellationAttribute는 영향을 주지 않습니다. 이 특성은 IAsyncEnumerable을 반환하는 비동기 반복기 메서드에 있는 CancellationToken 형식의 매개 변수에만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter">
        <source>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">비동기 반복기 '{0}'에 'CancellationToken' 형식의 매개 변수가 하나 이상 있지만, 이 중 'EnumeratorCancellation' 특성으로 데코레이트된 매개 변수가 없으므로 생성된 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator'에서 취소 토큰 매개 변수가 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndecoratedCancellationTokenParameter_Title">
        <source>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be unconsumed</source>
        <target state="translated">비동기 반복기 멤버에 'CancellationToken' 형식의 매개 변수가 하나 이상 있지만, 이 중 'EnumeratorCancellation' 특성으로 데코레이트된 매개 변수가 없으므로 생성된 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator'에서 취소 토큰 매개 변수가 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField">
        <source>Non-nullable {0} '{1}' is uninitialized. Consider declaring the {0} as nullable.</source>
        <target state="translated">null을 허용하지 않는 {0} '{1}'이(가) 초기화되지 않았습니다. {0}을(를) nullable로 선언하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UninitializedNonNullableField_Title">
        <source>Non-nullable field is uninitialized. Consider declaring as nullable.</source>
        <target state="translated">null을 허용하지 않는 필드가 초기화되지 않았습니다. nullable로 선언하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidToken">
        <source>The character(s) '{0}' cannot be used at this location.</source>
        <target state="translated">{0}' 문자를 이 위치에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_IncorrectComment">
        <source>Incorrect syntax was used in a comment.</source>
        <target state="translated">주석에 잘못된 구문이 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidCharEntity">
        <source>An invalid character was found inside an entity reference.</source>
        <target state="translated">엔터티 참조 내에서 잘못된 문자를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfTag">
        <source>Expected '&gt;' or '/&gt;' to close tag '{0}'.</source>
        <target state="translated">{0}' 닫기 태그에 '&gt;' 또는 '/&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedIdentifier">
        <source>An identifier was expected.</source>
        <target state="translated">식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidUnicodeChar">
        <source>Invalid unicode character.</source>
        <target state="translated">잘못된 유니코드 문자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_InvalidWhitespace">
        <source>Whitespace is not allowed at this location.</source>
        <target state="translated">이 위치에는 공백이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_LessThanInAttributeValue">
        <source>The character '&lt;' cannot be used in an attribute value.</source>
        <target state="translated">특성 값에 '&lt;' 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_MissingEqualsAttribute">
        <source>Missing equals sign between attribute and attribute value.</source>
        <target state="translated">특성과 특성 값 사이에 등호가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_RefUndefinedEntity_1">
        <source>Reference to undefined entity '{0}'.</source>
        <target state="translated">정의되지 않은 엔터티 '{0}'에 대한 참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoStartQuote">
        <source>A string literal was expected, but no opening quotation mark was found.</source>
        <target state="translated">문자열 리터럴이 필요하지만 여는 큰따옴표가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNoEndQuote">
        <source>Missing closing quotation mark for string literal.</source>
        <target state="translated">문자열 리터럴에 닫는 큰따옴표가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_StringLiteralNonAsciiQuote">
        <source>Non-ASCII quotations marks may not be used around string literals.</source>
        <target state="translated">ASCII가 아닌 따옴표는 문자열 리터럴 주위에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagNotExpected">
        <source>End tag was not expected at this location.</source>
        <target state="translated">이 위치에서 끝 태그가 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ElementTypeMatch">
        <source>End tag '{0}' does not match the start tag '{1}'.</source>
        <target state="translated">{0}' 끝 태그가 '{1}' 시작 태그와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_EndTagExpected">
        <source>Expected an end tag for element '{0}'.</source>
        <target state="translated">{0}' 요소에 대한 끝 태그가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_WhitespaceMissing">
        <source>Required white space was missing.</source>
        <target state="translated">필요한 공백이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_ExpectedEndOfXml">
        <source>Unexpected character at this location.</source>
        <target state="translated">이 위치에 예기치 않은 문자가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_CDataEndTagNotAllowed">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">요소 콘텐츠에는 ']]&gt;' 리터럴 문자열이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XML_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">{0}' 특성이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMetadataFile">
        <source>Metadata file '{0}' could not be found</source>
        <target state="translated">{0}' 메타데이터 파일을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references are not supported.</source>
        <target state="translated">메타데이터 참조는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_MetadataCantOpenFile">
        <source>Metadata file '{0}' could not be opened -- {1}</source>
        <target state="translated">{0}' 메타데이터 파일을 열 수 없습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDef">
        <source>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">{0}' 형식이 참조되지 않은 어셈블리에 정의되었습니다. '{1}' 어셈블리에 참조를 추가해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeDefFromModule">
        <source>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</source>
        <target state="translated">{0}' 형식이 추가되지 않은 모듈에 정의되었습니다. '{1}' 모듈을 추가해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputWriteFailed">
        <source>Could not write to output file '{0}' -- '{1}'</source>
        <target state="translated">출력 파일 '{0}'에 쓸 수 없습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEntryPoints">
        <source>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</source>
        <target state="translated">프로그램에 진입점이 두 개 이상 정의되어 있습니다. /main으로 컴파일하여 진입점이 포함된 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOps">
        <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
        <target state="translated">{0}' 연산자는 '{1}' 및 '{2}' 형식의 피연산자에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntDivByZero">
        <source>Division by constant zero</source>
        <target state="translated">상수 0으로 나누었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexLHS">
        <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
        <target state="translated">[]을 사용하는 인덱싱을 '{0}' 형식의 식에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexCount">
        <source>Wrong number of indices inside []; expected {0}</source>
        <target state="translated">[] 내부의 인덱스 수가 잘못되었습니다. {0}개가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOp">
        <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
        <target state="translated">{0}' 연산자는 '{1}' 형식의 피연산자에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOpOnNullOrDefault">
        <source>Operator '{0}' cannot be applied to operand '{1}'</source>
        <target state="translated">{0}' 연산자는 '{1}' 피연산자에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInStaticMeth">
        <source>Keyword 'this' is not valid in a static property, static method, or static field initializer</source>
        <target state="translated">정적 속성, 정적 메서드 또는 정적 필드 이니셜라이저에는 'this' 키워드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisInBadContext">
        <source>Keyword 'this' is not available in the current context</source>
        <target state="translated">현재 컨텍스트에서는 'this' 키워드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig">
        <source>'{0}' has the wrong signature to be an entry point</source>
        <target state="translated">'{0}'의 시그니처가 잘못되어 진입점이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidMainSig_Title">
        <source>Method has the wrong signature to be an entry point</source>
        <target state="translated">메서드의 서명이 잘못되어 진입점이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConv">
        <source>Cannot implicitly convert type '{0}' to '{1}'</source>
        <target state="translated">암시적으로 '{0}' 형식을 '{1}' 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitConv">
        <source>Cannot convert type '{0}' to '{1}'</source>
        <target state="translated">{0}' 형식을 '{1}' 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRange">
        <source>Constant value '{0}' cannot be converted to a '{1}'</source>
        <target state="translated">{0}' 상수 값을 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOps">
        <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
        <target state="translated">{0}' 연산자가 모호하여 '{1}' 및 '{2}' 형식의 피연산자에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigBinaryOpsOnDefault">
        <source>Operator '{0}' is ambiguous on operands 'default' and 'default'</source>
        <target state="translated">{0}' 연산자가 모호하여 'default' 및 'default' 피연산자에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUnaryOp">
        <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
        <target state="translated">{0}' 연산자가 모호하여 '{1}' 형식의 피연산자에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAttrOnOutParam">
        <source>An out parameter cannot have the In attribute</source>
        <target state="translated">out 매개 변수에는 In 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueCantBeNull">
        <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
        <target state="translated">{0}'은(는) null을 허용하지 않는 값 형식이므로 null을 이 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitBuiltinConv">
        <source>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</source>
        <target state="translated">참조 변환, boxing 변환, unboxing 변환, 래핑 변환 또는 null 형식 변환을 통해 '{0}' 형식을 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_DebugEmitFailure">
        <source>Unexpected error writing debug information -- '{0}'</source>
        <target state="translated">디버그 정보를 쓰는 동안 예기치 않은 오류가 발생했습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisReturnType">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 반환 형식이 '{0}' 메서드보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisParamType">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 매개 변수 형식이 '{0}' 메서드보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisFieldType">
        <source>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 필드 형식이 '{0}' 필드보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisPropertyType">
        <source>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 속성 형식이 '{0}' 속성보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerReturn">
        <source>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 인덱서 반환 형식이 '{0}' 인덱서보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisIndexerParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 매개 변수 형식이 '{0}' 인덱서보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 반환 형식이 '{0}' 연산자보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisOpParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 매개 변수 형식이 '{0}' 연산자보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateReturn">
        <source>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 반환 형식이 '{0}' 대리자보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisDelegateParam">
        <source>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 매개 변수 형식이 '{0}' 대리자보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseClass">
        <source>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 기본 클래스가 '{0}' 클래스보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBaseInterface">
        <source>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 기본 인터페이스가 '{0}' 인터페이스보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNeedsBothAccessors">
        <source>'{0}': event property must have both add and remove accessors</source>
        <target state="translated">'{0}': 이벤트 속성에는 add 및 remove 접근자가 둘 다 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotDelegate">
        <source>'{0}': event must be of a delegate type</source>
        <target state="translated">'{0}': 이벤트는 대리자 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent">
        <source>The event '{0}' is never used</source>
        <target state="translated">{0}' 이벤트가 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedEvent_Title">
        <source>Event is never used</source>
        <target state="translated">이벤트가 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventInitializer">
        <source>'{0}': instance event in interface cannot have initializer</source>
        <target state="translated">'{0}': 인터페이스의 인스턴스 이벤트에는 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsage">
        <source>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</source>
        <target state="translated">{0}' 이벤트는 += 또는 -=의 왼쪽에만 사용할 수 있습니다. 단 이 이벤트가 '{1}' 형식에서 사용될 때에는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitEventFieldImpl">
        <source>An explicit interface implementation of an event must use event accessor syntax</source>
        <target state="translated">이벤트의 명시적 인터페이스를 구현할 때에는 이벤트 접근자 구문을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonEvent">
        <source>'{0}': cannot override; '{1}' is not an event</source>
        <target state="translated">'{0}': 재정의할 수 없습니다. '{1}'은(는) 이벤트가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveMustHaveBody">
        <source>An add or remove accessor must have a body</source>
        <target state="translated">add 또는 remove 접근자에는 본문이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractEventInitializer">
        <source>'{0}': abstract event cannot have initializer</source>
        <target state="translated">'{0}': 추상 이벤트에는 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">{0}' 어셈블리 이름은 예약된 것이므로 대화형 세션에 참조로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedEnumerator">
        <source>The enumerator name '{0}' is reserved and cannot be used</source>
        <target state="translated">{0}' 열거자 이름은 예약된 것이므로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsMustHaveReferenceType">
        <source>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</source>
        <target state="translated">as 연산자는 참조 형식 또는 null 허용 형식과 함께 사용해야 합니다. '{0}'은(는) null을 허용하지 않는 값 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix">
        <source>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</source>
        <target state="translated">접미사 'l'은 숫자 '1'과 쉽게 혼동됩니다. 쉽게 구별할 수 있도록 'L'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LowercaseEllSuffix_Title">
        <source>The 'l' suffix is easily confused with the digit '1'</source>
        <target state="translated">접미사 'l'은 숫자 '1'과 쉽게 혼동됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventUsageNoField">
        <source>The event '{0}' can only appear on the left hand side of += or -=</source>
        <target state="translated">{0}' 이벤트는 += 또는 -=의 왼쪽에만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintOnlyAllowedOnGenericDecl">
        <source>Constraints are not allowed on non-generic declarations</source>
        <target state="translated">제네릭이 아닌 선언에는 제약 조건을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMustBeIdentifier">
        <source>Type parameter declaration must be an identifier not a type</source>
        <target state="translated">형식 매개 변수 선언은 형식이 아니라 식별자여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberReserved">
        <source>Type '{1}' already reserves a member called '{0}' with the same parameter types</source>
        <target state="translated">{1}' 형식에서 매개 변수 형식이 같은 '{0}' 멤버를 이미 예약했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName">
        <source>The parameter name '{0}' is a duplicate</source>
        <target state="translated">{0}' 매개 변수 이름이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInNS">
        <source>The namespace '{1}' already contains a definition for '{0}'</source>
        <target state="translated">{0}' 네임스페이스에 이미 '{1}'에 대한 정의가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNameInClass">
        <source>The type '{0}' already contains a definition for '{1}'</source>
        <target state="translated">{0}' 형식에 이미 '{1}'에 대한 정의가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContext">
        <source>The name '{0}' does not exist in the current context</source>
        <target state="translated">{0}' 이름이 현재 컨텍스트에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotInContextPossibleMissingReference">
        <source>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</source>
        <target state="translated">{0}' 이름이 현재 컨텍스트에 없습니다. '{1}' 어셈블리에 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigContext">
        <source>'{0}' is an ambiguous reference between '{1}' and '{2}'</source>
        <target state="translated">'{0}'은(는) '{1}' 및 '{2}' 사이에 모호한 참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing">
        <source>The using directive for '{0}' appeared previously in this namespace</source>
        <target state="translated">{0}'에 대한 using 지시문을 이 네임스페이스에서 이전에 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateUsing_Title">
        <source>Using directive appeared previously in this namespace</source>
        <target state="translated">using 지시문을 이전에 이 네임스페이스에서 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberFlag">
        <source>The modifier '{0}' is not valid for this item</source>
        <target state="translated">이 항목의 '{0}' 한정자가 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMemberProtection">
        <source>More than one protection modifier</source>
        <target state="translated">보호 한정자가 두 개 이상 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired">
        <source>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</source>
        <target state="translated">'{0}'은(는) 상속된 '{1}' 멤버를 숨깁니다. 숨기려면 new 키워드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Title">
        <source>Member hides inherited member; missing new keyword</source>
        <target state="translated">멤버가 상속된 멤버를 숨깁니다. new 키워드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewRequired_Description">
        <source>A variable was declared with the same name as a variable in a base class. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</source>
        <target state="translated">변수가 기본 클래스의 변수와 동일한 이름으로 선언되었습니다. 그러나 new 키워드가 사용되지 않았습니다. 이 경고는 new를 사용해야 하므로 선언에 new가 사용된 경우처럼 변수가 선언됨을 알려줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired">
        <source>The member '{0}' does not hide an accessible member. The new keyword is not required.</source>
        <target state="translated">{0}' 멤버는 액세스 가능한 멤버를 숨기지 않으므로 new 키워드가 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewNotRequired_Title">
        <source>Member does not hide an inherited member; new keyword is not required</source>
        <target state="translated">멤버는 상속된 멤버를 숨기지 않으므로 new 키워드가 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircConstValue">
        <source>The evaluation of the constant value for '{0}' involves a circular definition</source>
        <target state="translated">{0}'에 대한 상수 값 계산에 순환 정의가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyExists">
        <source>Type '{1}' already defines a member called '{0}' with the same parameter types</source>
        <target state="translated">{1}' 형식은 동일한 매개 변수 형식을 가진 '{0}' 멤버를 미리 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticNotVirtual">
        <source>A static member '{0}' cannot be marked as override, virtual, or abstract</source>
        <target state="translated">{0}' 정적 멤버는 override, virtual 또는 abstract로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNew">
        <source>A member '{0}' marked as override cannot be marked as new or virtual</source>
        <target state="translated">override로 표시된 '{0}' 멤버는 new 또는 virtual로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected">
        <source>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</source>
        <target state="translated">'{0}'은(는) 상속된 '{1}' 멤버를 숨깁니다. 현재 멤버가 해당 구현을 재정의하도록 하려면 override 키워드를 추가하세요. 그렇지 않으면 new 키워드를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NewOrOverrideExpected_Title">
        <source>Member hides inherited member; missing override keyword</source>
        <target state="translated">멤버가 상속된 멤버를 숨깁니다. override 키워드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotExpected">
        <source>'{0}': no suitable method found to override</source>
        <target state="translated">'{0}': 재정의할 적절한 메서드를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceUnexpected">
        <source>A namespace cannot directly contain members such as fields or methods</source>
        <target state="translated">네임스페이스는 필드나 메서드와 같은 멤버를 직접 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMember">
        <source>'{0}' does not contain a definition for '{1}'</source>
        <target state="translated">'{0}'에는 '{1}'에 대한 정의가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKknown">
        <source>'{0}' is a {1} but is used like a {2}</source>
        <target state="translated">'{0}'은(는) {1}이지만 {2}처럼 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSKunknown">
        <source>'{0}' is a {1}, which is not valid in the given context</source>
        <target state="translated">'{0}'은(는) 지정한 컨텍스트에서 유효하지 않은 {1}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectRequired">
        <source>An object reference is required for the non-static field, method, or property '{0}'</source>
        <target state="translated">static이 아닌 필드, 메서드 또는 속성 '{0}'에 개체 참조가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigCall">
        <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
        <target state="translated">{0}' 및 '{1}'의 메서드 또는 속성 간 호출이 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAccess">
        <source>'{0}' is inaccessible due to its protection level</source>
        <target state="translated">'보호 수준 때문에 '{0}'에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethDelegateMismatch">
        <source>No overload for '{0}' matches delegate '{1}'</source>
        <target state="translated">{1}' 대리자와 일치하는 '{0}'에 대한 오버로드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetObjectRequired">
        <source>An object of a type convertible to '{0}' is required</source>
        <target state="translated">{0}'(으)로 변환할 수 있는 형식의 개체가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequired">
        <source>Since '{0}' returns void, a return keyword must not be followed by an object expression</source>
        <target state="translated">{0}'이(가) void를 반환하므로 return 키워드 뒤에 개체 식이 나오면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalDuplicate">
        <source>A local variable or function named '{0}' is already defined in this scope</source>
        <target state="translated">이름이 '{0}'인 지역 변수 또는 함수가 이미 이 범위 안에 정의되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgLvalueExpected">
        <source>The left-hand side of an assignment must be a variable, property or indexer</source>
        <target state="translated">할당식의 왼쪽은 변수, 속성 또는 인덱서여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstParam">
        <source>'{0}': a static constructor must be parameterless</source>
        <target state="translated">'{0}': 정적 생성자에는 매개 변수가 없어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotConstantExpression">
        <source>The expression being assigned to '{0}' must be constant</source>
        <target state="translated">{0}'에 할당할 식은 상수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullConstRefField">
        <source>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</source>
        <target state="translated">'{0}'의 형식이 '{1}'입니다. 참조 형식이 문자열이 아닌 const 필드는 null로만 초기화할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalIllegallyOverrides">
        <source>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</source>
        <target state="translated">이름이 '{0}'인 지역 또는 매개 변수는 이 범위에서 선언될 수 없습니다. 해당 이름이 지역 또는 매개 변수를 정의하기 위해 바깥쪽 지역 범위에서 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingNamespace">
        <source>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</source>
        <target state="translated">using namespace' 지시문은 네임스페이스에만 적용할 수 있습니다. '{0}'은(는) 네임스페이스가 아니라 형식입니다. 대신 'using static' 지시문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUsingType">
        <source>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</source>
        <target state="translated">using static' 지시문은 형식에만 적용할 수 있습니다. '{0}'은(는) 형식이 아니라 네임스페이스입니다. 대신 'using namespace' 지시문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAliasHere">
        <source>A 'using static' directive cannot be used to declare an alias</source>
        <target state="translated">using static' 지시문을 사용하여 별칭을 선언할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBreakOrCont">
        <source>No enclosing loop out of which to break or continue</source>
        <target state="translated">break 또는 continue되어 빠져 나갈 루프가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLabel">
        <source>The label '{0}' is a duplicate</source>
        <target state="translated">{0}' 레이블이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructors">
        <source>The type '{0}' has no constructors defined</source>
        <target state="translated">{0}' 형식에 정의된 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewAbstract">
        <source>Cannot create an instance of the abstract class or interface '{0}'</source>
        <target state="translated">{0}' 추상 클래스 또는 인터페이스의 인스턴스를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstValueRequired">
        <source>A const field requires a value to be provided</source>
        <target state="translated">const 필드에 값을 입력해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBase">
        <source>Circular base class dependency involving '{0}' and '{1}'</source>
        <target state="translated">{0}' 및 '{1}'과(와) 관련된 순환 기본 클래스 종속성입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateConstructor">
        <source>The delegate '{0}' does not have a valid constructor</source>
        <target state="translated">{0}' 대리자에는 유효한 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodNameExpected">
        <source>Method name expected</source>
        <target state="translated">메서드 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantExpected">
        <source>A constant value is expected</source>
        <target state="translated">상수 값이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_V6SwitchGoverningTypeValueExpected">
        <source>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</source>
        <target state="translated">C# 6 이전 버전에서 switch 식 또는 case 레이블은 bool, char, string, integral, enum 또는 해당하는 nullable 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeValueExpected">
        <source>A value of an integral type expected</source>
        <target state="translated">정수 계열 형식 값이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateCaseLabel">
        <source>The switch statement contains multiple cases with the label value '{0}'</source>
        <target state="translated">switch 문에 '{0}' 레이블 값을 사용하는 경우가 여러 개 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidGotoCase">
        <source>A goto case is only valid inside a switch statement</source>
        <target state="translated">goto case는 switch 문 내부에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyLacksGet">
        <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
        <target state="translated">{0}' 속성 또는 인덱서는 get 접근자가 없으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExceptionType">
        <source>The type caught or thrown must be derived from System.Exception</source>
        <target state="translated">Catch 또는 Throw된 형식은 System.Exception에서 파생되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrow">
        <source>A throw statement with no arguments is not allowed outside of a catch clause</source>
        <target state="translated">인수가 없는 Throw 문은 Catch 절 외부에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFinallyLeave">
        <source>Control cannot leave the body of a finally clause</source>
        <target state="translated">제어가 finally 절의 본문을 벗어날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelShadow">
        <source>The label '{0}' shadows another label by the same name in a contained scope</source>
        <target state="translated">{0}' 레이블은 포함된 범위에서 같은 이름으로 다른 레이블을 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotFound">
        <source>No such label '{0}' within the scope of the goto statement</source>
        <target state="translated">goto 문의 범위 내에 '{0}' 레이블이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreachableCatch">
        <source>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</source>
        <target state="translated">이전의 catch 절에서 이 형식이나 상위 형식('{0}')의 예외를 모두 catch합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue">
        <source>Filter expression is a constant 'true', consider removing the filter</source>
        <target state="translated">필터 식이 상수 'true'입니다. 필터를 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantTrue_Title">
        <source>Filter expression is a constant 'true'</source>
        <target state="translated">필터 식이 상수 'true'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnExpected">
        <source>'{0}': not all code paths return a value</source>
        <target state="translated">'{0}': 코드 경로 중 일부만 값을 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected</source>
        <target state="translated">접근할 수 없는 코드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">접근할 수 없는 코드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallThrough">
        <source>Control cannot fall through from one case label ('{0}') to another</source>
        <target state="translated">한 case 레이블('{0}')에서 다른 case 레이블로 제어를 이동할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel">
        <source>This label has not been referenced</source>
        <target state="translated">이 레이블은 참조되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLabel_Title">
        <source>This label has not been referenced</source>
        <target state="translated">이 레이블은 참조되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolation">
        <source>Use of unassigned local variable '{0}'</source>
        <target state="translated">할당되지 않은 '{0}' 지역 변수를 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar">
        <source>The variable '{0}' is declared but never used</source>
        <target state="translated">{0}' 변수가 선언되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVar_Title">
        <source>Variable is declared but never used</source>
        <target state="translated">변수가 선언되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField">
        <source>The field '{0}' is never used</source>
        <target state="translated">{0}' 필드가 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedField_Title">
        <source>Field is never used</source>
        <target state="translated">필드가 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationField">
        <source>Use of possibly unassigned field '{0}'</source>
        <target state="translated">할당되지 않은 '{0}' 필드를 사용하고 있는 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationProperty">
        <source>Use of possibly unassigned auto-implemented property '{0}'</source>
        <target state="translated">할당되지 않은 자동 구현 속성 '{0}'을(를) 사용하고 있는 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThis">
        <source>Field '{0}' must be fully assigned before control is returned to the caller</source>
        <target state="translated">제어를 호출자에게 반환하려면 '{0}' 필드가 완전히 할당되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigQM">
        <source>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</source>
        <target state="translated">{0}'과(와) '{1}'은(는) 서로 암시적으로 변환되므로 조건식의 형식을 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidQM">
        <source>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</source>
        <target state="translated">{0}'과(와) '{1}' 사이에 암시적 변환이 없으므로 조건식의 형식을 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoBaseClass">
        <source>A base class is required for a 'base' reference</source>
        <target state="translated">base' 참조에는 기본 클래스가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseIllegal">
        <source>Use of keyword 'base' is not valid in this context</source>
        <target state="translated">이 컨텍스트에서는 'base' 키워드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectProhibited">
        <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
        <target state="translated">{0}' 멤버는 인스턴스 참조를 사용하여 액세스할 수 없습니다. 대신 형식 이름을 사용하여 한정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamUnassigned">
        <source>The out parameter '{0}' must be assigned to before control leaves the current method</source>
        <target state="translated">제어가 현재 메서드를 벗어나기 전에 '{0}' out 매개 변수를 할당해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidArray">
        <source>Invalid rank specifier: expected ',' or ']'</source>
        <target state="translated">잘못된 차수 지정자입니다. ',' 또는 ']'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasBody">
        <source>'{0}' cannot be extern and declare a body</source>
        <target state="translated">'{0}'은(는) extern일 수 없으며 본문을 선언합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternHasConstructorInitializer">
        <source>'{0}' cannot be extern and have a constructor initializer</source>
        <target state="translated">'{0}'은(는) extern일 수 없으며 생성자 이니셜라이저가 있으면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndExtern">
        <source>'{0}' cannot be both extern and abstract</source>
        <target state="translated">'{0}'은(는) extern 및 abstract일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamType">
        <source>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</source>
        <target state="translated">특성 생성자 매개 변수 '{0}'이(가) 유효한 특성 매개 변수 형식이 아닌 '{1}' 형식을 사용하고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeArgument">
        <source>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</source>
        <target state="translated">특성 인수는 특성 매개 변수 형식의 배열 생성 식, 상수 식 또는 typeof 식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeParamDefaultArgument">
        <source>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</source>
        <target state="translated">특성 생성자 매개 변수 '{0}'은(는) 선택 사항이지만 기본 매개 변수 값이 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue">
        <source>The given expression is always of the provided ('{0}') type</source>
        <target state="translated">지정된 식은 항상 제공된 ('{0}') 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysTrue_Title">
        <source>'is' expression's given expression is always of the provided type</source>
        <target state="translated">'is' 식의 지정된 식이 항상 제공된 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse">
        <source>The given expression is never of the provided ('{0}') type</source>
        <target state="translated">지정된 식은 제공된 ('{0}') 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsAlwaysFalse_Title">
        <source>'is' expression's given expression is never of the provided type</source>
        <target state="translated">'is' 식의 지정된 식이 제공된 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LockNeedsReference">
        <source>'{0}' is not a reference type as required by the lock statement</source>
        <target state="translated">'{0}'은(는) lock 문에 필요한 참조 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullNotValid">
        <source>Use of null is not valid in this context</source>
        <target state="translated">이 컨텍스트에서는 null을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultLiteralNotValid">
        <source>Use of default literal is not valid in this context</source>
        <target state="translated">이 컨텍스트에서는 기본 리터럴을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationThis">
        <source>The 'this' object cannot be used before all of its fields are assigned to</source>
        <target state="translated">모든 필드에 값을 할당하기 전에는 'this' 개체를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgsInvalid">
        <source>The __arglist construct is valid only within a variable argument method</source>
        <target state="translated">__arglist 구문은 가변 인수 메서드 내에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrExpected">
        <source>The * or -&gt; operator must be applied to a pointer</source>
        <target state="translated">* 또는 -&gt; 연산자는 포인터에 적용되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PtrIndexSingle">
        <source>A pointer must be indexed by only one value</source>
        <target state="translated">포인터는 한 값에 의해서만 인덱싱되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField">
        <source>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">{0}'은(는) 참조로 마샬링하는 클래스의 필드이므로 ref 또는 out 값으로 사용하거나 해당 주소를 가져오면 런타임 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ByRefNonAgileField_Title">
        <source>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</source>
        <target state="translated">참조로 마샬링하는 클래스의 필드를 ref 또는 out 값으로 사용하거나 해당 주소를 가져오면 런타임 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic">
        <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">정적 읽기 전용 필드에는 할당할 수 없습니다. 단 정적 생성자 또는 변수 이니셜라이저에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic">
        <source>A static readonly field cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">정적 읽기 전용 필드는 ref 또는 out 값으로 사용할 수 없습니다. 단 정적 생성자에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyProp">
        <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">{0}' 속성 또는 인덱서는 읽기 전용이므로 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalStatement">
        <source>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</source>
        <target state="translated">대입, 호출, 증가, 감소 및 새 개체 식만 문으로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetEnumerator">
        <source>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</source>
        <target state="translated">foreach의 반환 형식 '{1}'('{0}')에는 적절한 공용 MoveNext 메서드 및 공용 Current 속성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyLocals">
        <source>Only 65534 locals, including those generated by the compiler, are allowed</source>
        <target state="translated">지역 변수는 컴파일러가 생성한 것을 포함하여 65534개까지만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractBaseCall">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">추상 기본 멤버를 호출할 수 없습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefProperty">
        <source>A property or indexer may not be passed as an out or ref parameter</source>
        <target state="translated">속성 또는 인덱서는 out 또는 ref 매개 변수로 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ManagedAddr">
        <source>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</source>
        <target state="translated">관리되는 형식('{0}')의 주소 또는 크기를 가져오거나 해당 형식에 대한 포인터를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFixedInitType">
        <source>The type of a local declared in a fixed statement must be a pointer type</source>
        <target state="translated">fixed 문에 선언된 지역 변수의 형식은 포인터 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedMustInit">
        <source>You must provide an initializer in a fixed or using statement declaration</source>
        <target state="translated">fixed 또는 using 문 선언에 이니셜라이저를 입력해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAddrOp">
        <source>Cannot take the address of the given expression</source>
        <target state="translated">지정된 식의 주소를 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeeded">
        <source>You can only take the address of an unfixed expression inside of a fixed statement initializer</source>
        <target state="translated">고정되지 않은 식의 주소는 fixed 문의 이니셜라이저를 통해서만 가져올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotNeeded">
        <source>You cannot use the fixed statement to take the address of an already fixed expression</source>
        <target state="translated">이미 고정된 식의 주소를 가져오는 데 fixed 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeNeeded">
        <source>Pointers and fixed size buffers may only be used in an unsafe context</source>
        <target state="translated">포인터와 고정 크기 버퍼는 안전하지 않은 컨텍스트에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpTFRetType">
        <source>The return type of operator True or False must be bool</source>
        <target state="translated">True 또는 False 연산자의 반환 형식은 bool이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNeedsMatch">
        <source>The operator '{0}' requires a matching operator '{1}' to also be defined</source>
        <target state="translated">{0}' 연산자를 사용하려면 짝이 되는 '{1}' 연산자도 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoolOp">
        <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</source>
        <target state="translated">사용자 정의 논리 연산자('{0}')를 단락(short circuit) 연산자로 사용하려면 동일한 반환 형식과 매개 변수 형식을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveOpTF">
        <source>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</source>
        <target state="translated">{0}'을(를) 단락(short circuit) 연산자로 사용하려면 선언 형식 '{1}'이(가) true 및 false 연산자를 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg">
        <source>The variable '{0}' is assigned but its value is never used</source>
        <target state="translated">{0}' 할당되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedVarAssg_Title">
        <source>Variable is assigned but its value is never used</source>
        <target state="translated">변수가 할당되었지만 해당 값이 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CheckedOverflow">
        <source>The operation overflows at compile time in checked mode</source>
        <target state="translated">checked 모드에서 컴파일하면 작업이 오버플로됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstOutOfRangeChecked">
        <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
        <target state="translated">{0}' 상수 값을 '{1}'(으)로 변환할 수 없습니다. 재정의하려면 'unchecked' 구문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarargs">
        <source>A method with vararg cannot be generic, be in a generic type, or have a params parameter</source>
        <target state="translated">vararg가 있는 메서드는 제네릭이거나 제네릭 형식일 수 없으며 params 매개 변수를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsMustBeArray">
        <source>The params parameter must be a single dimensional array</source>
        <target state="translated">매개 변수 배열은 1차원 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalArglist">
        <source>An __arglist expression may only appear inside of a call or new expression</source>
        <target state="translated">__arglist 식은 call 또는 new 식 내부에만 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalUnsafe">
        <source>Unsafe code may only appear if compiling with /unsafe</source>
        <target state="translated">안전하지 않은 코드는 /unsafe를 사용하여 컴파일하는 경우에만 나타날 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigMember">
        <source>Ambiguity between '{0}' and '{1}'</source>
        <target state="translated">{0}'과(와) '{1}' 사이에 모호성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadForeachDecl">
        <source>Type and identifier are both required in a foreach statement</source>
        <target state="translated">foreach 문에는 형식과 식별자가 모두 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsLast">
        <source>A params parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">params 매개 변수는 정식 매개 변수 목록에서 마지막에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SizeofUnsafe">
        <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</source>
        <target state="translated">'{0}'에 미리 정의된 크기가 없으므로 sizeof는 안전하지 않은 컨텍스트에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNS">
        <source>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</source>
        <target state="translated">{1}' 네임스페이스에 '{0}' 형식 또는 네임스페이스 이름이 없습니다. 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitRefNonstatic">
        <source>A field initializer cannot reference the non-static field, method, or property '{0}'</source>
        <target state="translated">필드 이니셜라이저는 static이 아닌 필드, 메서드 또는 '{0}' 속성을 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedNonOverride">
        <source>'{0}' cannot be sealed because it is not an override</source>
        <target state="translated">'{0}'은(는) override가 아니므로 sealed가 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideSealed">
        <source>'{0}': cannot override inherited member '{1}' because it is sealed</source>
        <target state="translated">'{0}': 상속된 '{1}' 멤버는 봉인되어 있으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidError">
        <source>The operation in question is undefined on void pointers</source>
        <target state="translated">요청한 작업이 void 포인터에 정의되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnOverride">
        <source>The Conditional attribute is not valid on '{0}' because it is an override method</source>
        <target state="translated">{0}'은(는) 재정의 메서드이기 때문에 Conditional 특성이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PointerInAsOrIs">
        <source>Neither 'is' nor 'as' is valid on pointer types</source>
        <target state="translated">포인터 형식에는 'is' 또는 'as'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingFinalizeDeprecated">
        <source>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</source>
        <target state="translated">소멸자 및 object.Finalize는 직접 호출할 수 없습니다. 가능한 경우 IDisposable.Dispose를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">{0}' 형식 또는 네임스페이스 이름을 찾을 수 없습니다. using 지시문 또는 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeStackAllocSize">
        <source>Cannot use a negative size with stackalloc</source>
        <target state="translated">stackalloc에는 음수 크기를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Cannot create an array with a negative size</source>
        <target state="translated">음수 크기의 배열은 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideFinalizeDeprecated">
        <source>Do not override object.Finalize. Instead, provide a destructor.</source>
        <target state="translated">object.Finalize를 재정의하는 대신 소멸자를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallingBaseFinalizeDeprecated">
        <source>Do not directly call your base class Finalize method. It is called automatically from your destructor.</source>
        <target state="translated">기본 클래스 Finalize 메서드를 직접 호출하지 마세요. 이 메서드는 소멸자에서 자동으로 호출됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex">
        <source>Indexing an array with a negative index (array indices always start at zero)</source>
        <target state="translated">음수 인덱스를 사용하여 배열을 인덱싱했습니다. 배열 인덱스는 항상 0부터 시작합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NegativeArrayIndex_Title">
        <source>Indexing an array with a negative index</source>
        <target state="translated">음수 인덱스를 사용하여 배열을 인덱싱했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft">
        <source>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</source>
        <target state="translated">의도하지 않은 참조 비교가 있을 수 있습니다. 값 비교를 가져오려면 왼쪽을 '{0}' 형식으로 캐스팅하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareLeft_Title">
        <source>Possible unintended reference comparison; left hand side needs cast</source>
        <target state="translated">의도하지 않은 참조 비교가 있을 수 있습니다. 왼쪽을 캐스팅해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight">
        <source>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</source>
        <target state="translated">의도하지 않은 참조 비교가 있을 수 있습니다. 값 비교를 가져오려면 오른쪽을 '{0}' 형식으로 캐스팅하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRefCompareRight_Title">
        <source>Possible unintended reference comparison; right hand side needs cast</source>
        <target state="translated">의도하지 않은 참조 비교가 있을 수 있습니다. 오른쪽을 캐스팅해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCastInFixed">
        <source>The right hand side of a fixed statement assignment may not be a cast expression</source>
        <target state="translated">fixed 문의 오른쪽에는 캐스트 식을 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackallocInCatchFinally">
        <source>stackalloc may not be used in a catch or finally block</source>
        <target state="translated">stackalloc는 catch 또는 finally 블록에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsLast">
        <source>An __arglist parameter must be the last parameter in a formal parameter list</source>
        <target state="translated">__arglist 매개 변수는 정식 매개 변수 목록의 마지막에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPartial">
        <source>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</source>
        <target state="translated">{0}' 형식의 선언에 partial 한정자가 없습니다. 형식이 같은 다른 partial 선언이 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeKindConflict">
        <source>Partial declarations of '{0}' must be all classes, all structs, or all interfaces</source>
        <target state="translated">{0}'의 partial 선언은 모두 클래스, 구조체 또는 인터페이스여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialModifierConflict">
        <source>Partial declarations of '{0}' have conflicting accessibility modifiers</source>
        <target state="translated">{0}'의 partial 선언에 충돌하는 액세스 가능성 한정자가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMultipleBases">
        <source>Partial declarations of '{0}' must not specify different base classes</source>
        <target state="translated">{0}'의 partial 선언에는 서로 다른 기본 클래스를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParams">
        <source>Partial declarations of '{0}' must have the same type parameter names in the same order</source>
        <target state="translated">{0}'의 partial 선언은 형식 매개 변수 이름과 그 순서가 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongConstraints">
        <source>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">{0}'의 partial 선언에는 '{1}' 형식 매개 변수의 제약 조건에 일관성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoImplicitConvCast">
        <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
        <target state="translated">암시적으로 '{0}' 형식을 '{1}' 형식으로 변환할 수 없습니다. 명시적 변환이 있습니다. 캐스트가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMisplaced">
        <source>The 'partial' modifier can only appear immediately before 'class', 'struct', 'interface', or 'void'</source>
        <target state="translated">partial' 한정자는 'class', 'struct', 'interface' 또는 'void' 바로 앞에만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportedCircularBase">
        <source>Imported type '{0}' is invalid. It contains a circular base class dependency.</source>
        <target state="translated">가져온 '{0}' 형식이 잘못되었습니다. 이 형식에는 기본 클래스 순환 종속성이 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseDefViolationOut">
        <source>Use of unassigned out parameter '{0}'</source>
        <target state="translated">할당되지 않은 '{0}' out 매개 변수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArraySizeInDeclaration">
        <source>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</source>
        <target state="translated">변수 선언에는 배열 크기를 지정할 수 없습니다. 'new' 식을 사용하여 초기화해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleGetter">
        <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
        <target state="translated">get 접근자에 액세스할 수 없으므로 '{0}' 속성 또는 인덱서는 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSetter">
        <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
        <target state="translated">set 접근자에 액세스할 수 없으므로 '{0}' 속성 또는 인덱서는 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPropertyAccessMod">
        <source>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</source>
        <target state="translated">{0}' 접근자의 액세스 가능성 한정자는 '{1}' 속성 또는 인덱서보다 제한적이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyAccessMods">
        <source>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</source>
        <target state="translated">{0}' 속성 또는 인덱서의 두 접근자에 대해 액세스 가능성 한정자를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessModMissingAccessor">
        <source>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</source>
        <target state="translated">'{0}': 접근자의 액세스 가능성 한정자는 속성 또는 인덱서에 get 접근자와 set 접근자가 모두 있는 경우에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceAccessor">
        <source>'{0}' does not implement interface member '{1}'. '{2}' is not public.</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다. '{2}'이(가) public이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</source>
        <target state="translated">'{0}'이(가) '{1}' 패턴을 구현하지 않습니다. '{2}'이(가) '{3}'에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternIsAmbiguous_Title">
        <source>Type does not implement the collection pattern; members are ambiguous</source>
        <target state="translated">형식은 컬렉션 패턴을 구현하지 않습니다. 멤버가 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' is either static or not public.</source>
        <target state="translated">'{0}'이(가) '{1}' 패턴을 구현하지 않습니다. '{2}'이(가) public이 아니거나 static입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternStaticOrInaccessible_Title">
        <source>Type does not implement the collection pattern; member is either static or not public</source>
        <target state="translated">형식은 컬렉션 패턴을 구현하지 않습니다. 멤버가 public이 아니거나 static입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature">
        <source>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</source>
        <target state="translated">'{0}'이(가) '{1}' 패턴을 구현하지 않습니다. '{2}'에 잘못된 시그니처가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PatternBadSignature_Title">
        <source>Type does not implement the collection pattern; member has the wrong signature</source>
        <target state="translated">형식은 컬렉션 패턴을 구현하지 않습니다. 멤버의 서명이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</source>
        <target state="translated">'{0}'에서 friend 액세스 권한을 부여했지만, 출력 어셈블리('{1}')의 공개 키가 부여한 어셈블리의 InternalsVisibleTo 특성에서 지정된 키와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">{0}'에서 friend 액세스 권한을 부여했지만, 출력 어셈블리의 강력한 이름 서명 상태가 부여한 어셈블리의 상태와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass">
        <source>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</source>
        <target state="translated">partial 구조체 '{0}'의 여러 선언에서 필드 간 순서가 정의되어 있지 않습니다. 순서를 지정하려면 모든 인스턴스 필드가 같은 선언에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SequentialOnPartialClass_Title">
        <source>There is no defined ordering between fields in multiple declarations of partial struct</source>
        <target state="translated">partial 구조체의 여러 선언에서 필드 간 순서가 정의되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstType">
        <source>The type '{0}' cannot be declared const</source>
        <target state="translated">{0}' 형식은 const로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNewTyvar">
        <source>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</source>
        <target state="translated">{0}' 변수 형식에 new() 제약 조건이 없으므로 이 변수 형식의 인스턴스를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArity">
        <source>Using the generic {1} '{0}' requires {2} type arguments</source>
        <target state="translated">제네릭 {1} '{0}'을(를) 사용하려면 {2} 형식 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgument">
        <source>The type '{0}' may not be used as a type argument</source>
        <target state="translated">{0}' 형식은 형식 인수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsNotAllowed">
        <source>The {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">{1} '{0}'은(는) 형식 인수와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HasNoTypeVars">
        <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
        <target state="translated">제네릭이 아닌 {1} '{0}'은(는) 형식 인수와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewConstraintNotSatisfied">
        <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">'제네릭 형식 또는 메서드 '{0}'에서 '{1}' 매개 변수로 사용하려면 '{2}'이(가) 매개 변수가 없는 public 생성자를 사용하는 비추상 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedRefType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
        <target state="translated">{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}'에서 '{1}'(으)로의 암시적 참조 변환이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableEnum">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
        <target state="translated">{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}' null 허용 형식이 '{1}' 제약 조건을 충족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedNullableInterface">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
        <target state="translated">{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}' null 허용 형식이 '{1}' 제약 조건을 충족하지 않습니다. null 허용 형식은 어떠한 인터페이스 제약 조건도 만족할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedTyVar">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
        <target state="translated">{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}'에서 '{1}'(으)로의 boxing 변환 또는 형식 매개 변수 변환이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfiedValType">
        <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
        <target state="translated">{3}' 형식은 제네릭 형식 또는 '{0}' 메서드에서 '{2}' 형식 매개 변수로 사용할 수 없습니다. '{3}'에서 '{1}'(으)로의 boxing 변환이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateGeneratedName">
        <source>The parameter name '{0}' conflicts with an automatically-generated parameter name</source>
        <target state="translated">매개 변수 이름 '{0}'이(가) 자동으로 생성된 매개 변수 이름과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFound">
        <source>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</source>
        <target state="translated">전역 네임스페이스에 '{0}' 형식 또는 네임스페이스 이름이 없습니다. 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundMustBeLast">
        <source>The new() constraint must be the last constraint specified</source>
        <target state="translated">new() 제약 조건은 마지막에 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric">
        <source>'{0}': an entry point cannot be generic or in a generic type</source>
        <target state="translated">'{0}': 진입점은 제네릭 또는 제네릭 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainCantBeGeneric_Title">
        <source>An entry point cannot be generic or in a generic type</source>
        <target state="translated">진입점은 제네릭 또는 제네릭 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarCantBeNull">
        <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
        <target state="translated">null을 허용하지 않는 값 형식일 수 있으므로 null을 '{0}' 형식 매개 변수로 변환할 수 없습니다. 대신 'default({0})'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCantBeGeneric">
        <source>Cannot apply attribute class '{0}' because it is generic</source>
        <target state="translated">제네릭이므로 '{0}' 특성 클래스를 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateBound">
        <source>Duplicate constraint '{0}' for type parameter '{1}'</source>
        <target state="translated">{1}' 형식 매개 변수에 대한 '{0}' 제약 조건이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassBoundNotFirst">
        <source>The class type constraint '{0}' must come before any other constraints</source>
        <target state="translated">클래스 형식 제약 조건 '{0}'은(는) 다른 모든 제약 조건보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRetType">
        <source>'{1} {0}' has the wrong return type</source>
        <target state="translated">'{1} {0}'에 잘못된 반환 형식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateRefMismatch">
        <source>Ref mismatch between '{0}' and delegate '{1}'</source>
        <target state="translated">{0}'과(와) 대리자 '{1}' 사이의 참조 불일치</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConstraintClause">
        <source>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</source>
        <target state="translated">{0}' 형식 매개 변수의 제약 조건 절을 이미 지정했습니다. 형식 매개 변수의 모든 제약 조건은 하나의 where 절에 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantInferMethTypeArgs">
        <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
        <target state="translated">사용 현황에서 '{0}' 메서드의 형식 인수를 유추할 수 없습니다. 형식 인수를 명시적으로 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameNameAsTypeParam">
        <source>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</source>
        <target state="translated">'{0}': 매개 변수, 지역 변수 또는 지역 함수는 메서드 형식 매개 변수와 같은 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsWithTypeVar">
        <source>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</source>
        <target state="translated">형식 매개 변수 '{0}'에는 클래스 형식 제약 조건이나 'class' 제약 조건이 없으므로 'as' 연산자와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg">
        <source>The field '{0}' is assigned but its value is never used</source>
        <target state="translated">{0}' 필드가 할당되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedFieldAssg_Title">
        <source>Field is assigned but its value is never used</source>
        <target state="translated">필드가 할당되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIndexerNameAttr">
        <source>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</source>
        <target state="translated">{0}' 특성은 명시적 인터페이스 멤버 선언이 아닌 인덱서에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrArgWithTypeVars">
        <source>'{0}': an attribute argument cannot use type parameters</source>
        <target state="translated">'{0}': 특성 인수는 형식 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewTyvarWithArgs">
        <source>'{0}': cannot provide arguments when creating an instance of a variable type</source>
        <target state="translated">'{0}': 변수 형식의 인스턴스를 만들 때에는 인수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractSealedStatic">
        <source>'{0}': an abstract class cannot be sealed or static</source>
        <target state="translated">'{0}': 추상 클래스는 sealed 또는 static일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference">
        <source>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</source>
        <target state="translated">cref 특성에 모호한 참조가 있습니다. '{0}'. '{1}'(으)로 간주하지만 '{2}'을(를) 포함하여 다른 오버로드와 일치할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousXMLReference_Title">
        <source>Ambiguous reference in cref attribute</source>
        <target state="translated">cref 특성에 모호한 참조가 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef">
        <source>'{0}': a reference to a volatile field will not be treated as volatile</source>
        <target state="translated">'{0}': volatile 필드에 대한 참조는 volatile로 처리되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Title">
        <source>A reference to a volatile field will not be treated as volatile</source>
        <target state="translated">volatile 필드에 대한 참조는 volatile로 처리되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VolatileByRef_Description">
        <source>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</source>
        <target state="translated">일반적으로 volatile 필드는 volatile로 처리되지 않으므로 ref 또는 out 값으로 사용해서는 안 됩니다. 단, interlocked API를 호출하는 등의 경우에는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithImpl">
        <source>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</source>
        <target state="translated">{1}'에 ComImport 특성이 있으므로 '{0}'은(는) extern 또는 abstract여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithBase">
        <source>'{0}': a class with the ComImport attribute cannot specify a base class</source>
        <target state="translated">'{0}': ComImport 특성이 있는 클래스는 기본 클래스를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadConstraints">
        <source>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</source>
        <target state="translated">{1}' 메서드의 '{0}' 형식 매개 변수에 대한 제약 조건이 '{3}' 인터페이스 메서드의 '{2}' 형식 매개 변수에 대한 제약 조건과 일치해야 합니다. 명시적 인터페이스 구현을 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplBadTupleNames">
        <source>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</source>
        <target state="translated">{0}' 메서드의 서명에 있는 튜플 요소 이름은 인터페이스 메서드 '{1}'의 튜플 요소 이름(반환 형식에 포함)과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInAgg">
        <source>The type name '{0}' does not exist in the type '{1}'</source>
        <target state="translated">{0}' 형식 이름이 '{1}' 형식에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethGrpToNonDel">
        <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
        <target state="translated">{0}' 메서드 그룹을 비대리자 형식 '{1}'(으)로 변환할 수 없습니다. 메서드를 호출하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternAlias">
        <source>The extern alias '{0}' was not specified in a /reference option</source>
        <target state="translated">/reference 옵션에 extern 별칭('{0}')을 지정하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ColColWithTypeAlias">
        <source>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</source>
        <target state="translated">{0}' 별칭은 형식을 참조하므로 '::'과 함께 사용할 수 없습니다. 대신 '.'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasNotFound">
        <source>Alias '{0}' not found</source>
        <target state="translated">{0}' 별칭을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameAggAgg">
        <source>The type '{1}' exists in both '{0}' and '{2}'</source>
        <target state="translated">{1}' 형식이 '{0}' 및 '{2}'에 모두 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</source>
        <target state="translated">{0}'의 '{1}' 네임스페이스가 '{2}'의 '{3}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg">
        <source>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</source>
        <target state="translated">{0}'의 '{1}' 네임스페이스가 '{2}'에서 가져온 형식 '{3}'과(와) 충돌합니다. '{0}'에 정의된 네임스페이스를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisNsAgg_Title">
        <source>Namespace conflicts with imported type</source>
        <target state="translated">네임스페이스가 가져온 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg">
        <source>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">{0}'의 '{1}' 형식이 '{2}'에서 가져온 형식 '{3}'과(와) 충돌합니다. '{0}'에 정의된 형식을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggAgg_Title">
        <source>Type conflicts with imported type</source>
        <target state="translated">형식이 가져온 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs">
        <source>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</source>
        <target state="translated">{0}'의 '{1}' 형식이 '{2}'에서 가져온 네임스페이스 '{3}'과(와) 충돌합니다. '{0}'에 정의된 형식을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SameFullNameThisAggNs_Title">
        <source>Type conflicts with imported namespace</source>
        <target state="translated">형식이 가져온 네임스페이스와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SameFullNameThisAggThisNs">
        <source>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</source>
        <target state="translated">{0}'의 '{1}' 형식이 '{2}'의 '{3}' 네임스페이스와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAfterElements">
        <source>An extern alias declaration must precede all other elements defined in the namespace</source>
        <target state="translated">extern 별칭 선언은 네임스페이스에 정의된 다른 모든 요소보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn">
        <source>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</source>
        <target state="translated">global::'은 별칭이 아니라 전역 네임스페이스를 항상 참조하므로 별칭 이름을 'global'로 정의하지 않는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GlobalAliasDefn_Title">
        <source>Defining an alias named 'global' is ill-advised</source>
        <target state="translated">별칭 이름을 'global'로 정의하지 않는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SealedStaticClass">
        <source>'{0}': a class cannot be both static and sealed</source>
        <target state="translated">'{0}': 클래스는 static이면서 sealed일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateAbstractAccessor">
        <source>'{0}': abstract properties cannot have private accessors</source>
        <target state="translated">'{0}': 추상 속성에는 프라이빗 접근자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueExpected">
        <source>Syntax error; value expected</source>
        <target state="translated">구문 오류입니다. 값이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboxNotLValue">
        <source>Cannot modify the result of an unboxing conversion</source>
        <target state="translated">unboxing 변환 결과는 수정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethGrpInForEach">
        <source>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</source>
        <target state="translated">{0}'에서는 foreach를 수행할 수 없습니다. '{0}'을(를) 호출하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecRetType">
        <source>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</source>
        <target state="translated">++ 또는 -- 연산자의 반환 형식은 매개 변수 형식이거나 매개 변수 형식에서 파생되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundMustBeFirst">
        <source>The 'class' or 'struct' constraint must come before any other constraints</source>
        <target state="translated">class' 또는 'struct' 제약 조건은 다른 모든 제약 조건보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefValBoundWithClass">
        <source>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</source>
        <target state="translated">'{0}': constraint 클래스와 'class' 또는 'struct' 제약 조건을 둘 다 지정할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewBoundWithVal">
        <source>The 'new()' constraint cannot be used with the 'struct' constraint</source>
        <target state="translated">new()' 제약 조건은 'struct' 제약 조건과 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConstraintNotSatisfied">
        <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">제네릭 형식 또는 메서드 '{0}'에서 '{2}' 형식을 '{1}' 매개 변수로 사용하려면 해당 형식이 참조 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValConstraintNotSatisfied">
        <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
        <target state="translated">제네릭 형식 또는 메서드 '{0}'에서 '{2}' 형식을 '{1}' 매개 변수로 사용하려면 해당 형식이 null을 허용하지 않는 값 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularConstraint">
        <source>Circular constraint dependency involving '{0}' and '{1}'</source>
        <target state="translated">{0}' 및 '{1}'과(와) 관련된 순환 제약 조건 종속성입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseConstraintConflict">
        <source>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</source>
        <target state="translated">형식 매개 변수 '{0}'이(가) 상속하는 '{1}' 및 '{2}' 제약 조건이 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConWithValCon">
        <source>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</source>
        <target state="translated">형식 매개 변수 '{1}'에 'struct' 제약 조건이 있으므로 '{1}'은(는) '{0}'에 대한 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigUDConv">
        <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
        <target state="translated">{2}'에서 '{3}(으)로 변환하는 동안 모호한 사용자 정의 변환 '{0}' 및 '{1}'이(가) 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull">
        <source>The result of the expression is always 'null' of type '{0}'</source>
        <target state="translated">식의 결과 값은 항상 '{0}' 형식의 'null'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlwaysNull_Title">
        <source>The result of the expression is always 'null'</source>
        <target state="translated">식의 결과는 항상 'null'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnThis">
        <source>Cannot return 'this' by reference.</source>
        <target state="translated">this'를 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCtorInParameter">
        <source>Cannot use attribute constructor '{0}' because it is has 'in' parameters.</source>
        <target state="translated">특성 생성자 '{0}'은(는) 'in' 매개 변수가 있으므로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraints">
        <source>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</source>
        <target state="translated">재정의 및 명시적 인터페이스 구현 메서드에 대한 제약 조건은 기본 메서드에서 상속되므로 'class' 또는 'struct' 제약 조건을 제외하고는 직접 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbigOverride">
        <source>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</source>
        <target state="translated">상속된 멤버 '{0}'과(와) '{1}'은(는) '{2}' 형식에 같은 시그니처가 있으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DecConstError">
        <source>Evaluation of the decimal constant expression failed</source>
        <target state="translated">10진수 상수 식을 계산하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse">
        <source>Comparing with null of type '{0}' always produces 'false'</source>
        <target state="translated">{0}' 형식의 null과 비교하면 결과는 항상 'false'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmpAlwaysFalse_Title">
        <source>Comparing with null of struct type always produces 'false'</source>
        <target state="translated">구조체 형식의 null과 비교하면 결과는 항상 'false'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</source>
        <target state="translated">Finalize' 메서드를 사용하면 소멸자를 호출하는 데 방해가 될 수 있습니다. 소멸자를 선언하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Title">
        <source>Introducing a 'Finalize' method can interfere with destructor invocation</source>
        <target state="translated">Finalize' 메서드를 사용하면 소멸자를 호출하는 데 방해가 될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FinalizeMethod_Description">
        <source>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.

If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize.</source>
        <target state="translated">이 경고는 서명이 공용 가상 void Finalize인 메서드를 포함하는 클래스를 만들 때 발생합니다.

그런 클래스를 기본 클래스로 사용하고 파생 클래스에서 소멸자를 정의하는 경우 소멸자는 Finalize가 아닌 기본 클래스 Finalize 메서드를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplParams">
        <source>'{0}' should not have a params parameter since '{1}' does not</source>
        <target state="translated">'{1}'이(가) 없어 '{0}'에 params 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert">
        <source>The 'goto case' value is not implicitly convertible to type '{0}'</source>
        <target state="translated">goto case' 값은 '{0}' 형식으로 암시적으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GotoCaseShouldConvert_Title">
        <source>The 'goto case' value is not implicitly convertible to the switch type</source>
        <target state="translated">goto case' 값은 스위치 형식으로 암시적으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodImplementingAccessor">
        <source>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">{0}' 메서드는 '{2}' 형식의 인터페이스 접근자 '{1}'을(를) 구현할 수 없습니다. 명시적 인터페이스 구현을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">{1}' 형식의 값은 '{2}' 형식의 'null'과 같을 수 없으므로 식 결과는 항상 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">이 형식의 값은 'null'과 같을 수 없으므로 식의 결과가 항상 동일합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2">
        <source>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</source>
        <target state="translated">{1}' 형식의 값은 '{2}' 형식의 'null'과 같을 수 없으므로 식 결과는 항상 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NubExprIsConstBool2_Title">
        <source>The result of the expression is always the same since a value of this type is never equal to 'null'</source>
        <target state="translated">이 형식의 값은 'null'과 같을 수 없으므로 식의 결과가 항상 동일합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision">
        <source>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</source>
        <target state="translated">명시적 인터페이스 구현 '{0}'에 인터페이스 멤버가 두 개 이상 일치합니다. 실제로 선택되는 인터페이스 멤버는 구현에 따라 다릅니다. 대신 비명시적 구현을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExplicitImplCollision_Title">
        <source>Explicit interface implementation matches more than one interface member</source>
        <target state="translated">명시적 인터페이스 구현에 인터페이스 멤버가 두 개 이상 일치합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractHasBody">
        <source>'{0}' cannot declare a body because it is marked abstract</source>
        <target state="translated">'{0}'은(는) abstract로 표시되어 있으므로 본문을 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConcreteMissingBody">
        <source>'{0}' must declare a body because it is not marked abstract, extern, or partial</source>
        <target state="translated">'{0}'은(는) abstract, extern 또는 partial로 표시되어 있지 않으므로 본문을 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAndSealed">
        <source>'{0}' cannot be both abstract and sealed</source>
        <target state="translated">'{0}'은(는) abstract 및 sealed일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractNotVirtual">
        <source>The abstract {0} '{1}' cannot be marked virtual</source>
        <target state="translated">추상 {0} '{1}'은(는) virtual로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstant">
        <source>The constant '{0}' cannot be marked static</source>
        <target state="translated">{0}' 상수는 static으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonFunction">
        <source>'{0}': cannot override because '{1}' is not a function</source>
        <target state="translated">'{0}': '{1}'이(가) 함수가 아니므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonVirtual">
        <source>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</source>
        <target state="translated">'{0}': 상속된 '{1}' 멤버는 virtual, abstract 또는 override로 표시되지 않았으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeAccessOnOverride">
        <source>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</source>
        <target state="translated">'{0}': '{1}' 상속된 '{2}' 멤버를 재정의할 때 액세스 한정자를 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTupleNamesOnOverride">
        <source>'{0}': cannot change tuple element names when overriding inherited member '{1}'</source>
        <target state="translated">'{0}': 상속된 멤버 '{1}'을(를) 재정의할 때 튜플 요소 이름을 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeReturnTypeOnOverride">
        <source>'{0}': return type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 반환 형식이 재정의된 '{1}' 멤버와 일치하려면 '{2}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantDeriveFromSealedType">
        <source>'{0}': cannot derive from sealed type '{1}'</source>
        <target state="translated">'{0}': sealed 형식 '{1}'에서 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractInConcreteClass">
        <source>'{0}' is abstract but it is contained in non-abstract class '{1}'</source>
        <target state="translated">'{0}'은(는) 추상이지만 비추상 클래스인 '{1}'에 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithExplicitConstructorCall">
        <source>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</source>
        <target state="translated">'{0}': 정적 생성자에는 명시적 'this' 또는 'base' 생성자 호출을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticConstructorWithAccessModifiers">
        <source>'{0}': access modifiers are not allowed on static constructors</source>
        <target state="translated">'{0}': 정적 생성자에서는 액세스 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself</source>
        <target state="translated">{0}' 생성자는 자신을 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectRecursiveConstructorCall">
        <source>Constructor '{0}' cannot call itself through another constructor</source>
        <target state="translated">{0}' 생성자는 다른 생성자를 통해 자신을 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCallingBaseConstructor">
        <source>'{0}' has no base class and cannot call a base constructor</source>
        <target state="translated">'{0}'에는 기본 클래스가 없으므로 기본 생성자를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">미리 정의된 형식 '{0}'을(를) 정의하지 않았거나 가져오지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeNotFound">
        <source>Predefined type '{0}' is not defined or imported</source>
        <target state="translated">미리 정의된 형식 '{0}'을(를) 정의하지 않았거나 가져오지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">미리 정의된 형식 '{0}'이(가) 여러 참조된 어셈블리('{1}' 및 '{2}')에서 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructWithBaseConstructorCall">
        <source>'{0}': structs cannot call base class constructors</source>
        <target state="translated">'{0}': 구조체는 기본 클래스 생성자를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutCycle">
        <source>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</source>
        <target state="translated">{1}' 형식의 '{0}' 구조체 멤버는 구조체 레이아웃에서 순환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainFields">
        <source>Interfaces cannot contain instance fields</source>
        <target state="translated">인터페이스에는 인스턴스 필드가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConstructors">
        <source>Interfaces cannot contain instance constructors</source>
        <target state="translated">인터페이스에는 인스턴스 생성자가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInterfaceInInterfaceList">
        <source>Type '{0}' in interface list is not an interface</source>
        <target state="translated">인터페이스 목록에 있는 '{0}' 형식이 인터페이스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceInBaseList">
        <source>'{0}' is already listed in interface list</source>
        <target state="translated">'{0}'이(가) 이미 인터페이스 목록에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInterfaceWithTupleNamesInBaseList">
        <source>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}'은(는) 다른 튜플 요소 이름을 사용하는 '{2}' 형식에 대한 인터페이스 목록에 '{1}'(으)로 이미 나열되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInInterfaceInheritance">
        <source>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</source>
        <target state="translated">상속된 '{1}' 인터페이스는 '{0}'의 인터페이스 계층 구조에서 순환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HidingAbstractMethod">
        <source>'{0}' hides inherited abstract member '{1}'</source>
        <target state="translated">'{0}'은(는) 상속된 추상 멤버 '{1}'을(를) 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedAbstractMethod">
        <source>'{0}' does not implement inherited abstract member '{1}'</source>
        <target state="translated">'{0}'은(는) 상속된 추상 멤버 '{1}'을(를) 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectCantHaveBases">
        <source>The class System.Object cannot have a base class or implement an interface</source>
        <target state="translated">System.Object 클래스는 기본 클래스를 포함할 수 없으며 인터페이스를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationNotInterface">
        <source>'{0}' in explicit interface declaration is not an interface</source>
        <target state="translated">'명시적 인터페이스 선언에서 '{0}'은(는) 인터페이스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberNotFound">
        <source>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</source>
        <target state="translated">명시적 인터페이스 선언에서 구현할 수 있는 인터페이스 멤버 중에 '{0}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassDoesntImplementInterface">
        <source>'{0}': containing type does not implement interface '{1}'</source>
        <target state="translated">'{0}': 포함하는 형식이 '{1}' 인터페이스를 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
        <source>'{0}': explicit interface declaration can only be declared in a class, struct or interface</source>
        <target state="translated">'{0}': 명시적 인터페이스 선언은 클래스, 구조체 또는 인터페이스에서만 선언할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNameSameAsType">
        <source>'{0}': member names cannot be the same as their enclosing type</source>
        <target state="translated">'{0}': 멤버 이름은 바깥쪽 형식과 같을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumeratorOverflow">
        <source>'{0}': the enumerator value is too large to fit in its type</source>
        <target state="translated">'{0}': 열거자 값이 너무 커서 해당 형식에 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNonProperty">
        <source>'{0}': cannot override because '{1}' is not a property</source>
        <target state="translated">'{0}': '{1}'이(가) 속성이 아니므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable get accessor</source>
        <target state="translated">'{0}': '{1}'에 재정의 가능한 get 접근자가 없으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetToOverride">
        <source>'{0}': cannot override because '{1}' does not have an overridable set accessor</source>
        <target state="translated">'{0}': '{1}'에 재정의 가능한 set 접근자가 없으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyCantHaveVoidType">
        <source>'{0}': property or indexer cannot have void type</source>
        <target state="translated">'{0}': 속성이나 인덱서에는 void 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyWithNoAccessors">
        <source>'{0}': property or indexer must have at least one accessor</source>
        <target state="translated">'{0}': 속성이나 인덱서에는 접근자가 하나 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewVirtualInSealed">
        <source>'{0}' is a new virtual member in sealed class '{1}'</source>
        <target state="translated">'{0}'은(는) 봉인 클래스 '{1}'의 새 가상 멤버입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyAddingAccessor">
        <source>'{0}' adds an accessor not found in interface member '{1}'</source>
        <target state="translated">'{0}'이(가) '{1}' 인터페이스 멤버에서 찾을 수 없는 접근자를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitPropertyMissingAccessor">
        <source>Explicit interface implementation '{0}' is missing accessor '{1}'</source>
        <target state="translated">명시적 인터페이스 구현 '{0}'에 '{1}' 접근자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithInterface">
        <source>'{0}': user-defined conversions to or from an interface are not allowed</source>
        <target state="translated">'{0}': 인터페이스(로)부터의 사용자 정의 변환은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithBase">
        <source>'{0}': user-defined conversions to or from a base class are not allowed</source>
        <target state="translated">'{0}': 인터페이스(로)부터의 사용자 정의 변환은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionWithDerived">
        <source>'{0}': user-defined conversions to or from a derived class are not allowed</source>
        <target state="translated">'{0}': 파생 클래스(로)부터의 사용자 정의 변환은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityConversion">
        <source>User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type</source>
        <target state="translated">사용자 정의 연산자는 바깥쪽 형식의 개체를 가져와서 바깥쪽 형식의 개체로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotInvolvingContainedType">
        <source>User-defined conversion must convert to or from the enclosing type</source>
        <target state="translated">사용자 정의 변환은 바깥쪽 형식으로 변환하거나 바깥쪽 형식으로부터 변환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionInClass">
        <source>Duplicate user-defined conversion in type '{0}'</source>
        <target state="translated">{0}' 형식의 사용자 정의 변환이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorsMustBeStatic">
        <source>User-defined operator '{0}' must be declared static and public</source>
        <target state="translated">{0}' 사용자 정의 연산자는 static 및 public으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIncDecSignature">
        <source>The parameter type for ++ or -- operator must be the containing type</source>
        <target state="translated">++ 또는 -- 연산자의 매개 변수 형식은 포함하는 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnaryOperatorSignature">
        <source>The parameter of a unary operator must be the containing type</source>
        <target state="translated">단항 연산자의 매개 변수는 포함하는 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinaryOperatorSignature">
        <source>One of the parameters of a binary operator must be the containing type</source>
        <target state="translated">이항 연산자의 매개 변수 중 하나는 포함하는 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadShiftOperatorSignature">
        <source>The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int</source>
        <target state="translated">오버로드된 시프트 연산자의 첫 번째 피연산자는 포함하는 형식과 동일한 형식이어야 하며 두 번째 피연산자는 정수 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructsCantContainDefaultConstructor">
        <source>Structs cannot contain explicit parameterless constructors</source>
        <target state="translated">구조체는 매개 변수가 없는 명시적 생성자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumsCantContainDefaultConstructor">
        <source>Enums cannot contain explicit parameterless constructors</source>
        <target state="translated">열거형은 명시적인 매개 변수가 없는 생성자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideBogusMethod">
        <source>'{0}': cannot override '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}': '{1}'은(는) 해당 언어에서 지원되지 않으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogus">
        <source>'{0}' is not supported by the language</source>
        <target state="translated">'{0}'은(는) 언어에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallSpecialMethod">
        <source>'{0}': cannot explicitly call operator or accessor</source>
        <target state="translated">'{0}': 연산자나 접근자를 명시적으로 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeReference">
        <source>'{0}': cannot reference a type through an expression; try '{1}' instead</source>
        <target state="translated">'{0}': 식을 통해 형식을 참조할 수 없습니다. 대신 '{1}'을(를) 시도하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldInitializerInStruct">
        <source>'{0}': cannot have instance property or field initializers in structs</source>
        <target state="translated">'{0}': 구조체에는 인스턴스 속성 또는 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDestructorName">
        <source>Name of destructor must match name of class</source>
        <target state="translated">소멸자 이름은 클래스 이름과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyClassesCanContainDestructors">
        <source>Only class types can contain destructors</source>
        <target state="translated">클래스 형식만 소멸자를 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictAliasAndMember">
        <source>Namespace '{1}' contains a definition conflicting with alias '{0}'</source>
        <target state="translated">{1}' 네임스페이스에 '{0}' 별칭과 충돌하는 정의가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingAliasAndDefinition">
        <source>Alias '{0}' conflicts with {1} definition</source>
        <target state="translated">{0}' 별칭이 {1} 정의와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnSpecialMethod">
        <source>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, or explicit interface implementation</source>
        <target state="translated">{0}'에는 생성자, 소멸자, 연산자 또는 명시적 인터페이스 구현이기 때문에 Conditional 특성이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalMustReturnVoid">
        <source>The Conditional attribute is not valid on '{0}' because its return type is not void</source>
        <target state="translated">반환 형식이 void가 아니므로 '{0}'에서는 Conditional 특성이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttribute">
        <source>Duplicate '{0}' attribute</source>
        <target state="translated">{0}' 특성이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAttributeInNetModule">
        <source>Duplicate '{0}' attribute in '{1}'</source>
        <target state="translated">{1}'에서 '{0}' 특성이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnInterfaceMethod">
        <source>The Conditional attribute is not valid on interface members</source>
        <target state="translated">인터페이스 멤버에서는 Conditional 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorCantReturnVoid">
        <source>User-defined operators cannot return void</source>
        <target state="translated">사용자 정의 연산자는 void를 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicConversion">
        <source>'{0}': user-defined conversions to or from the dynamic type are not allowed</source>
        <target state="translated">'{0}': 동적 유형과의 사용자 정의 변환은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeArgument">
        <source>Invalid value for argument to '{0}' attribute</source>
        <target state="translated">{0}' 특성에 대해 잘못된 인수 값입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">지정한 관리되지 않은 형식에 대한 매개 변수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">{0}' 특성 매개 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">{0}' 또는 '{1}' 특성 매개 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">관리되지 않은 형식 '{0}'은(는) 필드에서 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">관리되지 않은 형식 '{0}'은(는) 필드에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnBadSymbolType">
        <source>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</source>
        <target state="translated">이 선언 형식에서는 '{0}' 특성이 유효하지 않습니다. 이 특성은 '{1}' 선언에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FloatOverflow">
        <source>Floating-point constant is outside the range of type '{0}'</source>
        <target state="translated">부동 소수점 상수가 '{0}' 형식 범위 밖에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithoutUuidAttribute">
        <source>The Guid attribute must be specified with the ComImport attribute</source>
        <target state="translated">Guid 특성은 ComImport 특성과 함께 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNamedArgument">
        <source>Invalid value for named attribute argument '{0}'</source>
        <target state="translated">명명된 특성 인수 '{0}'에 대해 잘못된 값입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInvalidMethod">
        <source>The DllImport attribute must be specified on a method marked 'static' and 'extern'</source>
        <target state="translated">DllImport 특성은 'static' 및 'extern'으로 표시된 메서드에만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">{0}'을(를) 업데이트할 수 없습니다. 특성 '{1}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericMethod">
        <source>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</source>
        <target state="needs-review-translation">DllImport 특성은 제네릭이거나 제네릭 형식에 포함된 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantBeRefAny">
        <source>Field or property cannot be of type '{0}'</source>
        <target state="translated">필드 또는 속성은 '{0}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldAutoPropCantBeByRefLike">
        <source>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</source>
        <target state="translated">필드 또는 자동 구현 속성은 ref struct의 인스턴스 멤버인 경우 외에는 '{0}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayElementCantBeRefAny">
        <source>Array elements cannot be of type '{0}'</source>
        <target state="translated">배열 요소는 '{0}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol">
        <source>'{0}' is obsolete</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbol_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">형식 또는 멤버는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotAnAttributeClass">
        <source>'{0}' is not an attribute class</source>
        <target state="translated">'{0}'은(는) 특성 클래스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgument">
        <source>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</source>
        <target state="translated">'명명된 특성 인수 '{0}'이(가) 잘못되었습니다. 명명된 특성 인수는 readonly, static 또는 const가 아닌 필드이거나 static이 아닌 public 읽기/쓰기 속성이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedSymbolStr_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">형식 또는 멤버는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedSymbolStr">
        <source>'{0}' is obsolete: '{1}'</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerCantHaveVoidType">
        <source>Indexers cannot have void type</source>
        <target state="translated">인덱서에는 void 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VirtualPrivate">
        <source>'{0}': virtual or abstract members cannot be private</source>
        <target state="translated">'{0}': 가상 또는 추상 멤버는 프라이빗일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitToNonArrayType">
        <source>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</source>
        <target state="translated">배열 이니셜라이저 식은 배열 형식에 할당하는 데에만 사용할 수 있습니다. 대신 new 식을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInBadPlace">
        <source>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</source>
        <target state="translated">배열 이니셜라이저는 변수 또는 필드 이니셜라이저에서만 사용할 수 있습니다. 대신 new 식을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingStructOffset">
        <source>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</source>
        <target state="translated">'{0}': StructLayout(LayoutKind.Explicit)으로 표시된 형식의 인스턴스 필드에는 FieldOffset 특성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation">
        <source>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</source>
        <target state="translated">{0}' 메서드, 연산자 또는 접근자가 외부로 표시되었지만 특성이 없습니다. DllImport 특성을 추가하여 외부 구현을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternMethodNoImplementation_Title">
        <source>Method, operator, or accessor is marked external and has no attributes on it</source>
        <target state="translated">메서드, 연산자 또는 접근자가 external로 표시되었지만 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed">
        <source>'{0}': new protected member declared in sealed class</source>
        <target state="translated">'{0}': sealed 클래스에 새 protected 멤버가 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProtectedInSealed_Title">
        <source>New protected member declared in sealed class</source>
        <target state="translated">sealed 클래스에 새 protected 멤버가 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedByConditional">
        <source>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</source>
        <target state="translated">{0}' 조건부 멤버는 '{2}' 형식으로 '{1}' 인터페이스 멤버를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalRefParam">
        <source>ref and out are not valid in this context</source>
        <target state="translated">이 컨텍스트에서는 ref 및 out을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgumentToAttribute">
        <source>The argument to the '{0}' attribute must be a valid identifier</source>
        <target state="translated">{0}' 특성의 인수에는 유효한 식별자를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadStruct">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 특성은 StructLayout(LayoutKind.Explicit)으로 표시된 형식의 멤버에만 배치할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructOffsetOnBadField">
        <source>The FieldOffset attribute is not allowed on static or const fields</source>
        <target state="translated">static 또는 const 필드에는 FieldOffset 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeUsageOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on classes derived from System.Attribute</source>
        <target state="translated">{0}' 특성은 System.Attribute에서 파생된 클래스에만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement">
        <source>Possible mistaken empty statement</source>
        <target state="translated">빈 문에 오류가 있는 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PossibleMistakenNullStatement_Title">
        <source>Possible mistaken empty statement</source>
        <target state="translated">빈 문에 오류가 있는 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedAttributeArgument">
        <source>'{0}' duplicate named attribute argument</source>
        <target state="translated">'{0}'은(는) 중복 명명된 특성 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromEnumOrValueType">
        <source>'{0}' cannot derive from special class '{1}'</source>
        <target state="translated">'{0}'은(는) '{1}' 특수 클래스에서 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberOnIndexedType">
        <source>Cannot specify the DefaultMember attribute on a type containing an indexer</source>
        <target state="translated">인덱서를 포함하는 형식에 DefaultMember 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusType">
        <source>'{0}' is a type not supported by the language</source>
        <target state="translated">'{0}'은(는) 언어에서 지원하는 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField">
        <source>Field '{0}' is never assigned to, and will always have its default value {1}</source>
        <target state="translated">{0}' 필드에는 할당되지 않으므로 항상 {1} 기본값을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnassignedInternalField_Title">
        <source>Field is never assigned to, and will always have its default value</source>
        <target state="translated">필드에는 할당되지 않으므로 항상 기본값을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CStyleArray">
        <source>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</source>
        <target state="translated">배열 선언자가 잘못되었습니다. 관리되는 배열을 선언하려면 차수 지정자가 변수 식별자보다 앞에 와야 합니다. 고정 크기 버퍼 필드를 선언하려면 fixed 키워드를 필드 형식 앞에 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp">
        <source>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</source>
        <target state="translated">정수 계열 상수와 비교하는 것은 의미가 없습니다. 상수가 '{0}' 형식의 범위를 벗어났습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VacuousIntegralComp_Title">
        <source>Comparison to integral constant is useless; the constant is outside the range of the type</source>
        <target state="translated">정수 계열 상수와 비교하는 것은 의미가 없습니다. 상수가 형식의 범위를 벗어났습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractAttributeClass">
        <source>Cannot apply attribute class '{0}' because it is abstract</source>
        <target state="translated">{0}' 특성 클래스는 abstract이므로 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedAttributeArgumentType">
        <source>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</source>
        <target state="translated">'{0}'이(가) 유효한 특성 매개 변수 형식이 아니므로 잘못 명명된 특성 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPredefinedMember">
        <source>Missing compiler required member '{0}.{1}'</source>
        <target state="translated">{0}.{1}' 멤버가 필요한 컴파일러가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration">
        <source>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}'은(는) 이 선언에 유효한 특성 위치가 아닙니다. 이 선언에 유효한 특성 위치는 '{1}'입니다. 이 블록의 모든 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeLocationOnBadDeclaration_Title">
        <source>Not a valid attribute location for this declaration</source>
        <target state="translated">이 선언의 올바른 특성 위치가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation">
        <source>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</source>
        <target state="translated">'{0}'은(는) 인식할 수 있는 특성 위치가 아닙니다. 이 선언의 유효한 특성 위치는 '{1}'입니다. 이 블록의 모든 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAttributeLocation_Title">
        <source>Not a recognized attribute location</source>
        <target state="translated">인식할 수 있는 특성 위치가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode">
        <source>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}'은(는) Object.Equals(object o)를 재정의하지만 Object.GetHashCode()를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualsWithoutGetHashCode_Title">
        <source>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</source>
        <target state="translated">형식은 Object.Equals(object o)를 재정의하지만 Object.GetHashCode()를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals">
        <source>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">'{0}'은(는) == 연산자 또는 != 연산자를 정의하지만 Object.Equals(object o)를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutEquals_Title">
        <source>Type defines operator == or operator != but does not override Object.Equals(object o)</source>
        <target state="translated">형식은 == 연산자 또는 != 연산자를 정의하지만 Object.Equals(object o)를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode">
        <source>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">'{0}'은(는) == 연산자 또는 != 연산자를 정의하지만 Object.GetHashCode()를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualityOpWithoutGetHashCode_Title">
        <source>Type defines operator == or operator != but does not override Object.GetHashCode()</source>
        <target state="translated">형식은 == 연산자 또는 != 연산자를 정의하지만 Object.GetHashCode()를 재정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnRefParam">
        <source>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</source>
        <target state="translated">ref 매개 변수에 Out 특성만 지정할 수는 없습니다. In 특성도 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadRefKind">
        <source>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</source>
        <target state="translated">'{0}'은(는) 매개 변수 한정자 '{2}' 및 '{3}'만 다른 오버로드된 {1}을(를) 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralDoubleCast">
        <source>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</source>
        <target state="translated">double 형식의 리터럴을 암시적으로 '{1}' 형식으로 변환할 수 없습니다. 이 형식의 리터럴을 만들려면 '{0}' 접미사를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg">
        <source>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</source>
        <target state="translated">조건식에 할당을 사용하면 항상 상수가 됩니다. = 대신 ==을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IncorrectBooleanAssg_Title">
        <source>Assignment in conditional expression is always constant</source>
        <target state="translated">조건식에 할당을 사용하면 항상 상수가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStruct">
        <source>'{0}': new protected member declared in struct</source>
        <target state="translated">'{0}': 구조체에 새 protected 멤버가 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentIndexerNames">
        <source>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</source>
        <target state="translated">두 인덱서의 이름이 다릅니다. IndexerName 특성은 한 형식 안의 모든 인덱서에 대해서는 같은 이름으로 사용되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithUserCtor">
        <source>A class with the ComImport attribute cannot have a user-defined constructor</source>
        <target state="translated">ComImport 특성이 있는 클래스에는 사용자 정의 생성자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldCantHaveVoidType">
        <source>Field cannot have void type</source>
        <target state="translated">필드에는 void 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete">
        <source>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</source>
        <target state="translated">{0}' 멤버는 사용되지 않는 멤버 '{1}'을(를) 재정의합니다. '{0}'에 Obsolete 특성을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonObsoleteOverridingObsolete_Title">
        <source>Member overrides obsolete member</source>
        <target state="translated">멤버가 사용되지 않는 멤버를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SystemVoid">
        <source>System.Void cannot be used from C# -- use typeof(void) to get the void type object</source>
        <target state="translated">System.Void는 C#에서 사용할 수 없습니다. void 형식 개체를 가져오려면 typeof(void)를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitParamArray">
        <source>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</source>
        <target state="translated">System.ParamArrayAttribute'를 사용하지 않고, 대신 'params' 키워드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend">
        <source>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</source>
        <target state="translated">부호 확장 피연산자에 비트 OR 연산자를 사용했습니다. 더 작은 부호 없는 형식으로 먼저 캐스팅하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Title">
        <source>Bitwise-or operator used on a sign-extended operand</source>
        <target state="translated">부호 확장된 피연산자에 비트 OR 연산자를 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BitwiseOrSignExtend_Description">
        <source>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</source>
        <target state="translated">컴파일러에서 변수를 암시적으로 넓히고 부호 확장한 다음 비트 OR 연산에서 결과 값을 사용했습니다. 예기치 않은 동작이 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileStruct">
        <source>'{0}': a volatile field cannot be of the type '{1}'</source>
        <target state="translated">'{0}': volatile 필드는 '{1}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VolatileAndReadonly">
        <source>'{0}': a field cannot be both volatile and readonly</source>
        <target state="translated">'{0}': 필드는 volatile이면서 readonly일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbstractField">
        <source>The modifier 'abstract' is not valid on fields. Try using a property instead.</source>
        <target state="translated">필드의 'abstract' 한정자가 유효하지 않습니다. 대신 속성을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusExplicitImpl">
        <source>'{0}' cannot implement '{1}' because it is not supported by the language</source>
        <target state="translated">'{0}'은(는) 언어에서 지원되지 않으므로 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitMethodImplAccessor">
        <source>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</source>
        <target state="translated">'명시적 메서드 구현에서 '{0}'은(는) 접근자이므로 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport">
        <source>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">'{0}' 인터페이스는 'CoClassAttribute'로 표시되어 있고 'ComImportAttribute'로 표시되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CoClassWithoutComImport_Title">
        <source>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</source>
        <target state="translated">인터페이스는 'CoClassAttribute'로 표시되어 있고 'ComImportAttribute'로 표시되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalWithOutParam">
        <source>Conditional member '{0}' cannot have an out parameter</source>
        <target state="translated">{0}' 조건부 멤버에는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessorImplementingMethod">
        <source>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</source>
        <target state="translated">{0}' 접근자는 '{2}' 형식에 대해 '{1}' 인터페이스 멤버를 구현할 수 없습니다. 명시적 인터페이스 구현을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualAsExpression">
        <source>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</source>
        <target state="translated">네임스페이스 별칭 한정자 '::'은 항상 형식 또는 네임스페이스를 확인하므로 여기에 사용할 수 없습니다. 대신 '.'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DerivingFromATyVar">
        <source>Cannot derive from '{0}' because it is a type parameter</source>
        <target state="translated">형식 매개 변수이므로 '{0}'에서 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParameter">
        <source>Duplicate type parameter '{0}'</source>
        <target state="translated">중복된 '{0}' 형식 매개 변수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter">
        <source>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</source>
        <target state="translated">{0}' 형식 매개 변수가 외부 형식 '{1}'의 형식 매개 변수와 이름이 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeParameterSameAsOuterTypeParameter_Title">
        <source>Type parameter has the same name as the type parameter from outer type</source>
        <target state="translated">형식 매개 변수가 외부 형식의 형식 매개 변수와 이름이 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVariableSameAsParent">
        <source>Type parameter '{0}' has the same name as the containing type, or method</source>
        <target state="translated">{0}' 형식 매개 변수의 이름이 포함하는 형식 또는 메서드의 이름과 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnifyingInterfaceInstantiations">
        <source>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</source>
        <target state="translated">'{1}'과(와) '{2}'은(는) 일부 형식 매개 변수를 대체할 때 통합될 수 있으므로 '{0}'에서는 둘 다 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericDerivingFromAttribute">
        <source>A generic type cannot derive from '{0}' because it is an attribute class</source>
        <target state="translated">{0}'은(는) 특성 클래스이므로 제네릭 형식을 파생시킬 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TyVarNotFoundInConstraint">
        <source>'{1}' does not define type parameter '{0}'</source>
        <target state="translated">'{1}'은(는) '{0}' 형식 매개 변수를 정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBoundType">
        <source>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">'{0}'은(는) 유효한 제약 조건이 아닙니다. 제약 조건으로 사용되는 형식은 인터페이스, 봉인되지 않은 클래스 또는 형식 매개 변수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialTypeAsBound">
        <source>Constraint cannot be special class '{0}'</source>
        <target state="translated">제약 조건은 '{0}' 특수 클래스가 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisBound">
        <source>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 제약 조건 형식이 '{0}'보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LookupInTypeVariable">
        <source>Cannot do member lookup in '{0}' because it is a type parameter</source>
        <target state="translated">{0}'은(는) 형식 매개 변수이므로 멤버를 조회할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintType">
        <source>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</source>
        <target state="translated">잘못된 제약 조건 형식입니다. 제약 조건으로 사용되는 형식은 인터페이스, 봉인되지 않은 클래스 또는 형식 매개 변수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstanceMemberInStaticClass">
        <source>'{0}': cannot declare instance members in a static class</source>
        <target state="translated">'{0}': 정적 클래스에 인스턴스 멤버를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticBaseClass">
        <source>'{1}': cannot derive from static class '{0}'</source>
        <target state="translated">'{1}': 정적 클래스 '{0}'에서 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorInStaticClass">
        <source>Static classes cannot have instance constructors</source>
        <target state="translated">정적 클래스는 인스턴스 생성자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DestructorInStaticClass">
        <source>Static classes cannot contain destructors</source>
        <target state="translated">정적 클래스는 소멸자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InstantiatingStaticClass">
        <source>Cannot create an instance of the static class '{0}'</source>
        <target state="translated">{0}' 정적 클래스의 인스턴스를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticDerivedFromNonObject">
        <source>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</source>
        <target state="translated">정적 클래스 '{0}'은(는) '{1}' 형식에서 파생될 수 없습니다. 정적 클래스는 개체에서 파생되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticClassInterfaceImpl">
        <source>'{0}': static classes cannot implement interfaces</source>
        <target state="translated">'{0}': 정적 클래스는 인터페이스를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefStructInterfaceImpl">
        <source>'{0}': ref structs cannot implement interfaces</source>
        <target state="translated">'{0}': ref struct에서 인터페이스를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorInStaticClass">
        <source>'{0}': static classes cannot contain user-defined operators</source>
        <target state="translated">'{0}': 정적 클래스는 사용자 정의 연산자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertToStaticClass">
        <source>Cannot convert to static type '{0}'</source>
        <target state="translated">{0}' 정적 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsStaticClass">
        <source>'{0}': static classes cannot be used as constraints</source>
        <target state="translated">'{0}': 정적 클래스는 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgIsStaticClass">
        <source>'{0}': static types cannot be used as type arguments</source>
        <target state="translated">'{0}': 정적 형식은 형식 인수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfStaticClass">
        <source>'{0}': array elements cannot be of static type</source>
        <target state="translated">'{0}': 배열 요소는 정적 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerInStaticClass">
        <source>'{0}': cannot declare indexers in a static class</source>
        <target state="translated">'{0}': 정적 클래스에는 인덱서를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterIsStaticClass">
        <source>'{0}': static types cannot be used as parameters</source>
        <target state="translated">'{0}': 정적 형식은 매개 변수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnTypeIsStaticClass">
        <source>'{0}': static types cannot be used as return types</source>
        <target state="translated">'{0}': 정적 형식은 반환 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarDeclIsStaticClass">
        <source>Cannot declare a variable of static type '{0}'</source>
        <target state="translated">{0}' 정적 형식의 변수를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyThrowInFinally">
        <source>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</source>
        <target state="translated">바로 바깥쪽 catch 절에 중첩된 finally 절에는 인수가 없는 throw 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}'은(는) 유효한 서식 지정자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose">
        <source>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</source>
        <target state="translated">using 또는 lock 문의 인수인 지역 변수 '{0}'에 대한 할당이 잘못되었을 수 있습니다. 지역 변수의 원래 값에 대해 Dispose 호출 또는 잠금 해제가 수행됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToLockOrDispose_Title">
        <source>Possibly incorrect assignment to local which is the argument to a using or lock statement</source>
        <target state="translated">using 또는 lock 문의 인수인 지역 변수에 대한 할당이 잘못되었을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeInThisAssembly">
        <source>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</source>
        <target state="translated">{0}' 형식이 이 어셈블리에 정의되었지만 형식 전달자가 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeIsNested">
        <source>Cannot forward type '{0}' because it is a nested type of '{1}'</source>
        <target state="translated">{0}' 형식은 '{1}'의 중첩 형식이므로 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CycleInTypeForwarder">
        <source>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</source>
        <target state="translated">{0}' 형식에 대한 형식 전달자가 '{1}' 어셈블리에서 순환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyNameOnNonModule">
        <source>The /moduleassemblyname option may only be specified when building a target type of 'module'</source>
        <target state="translated">/moduleassemblyname 옵션은 빌드하는 대상 형식이 'module'인 경우에만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">{0}' 어셈블리 참조가 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFwdType">
        <source>Invalid type specified as an argument for TypeForwardedTo attribute</source>
        <target state="translated">TypeForwardedTo 특성의 인수로 잘못된 형식이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberStatic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is static.</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다. '{2}'은(는) static이므로 인터페이스 멤버를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberNotPublic">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다. '{2}'은(는) public이 아니므로 인터페이스 멤버를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</source>
        <target state="translated">'{0}'은(는) '{1}' 인터페이스 멤버를 구현하지 않습니다. '{2}'에 일치하는 반환 형식 '{3}'이(가) 없으므로 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeForwarder">
        <source>'{0}' duplicate TypeForwardedToAttribute</source>
        <target state="translated">'{0}'에서 TypeForwardedToAttribute가 중복됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSelectOrGroup">
        <source>A query body must end with a select clause or a group clause</source>
        <target state="translated">쿼리 본문은 select 절 또는 group 절로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordOn">
        <source>Expected contextual keyword 'on'</source>
        <target state="translated">상황별 키워드 'on'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordEquals">
        <source>Expected contextual keyword 'equals'</source>
        <target state="translated">상황별 키워드 'equals'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContextualKeywordBy">
        <source>Expected contextual keyword 'by'</source>
        <target state="translated">상황별 키워드 'by'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAnonymousTypeMemberDeclarator">
        <source>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</source>
        <target state="translated">잘못된 익명 형식 멤버 선언자입니다. 익명 형식 멤버는 멤버 할당, 단순한 이름 또는 멤버 액세스로 선언되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInitializerElementInitializer">
        <source>Invalid initializer member declarator</source>
        <target state="translated">잘못된 이니셜라이저 멤버 선언자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InconsistentLambdaParameterUsage">
        <source>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</source>
        <target state="translated">람다 매개 변수가 일관성 없이 사용되었습니다. 매개 변수 형식은 모두 명시적이거나 암시적이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInvalidModifier">
        <source>A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers</source>
        <target state="translated">부분 메서드(Partial Method)에는 액세스 한정자 또는 virtual, abstract, override, new, sealed나 extern 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyInPartialClass">
        <source>A partial method must be declared within a partial class, partial struct, or partial interface</source>
        <target state="translated">부분 메서드(Partial method)는 partial 클래스, partial 구조체 또는 partial 인터페이스 내에 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodCannotHaveOutParameters">
        <source>A partial method cannot have out parameters</source>
        <target state="translated">부분 메서드(Partial Method)에는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodNotExplicit">
        <source>A partial method may not explicitly implement an interface method</source>
        <target state="translated">부분 메서드(Partial Method)는 인터페이스 메서드를 명시적으로 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodExtensionDifference">
        <source>Both partial method declarations must be extension methods or neither may be an extension method</source>
        <target state="translated">두 부분 메서드(Partial Method) 선언 모두 확장 메서드이거나 확장 메서드가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneLatent">
        <source>A partial method may not have multiple defining declarations</source>
        <target state="translated">부분 메서드(Partial Method)에는 하나의 정의 선언만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodOnlyOneActual">
        <source>A partial method may not have multiple implementing declarations</source>
        <target state="translated">부분 메서드(Partial Method)에는 하나의 구현 선언만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamsDifference">
        <source>Both partial method declarations must use a params parameter or neither may use a params parameter</source>
        <target state="translated">두 부분 메서드(Partial Method) 선언 모두 params 매개 변수를 사용하거나 params 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustHaveLatent">
        <source>No defining declaration found for implementing declaration of partial method '{0}'</source>
        <target state="translated">{0}' 부분 메서드(Partial Method)의 구현 선언에 대한 정의 선언이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentTupleNames">
        <source>Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.</source>
        <target state="translated">두 부분 메서드(Partial Method) 선언 '{0}' 및 '{1}' 모두에서 동일한 튜플 요소 이름을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInconsistentConstraints">
        <source>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</source>
        <target state="translated">'{0}'의 부분 메서드(Partial method) 선언의 '{1}' 형식 매개 변수에 대한 제약 조건이 일관되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodToDelegate">
        <source>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</source>
        <target state="translated">{0}'은(는) 구현 선언이 없는 부분 메서드(Partial Method)이므로 이 메서드로부터 대리자를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodStaticDifference">
        <source>Both partial method declarations must be static or neither may be static</source>
        <target state="translated">두 부분 메서드(Partial Method) 선언 모두 static이거나 static이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodUnsafeDifference">
        <source>Both partial method declarations must be unsafe or neither may be unsafe</source>
        <target state="translated">두 부분 메서드(Partial Method) 선언 모두 unsafe이거나 unsafe가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodInExpressionTree">
        <source>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</source>
        <target state="translated">정의 선언만 있는 부분 메서드(Partial Method) 또는 제거된 조건부 메서드는 식 트리에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustReturnVoid">
        <source>Partial methods must have a void return type</source>
        <target state="translated">부분 메서드(Partial Method)의 반환 형식은 void여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete">
        <source>Obsolete member '{0}' overrides non-obsolete member '{1}'</source>
        <target state="translated">사용되지 않는 '{0}' 멤버가 사용되는 '{1}' 멤버를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteOverridingNonObsolete_Title">
        <source>Obsolete member overrides non-obsolete member</source>
        <target state="translated">사용되지 않는 멤버가 사용되는 멤버를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong">
        <source>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</source>
        <target state="translated">{0}'의 정규화된 이름이 디버그 정보로는 너무 깁니다. '/debug' 옵션 없이 컴파일됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebugFullNameTooLong_Title">
        <source>Fully qualified name is too long for debug information</source>
        <target state="translated">정규화된 이름이 너무 길어서 디버그 정보에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedBadValue">
        <source>Cannot assign {0} to an implicitly-typed variable</source>
        <target state="translated">암시적으로 형식화된 변수에 {0}을(를) 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableWithNoInitializer">
        <source>Implicitly-typed variables must be initialized</source>
        <target state="translated">암시적으로 형식화된 지역 변수는 초기화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableMultipleDeclarator">
        <source>Implicitly-typed variables cannot have multiple declarators</source>
        <target state="translated">암시적으로 형식화된 변수에는 선언자를 여러 개 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
        <source>Cannot initialize an implicitly-typed variable with an array initializer</source>
        <target state="translated">암시적으로 형식화된 변수는 배열 이니셜라이저를 사용하여 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedLocalCannotBeFixed">
        <source>Implicitly-typed local variables cannot be fixed</source>
        <target state="translated">암시적으로 형식화된 지역 변수는 fixed일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedVariableCannotBeConst">
        <source>Implicitly-typed variables cannot be constant</source>
        <target state="translated">암시적으로 형식화된 변수는 상수일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation">
        <source>Constructor '{0}' is marked external</source>
        <target state="translated">{0}' 생성자가 external로 표시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExternCtorNoImplementation_Title">
        <source>Constructor is marked external</source>
        <target state="translated">생성자가 external로 표시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFound">
        <source>The contextual keyword 'var' may only appear within a local variable declaration or in script code</source>
        <target state="translated">상황별 키워드 'var'는 지역 변수 선언이나 스크립트 코드에만 표시할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedArrayNoBestType">
        <source>No best type found for implicitly-typed array</source>
        <target state="translated">암시적으로 형식화된 배열에 가장 적합한 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyAssignedBadValue">
        <source>Cannot assign '{0}' to anonymous type property</source>
        <target state="translated">무명 형식 속성에 {0}을(를) 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBaseAccess">
        <source>An expression tree may not contain a base access</source>
        <target state="translated">식 트리에는 기본 액세스를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAssignment">
        <source>An expression tree may not contain an assignment operator</source>
        <target state="translated">식 트리에는 대입 연산자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDuplicatePropertyName">
        <source>An anonymous type cannot have multiple properties with the same name</source>
        <target state="translated">익명 형식에는 동일한 이름의 속성을 여러 개 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaToExpressionTree">
        <source>A lambda expression with a statement body cannot be converted to an expression tree</source>
        <target state="translated">문 본문이 있는 람다 식은 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeMustHaveDelegate">
        <source>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</source>
        <target state="translated">람다 식을 '{0}' 형식 인수가 대리자 형식이 아닌 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNotAvailable">
        <source>Cannot use anonymous type in a constant expression</source>
        <target state="translated">상수 식에서는 익명 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInIsAs">
        <source>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</source>
        <target state="translated">is' 또는 'as' 연산자의 첫 번째 피연산자는 람다 식, 무명 메서드 또는 메서드 그룹이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypelessTupleInAs">
        <source>The first operand of an 'as' operator may not be a tuple literal without a natural type.</source>
        <target state="translated">as' 연산자의 첫 번째 피연산자는 자연 형식이 없는 튜플 리터럴일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
        <source>An expression tree may not contain a multidimensional array initializer</source>
        <target state="translated">식 트리에는 다차원 배열 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArgument">
        <source>Argument missing</source>
        <target state="translated">인수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclaration">
        <source>Cannot use local variable '{0}' before it is declared</source>
        <target state="translated">{0}' 지역 변수는 선언되지 않으면 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecursivelyTypedVariable">
        <source>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</source>
        <target state="translated">이니셜라이저가 직간접적으로 정의를 참조하고 있어 '{0}' 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnassignedThisAutoProperty">
        <source>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller.</source>
        <target state="translated">제어가 호출자에게 반환되기 전에 자동으로 구현된 '{0}' 속성이 완전히 할당되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariableUsedBeforeDeclarationAndHidesField">
        <source>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</source>
        <target state="translated">{0}' 지역 변수는 선언되지 않으면 사용할 수 없습니다. 지역 변수를 선언하면 '{1}' 필드가 숨겨집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsBadCoalesce">
        <source>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</source>
        <target state="translated">왼쪽에 null 또는 기본 리터럴이 있는 병합 연산자를 람다 식 트리에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemicolonExpected">
        <source>; expected</source>
        <target state="translated">;이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxError">
        <source>Syntax error, '{0}' expected</source>
        <target state="translated">구문 오류입니다. '{0}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifier">
        <source>Duplicate '{0}' modifier</source>
        <target state="translated">{0}' 한정자가 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessor">
        <source>Property accessor already defined</source>
        <target state="translated">속성 접근자가 이미 정의되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralTypeExpected">
        <source>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</source>
        <target state="translated">byte, sbyte, short, ushort, int, uint, long 또는 ulong 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalEscape">
        <source>Unrecognized escape sequence</source>
        <target state="translated">인식할 수 없는 이스케이프 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewlineInConst">
        <source>Newline in constant</source>
        <target state="translated">상수에 줄 바꿈 문자가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyCharConst">
        <source>Empty character literal</source>
        <target state="translated">빈 문자 리터럴입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCharsInConst">
        <source>Too many characters in character literal</source>
        <target state="translated">문자 리터럴에 문자가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">잘못된 숫자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GetOrSetExpected">
        <source>A get or set accessor expected</source>
        <target state="translated">get 또는 set 접근자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassTypeExpected">
        <source>An object, string, or class type expected</source>
        <target state="translated">개체, 문자열 또는 클래스 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentExpected">
        <source>Named attribute argument expected</source>
        <target state="translated">명명된 특성 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyCatches">
        <source>Catch clauses cannot follow the general catch clause of a try statement</source>
        <target state="translated">Catch 절은 try 문의 일반 catch 절 뒤에 올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisOrBaseExpected">
        <source>Keyword 'this' or 'base' expected</source>
        <target state="translated">this' 또는 'base' 키워드가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlUnaryOperatorExpected">
        <source>Overloadable unary operator expected</source>
        <target state="translated">오버로드할 수 있는 단항 연산자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlBinaryOperatorExpected">
        <source>Overloadable binary operator expected</source>
        <target state="translated">오버로드할 수 있는 이항 연산자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntOverflow">
        <source>Integral constant is too large</source>
        <target state="translated">정수 계열 상수가 너무 큽니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EOFExpected">
        <source>Type or namespace definition, or end-of-file expected</source>
        <target state="translated">형식이나 네임스페이스 정의 또는 파일 끝(EOF)이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalDefinitionOrStatementExpected">
        <source>Member definition, statement, or end-of-file expected</source>
        <target state="translated">멤버 정의, 문 또는 파일 끝(EOF)이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmbeddedStmt">
        <source>Embedded statement cannot be a declaration or labeled statement</source>
        <target state="translated">포함 문은 선언 또는 레이블 문일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDirectiveExpected">
        <source>Preprocessor directive expected</source>
        <target state="translated">전처리기 지시문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">한 줄로 된 주석이나 줄의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseParenExpected">
        <source>) expected</source>
        <target state="translated">)가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndifDirectiveExpected">
        <source>#endif directive expected</source>
        <target state="translated">#endif 지시문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedDirective">
        <source>Unexpected preprocessor directive</source>
        <target state="translated">예기치 않은 전처리기 지시문이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorDirective">
        <source>#error: '{0}'</source>
        <target state="translated">#오류: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective">
        <source>#warning: '{0}'</source>
        <target state="translated">#warning: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_WarningDirective_Title">
        <source>#warning directive</source>
        <target state="translated">#warning 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeExpected">
        <source>Type expected</source>
        <target state="translated">형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPDefFollowsToken">
        <source>Cannot define/undefine preprocessor symbols after first token in file</source>
        <target state="translated">파일의 첫 토큰 뒤에 전처리기 기호를 정의/정의 해제할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPReferenceFollowsToken">
        <source>Cannot use #r after first token in file</source>
        <target state="translated">파일의 첫 토큰 뒤에 #r을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenEndedComment">
        <source>End-of-file found, '*/' expected</source>
        <target state="translated">파일 끝(EOF)이 있습니다. '*/'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">병합 충돌 표식을 발견했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">refonly를 사용할 때 refout을 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">/refout 또는 /refonly를 사용할 때 NET 모듈을 컴파일할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OvlOperatorExpected">
        <source>Overloadable operator expected</source>
        <target state="translated">오버로드할 수 있는 연산자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionDirectiveExpected">
        <source>#endregion directive expected</source>
        <target state="translated">#endregion 지시문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLit">
        <source>Unterminated string literal</source>
        <target state="translated">문자열 리터럴이 종료되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDirectivePlacement">
        <source>Preprocessor directives must appear as the first non-whitespace character on a line</source>
        <target state="translated">전처리기 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentifierExpectedKW">
        <source>Identifier expected; '{1}' is a keyword</source>
        <target state="translated">식별자가 필요합니다. '{1}'은(는) 키워드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceExpected">
        <source>{ or ; expected</source>
        <target state="translated">{ 또는 ;이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiTypeInDeclaration">
        <source>Cannot use more than one type in a for, using, fixed, or declaration statement</source>
        <target state="translated">for 문, using 문, fixed 문, 선언문 등에는 둘 이상의 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveExpected">
        <source>An add or remove accessor expected</source>
        <target state="translated">add 또는 remove 접근자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedCharacter">
        <source>Unexpected character '{0}'</source>
        <target state="translated">예기치 않은 '{0}' 문자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedToken">
        <source>Unexpected token '{0}'</source>
        <target state="translated">예기치 않은 토큰 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedInStatic">
        <source>'{0}': static classes cannot contain protected members</source>
        <target state="translated">'{0}': 정적 클래스는 protected 멤버를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch">
        <source>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</source>
        <target state="translated">이전의 catch 절에서 이미 모든 예외를 catch합니다. 예외가 아닌 모든 throw된 항목은 System.Runtime.CompilerServices.RuntimeWrappedException에 래핑됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Title">
        <source>A previous catch clause already catches all exceptions</source>
        <target state="translated">이전의 catch 절에서 이미 모든 예외를 catch합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableGeneralCatch_Description">
        <source>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.

A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS exceptions are wrapped as Exceptions and the catch (System.Exception e) block catches them.</source>
        <target state="translated">이 경고는 catch() 블록의 catch (System.Exception e) 블록 뒤에 지정된 예외 형식이 없을 때 발생합니다. 이 경고는 catch() 블록이 예외를 catch하지 않음을 알려줍니다.

catch (System.Exception e) 블록 뒤의 catch() 블록은 RuntimeCompatibilityAttribute가 AssemblyInfo.cs 파일에 false로 설정되어 있는 경우 CLS가 아닌 예외를 catch할 수 있습니다. [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. 이 특성이 false로 명시적으로 설정되어 있지 않은 경우 모든 throw되는 CLS가 아닌 예외가 예외로 래핑되고 catch (System.Exception e) 블록에서 해당 예외를 catch합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IncrementLvalueExpected">
        <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
        <target state="translated">증가 연산자 또는 감소 연산자의 피연산자는 변수, 속성 또는 인덱서여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtension">
        <source>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
        <target state="translated">'{0}'에는 '{1}'에 대한 정의가 포함되어 있지 않고, '{0}' 형식의 첫 번째 인수를 허용하는 액세스 가능한 확장 메서드 '{1}'이(가) 없습니다. using 지시문 또는 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuchMemberOrExtensionNeedUsing">
        <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</source>
        <target state="translated">'{0}'에는 '{1}'에 대한 정의가 포함되어 있지 않고, '{0}' 형식의 첫 번째 인수를 허용하는 확장 메서드 '{1}' 이(가) 없습니다. '{2}'에 대한 using 지시문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadThisParam">
        <source>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</source>
        <target state="translated">{0}' 메서드의 첫 번째 매개 변수가 아닌 매개 변수에 매개 변수 한정자 'this'가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParameterModifiers">
        <source> The parameter modifier '{0}' cannot be used with '{1}'</source>
        <target state="translated"> 매개 변수 한정자 '{0}'을(를) '{1}'과(와) 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeforThis">
        <source>The first parameter of an extension method cannot be of type '{0}'</source>
        <target state="translated">확장 메서드의 첫 번째 매개 변수는 '{0}' 형식이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamModThis">
        <source>A parameter array cannot be used with 'this' modifier on an extension method</source>
        <target state="translated">매개 변수 배열은 확장 메서드의 'this' 한정자와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionMeth">
        <source>Extension method must be static</source>
        <target state="translated">확장 메서드는 정적이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExtensionAgg">
        <source>Extension method must be defined in a non-generic static class</source>
        <target state="translated">확장 메서드는 제네릭이 아닌 정적 클래스에 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DupParamMod">
        <source>A parameter can only have one '{0}' modifier</source>
        <target state="translated">매개 변수에는 '{0}' 한정자 하나만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodsDecl">
        <source>Extension methods must be defined in a top level static class; {0} is a nested class</source>
        <target state="translated">확장 메서드는 최상위 정적 클래스에 정의해야 합니다. {0}은(는) 중첩된 클래스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttrNotFound">
        <source>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</source>
        <target state="translated">컴파일러에 필요한 '{0}' 형식을 찾을 수 없으므로 새 확장 메서드를 정의할 수 없습니다. System.Core.dll의 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitExtension">
        <source>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</source>
        <target state="translated">System.Runtime.CompilerServices.ExtensionAttribute' 대신 'this' 키워드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitDynamicAttr">
        <source>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</source>
        <target state="translated">System.Runtime.CompilerServices.DynamicAttribute' 대신 'dynamic' 키워드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseCtor">
        <source>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</source>
        <target state="translated">생성자 호출을 동적으로 디스패치해야 하지만 해당 호출이 생성자 이니셜라이저의 일부이므로 동적으로 디스패치할 수 없습니다. 동적 인수를 캐스팅하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypeExtDelegate">
        <source>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</source>
        <target state="translated">값 형식 '{1}'에 정의된 확장 메서드 '{0}'은(는) 대리자를 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgCount">
        <source>No overload for method '{0}' takes {1} arguments</source>
        <target state="translated">인수 {1}개를 사용하는 '{0}' 메서드에 대한 오버로드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgType">
        <source>Argument {0}: cannot convert from '{1}' to '{2}'</source>
        <target state="translated">{0} 인수: '{1}'에서 '{2}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourceFile">
        <source>Source file '{0}' could not be opened -- {1}</source>
        <target state="translated">{0}' 소스 파일을 열 수 없습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRefResource">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">모듈을 빌드하는 동안 리소스 파일을 링크할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceNotUnique">
        <source>Resource identifier '{0}' has already been used in this assembly</source>
        <target state="translated">{0}' 리소스 식별자가 이 어셈블리에 이미 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceFileNameNotUnique">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</source>
        <target state="translated">링크된 각 리소스와 모듈에는 고유한 파일 이름이 있어야 합니다. '{0}' 파일 이름은 이 어셈블리에 두 번 이상 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportNonAssembly">
        <source>The referenced file '{0}' is not an assembly</source>
        <target state="translated">참조된 '{0}' 파일은 어셈블리가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefLvalueExpected">
        <source>A ref or out value must be an assignable variable</source>
        <target state="translated">ref 또는 out 값은 할당 가능한 변수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInStaticMeth">
        <source>Keyword 'base' is not available in a static method</source>
        <target state="translated">base' 키워드는 정적 메서드에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseInBadContext">
        <source>Keyword 'base' is not available in the current context</source>
        <target state="translated">base' 키워드는 현재 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RbraceExpected">
        <source>} expected</source>
        <target state="translated">}가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbraceExpected">
        <source>{ expected</source>
        <target state="translated">{가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExpected">
        <source>'in' expected</source>
        <target state="translated">'in'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocExpr">
        <source>Invalid preprocessor expression</source>
        <target state="translated">전처리기 식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMemberDecl">
        <source>Invalid token '{0}' in class, struct, or interface member declaration</source>
        <target state="translated">클래스, 구조체 또는 인터페이스 멤버 선언에 잘못된 '{0}' 토큰이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberNeedsType">
        <source>Method must have a return type</source>
        <target state="translated">메서드에는 반환 형식이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseType">
        <source>Invalid base type</source>
        <target state="translated">기본 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch">
        <source>Empty switch block</source>
        <target state="translated">빈 스위치 블록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptySwitch_Title">
        <source>Empty switch block</source>
        <target state="translated">빈 스위치 블록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>Expected catch or finally</source>
        <target state="translated">catch 또는 finally가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidExprTerm">
        <source>Invalid expression term '{0}'</source>
        <target state="translated">잘못된 식의 항 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNewExpr">
        <source>A new expression requires (), [], or {} after type</source>
        <target state="translated">new 식은 형식 뒤에 (), [], 또는 {}가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNamespacePrivate">
        <source>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</source>
        <target state="translated">네임스페이스에 정의된 요소는 명시적으로 private, protected, protected internal 또는 private protected로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVarDecl">
        <source>Expected ; or = (cannot specify constructor arguments in declaration)</source>
        <target state="translated">; 또는 =가 필요합니다. 선언에서는 생성자 인수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingAfterElements">
        <source>A using clause must precede all other elements defined in the namespace except extern alias declarations</source>
        <target state="translated">extern 별칭 선언을 제외하고 using 절은 네임스페이스에 정의된 다른 모든 요소보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBinOpArgs">
        <source>Overloaded binary operator '{0}' takes two parameters</source>
        <target state="translated">오버로드된 '{0}' 이항 연산자는 매개 변수를 두 개 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUnOpArgs">
        <source>Overloaded unary operator '{0}' takes one parameter</source>
        <target state="translated">오버로드된 '{0}' 단항 연산자는 매개 변수를 한 개 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidParameter">
        <source>Invalid parameter type 'void'</source>
        <target state="translated">void' 매개 변수 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAlias">
        <source>The using alias '{0}' appeared previously in this namespace</source>
        <target state="translated">using 별칭 '{0}'을(를) 이전에 이 네임스페이스에서 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadProtectedAccess">
        <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
        <target state="translated">{1}' 형식의 한정자를 통해 보호된 멤버 '{0}'에 액세스할 수 없습니다. 한정자는 '{2}' 형식이거나 여기에서 파생된 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddModuleAssembly">
        <source>'{0}' cannot be added to this assembly because it already is an assembly</source>
        <target state="translated">'{0}'은(는) 이미 어셈블리이므로 이 어셈블리에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp2">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
        <target state="translated">{0}' 속성, 인덱서 또는 이벤트는 이 언어에서 지원되지 않습니다. '{1}' 또는 '{2}' 접근자 메서드를 직접 호출해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BindToBogusProp1">
        <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
        <target state="translated">{0}' 속성, 인덱서 또는 이벤트는 이 언어에서 지원되지 않습니다. '{1}' 접근자 메서드를 직접 호출해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoVoidHere">
        <source>Keyword 'void' cannot be used in this context</source>
        <target state="translated">이 컨텍스트에는 'void' 키워드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexerNeedsParam">
        <source>Indexers must have at least one parameter</source>
        <target state="translated">인덱서에 매개 변수를 하나 이상 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArraySyntax">
        <source>Array type specifier, [], must appear before parameter name</source>
        <target state="translated">배열 형식 지정자인 []은 매개 변수 이름 앞에 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorSyntax">
        <source>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</source>
        <target state="translated">선언이 잘못되었습니다. 대신 '{0} operator &lt;dest-type&gt; (...'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotFound">
        <source>Could not find '{0}' specified for Main method</source>
        <target state="translated">Main 메서드에 지정된 '{0}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassNotClass">
        <source>'{0}' specified for Main method must be a non-generic class, struct, or interface</source>
        <target state="translated">Main 메서드에 지정된 '{0}'은(는) 제네릭이 아닌 클래스, 구조체 또는 인터페이스여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainInClass">
        <source>'{0}' does not have a suitable static 'Main' method</source>
        <target state="translated">'{0}'에 적합한 정적 Main 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MainClassIsImport">
        <source>Cannot use '{0}' for Main method because it is imported</source>
        <target state="translated">가져온 것이므로 Main 메서드에 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutputNeedsName">
        <source>Outputs without source must have the /out option specified</source>
        <target state="translated">소스 없는 출력의 경우 /out 옵션을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest</source>
        <target state="translated">Win32 리소스 파일과 Win32 매니페스트는 서로 충돌하므로 함께 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndIcon">
        <source>Conflicting options specified: Win32 resource file; Win32 icon</source>
        <target state="translated">Win32 리소스 파일과 Win32 아이콘 옵션은 서로 충돌하므로 함께 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadResource">
        <source>Error reading resource '{0}' -- '{1}'</source>
        <target state="translated">{0}' 리소스 파일을 읽는 동안 오류가 발생했습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">XML 문서 파일 쓰기 오류: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError">
        <source>XML comment has badly formed XML -- '{0}'</source>
        <target state="translated">XML 주석에 잘못된 형식의 XML이 있습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseError_Title">
        <source>XML comment has badly formed XML</source>
        <target state="translated">XML 주석에 잘못된 형식의 XML이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag">
        <source>XML comment has a duplicate param tag for '{0}'</source>
        <target state="translated">XML 주석에는 '{0}'에 중복된 param 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateParamTag_Title">
        <source>XML comment has a duplicate param tag</source>
        <target state="translated">XML 주석에 중복 매개 변수 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag">
        <source>XML comment has a param tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">XML 주석에 '{0}'에 대한 param 태그가 있지만 해당 이름의 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamTag_Title">
        <source>XML comment has a param tag, but there is no parameter by that name</source>
        <target state="translated">XML 주석에 param 태그가 있지만 해당 이름의 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag">
        <source>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</source>
        <target state="translated">{1}'의 XML 주석에는 '{0}'에 대한 paramref 태그가 있지만 해당 이름의 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedParamRefTag_Title">
        <source>XML comment has a paramref tag, but there is no parameter by that name</source>
        <target state="translated">XML 주석에 paramref 태그가 있지만 해당 이름의 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag">
        <source>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</source>
        <target state="translated">{0}' 매개 변수와 짝이 맞는 매개 변수 태그가 '{1}'의 XML 주석에 없습니다. 다른 매개 변수는 짝이 맞는 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingParamTag_Title">
        <source>Parameter has no matching param tag in the XML comment (but other parameters do)</source>
        <target state="translated">매개 변수와 짝이 맞는 매개 변수 태그가 XML 주석에 없습니다. 다른 매개 변수는 짝이 맞는 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef">
        <source>XML comment has cref attribute '{0}' that could not be resolved</source>
        <target state="translated">XML 주석에 확인할 수 없는 '{0}' cref 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRef_Title">
        <source>XML comment has cref attribute that could not be resolved</source>
        <target state="translated">XML 주석에 확인할 수 없는 cref 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStackAllocExpr">
        <source>A stackalloc expression requires [] after type</source>
        <target state="translated">stackalloc 식에서 형식 뒤에는 []가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLineNumber">
        <source>The line number specified for #line directive is missing or invalid</source>
        <target state="translated">#line 지시문에 지정한 줄 번호가 없거나 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingPPFile">
        <source>Quoted file name, single-line comment or end-of-line expected</source>
        <target state="translated">따옴표 붙은 파일 이름, 한 줄로 된 주석 또는 줄의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedPPFile">
        <source>Quoted file name expected</source>
        <target state="translated">따옴표 붙은 파일 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#r is only allowed in scripts</source>
        <target state="translated">#r은 스크립트에서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachMissingMember">
        <source>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'</source>
        <target state="translated">'{0}' 형식 변수에서 foreach 문을 수행할 수 없습니다. '{0}'에는 '{1}'에 대한 공용 인스턴스 정의가 없기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType">
        <source>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</source>
        <target state="translated">XML 주석 cref 특성의 {0} 매개 변수에 대해 잘못된 형식입니다('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefParamType_Title">
        <source>Invalid type for parameter in XML comment cref attribute</source>
        <target state="translated">XML 주석 cref 특성의 매개 변수에 대해 잘못된 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 주석 cref 특성에서 반환 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefReturnType_Title">
        <source>Invalid return type in XML comment cref attribute</source>
        <target state="translated">XML 주석 cref 특성에서 반환 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWin32Res">
        <source>Error reading Win32 resources -- {0}</source>
        <target state="translated">Win32 리소스 읽기 오류 -- {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax">
        <source>XML comment has syntactically incorrect cref attribute '{0}'</source>
        <target state="translated">XML 주석에 잘못된 cref 특성 '{0}' 구문이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefSyntax_Title">
        <source>XML comment has syntactically incorrect cref attribute</source>
        <target state="translated">XML 주석에 잘못된 cref 특성 구문이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifierLocation">
        <source>Member modifier '{0}' must precede the member type and name</source>
        <target state="translated">{0}' 멤버 한정자는 멤버 형식과 이름 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingArraySize">
        <source>Array creation must have array size or array initializer</source>
        <target state="translated">배열을 만들 때에는 배열 크기 또는 배열 이니셜라이저가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 주석이 유효한 언어 요소에 배치되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnprocessedXMLComment_Title">
        <source>XML comment is not placed on a valid language element</source>
        <target state="translated">XML 주석이 유효한 언어 요소에 배치되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude">
        <source>Unable to include XML fragment '{1}' of file '{0}' -- {2}</source>
        <target state="translated">{0}' 파일의 '{1}' XML 조각을 포함할 수 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FailedInclude_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">XML 조각을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude">
        <source>Invalid XML include element -- {0}</source>
        <target state="translated">잘못된 XML 포함 요소입니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidInclude_Title">
        <source>Invalid XML include element</source>
        <target state="translated">XML 포함 요소가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment">
        <source>Missing XML comment for publicly visible type or member '{0}'</source>
        <target state="translated">공개된 '{0}' 멤버 또는 형식에 대한 XML 주석이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Title">
        <source>Missing XML comment for publicly visible type or member</source>
        <target state="translated">공개된 형식 또는 멤버에 대한 XML 주석이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingXMLComment_Description">
        <source>The /doc compiler option was specified, but one or more constructs did not have comments.</source>
        <target state="translated">/doc 컴파일러 옵션을 지정했지만 하나 이상의 구문에 주석이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError">
        <source>Badly formed XML in included comments file -- '{0}'</source>
        <target state="translated">포함된 주석 파일에 잘못된 형식의 XML이 있습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLParseIncludeError_Title">
        <source>Badly formed XML in included comments file</source>
        <target state="translated">포함된 주석 파일에 잘못된 형식의 XML이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelArgCount">
        <source>Delegate '{0}' does not take {1} arguments</source>
        <target state="translated">{0}' 대리자는 인수를 {1}개 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedSemicolon">
        <source>Semicolon after method or accessor block is not valid</source>
        <target state="translated">메서드 또는 접근자 블록 뒤의 세미콜론이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodReturnCantBeRefAny">
        <source>Method or delegate cannot return type '{0}'</source>
        <target state="translated">메서드 또는 대리자는 '{0}' 형식을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompileCancelled">
        <source>Compilation cancelled by user</source>
        <target state="translated">사용자가 컴파일을 취소했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodArgCantBeRefAny">
        <source>Cannot make reference to variable of type '{0}'</source>
        <target state="translated">{0}' 형식의 변수에 참조를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal">
        <source>Cannot assign to '{0}' because it is read-only</source>
        <target state="translated">읽기 전용인 '{0}'에는 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal">
        <source>Cannot use '{0}' as a ref or out value because it is read-only</source>
        <target state="translated">{0}'은(는) 읽기 전용이므로 ref 또는 out 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on C# types</source>
        <target state="translated">RequiredAttribute 특성은 C# 형식에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoModifiersOnAccessor">
        <source>Modifiers cannot be placed on event accessor declarations</source>
        <target state="translated">이벤트 접근자 선언에는 한정자를 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamsCantBeWithModifier">
        <source>The params parameter cannot be declared as {0}</source>
        <target state="translated">params 매개 변수는 {0}(으)로 선언될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnNotLValue">
        <source>Cannot modify the return value of '{0}' because it is not a variable</source>
        <target state="translated">{0}'은(는) 변수가 아니므로 해당 반환 값을 수정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingCoClass">
        <source>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</source>
        <target state="translated">{1}' 인터페이스에 대해 관리되는 coclass 래퍼 클래스 '{0}'을(를) 찾을 수 없습니다. 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAttribute">
        <source>'{0}' is ambiguous between '{1}' and '{2}'; use either '@{0}' or '{0}Attribute'</source>
        <target state="translated">'{0}'이(가) '{1}'과(와) '{2}' 사이에서 모호합니다. '@{0}' 또는 '{0}Attribute'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgExtraRef">
        <source>Argument {0} may not be passed with the '{1}' keyword</source>
        <target state="translated">{0} 인수는 '{1}' 키워드와 함께 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource">
        <source>Option '{0}' overrides attribute '{1}' given in a source file or added module</source>
        <target state="translated">{0}' 옵션은 소스 파일 또는 추가된 모듈에 지정된 '{1}' 특성을 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Title">
        <source>Option overrides attribute given in a source file or added module</source>
        <target state="translated">옵션은 원본 파일 또는 추가된 모듈에 지정된 특성을 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CmdOptionConflictsSource_Description">
        <source>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</source>
        <target state="translated">이 경고는 소스에 있는 AssemblyKeyFileAttribute 또는 AssemblyKeyNameAttribute 어셈블리 특성이 /keyfile 또는 /keycontainer 명령줄 옵션이나 프로젝트 속성에 지정된 키 파일 이름 또는 키 컨테이너와 충돌하는 경우에 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompatMode">
        <source>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</source>
        <target state="translated">{0}'은(는) /langversion의 유효한 옵션이 아닙니다. '/ langversion:?'를 사용하여 지원되는 값을 나열하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnConditional">
        <source>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</source>
        <target state="translated">Conditional 특성이 있으므로 '{0}'을(를) 사용하여 대리자를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantMakeTempFile">
        <source>Cannot create temporary file -- {0}</source>
        <target state="translated">임시 파일을 만들 수 없습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgRef">
        <source>Argument {0} must be passed with the '{1}' keyword</source>
        <target state="translated">{0} 인수는 '{1}' 키워드와 함께 전달해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldInAnonMeth">
        <source>The yield statement cannot be used inside an anonymous method or lambda expression</source>
        <target state="translated">yield 문은 무명 메서드 또는 람다 식 안에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnInIterator">
        <source>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</source>
        <target state="translated">반복기에서 값을 반환할 수 없습니다. yield return 문을 사용하여 값을 반환하거나 yield break 문을 사용하여 반복을 끝내세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorArgType">
        <source>Iterators cannot have ref, in or out parameters</source>
        <target state="translated">반복기에는 ref, in 또는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</source>
        <target state="translated">{1}'이(가) 반복기 인터페이스 형식이 아니므로 '{0}'의 본문은 반복기 블록이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInFinally">
        <source>Cannot yield in the body of a finally clause</source>
        <target state="translated">finally 절의 본문에서는 yield를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryOfCatch">
        <source>Cannot yield a value in the body of a try block with a catch clause</source>
        <target state="translated">catch 절이 포함된 try 블록의 본문에서는 값을 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyYield">
        <source>Expression expected after yield return</source>
        <target state="translated">yield return 다음에는 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUse">
        <source>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</source>
        <target state="translated">무명 메서드, 람다 식, 쿼리 식 또는 로컬 함수 안에서는 ref, out 또는 in 매개 변수 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalInnerUnsafe">
        <source>Unsafe code may not appear in iterators</source>
        <target state="translated">반복기에는 안전하지 않은 코드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInCatch">
        <source>Cannot yield a value in the body of a catch clause</source>
        <target state="translated">catch 절 본문에서는 값을 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateLeave">
        <source>Control cannot leave the body of an anonymous method or lambda expression</source>
        <target state="translated">제어가 무명 메서드 또는 람다 식의 본문을 벗어날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">인식할 수 없는 #pragma 지시문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPragma_Title">
        <source>Unrecognized #pragma directive</source>
        <target state="translated">인식할 수 없는 #pragma 지시문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning">
        <source>Expected 'disable' or 'restore'</source>
        <target state="translated">'disable' 또는 'restore'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPWarning_Title">
        <source>Expected 'disable' or 'restore' after #pragma warning</source>
        <target state="translated">#pragma warning 뒤에 'disable' 또는 'restore'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber">
        <source>Cannot restore warning 'CS{0}' because it was disabled globally</source>
        <target state="translated">전역으로 사용하지 않도록 설정되었기 때문에 'CS{0}' 경고를 복원할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadRestoreNumber_Title">
        <source>Cannot restore warning because it was disabled globally</source>
        <target state="translated">전역으로 사용하지 않도록 설정되었기 때문에 경고를 복원할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsIterator">
        <source>__arglist is not allowed in the parameter list of iterators</source>
        <target state="translated">__arglist는 반복기의 매개 변수 목록에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeIteratorArgType">
        <source>Iterators cannot have unsafe parameters or yield types</source>
        <target state="translated">반복기에 안전하지 않은 매개 변수 또는 yield 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCoClassSig">
        <source>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</source>
        <target state="translated">{1}' 인터페이스에 대해 관리되는 coclass 래퍼 클래스 시그니처 '{0}'은(는) 유효한 클래스 이름 시그니처가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIEnumOfT">
        <source>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">foreach 문은 '{1}'의 여러 인스턴스화를 구현하므로 '{0}' 형식의 변수에는 foreach 문을 수행할 수 없습니다. 특정 인터페이스 인스턴스화로 캐스팅하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedDimsRequired">
        <source>A fixed size buffer field must have the array size specifier after the field name</source>
        <target state="translated">고정 크기 버퍼 필드에는 필드 이름 뒤에 배열 크기 지정자를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNotInStruct">
        <source>Fixed size buffer fields may only be members of structs</source>
        <target state="translated">고정 크기 버퍼 필드는 구조체의 멤버로만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousReturnExpected">
        <source>Not all code paths return a value in {0} of type '{1}'</source>
        <target state="translated">코드 경로 중 일부에서만 '{1}' 형식의 {0}에 있는 값을 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature">
        <source>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">{0}' 기능은 표준화된 ISO C# 언어 사양의 일부가 아니므로 다른 컴파일러에서 지원하지 않을 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonECMAFeature_Title">
        <source>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</source>
        <target state="translated">기능은 표준화된 ISO C# 언어 사양의 일부가 아니므로 다른 컴파일러에서 지원하지 않을 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedVerbatimLiteral">
        <source>Keyword, identifier, or string expected after verbatim specifier: @</source>
        <target state="translated">축자 지정자 @ 뒤에는 키워드, 식별자 또는 문자열이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly">
        <source>A readonly field cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">읽기 전용 필드는 ref 또는 out 값으로 사용할 수 없습니다. 단 생성자에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonly2">
        <source>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</source>
        <target state="translated">읽기 전용 필드 '{0}'의 멤버는 ref 또는 out 값으로 사용할 수 없습니다. 단 생성자에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly">
        <source>A readonly field cannot be assigned to (except in a constructor of the class in which the field is defined or a variable initializer))</source>
        <target state="translated">읽기 전용 필드에는 할당할 수 없습니다. 단, 필드가 정의된 클래스의 생성자 또는 변수 이니셜라이저에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonly2">
        <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
        <target state="translated">읽기 전용 필드 '{0}'의 멤버는 수정할 수 없습니다. 단 생성자 또는 변수 이니셜라이저에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField">
        <source>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}'은(는) 읽기 전용 변수이므로 ref 또는 out 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</source>
        <target state="translated">{0} '{1}'의 멤버는 읽기 전용 변수이므로 ref 또는 out 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField">
        <source>Cannot assign to {0} '{1}' because it is a readonly variable</source>
        <target state="translated">읽기 전용 변수이므로 {0} '{1}'에 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssignReadonlyNotField2">
        <source>Cannot assign to a member of {0} '{1}' because it is a readonly variable</source>
        <target state="translated">읽기 전용 변수이므로 {0} '{1}'의 멤버에 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField">
        <source>Cannot return {0} '{1}' by writable reference because it is a readonly variable</source>
        <target state="translated">{0} '{1}'은(는) 읽기 전용 변수이므로 쓰기 가능 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyNotField2">
        <source>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</source>
        <target state="translated">{0} '{1}'의 멤버는 읽기 전용 변수이므로 쓰기 가능 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
        <target state="translated">정적 읽기 전용 필드 '{0}'의 필드에는 할당할 수 없습니다. 단 정적 생성자 또는 변수 이니셜라이저에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</source>
        <target state="translated">정적 읽기 전용 필드 '{0}'의 필드는 ref 또는 out 값으로 사용할 수 없습니다. 단 정적 생성자에서는 예외입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocal2Cause">
        <source>Cannot modify members of '{0}' because it is a '{1}'</source>
        <target state="translated">{1}'인 '{0}'의 멤버는 수정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocal2Cause">
        <source>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">{0}'의 필드는 '{1}'이므로 ref 또는 out 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssgReadonlyLocalCause">
        <source>Cannot assign to '{0}' because it is a '{1}'</source>
        <target state="translated">{1}'인 '{0}'에는 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReadonlyLocalCause">
        <source>Cannot use '{0}' as a ref or out value because it is a '{1}'</source>
        <target state="translated">{0}'은(는) '{1}'이므로 ref 또는 out 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride">
        <source>{0}. See also error CS{1}.</source>
        <target state="translated">{0}. 오류 CS{1}도 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Title">
        <source>Warning is overriding an error</source>
        <target state="translated">경고에서 오류를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ErrorOverride_Description">
        <source>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</source>
        <target state="translated">컴파일러에서 오류를 경고로 재정의할 때 이 경고를 발생합니다. 문제에 대한 자세한 내용을 보려면 언급된 오류 코드를 검색하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonMethToNonDel">
        <source>Cannot convert {0} to type '{1}' because it is not a delegate type</source>
        <target state="translated">{0}은(는) 대리자 형식이 아니므로 '{1}' 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethParams">
        <source>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</source>
        <target state="translated">매개 변수 형식이 대리자 매개 변수 형식과 일치하지 않으므로 {0}을(를) 형식 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethReturns">
        <source>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</source>
        <target state="translated">블록의 반환 형식 중 일부를 암시적으로 대리자 반환 형식으로 변환할 수 없으므로 {0}을(를) 지정한 대리자 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnExpression">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than 'Task&lt;{0}&gt;'</source>
        <target state="translated">비동기 메서드이기 때문에 이 메서드의 반환 식은 'Task&lt;{0}&gt;' 형식이 아니라 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAsyncAnonFuncReturns">
        <source>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</source>
        <target state="translated">비동기 {0}을(를) 대리자 형식 '{1}'(으)로 변환할 수 없습니다. 비동기 {0}은(는) void, Task 또는 Task&lt;T&gt;를 반환할 수 있는데, 세 형식 모두 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalFixedType">
        <source>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</source>
        <target state="translated">고정 크기 버퍼는 bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float 또는 double 형식 중 하나여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedOverflow">
        <source>Fixed size buffer of length {0} and type '{1}' is too big</source>
        <target state="translated">길이가 {0}인 '{1}' 형식의 고정 크기 버퍼가 너무 큽니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFixedArraySize">
        <source>Fixed size buffers must have a length greater than zero</source>
        <target state="translated">고정 크기 버퍼의 길이는 0보다 커야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferNotFixed">
        <source>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</source>
        <target state="translated">고정되지 않은 식에 포함된 고정 크기 버퍼는 사용할 수 없습니다. fixed 문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeNotOnAccessor">
        <source>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</source>
        <target state="translated">속성 또는 이벤트 접근자에서는 '{0}' 특성이 유효하지 않습니다. 이 특성은 '{1}' 선언에만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir">
        <source>Invalid search path '{0}' specified in '{1}' -- '{2}'</source>
        <target state="translated">잘못된 검색 경로 '{0}'이(가) '{1}'에 지정되었습니다. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidSearchPathDir_Title">
        <source>Invalid search path specified</source>
        <target state="translated">지정한 검색 경로가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarArgs">
        <source>__arglist is not valid in this context</source>
        <target state="translated">이 컨텍스트에는 __arglist를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalParams">
        <source>params is not valid in this context</source>
        <target state="translated">이 컨텍스트에서는 params가 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModifiersOnNamespace">
        <source>A namespace declaration cannot have modifiers or attributes</source>
        <target state="translated">네임스페이스 선언에는 한정자 또는 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPlatformType">
        <source>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</source>
        <target state="translated">/platform에 대해 잘못된 '{0}' 옵션입니다. anycpu, x86, Itanium, arm, arm64 또는 x64여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThisStructNotInAnonMeth">
        <source>Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.</source>
        <target state="translated">구조체 안의 무명 메서드, 람다 식 및 쿼리 식은 'this'의 인스턴스 멤버에 액세스할 수 없습니다. 'this'를 무명 메서드, 람다 식 또는 쿼리 식 외부에 있는 지역 변수에 복사한 다음 이 지역 변수를 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIDisp">
        <source>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.</source>
        <target state="translated">'{0}': using 문에 사용된 형식은 암시적으로 'System.IDisposable'로 변환할 수 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamRef">
        <source>Parameter {0} must be declared with the '{1}' keyword</source>
        <target state="translated">{0} 매개 변수는 '{1}' 키워드를 사용하여 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamExtraRef">
        <source>Parameter {0} should not be declared with the '{1}' keyword</source>
        <target state="translated">{0} 매개 변수는 '{1}' 키워드를 사용하여 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadParamType">
        <source>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</source>
        <target state="translated">{0} 매개 변수가 '{1}{2}' 형식으로 선언되었지만 '{3}{4}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadExternIdentifier">
        <source>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</source>
        <target state="translated">/reference'에 대해 잘못된 extern 별칭입니다. '{0}'이(가) 유효한 식별자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasMissingFile">
        <source>Invalid reference alias option: '{0}=' -- missing filename</source>
        <target state="translated">잘못된 참조 별칭 옵션입니다. '{0}=' -- 파일 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalExternAlias">
        <source>You cannot redefine the global extern alias</source>
        <target state="translated">전역 extern 별칭을 다시 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInSource">
        <source>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</source>
        <target state="translated">{0}' 형식에 대한 참조는 이 어셈블리에 정의된 것으로 되어 있지만 소스 또는 추가된 모듈에 정의되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingTypeInAssembly">
        <source>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</source>
        <target state="translated">{0}' 형식에 대한 참조는 '{1}'에 정의된 것으로 되어 있지만 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes">
        <source>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</source>
        <target state="translated">미리 정의된 형식 '{0}'이(가) 전역 별칭의 여러 어셈블리에 정의되었습니다. '{1}'의 정의를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Title">
        <source>Predefined type is defined in multiple assemblies in the global alias</source>
        <target state="translated">미리 정의된 형식이 전역 별칭의 여러 어셈블리에 정의되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultiplePredefTypes_Description">
        <source>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side.</source>
        <target state="translated">이 오류는 미리 정의한 시스템 형식(예: System.Int32)이 두 어셈블리에 있는 경우에 발생합니다. 이 오류는 서로 다른 두 위치에서 mscorlib 또는 System.Runtime.dll을 참조할 경우(두 버전의 .NET Framework를 나란히 실행할 경우)에 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalCantBeFixedAndHoisted">
        <source>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</source>
        <target state="translated">지역 '{0}' 또는 해당 멤버의 주소를 가져와 무명 메서드 또는 람다 식 안에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">소스 파일의 줄 수가 PDB에 표시할 수 있는 16,707,565줄을 초과했습니다. 디버그 정보가 올바르지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TooManyLinesForDebugger_Title">
        <source>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</source>
        <target state="translated">소스 파일의 줄 수가 PDB에 표시할 수 있는 16,707,565줄을 초과했습니다. 디버그 정보가 올바르지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantConvAnonMethNoParams">
        <source>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</source>
        <target state="translated">{0}' 대리자 형식에 out 매개 변수가 하나 이상 있으므로 매개 변수 목록이 없는 무명 메서드 블록을 이 대리자 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalOnNonAttributeClass">
        <source>Attribute '{0}' is only valid on methods or attribute classes</source>
        <target state="translated">{0}' 특성은 메서드 또는 특성 클래스에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField">
        <source>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</source>
        <target state="translated">{0}'은(는) 참조로 마샬링하는 클래스의 필드이므로 이 필드의 멤버에 액세스하면 런타임 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Title">
        <source>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</source>
        <target state="translated">참조로 마샬링하는 클래스의 필드에 있는 멤버에 액세스하면 런타임 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallOnNonAgileField_Description">
        <source>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and call the method on that variable.</source>
        <target state="translated">이 경고는 MarshalByRefObject에서 파생되는 클래스 멤버에 대한 메서드, 속성 또는 인덱서를 호출하려고 하고, 멤버가 값 형식일 때 발생합니다. MarshalByRefObject에서 상속되는 개체는 일반적으로 애플리케이션 도메인 전체에서 참조로 마샬링됩니다. 애플리케이션 도메인에서 그런 개체의 값 형식 멤버에 직접 액세스하려고 시도하는 코드가 있을 경우 런타임 예외가 발생합니다. 이 경고를 해결하려면 먼저 멤버를 지역 변수에 복사하고 해당 변수에 대한 메서드를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber">
        <source>'{0}' is not a valid warning number</source>
        <target state="translated">'{0}'은(는) 유효한 경고 번호가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Title">
        <source>Not a valid warning number</source>
        <target state="translated">올바른 경고 번호가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadWarningNumber_Description">
        <source>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</source>
        <target state="translated">#pragma 경고 전처리기 지시문에 전달된 번호는 올바른 경고 번호가 아닙니다. 번호가 오류가 아닌 경고를 나타내는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber">
        <source>Invalid number</source>
        <target state="translated">잘못된 숫자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidNumber_Title">
        <source>Invalid number</source>
        <target state="translated">잘못된 숫자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong">
        <source>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</source>
        <target state="translated">전처리기 지시문에 잘못된 파일 이름이 지정되었습니다. 파일 이름이 너무 길거나 유효한 파일 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileNameTooLong_Title">
        <source>Invalid filename specified for preprocessor directive</source>
        <target state="translated">전처리기 지시문에 지정한 파일 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum">
        <source>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</source>
        <target state="translated">#pragma checksum 구문이 잘못되었습니다. #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IllegalPPChecksum_Title">
        <source>Invalid #pragma checksum syntax</source>
        <target state="translated">#pragma checksum 구문이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected">
        <source>Single-line comment or end-of-line expected</source>
        <target state="translated">한 줄로 된 주석이나 줄의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EndOfPPLineExpected_Title">
        <source>Single-line comment or end-of-line expected after #pragma directive</source>
        <target state="translated">#pragma 지시문 뒤에는 한 줄로 된 주석 또는 줄의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum">
        <source>Different checksum values given for '{0}'</source>
        <target state="translated">{0}'에 대해 서로 다른 체크섬 값이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingChecksum_Title">
        <source>Different #pragma checksum values given</source>
        <target state="translated">서로 다른 #pragma 체크섬 값이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved</source>
        <target state="translated">{0}' 어셈블리 참조가 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">어셈블리 참조가 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Description">
        <source>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</source>
        <target state="translated">이 경고는 특성(예: InternalsVisibleToAttribute)이 올바르게 지정되지 않았음을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">{1}'이(가) 사용하는 '{0}' 어셈블리 참조가 '{3}'의 '{2}'과(와) 일치하는 것으로 간주합니다. 런타임 정책을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">어셈블리 참조가 ID와 일치하는 것으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceMajMin_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">두 어셈블리의 릴리스 및/또는 버전 번호가 다릅니다. 통합하려면 애플리케이션의 .config 파일에서 지시문을 지정하고 어셈블리의 강력한 이름을 올바르게 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev">
        <source>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</source>
        <target state="translated">{1}'이(가) 사용하는 '{0}' 어셈블리 참조가 '{3}'의 '{2}'과(와) 일치하는 것으로 간주합니다. 런타임 정책을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Title">
        <source>Assuming assembly reference matches identity</source>
        <target state="translated">어셈블리 참조가 ID와 일치하는 것으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnifyReferenceBldRev_Description">
        <source>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</source>
        <target state="translated">두 어셈블리의 릴리스 및/또는 버전 번호가 다릅니다. 통합하려면 애플리케이션의 .config 파일에서 지시문을 지정하고 어셈블리의 강력한 이름을 올바르게 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">ID가 동일한 여러 어셈블리를 가져왔습니다('{0}', '{1}'). 중복된 참조 중 하나를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImportSimple">
        <source>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</source>
        <target state="translated">단순한 이름 '{0}'이(가) 같은 어셈블리를 이미 가져왔습니다. 참조 중 하나(예: '{1}')를 제거하거나 side-by-side를 사용할 수 있도록 서명하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblyMatchBadVersion">
        <source>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</source>
        <target state="translated">ID가 '{1}'인 '{0}' 어셈블리는 ID가 '{4}'인 참조된 어셈블리 '{3}' 이후 버전인 '{2}'을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedNeedsLvalue">
        <source>Fixed size buffers can only be accessed through locals or fields</source>
        <target state="translated">고정 크기 버퍼는 지역 변수 또는 필드를 통해서만 액세스할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag">
        <source>XML comment has a duplicate typeparam tag for '{0}'</source>
        <target state="translated">XML 주석에는 '{0}'에 중복된 typeparam 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateTypeParamTag_Title">
        <source>XML comment has a duplicate typeparam tag</source>
        <target state="translated">XML 주석에 중복 형식 매개 변수 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag">
        <source>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">XML 주석에는 '{0}'에 대한 typeparam 태그가 있지만 해당 이름의 형식 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamTag_Title">
        <source>XML comment has a typeparam tag, but there is no type parameter by that name</source>
        <target state="translated">XML 주석에 typeparam 태그가 있지만 해당 이름의 형식 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag">
        <source>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</source>
        <target state="translated">{1}'의 XML 주석에는 '{0}'에 대한 typeparamref 태그가 있지만 해당 이름의 형식 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnmatchedTypeParamRefTag_Title">
        <source>XML comment has a typeparamref tag, but there is no type parameter by that name</source>
        <target state="translated">XML 주석에 typeparamref 태그가 있지만 해당 이름의 형식 매개 변수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag">
        <source>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</source>
        <target state="translated">{1}'의 XML 주석에 '{0}' 형식 매개 변수와 짝이 맞는 형식 매개 변수 태그가 없습니다. 다른 형식 매개 변수는 짝이 맞는 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingTypeParamTag_Title">
        <source>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</source>
        <target state="translated">형식 매개 변수와 짝이 맞는 형식 매개 변수 태그가 XML 주석에 없습니다. 다른 형식 매개 변수는 짝이 맞는 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeTypeOnOverride">
        <source>'{0}': type must be '{2}' to match overridden member '{1}'</source>
        <target state="translated">'{0}': 재정의된 '{1}' 멤버와 일치하려면 '{2}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttr">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</source>
        <target state="translated">System.Runtime.CompilerServices.FixedBuffer' 특성을 사용하지 마세요. 대신 'fixed' 필드 한정자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf">
        <source>Assignment made to same variable; did you mean to assign something else?</source>
        <target state="translated">같은 변수에 할당했습니다. 다른 요소를 할당하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssignmentToSelf_Title">
        <source>Assignment made to same variable</source>
        <target state="translated">같은 변수에 할당했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf">
        <source>Comparison made to same variable; did you mean to compare something else?</source>
        <target state="translated">같은 변수를 비교했습니다. 다른 요소를 비교하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComparisonToSelf_Title">
        <source>Comparison made to same variable</source>
        <target state="translated">같은 변수와 비교했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Res">
        <source>Error opening Win32 resource file '{0}' -- '{1}'</source>
        <target state="translated">{0}' Win32 리소스 파일을 여는 동안 오류가 발생했습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault">
        <source>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</source>
        <target state="translated">{0}'의 기본값이 null이므로 식에서 항상 System.NullReferenceException이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DotOnDefault_Title">
        <source>Expression will always cause a System.NullReferenceException because the type's default value is null</source>
        <target state="translated">형식의 기본값이 null이므로 식은 항상 System.NullReferenceException을 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMultipleInheritance">
        <source>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</source>
        <target state="translated">{0}' 클래스는 기본 클래스('{1}', '{2}')를 여러 개 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseClassMustBeFirst">
        <source>Base class '{0}' must come before any interfaces</source>
        <target state="translated">기본 클래스 '{0}'은(는) 다른 모든 인터페이스보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar">
        <source>XML comment has cref attribute '{0}' that refers to a type parameter</source>
        <target state="translated">XML 주석에 형식 매개 변수를 참조하는 '{0}' cref 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadXMLRefTypeVar_Title">
        <source>XML comment has cref attribute that refers to a type parameter</source>
        <target state="translated">XML 주석에 형식 매개 변수를 참조하는 cref 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArgs">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Friend 어셈블리 참조 '{0}'이(가) 잘못되었습니다. InternalsVisibleTo 선언에는 버전, 문화권, 공개 키 토큰 또는 프로세서 아키텍처를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblySNReq">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Friend 어셈블리 참조 '{0}'이(가) 잘못되었습니다. 강력한 이름의 서명된 어셈블리에는 InternalsVisibleTo 선언에 공개 키를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateOnNullable">
        <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</source>
        <target state="translated">{0}'은(는) 'System.Nullable&lt;T&gt;'의 멤버이므로 대리자를 바인딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCtorArgCount">
        <source>'{0}' does not contain a constructor that takes {1} arguments</source>
        <target state="translated">'{0}'에는 인수를 {1}개 사용하는 생성자가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotFirst">
        <source>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</source>
        <target state="translated">using 절과 extern 별칭 선언을 제외하고 어셈블리 특성과 모듈 특성은 파일에 정의된 다른 모든 요소보다 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionExpected">
        <source>Expected expression</source>
        <target state="translated">식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</source>
        <target state="translated">/subsystemversion에 대해 잘못된 버전({0})입니다. 버전은 ARM 또는 AppContainerExe의 경우 6.02 이상이어야 하고, 그 외의 경우 4.00 이상이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">포함된 interop 메서드 '{0}'에 본문이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWarningLevel">
        <source>Warning level must be in the range 0-4</source>
        <target state="translated">경고 수준은 0부터 4까지의 범위에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDebugType">
        <source>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</source>
        <target state="translated">/debug에 대해 잘못된 '{0}' 옵션입니다. 'portable', 'embedded', 'full' 또는 'pdbonly'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResourceVis">
        <source>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</source>
        <target state="translated">잘못된 '{0}' 옵션입니다. 리소스 표시 유형은 'public' 또는 'private'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueTypeMustMatch">
        <source>The type of the argument to the DefaultParameterValue attribute must match the parameter type</source>
        <target state="translated">DefaultParameterValue 특성에 대한 인수 형식이 매개 변수 형식과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBadValueType">
        <source>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</source>
        <target state="translated">{0}' 형식의 인수는 DefaultParameterValue 특성에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberAlreadyInitialized">
        <source>Duplicate initialization of member '{0}'</source>
        <target state="translated">{0}' 멤버의 초기화가 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberCannotBeInitialized">
        <source>Member '{0}' cannot be initialized. It is not a field or property.</source>
        <target state="translated">{0}' 멤버를 초기화할 수 없습니다. 이 멤버는 필드 또는 속성이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticMemberInObjectInitializer">
        <source>Static field or property '{0}' cannot be assigned in an object initializer</source>
        <target state="translated">정적 필드 또는 속성 '{0}'은(는) 개체 이니셜라이저에 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadonlyValueTypeInObjectInitializer">
        <source>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">형식이 '{1}'인 읽기 전용 필드 '{0}'의 멤버는 값 형식이므로 개체 이니셜라이저를 사용하여 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTypePropertyInObjectInitializer">
        <source>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</source>
        <target state="translated">형식이 '{1}'인 '{0}' 속성의 멤버는 값 형식이므로 개체 이니셜라이저를 사용하여 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeTypeInObjectCreation">
        <source>Unsafe type '{0}' cannot be used in object creation</source>
        <target state="translated">안전하지 않은 '{0}' 형식은 개체를 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyElementInitializer">
        <source>Element initializer cannot be empty</source>
        <target state="translated">요소 이니셜라이저는 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasWrongSignature">
        <source>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</source>
        <target state="translated">{0}'에 가장 일치하는 오버로드된 메서드에는 잘못된 이니셜라이저 요소의 시그니처가 있습니다. 초기화 가능한 Add는 액세스 가능한 인스턴스 메서드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollectionInitRequiresIEnumerable">
        <source>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</source>
        <target state="translated">{0}' 형식은 'System.Collections.IEnumerable'을 구현하지 않으므로 컬렉션 이니셜라이저를 사용하여 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSetWin32Manifest">
        <source>Error reading Win32 manifest file '{0}' -- '{1}'</source>
        <target state="translated">{0}' Win32 매니페스트 파일을 읽는 동안 오류가 발생했습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">/win32manifest는 어셈블리에만 적용되므로 모듈의 경우 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CantHaveManifestForModule_Title">
        <source>Ignoring /win32manifest for module because it only applies to assemblies</source>
        <target state="translated">/win32manifest는 어셈블리에만 적용되므로 모듈의 경우 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceArgType">
        <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</source>
        <target state="translated">'{0}'에는 '{1}'에 대한 정의가 포함되어 있지 않고, 가장 적합한 확장 메서드 오버로드 '{2}'에는 '{3}' 형식의 수신기가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateRangeVariable">
        <source>The range variable '{0}' has already been declared</source>
        <target state="translated">{0}' 범위 변수가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableOverrides">
        <source>The range variable '{0}' conflicts with a previous declaration of '{0}'</source>
        <target state="translated">범위 변수 '{0}'이(가) '{0}'의 이전 선언과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableAssignedBadValue">
        <source>Cannot assign {0} to a range variable</source>
        <target state="translated">{0}을(를) 범위 변수에 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderCastable">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</source>
        <target state="translated">소스 형식 '{0}'에 대해 구현된 쿼리 패턴을 찾을 수 없습니다. '{1}'을(를) 찾을 수 없습니다. 범위 변수 '{2}'의 형식을 명시적으로 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProviderStandard">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?</source>
        <target state="translated">소스 형식 '{0}'에 대해 구현된 쿼리 패턴을 찾을 수 없습니다. '{1}'을(를) 찾을 수 없습니다. 'System.Core.dll'에 대한 참조 또는 'System.Linq'에 대한 using 지시문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNoProvider">
        <source>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</source>
        <target state="translated">소스 형식 '{0}'에 대해 구현된 쿼리 패턴을 찾을 수 없습니다. '{1}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOuterKey">
        <source>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">이름 '{0}'은(는) 'equals'의 왼쪽에 올 수 있는 범위에 속하지 않습니다. 'equals'의 양쪽에 있는 식을 서로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInnerKey">
        <source>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</source>
        <target state="translated">이름 '{0}'은(는) 'equals'의 오른쪽에 올 수 있는 범위에 속하지 않습니다. 'equals'의 양쪽에 있는 식을 서로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOutRefRangeVariable">
        <source>Cannot pass the range variable '{0}' as an out or ref parameter</source>
        <target state="translated">범위 변수 '{0}'을(를) out 또는 ref 매개 변수로 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryMultipleProviders">
        <source>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</source>
        <target state="translated">소스 형식 '{0}'에 쿼리 패턴이 여러 번 구현되어 있습니다. '{1}'에 대한 호출이 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedMulti">
        <source>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 절에 있는 식 중 하나의 형식이 잘못되었습니다. '{1}'에 대한 호출에서 형식을 유추하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailed">
        <source>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</source>
        <target state="translated">{0} 절에 있는 식의 형식이 잘못되었습니다. '{1}'에 대한 호출에서 형식을 유추하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryTypeInferenceFailedSelectMany">
        <source>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</source>
        <target state="translated">형식이 '{0}'인 식은 소스 형식이 '{1}'인 쿼리 식의 후속 from 절에서 사용할 수 없습니다. '{2}' 호출 시 형식을 유추하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsPointerOp">
        <source>An expression tree may not contain an unsafe pointer operation</source>
        <target state="translated">식 트리에는 안전하지 않은 포인터 연산을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsAnonymousMethod">
        <source>An expression tree may not contain an anonymous method expression</source>
        <target state="translated">식 트리에는 무명 메서드 식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousMethodToExpressionTree">
        <source>An anonymous method expression cannot be converted to an expression tree</source>
        <target state="translated">무명 메서드 식을 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableReadOnly">
        <source>Range variable '{0}' cannot be assigned to -- it is read only</source>
        <target state="translated">범위 변수 '{0}'은(는) 읽기 전용이므로 이 변수에 값을 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryRangeVariableSameAsTypeParam">
        <source>The range variable '{0}' cannot have the same name as a method type parameter</source>
        <target state="translated">범위 변수 '{0}'에 메서드 형식 매개 변수와 동일한 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeVarNotFoundRangeVariable">
        <source>The contextual keyword 'var' cannot be used in a range variable declaration</source>
        <target state="translated">범위 변수 선언에는 상황별 키워드'var'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypesForCollectionAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</source>
        <target state="translated">오버로드된 Add 메서드 중 해당 컬렉션 이니셜라이저에 가장 적합한 '{0}'에 잘못된 인수가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParameterInExpressionTree">
        <source>An expression tree lambda may not contain a ref, in or out parameter</source>
        <target state="translated">람다 식 트리에는 ref, in 또는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarArgsInExpressionTree">
        <source>An expression tree lambda may not contain a method with variable arguments</source>
        <target state="translated">람다 식 트리에는 가변 인수가 있는 메서드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemGroupInExpressionTree">
        <source>An expression tree lambda may not contain a method group</source>
        <target state="translated">람다 식 트리에는 메서드 그룹을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerAddHasParamModifiers">
        <source>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</source>
        <target state="translated">컬렉션 이니셜라이저에 대한 '{0}'에 가장 일치하는 오버로드된 메서드를 사용할 수 없습니다. 컬렉션 이니셜라이저 'Add' 메서드에는 ref 또는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonInvocableMemberCalled">
        <source>Non-invocable member '{0}' cannot be used like a method.</source>
        <target state="translated">호출할 수 없는 멤버인 '{0}'은(는) 메서드처럼 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches">
        <source>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">{0}' 멤버는 '{2}' 형식의 인터페이스 멤버 '{1}'을(를) 구현합니다. 런타임에 인터페이스 멤버에 일치하는 여러 항목이 있습니다. 호출되는 메서드는 구현에 따라 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Title">
        <source>Member implements interface member with multiple matches at run-time</source>
        <target state="translated">멤버가 런타임에 여러 개의 일치 항목을 포함하는 인터페이스 멤버를 구현합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeImplementationMatches_Description">
        <source>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.

Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.

Give the compiler some way to differentiate the methods. For example, you can give them different names or provide an additional parameter on one of them.</source>
        <target state="translated">이 경고는 두 인터페이스 메서드에서 특정 매개 변수가 ref로 표시되는지 out으로 표시되는지 여부만 다른 경우에 생성될 수 있습니다. 런타임에 호출되는 메서드가 명확하거나 보장되지 않으므로 이 경고를 방지하도록 코드를 변경하는 것이 좋습니다.

C#에서는 out과 ref를 구분하지만 CLR에서는 동일한 것으로 간주합니다. 따라서 인터페이스를 구현할 메서드를 결정할 때 CLR에서는 하나만 선택합니다.

컴파일러에서 두 메서드를 구분할 수 있는 몇 가지 방법을 지정하세요. 예를 들어 다른 이름을 지정하거나 둘 중 하나에 대해 추가 매개 변수를 제공할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches">
        <source>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called.</source>
        <target state="translated">{1}' 멤버는 '{0}'을(를) 재정의합니다. 런타임에 여러 재정의 후보가 있습니다. 호출되는 메서드는 구현에 따라 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleRuntimeOverrideMatches_Title">
        <source>Member overrides base member with multiple override candidates at run-time</source>
        <target state="translated">멤버가 런타임에 여러 재정의 후보로 기본 멤버를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectOrCollectionInitializerWithDelegateCreation">
        <source>Object and collection initializer expressions may not be applied to a delegate creation expression</source>
        <target state="translated">개체 및 컬렉션 이니셜라이저 식은 대리자 생성 식에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstantDeclarationType">
        <source>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</source>
        <target state="translated">'{0}'의 형식이 '{1}'입니다. 상수 선언에 지정되는 형식은 sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, enum-type 또는 reference-type이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>Source file '{0}' could not be found.</source>
        <target state="translated">{0}' 소스 파일을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>Source file '{0}' specified multiple times</source>
        <target state="translated">{0}' 소스 파일을 여러 번 지정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">소스 파일이 여러 번 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoFileSpec">
        <source>Missing file specification for '{0}' option</source>
        <target state="translated">{0}' 옵션에 대한 파일 사양이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsString">
        <source>Command-line syntax error: Missing '{0}' for '{1}' option</source>
        <target state="translated">명령줄 구문 오류: '{0}' 옵션에 대한 '{1}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitch">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">인식할 수 없는 옵션: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources">
        <source>No source files specified.</source>
        <target state="translated">소스 파일을 지정하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoSources_Title">
        <source>No source files specified</source>
        <target state="translated">소스 파일을 지정하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a script (.csx file) but none specified</source>
        <target state="translated">스크립트(.csx 파일)가 필요하지만 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenResponseFile">
        <source>Error opening response file '{0}'</source>
        <target state="translated">{0}' 지시 파일을 여는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>Cannot open '{0}' for writing -- '{1}'</source>
        <target state="translated">{0}'을(를) 쓰기용으로 열 수 없습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadBaseNumber">
        <source>Invalid image base number '{0}'</source>
        <target state="translated">잘못된 '{0}' 이미지 기준 번호입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>'{0}' is a binary file instead of a text file</source>
        <target state="translated">'{0}'은(는) 텍스트 파일이 아니라 이진 파일입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadCodepage">
        <source>Code page '{0}' is invalid or not installed</source>
        <target state="translated">{0}' 코드 페이지가 잘못되었거나 설치되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">{0}' 알고리즘은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMainOnDLL">
        <source>Cannot specify /main if building a module or library</source>
        <target state="translated">모듈이나 라이브러리를 빌드하고 있으면 /main을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidTarget">
        <source>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</source>
        <target state="translated">잘못된 /target의 대상 형식입니다. 'exe', 'winexe', 'library' 또는 'module'을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">지시 파일에 지정되었기 때문에 /noconfig 옵션을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigNotOnCommandLine_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">지시 파일에 지정되었기 때문에 /noconfig 옵션을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">잘못된 파일 섹션 맞춤 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">잘못된 출력 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">잘못된 디버그 정보 형식: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LegacyObjectIdSyntax">
        <source>'id#' syntax is no longer supported. Use '$id' instead.</source>
        <target state="translated">'id#' 구문은 더 이상 지원되지 않습니다. '$id'를 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">전처리 기호의 이름이 잘못되었습니다. '{0}'은(는) 유효한 식별자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefineIdentifierRequired_Title">
        <source>Invalid name for a preprocessing symbol; not a valid identifier</source>
        <target state="translated">전처리 기호의 이름이 잘못되었습니다. 유효한 식별자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_OutputFileExists">
        <source>Cannot create short filename '{0}' when a long filename with the same short filename already exists</source>
        <target state="translated">약식 파일 이름이 같은 긴 파일 이름이 이미 있으면 '{0}' 약식 파일 이름을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneAliasPerReference">
        <source>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</source>
        <target state="translated">extern 별칭을 선언하는 /reference 옵션에는 파일 이름을 하나만 지정할 수 있습니다. 여러 별칭 또는 파일 이름을 지정하려면 /reference 옵션을 여러 개 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsNumber">
        <source>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</source>
        <target state="translated">명령줄 구문 오류: '{0}' 옵션에 대한 ':&lt;number&gt;'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDebugSwitch">
        <source>The /pdb option requires that the /debug option also be used</source>
        <target state="translated">/pdb 옵션은 /debug 옵션과 함께 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComRefCallInExpressionTree">
        <source>An expression tree lambda may not contain a COM call with ref omitted on arguments</source>
        <target state="translated">람다 식 트리에는 인수에서 ref가 생략된 COM 호출을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">명령줄 구문 오류: '{1}' 옵션에 대해 잘못된 '{0}' Guid 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">명령줄 구문 오류: '{1}' 옵션에 대한 Guid가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">가변 인수가 있는 메서드가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoVarArgs_Title">
        <source>Methods with variable arguments are not CLS-compliant</source>
        <target state="translated">가변 인수가 있는 메서드가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType">
        <source>Argument type '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 인수 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadArgType_Title">
        <source>Argument type is not CLS-compliant</source>
        <target state="translated">인수 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType">
        <source>Return type of '{0}' is not CLS-compliant</source>
        <target state="translated">{0}'의 반환 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadReturnType_Title">
        <source>Return type is not CLS-compliant</source>
        <target state="translated">반환 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType">
        <source>Type of '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadFieldPropType_Description">
        <source>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</source>
        <target state="translated">public, protected 또는 protected internal 변수는 CLS(공용 언어 사양)를 따르는 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase">
        <source>Identifier '{0}' differing only in case is not CLS-compliant</source>
        <target state="translated">대/소문자만 다른 '{0}' 식별자가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifierCase_Title">
        <source>Identifier differing only in case is not CLS-compliant</source>
        <target state="translated">대/소문자만 다른 식별자가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut">
        <source>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">ref, out 또는 배열 차수만 다른 오버로드된 '{0}' 메서드는 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadRefOut_Title">
        <source>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</source>
        <target state="translated">ref, out 또는 배열 차수만 다른 오버로드된 메서드는 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed">
        <source>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">명명되지 않은 배열 형식만 다른 오버로드된 '{0}' 메서드는 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Title">
        <source>Overloaded method differing only by unnamed array types is not CLS-compliant</source>
        <target state="translated">명명되지 않은 배열 형식만 다른 오버로드된 메서드는 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_OverloadUnnamed_Description">
        <source>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute.</source>
        <target state="translated">이 오류는 가변 배열을 사용하는 오버로드된 메서드가 있고 메서드 서명 간에 배열의 요소 형식만 다른 경우에 발생합니다. 이 오류를 방지하려면 가변 배열 대신 직사각형 배열을 사용하고, 추가 매개 변수를 사용하여 함수 호출을 명확하게 구분하고, 하나 이상의 오버로드된 메서드 이름을 바꾸세요. 또는 CLS 규격이 필요하지 않은 경우 CLSCompliantAttribute 특성을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier">
        <source>Identifier '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 식별자가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadIdentifier_Title">
        <source>Identifier is not CLS-compliant</source>
        <target state="translated">식별자가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase">
        <source>'{0}': base type '{1}' is not CLS-compliant</source>
        <target state="translated">'{0}': '{1}' 기본 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Title">
        <source>Base type is not CLS-compliant</source>
        <target state="translated">기본 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadBase_Description">
        <source>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant.</source>
        <target state="translated">기본 형식은 CLS(공용 언어 사양) 규격으로 표시된 어셈블리에서 CLS를 따를 필요가 없는 것으로 표시되었습니다. 어셈블리가 CLS 규격인 것으로 지정하는 특성을 제거하거나 형식이 CLS 규격이 아님을 나타내는 특성을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember">
        <source>'{0}': CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">'{0}': CLS 규격 인터페이스는 CLS 규격 멤버만 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterfaceMember_Title">
        <source>CLS-compliant interfaces must have only CLS-compliant members</source>
        <target state="translated">CLS 규격 인터페이스는 CLS 규격 멤버만 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers">
        <source>'{0}': only CLS-compliant members can be abstract</source>
        <target state="translated">'{0}': CLS 규격 멤버만 abstract일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NoAbstractMembers_Title">
        <source>Only CLS-compliant members can be abstract</source>
        <target state="translated">CLS 규격 멤버만 abstract일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">CLS 규격 검사를 사용하려면 모듈이 아니라 어셈블리에 CLSCompliant 특성을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules_Title">
        <source>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</source>
        <target state="translated">CLS 규격 검사를 사용하려면 모듈이 아니라 어셈블리에 CLSCompliant 특성을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">추가된 모듈은 어셈블리와 일치하도록 CLSCompliant 특성으로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ModuleMissingCLS_Title">
        <source>Added modules must be marked with the CLSCompliant attribute to match the assembly</source>
        <target state="translated">추가된 모듈은 어셈블리와 일치하도록 CLSCompliant 특성으로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS">
        <source>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'어셈블리에 CLSCompliant 특성이 없으므로 '{0}'을(를) CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS_Title">
        <source>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">어셈블리에 CLSCompliant 특성이 없으므로 형식 또는 멤버를 CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType">
        <source>'{0}' has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">'{0}'에는 CLS 규격 형식만 사용하는 액세스 가능 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadAttributeType_Title">
        <source>Type has no accessible constructors which use only CLS-compliant types</source>
        <target state="translated">형식에는 CLS 규격 형식만 사용하는 액세스 가능 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">특성 인수로 사용된 배열은 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_ArrayArgumentToAttribute_Title">
        <source>Arrays as attribute arguments is not CLS-compliant</source>
        <target state="translated">특성 인수로 사용된 배열은 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">어셈블리의 CLSCompliant 특성과 다른 모듈의 CLSCompliant 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_NotOnModules2_Title">
        <source>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</source>
        <target state="translated">어셈블리의 CLSCompliant 특성과 다른 모듈의 CLSCompliant 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse">
        <source>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</source>
        <target state="translated">'{0}'은(는) CLS 규격이 아닌 '{1}' 형식의 멤버이므로 CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_IllegalTrueInFalse_Title">
        <source>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</source>
        <target state="translated">형식은 CLS 규격이 아닌 형식의 멤버이므로 CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType">
        <source>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</source>
        <target state="translated">{0}'은(는) 이 어셈블리 외부에 노출되지 않으므로 CLS 규격 검사를 수행하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnPrivateType_Title">
        <source>CLS compliance checking will not be performed because it is not visible from outside this assembly</source>
        <target state="translated">이 어셈블리 외부에 노출되지 않으므로 CLS 규격 검사를 수행하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2">
        <source>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">'어셈블리에 CLSCompliant 특성이 없으므로 '{0}'에 CLSCompliant 특성이 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_AssemblyNotCLS2_Title">
        <source>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</source>
        <target state="translated">어셈블리에 CLSCompliant 특성이 없으므로 형식 또는 멤버에 CLSCompliant 특성이 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam">
        <source>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 특성을 매개 변수에 적용하면 의미가 없습니다. 대신 이 특성을 메서드에 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnParam_Title">
        <source>CLSCompliant attribute has no meaning when applied to parameters</source>
        <target state="translated">CLSCompliant 특성을 매개 변수에 적용하면 의미가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn">
        <source>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</source>
        <target state="translated">CLSCompliant 특성은 반환 형식에 적용하면 의미가 없습니다. 대신 이 특성을 메서드에 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_MeaninglessOnReturn_Title">
        <source>CLSCompliant attribute has no meaning when applied to return types</source>
        <target state="translated">CLSCompliant 특성을 반환 형식에 적용하면 의미가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar">
        <source>Constraint type '{0}' is not CLS-compliant</source>
        <target state="translated">{0}' 제약 조건 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadTypeVar_Title">
        <source>Constraint type is not CLS-compliant</source>
        <target state="translated">제약 조건 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField">
        <source>CLS-compliant field '{0}' cannot be volatile</source>
        <target state="translated">CLS 규격 필드 '{0}'은(는) volatile일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_VolatileField_Title">
        <source>CLS-compliant field cannot be volatile</source>
        <target state="translated">CLS 규격 필드는 volatile일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface">
        <source>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</source>
        <target state="translated">'기본 인터페이스 '{1}'이(가) CLS 규격이 아니므로 '{0}'은(는) CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLS_BadInterface_Title">
        <source>Type is not CLS-compliant because base interface is not CLS-compliant</source>
        <target state="translated">기본 인터페이스가 CLS 규격이 아니므로 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg">
        <source>'await' requires that the type {0} have a suitable 'GetAwaiter' method</source>
        <target state="translated">'await'의 경우 {0} 형식에 적합한 GetAwaiter 메서드가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgIntrinsic">
        <source>Cannot await '{0}'</source>
        <target state="translated">{0}'에 대해 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaiterPattern">
        <source>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</source>
        <target state="translated">'await'의 경우 '{1}.GetAwaiter()'의 반환 형식 '{0}'에 적합한 'IsCompleted', 'OnCompleted' 및 'GetResult' 멤버가 있어야 하며 'INotifyCompletion' 또는 'ICriticalNotifyCompletion'을 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArg_NeedSystem">
        <source>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</source>
        <target state="translated">'await'를 사용하려면 '{0}' 형식에 적합한 'GetAwaiter' 메서드가 있어야 합니다. 'System'에 대해 using 지시문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitArgVoidCall">
        <source>Cannot await 'void'</source>
        <target state="translated">void'에 대해 'void'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitAsIdentifier">
        <source>'await' cannot be used as an identifier within an async method or lambda expression</source>
        <target state="translated">'await'는 비동기 메서드나 람다 식 내에서 식별자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface">
        <source>'{0}' does not implement '{1}'</source>
        <target state="translated">'{0}'은(는) '{1}'을(를) 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequired">
        <source>Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">{0}'이(가) 'Task'를 반환하는 비동기 메서드이므로 return 키워드 뒤에 개체 식이 나오면 안 됩니다. 'Task&lt;T&gt;'를 반환하려고 했습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</source>
        <target state="translated">비동기 메서드의 반환 형식은 void, Task, Task&lt;T&gt;, task와 유사한 형식, IAsyncEnumerable&lt;T&gt; 또는 IAsyncEnumerator&lt;T&gt;여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReturnVoid">
        <source>Cannot return an expression of type 'void'</source>
        <target state="translated">void' 형식의 식을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarargsAsync">
        <source>__arglist is not allowed in the parameter list of async methods</source>
        <target state="translated">__arglist는 비동기 메서드의 매개 변수 목록에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefTypeAndAwait">
        <source>'await' cannot be used in an expression containing the type '{0}'</source>
        <target state="translated">'await'는 '{0}' 형식이 포함된 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsafeAsyncArgType">
        <source>Async methods cannot have unsafe parameters or return types</source>
        <target state="translated">비동기 메서드에는 안전하지 않은 매개 변수 또는 반환 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncArgType">
        <source>Async methods cannot have ref, in or out parameters</source>
        <target state="translated">비동기 메서드에는 ref, in 또는 out 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsync">
        <source>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</source>
        <target state="translated">await' 연산자는 'async' 한정자로 표시된 메서드나 람다 식 내에 포함된 경우에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncLambda">
        <source>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</source>
        <target state="translated">await' 연산자는 비동기 {0} 내에서만 사용할 수 있습니다. 'async' 한정자로 이 {0}을(를) 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</source>
        <target state="translated">await' 연산자는 비동기 메서드 내에서만 사용할 수 있습니다. 'async' 한정자로 이 메서드를 표시하고 해당 반환 형식을 'Task&lt;{0}&gt;'로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitWithoutVoidAsyncMethod">
        <source>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">await' 연산자는 비동기 메서드 내에서만 사용할 수 있습니다. 'async' 한정자로 이 메서드를 표시하고 해당 반환 형식을 'Task'로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInFinally">
        <source>Cannot await in the body of a finally clause</source>
        <target state="translated">finally 절의 본문에서는 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatch">
        <source>Cannot await in a catch clause</source>
        <target state="translated">catch 절에서 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInCatchFilter">
        <source>Cannot await in the filter expression of a catch clause</source>
        <target state="translated">catch 절의 필터 식에서 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInLock">
        <source>Cannot await in the body of a lock statement</source>
        <target state="translated">lock 문의 본문에서 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInStaticVariableInitializer">
        <source>The 'await' operator cannot be used in a static script variable initializer.</source>
        <target state="translated">await' 연산자는 정적 스크립트 변수 이니셜라이저에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AwaitInUnsafeContext">
        <source>Cannot await in an unsafe context</source>
        <target state="translated">안전하지 않은 컨텍스트에서는 await를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLacksBody">
        <source>The 'async' modifier can only be used in methods that have a body.</source>
        <target state="translated">async' 한정자는 본문이 있는 메서드에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefLocal">
        <source>Parameters or locals of type '{0}' cannot be declared in async methods or lambda expressions.</source>
        <target state="translated">{0}' 형식의 매개 변수 또는 로컬은 비동기 메서드나 람다 식에서 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecialByRefIterator">
        <source>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.</source>
        <target state="translated">{0}'은(는) ref struct이므로 비동기 또는 반복기 메서드의 '{0}' 형식 열거자에서 foreach 문을 수행할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
        <source>Security attribute '{0}' cannot be applied to an Async method.</source>
        <target state="translated">{0}' 보안 특성은 비동기 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
        <source>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">특성이 'SecurityCritical' 또는 'SecuritySafeCritical'인 인터페이스, 클래스 또는 구조에서는 비동기 메서드가 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInQuery">
        <source>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</source>
        <target state="translated">await' 연산자는 초기 'from' 절의 첫 번째 Collection 식이나 'join' 절의 Collection 식 내의 쿼리 식에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">이 비동기 메서드에는 'await' 연산자가 없으며 메서드가 동시에 실행됩니다. 'await' 연산자를 사용하여 비블로킹 API 호출을 대기하거나, 'await Task.Run(...)'을 사용하여 백그라운드 스레드에서 CPU 바인딩된 작업을 수행하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>Async method lacks 'await' operators and will run synchronously</source>
        <target state="translated">이 비동기 메서드에는 'await' 연산자가 없으며 메서드가 동시에 실행됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</source>
        <target state="translated">이 호출이 대기되지 않으므로 호출이 완료되기 전에 현재 메서드가 계속 실행됩니다. 호출 결과에 'await' 연산자를 적용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">이 호출을 대기하지 않으므로 호출이 완료되기 전에 현재 메서드가 계속 실행됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Description">
        <source>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.

An equally important issue is what happens to exceptions that are raised in the called async method. An exception that's raised in a method that returns a Task or Task&lt;TResult&gt; is stored in the returned task. If you don't await the task or explicitly check for exceptions, the exception is lost. If you await the task, its exception is rethrown.

As a best practice, you should always await the call.

You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions. In that case, you can suppress the warning by assigning the task result of the call to a variable.</source>
        <target state="translated">현재 메서드는 Task 또는 Task&lt;TResult&gt;를 반환하는 비동기 메서드를 호출하므로 await 연산자를 결과에 적용하지 않습니다. 비동기 메서드를 호출하면 비동기 작업이 시작됩니다. 그러나 await 연산자가 적용되지 않으므로 작업이 완료될 때까지 기다리지 않고 프로그램이 계속 진행됩니다. 대부분의 경우 이 동작은 예상과 다릅니다. 일반적으로 호출 메서드의 다양한 측면에 따라 호출 결과가 달라지며, 최소한 호출을 포함하는 메서드에서 반환되기 이전에 호출된 메서드가 완료되어야 합니다.

호출된 비동기 메서드에서 발생하는 예외에 대해 발생하는 문제도 중요합니다. Task 또는 Task&lt;TResult&gt;를 반환하는 메서드에서 발생하는 예외는 반환된 작업에 저장됩니다. 작업을 대기하지 않거나 예외를 명시적으로 확인하지 않을 경우 예외가 손실됩니다. 작업을 대기하면 예외가 다시 발생합니다.

따라서 항상 호출을 대기하는 것이 좋습니다.

비동기 호출이 완료되는 동안 대기하지 않고 호출된 메서드가 예외를 발생하지 않는 경우에만 이 경고를 무시해야 합니다. 이 경우 호출의 작업 결과를 변수에 할당하여 경고를 무시할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an async method</source>
        <target state="translated">'MethodImplOptions.Synchronized'는 비동기 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerLineNumberParam">
        <source>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">{0}' 형식에서 '{1}' 형식으로의 표준 변환이 없기 때문에 CallerLineNumberAttribute를 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerFilePathParam">
        <source>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">{0}' 형식에서 '{1}' 형식으로의 표준 변환이 없기 때문에 CallerFilePathAttribute를 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForCallerMemberNameParam">
        <source>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</source>
        <target state="translated">{0}' 형식에서 '{1}' 형식으로의 표준 변환이 없기 때문에 CallerMemberNameAttribute를 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerLineNumberParamWithoutDefaultValue">
        <source>The CallerLineNumberAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerLineNumberAttribute는 기본값이 있는 매개 변수에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerFilePathParamWithoutDefaultValue">
        <source>The CallerFilePathAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerFilePathAttribute는 기본값이 있는 매개 변수에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCallerMemberNameParamWithoutDefaultValue">
        <source>The CallerMemberNameAttribute may only be applied to parameters with default values</source>
        <target state="translated">CallerMemberNameAttribute는 기본값이 있는 매개 변수에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation">
        <source>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerLineNumberAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberParamForUnconsumedLocation_Title">
        <source>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerLineNumberAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">{0}' 매개 변수에 적용된 CallerFilePathAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathParamForUnconsumedLocation_Title">
        <source>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerFilePathAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerMemberNameAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerMemberNameParamForUnconsumedLocation_Title">
        <source>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">CallerMemberNameAttribute는 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoEntryPoint">
        <source>Program does not contain a static 'Main' method suitable for an entry point</source>
        <target state="translated">프로그램에는 진입점에 적합한 정적 'Main' 메서드가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerIncorrectLength">
        <source>An array initializer of length '{0}' is expected</source>
        <target state="translated">길이가 '{0}'인 배열 이니셜라이저가 필요합니다</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerExpected">
        <source>A nested array initializer is expected</source>
        <target state="translated">중첩 배열 이니셜라이저가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalVarianceSyntax">
        <source>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</source>
        <target state="translated">가변성(variance) 한정자가 잘못되었습니다. 인터페이스 및 대리자 형식 매개 변수만 variant로 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedAliasedName">
        <source>Unexpected use of an aliased name</source>
        <target state="translated">예기치 않은 별칭이 지정된 이름의 사용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGenericName">
        <source>Unexpected use of a generic name</source>
        <target state="translated">예기치 않은 제네릭 이름의 사용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedUnboundGenericName">
        <source>Unexpected use of an unbound generic name</source>
        <target state="translated">예기치 않게 바인딩되지 않은 제네릭 이름이 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalStatement">
        <source>Expressions and statements can only occur in a method body</source>
        <target state="translated">식과 문은 메서드 본문에만 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentForArray">
        <source>An array access may not have a named argument specifier</source>
        <target state="translated">배열 액세스에는 명명된 인수 지정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotYetImplementedInRoslyn">
        <source>This language feature ('{0}') is not yet implemented.</source>
        <target state="translated">이 언어 기능('{0}')은 아직 구현되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueNotAllowed">
        <source>Default values are not valid in this context.</source>
        <target state="translated">이 컨텍스트에서는 기본값은 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenIcon">
        <source>Error opening icon file {0} -- {1}</source>
        <target state="translated">{0} 아이콘 파일을 여는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenWin32Manifest">
        <source>Error opening Win32 manifest file {0} -- {1}</source>
        <target state="translated">{0} Win32 매니페스트 파일을 여는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorBuildingWin32Resources">
        <source>Error building Win32 resources -- {0}</source>
        <target state="translated">Win32 리소스를 만드는 동안 오류가 발생했습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueBeforeRequiredValue">
        <source>Optional parameters must appear after all required parameters</source>
        <target state="translated">선택적 매개 변수는 모든 필수 매개 변수 다음에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitImplCollisionOnRefOut">
        <source>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</source>
        <target state="translated">지정한 형식 매개 변수가 있는 '{0}' 인터페이스를 사용하면 '{1}' 메서드에 ref 및 out만 다른 오버로드가 포함되므로 해당 인터페이스를 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialWrongTypeParamsVariance">
        <source>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</source>
        <target state="translated">{0}'의 partial 선언에는 동일한 순서로 동일한 형식 매개 변수 이름과 가변성(variance) 한정자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedVariance">
        <source>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</source>
        <target state="translated">잘못된 가변성(variance): '{1}' 형식 매개 변수는 '{0}'에서 유효한 {3}이어야 합니다. '{1}'은(는) {2}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromDynamic">
        <source>'{0}': cannot derive from the dynamic type</source>
        <target state="translated">'{0}': 동적 유형에서 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeriveFromConstructedDynamic">
        <source>'{0}': cannot implement a dynamic interface '{1}'</source>
        <target state="translated">'{0}': 동적 인터페이스 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicTypeAsBound">
        <source>Constraint cannot be the dynamic type</source>
        <target state="translated">제약 조건은 동적 유형일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructedDynamicTypeAsBound">
        <source>Constraint cannot be a dynamic type '{0}'</source>
        <target state="translated">제약 조건은 '{0}' 동적 유형일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicRequiredTypesMissing">
        <source>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</source>
        <target state="translated">동적 식을 컴파일하는 데 필요한 하나 이상의 형식을 찾을 수 없습니다. 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataNameTooLong">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">{0}' 이름이 메타데이터에 허용된 최대 길이를 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesNotAllowed">
        <source>Attributes are not valid in this context.</source>
        <target state="translated">이 컨텍스트에서는 특성이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExternAliasNotAllowed">
        <source>'extern alias' is not valid in this context</source>
        <target state="translated">'이 컨텍스트에서는 'extern 별칭'이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing">
        <source>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</source>
        <target state="translated">{0}'을(를) 사용한 '{1}' 호환성 테스트는 근본적으로 '{2}' 호환성 테스트와 동일하며 null이 아닌 모든 값에서 성공합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IsDynamicIsConfusing_Title">
        <source>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</source>
        <target state="translated">is'를 사용한 'dynamic' 호환성 테스트는 근본적으로 'Object' 호환성 테스트와 동일합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_YieldNotAllowedInScript">
        <source>Cannot use 'yield' in top-level script code</source>
        <target state="translated">최상위 스크립트 코드에서 'yield'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>Cannot declare namespace in script code</source>
        <target state="translated">스크립트 코드에서 네임스페이스를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalAttributesNotAllowed">
        <source>Assembly and module attributes are not allowed in this context</source>
        <target state="translated">이 컨텍스트에 어셈블리 및 모듈 특성이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDelegateType">
        <source>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</source>
        <target state="translated">{0}' 대리자에 invoke 메서드가 없거나 지원되지 않는 반환 형식 또는 매개 변수 형식을 사용한 invoke 메서드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global script code; ignoring '{0}' entry point.</source>
        <target state="translated">프로그램의 진입점은 전역 스크립트 코드이므로 '{0}' 진입점을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global script code; ignoring entry point</source>
        <target state="translated">프로그램의 진입점이 전역 스크립트 코드이며 진입점을 무시함</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticInAsOrIs">
        <source>The second operand of an 'is' or 'as' operator may not be static type '{0}'</source>
        <target state="translated">is' 또는 'as' 연산자의 두 번째 피연산자는 '{0}' 정적 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadVisEventType">
        <source>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</source>
        <target state="translated">일관성 없는 액세스 가능성: '{1}' 이벤트 형식이 '{0}' 이벤트보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgument">
        <source>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</source>
        <target state="translated">명명된 인수 사양은 모든 고정 인수를 지정한 다음에 와야 합니다. 뒤에 오지 않는 명명된 인수를 허용하려면 {0} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</source>
        <target state="translated">명명된 인수 사양은 동적 호출에서 모든 고정 인수를 지정한 다음에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgument">
        <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">{0}'에 가장 적합한 오버로드에는 '{1}' 매개 변수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamedArgumentForDelegateInvoke">
        <source>The delegate '{0}' does not have a parameter named '{1}'</source>
        <target state="translated">{0}' 대리자에는 '{1}' 매개 변수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedArgument">
        <source>Named argument '{0}' cannot be specified multiple times</source>
        <target state="translated">명명된 인수 '{0}'을(를) 여러 번 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentUsedInPositional">
        <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
        <target state="translated">명명된 인수 '{0}'은(는) 위치 인수가 이미 지정된 매개 변수를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">명명된 인수 '{0}'은(는) 잘못된 위치에 사용되었지만 뒤에 명명되지 않은 인수가 옵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueUsedWithAttributes">
        <source>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</source>
        <target state="translated">DefaultParameterAttribute 또는 OptionalAttribute와 함께 기본 매개 변수 값을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueMustBeConstant">
        <source>Default parameter value for '{0}' must be a compile-time constant</source>
        <target state="translated">{0}'의 기본 매개 변수 값은 컴파일 타임 상수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefOutDefaultValue">
        <source>A ref or out parameter cannot have a default value</source>
        <target state="translated">ref 또는 out 매개 변수에는 기본값을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForExtensionParameter">
        <source>Cannot specify a default value for the 'this' parameter</source>
        <target state="translated">this' 매개 변수의 기본값을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForParamsParameter">
        <source>Cannot specify a default value for a parameter array</source>
        <target state="translated">매개 변수 배열의 기본값을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForDefaultParam">
        <source>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</source>
        <target state="translated">{1}' 형식으로의 표준 변환이 없으므로 형식이 '{0}'인 값을 기본 매개 변수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConversionForNubDefaultParam">
        <source>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</source>
        <target state="translated">{0}'이(가) 단순 형식이 아니기 때문에 null 허용 매개 변수 '{1}'에 형식이 '{0}'인 값을 기본 매개 변수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotNullRefDefaultParameter">
        <source>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</source>
        <target state="translated">'{0}'의 형식이 '{1}'입니다. 문자열이 아닌 참조 형식의 기본 매개 변수 값은 null로만 초기화할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation">
        <source>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">'{0}' 매개 변수에 지정된 기본값은 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultValueForUnconsumedLocation_Title">
        <source>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</source>
        <target state="translated">지정된 기본값은 선택적 인수를 허용하지 않는 컨텍스트에서 사용되는 멤버에 적용되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error signing output with public key from file '{0}' -- {1}</source>
        <target state="translated">{0}' 파일에서 공용 키를 사용하여 출력에 서명하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error signing output with public key from container '{0}' -- {1}</source>
        <target state="translated">{0}' 컨테이너에서 공용 키를 사용하여 출력에 서명하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicTypeof">
        <source>The typeof operator cannot be used on the dynamic type</source>
        <target state="translated">typeof 연산자는 동적 유형에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDynamicOperation">
        <source>An expression tree may not contain a dynamic operation</source>
        <target state="translated">식 트리에는 동적 연산을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncExpressionTree">
        <source>Async lambda expressions cannot be converted to expression trees</source>
        <target state="translated">비동기 람다 식을 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicAttributeMissing">
        <source>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">컴파일러에서 요구하는 '{0}' 형식을 찾지 못했기 때문에 'dynamic'을 사용하는 클래스 또는 멤버를 정의할 수 없습니다. 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotPassNullForFriendAssembly">
        <source>Cannot pass null for friend assembly name</source>
        <target state="translated">null 또는 friend 어셈블리 이름을 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing</source>
        <target state="translated">{0}' 키 파일에 서명에 필요한 프라이빗 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignButNoKey">
        <source>Public signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">공개 서명이 지정되었으며 공개 키가 있어야 하지만 공개 키가 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">netmodule에 대해 공개 서명이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">서명 연기가 지정되어 공개 키가 필요하지만 지정된 공개 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">서명 연기가 지정되어 공개 키가 필요하지만 지정된 공개 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string does not conform to the required format - major[.minor[.build[.revision]]]</source>
        <target state="translated">지정한 버전 문자열이 필요한 형식 major[.minor[.build[.revision]]]을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormatDeterministic">
        <source>The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</source>
        <target state="translated">지정한 버전 문자열에는 결정성과 호환되지 않는 와일드카드가 포함되어 있습니다. 버전 문자열에서 와일드카드를 제거하거나 이 컴파일에 대해 결정성을 사용하지 않도록 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string does not conform to the required format - major.minor.build.revision (without wildcards)</source>
        <target state="translated">지정한 버전 문자열이 필요한 형식 major.minor.build.revision(와일드카드 없음)을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">지정한 버전 문자열이 권장 형식 major.minor.build.revision을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">지정한 버전 문자열이 권장 형식 major.minor.build.revision을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">실행 파일은 위성 어셈블리일 수 없습니다. 문화권은 항상 비워 두어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCorrespondingArgument">
        <source>There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'</source>
        <target state="translated">{1}'에서 필요한 정식 매개 변수 '{0}'에 해당하는 제공된 인수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">명령줄 스위치 '{0}'이(가) 아직 구현되지 않아 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">명령줄 스위치가 아직 구현되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">모듈 '{0}'을(를) 내보내지 못했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedLocalInLambda">
        <source>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">무명 메서드, 람다 식 또는 쿼리 식에는 '{0}' 고정 로컬을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsNamedArgument">
        <source>An expression tree may not contain a named argument specification</source>
        <target state="translated">식 트리에는 명명된 인수 사양을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOptionalArgument">
        <source>An expression tree may not contain a call or invocation that uses optional arguments</source>
        <target state="translated">식 트리에는 선택적 인수를 사용하는 호출을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIndexedProperty">
        <source>An expression tree may not contain an indexed property</source>
        <target state="translated">식 트리에는 인덱싱된 속성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyRequiresParams">
        <source>Indexed property '{0}' has non-optional arguments which must be provided</source>
        <target state="translated">인덱싱된 속성 '{0}'에 반드시 제공되어야 하는 필수 인수가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedPropertyMustHaveAllOptionalParams">
        <source>Indexed property '{0}' must have all arguments optional</source>
        <target state="translated">인덱싱된 속성 '{0}'에 모든 선택적 인수가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecialByRefInLambda">
        <source>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</source>
        <target state="translated">{0}' 형식의 인스턴스는 중첩된 함수, 쿼리 식, 반복기 블록 또는 비동기 메서드 내에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction</source>
        <target state="translated">보안 특성에 대한 첫 번째 인수는 유효한 SecurityAction이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'</source>
        <target state="translated">{0}' 보안 특성에 있는 SecurityAction 값('{1}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</source>
        <target state="translated">어셈블리에 적용된 보안 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</source>
        <target state="translated">형식 또는 메서드에 적용된 보안 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</source>
        <target state="translated">PrincipalPermission 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotValidInExpressionTree">
        <source>An expression tree may not contain '{0}'</source>
        <target state="translated">식 트리는 '{0}'을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</source>
        <target state="translated">PermissionSet 특성에 대해 명명된 인수 '{1}'에 지정된 '{0}' 파일 경로를 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</source>
        <target state="translated">PermissionSet 특성에 대해 명명된 인수 '{1}'에 지정된 '{0}' 파일을 읽는 동안 오류가 발생했습니다. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GlobalSingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</source>
        <target state="translated">전역 네임스페이스에 형식 이름 '{0}'이(가) 없습니다. 이 형식은 '{1}' 어셈블리에 전달되었습니다. 해당 어셈블리에 대한 참조를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DottedTypeNameNotFoundInNSFwd">
        <source>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</source>
        <target state="translated">네임스페이스 '{1}'에 형식 이름 '{0}'이(가) 없습니다. 이 형식은 '{2}' 어셈블리에 전달되었습니다. 해당 어셈블리에 대한 참조를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleTypeNameNotFoundFwd">
        <source>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</source>
        <target state="translated">형식 이름 '{0}'이(가) 없습니다. 이 형식은 '{1}' 어셈블리에 전달되었습니다. 해당 어셈블리에 대한 참조를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AssemblySpecifiedForLinkAndRef">
        <source>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</source>
        <target state="translated">{0}' 및 '{1}' 어셈블리가 동일한 메타데이터를 참조하지만 하나만 링크된 참조이며 /link 옵션을 사용하여 지정되었습니다. 참조 중 하나를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</source>
        <target state="translated">오버로드된 Add 메서드 중 해당 컬렉션 이니셜라이저 요소에 가장 적합한 '{0}'은(는) 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAdd_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">컬렉션 이니셜라이저 요소에 가장 적합한 오버로드된 Add 메서드는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">오버로드된 Add 메서드 중 해당 컬렉션 이니셜라이저 요소에 가장 적합한 '{0}'은(는) 사용되지 않습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DeprecatedCollectionInitAddStr_Title">
        <source>The best overloaded Add method for the collection initializer element is obsolete</source>
        <target state="translated">컬렉션 이니셜라이저 요소에 가장 적합한 오버로드된 Add 메서드는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeprecatedCollectionInitAddStr">
        <source>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</source>
        <target state="translated">오버로드된 Add 메서드 중 해당 컬렉션 이니셜라이저 요소에 가장 적합한 '{0}'은(는) 사용되지 않습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IteratorInInteractive">
        <source>Yield statements may not appear at the top level in interactive code.</source>
        <target state="translated">Yield 문이 대화형 코드의 최상위 수준에 표시되지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">이 선언 형식에서는 '{0}' 보안 특성이 유효하지 않습니다. 보안 특성은 어셈블리, 형식 및 메서드 선언에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArg">
        <source>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</source>
        <target state="translated">{0}' 형식의 식을 동적으로 디스패치된 작업의 인수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgLambda">
        <source>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</source>
        <target state="translated">람다 식을 대리자 또는 식 트리 형식으로 먼저 캐스팅하지 않고는 동적으로 디스패치된 작업의 인수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicMethodArgMemgrp">
        <source>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</source>
        <target state="translated">메서드 그룹을 동적으로 디스패치된 작업의 인수로 사용할 수 없습니다. 메서드를 호출하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBase">
        <source>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">{0}' 메서드 호출을 동적으로 디스패치해야 하지만 해당 호출이 기본 액세스 식의 일부이므로 동적으로 디스패치할 수 없습니다. 동적 인수를 캐스팅하거나 기본 액세스를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDynamicQuery">
        <source>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</source>
        <target state="translated">소스 형식이 'dynamic'인 쿼리 식 또는 'dynamic' 형식의 조인 시퀀스가 포함된 쿼리 식은 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDynamicPhantomOnBaseIndexer">
        <source>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</source>
        <target state="translated">인덱서 액세스를 동적으로 디스패치해야 하지만 해당 액세스가 기본 액세스 식의 일부이므로 동적으로 디스패치할 수 없습니다. 동적 인수를 캐스팅하거나 기본 액세스를 제거하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod">
        <source>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</source>
        <target state="translated">적용 가능한 하나 이상의 오버로드가 조건부 메서드이므로 '{0}' 메서드에 대해 동적으로 디스패치된 호출이 런타임에 실패할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DynamicDispatchToConditionalMethod_Title">
        <source>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</source>
        <target state="translated">하나 이상의 적용 가능한 오버로드가 조건부 메서드이므로 동적으로 디스패치된 호출이 런타임에 실패할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadArgTypeDynamicExtension">
        <source>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</source>
        <target state="translated">'{0}'에 이름이 '{1}'인 적용 가능한 메서드가 없지만 이 이름의 확장 메서드는 있습니다. 확장 메서드는 동적으로 발송할 수 없습니다. 동적 인수를 캐스팅하거나 확장 메서드 구문 없이 확장 메서드를 호출해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerMemberNameAttribute는 효과가 없습니다. CallerFilePathAttribute에서 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerFilePathPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</source>
        <target state="translated">CallerMemberNameAttribute는 CallerFilePathAttribute에 의해 재정의되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerMemberNameAttribute는 효과가 없습니다. CallerLineNumberAttribute에서 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
        <source>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerMemberNameAttribute는 CallerLineNumberAttribute에 의해 재정의되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath">
        <source>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerFilePathAttribute는 효과가 없습니다. CallerLineNumberAttribute에서 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
        <source>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</source>
        <target state="translated">CallerFilePathAttribute는 CallerLineNumberAttribute에 의해 재정의되므로 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDynamicCondition">
        <source>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</source>
        <target state="translated">식은 부울로 암시적으로 변환할 수 있어야 하거나 '{0}' 형식은 '{1}' 연산자를 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTEventWithRegular">
        <source>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</source>
        <target state="translated">'{2}'은(는) Windows Runtime 이벤트이고 '{3}'은(는) 일반 .NET 이벤트이므로 '{0}'에서 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1">
        <source>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</source>
        <target state="translated">모든 참조가 범위를 벗어나기 전에 할당된 {0} 인스턴스에서 System.IDisposable.Dispose()를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
        <source>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</source>
        <target state="translated">할당된 인스턴스에 대한 모든 참조가 범위를 벗어나기 전에 System.IDisposable.Dispose()를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2">
        <source>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</source>
        <target state="translated">할당된 {0} 인스턴스는 일부 예외 경로와 함께 삭제되지 않습니다. 모든 참조가 범위를 벗어나기 전에 System.IDisposable.Dispose()를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
        <source>Allocated instance is not disposed along all exception paths</source>
        <target state="translated">할당된 인스턴스는 일부 예외 경로와 함께 삭제되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
        <source>Object '{0}' can be disposed more than once.</source>
        <target state="translated">{0}' 개체는 여러 번 삭제할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
        <source>Object can be disposed more than once</source>
        <target state="translated">개체를 여러 번 삭제할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCoClassOnLink">
        <source>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</source>
        <target state="translated">Interop 형식 '{0}'을(를) 포함할 수 없습니다. 적용 가능한 인터페이스를 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIANestedType">
        <source>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">{0}' 형식은 중첩 형식이기 때문에 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">'{0}' 형식에 제네릭 인수가 있으므로 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropStructContainsMethods">
        <source>Embedded interop struct '{0}' can contain only public instance fields.</source>
        <target state="translated">포함된 interop 구조체 '{0}'은(는) public 인스턴스 필드만 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRtEventPassedByRef">
        <source>A Windows Runtime event may not be passed as an out or ref parameter.</source>
        <target state="translated">Windows Runtime 이벤트를 out 또는 ref 매개 변수로 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingMethodOnSourceInterface">
        <source>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</source>
        <target state="translated">소스 인터페이스 '{0}'에는 '{2}' 이벤트를 포함하는 데 필요한 '{1}' 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSourceInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">{0}' 인터페이스에는 '{1}' 이벤트를 포함하는 데 필요한 소스 인터페이스가 잘못 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypeMissingAttribute">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">필수 '{1}' 특성이 없으므로 Interop 형식 '{0}'을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttribute">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">어셈블리 '{0}'에 '{1}' 특성이 없으므로 이 어셈블리의 interop 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAssemblyMissingAttributes">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">어셈블리 '{0}'에 '{1}' 특성 또는 '{2}' 특성이 없으므로 이 어셈블리의 interop 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropTypesWithSameNameAndGuid">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">어셈블리 '{1}'과(와) '{2}' 모두에 있는 interop 형식 '{0}'을(를) 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">{1}' 어셈블리의 interop 형식 '{0}'을(를) 포함하면 현재 어셈블리에서 이름 충돌이 발생합니다. 'Interop 형식 포함' 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">{1}' 어셈블리에서 만든 어셈블리에 대한 간접 참조 때문에 포함된 interop 어셈블리 '{0}'에 대한 참조를 만들었습니다. 두 어셈블리 중 하나에서 'Interop 형식 포함' 속성을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
        <source>A reference was created to embedded interop assembly because of an indirect assembly reference</source>
        <target state="translated">간접 어셈블리 참조로 인해 포함된 interop 어셈블리에 대한 참조를 만들었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
        <source>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).

To embed interop type information for both assemblies, use /link for references to each assembly (set the Embed Interop Types property to True).

To remove the warning, you can use /reference instead (set the Embed Interop Types property to False). In this case, a primary interop assembly (PIA) provides interop type information.</source>
        <target state="translated">/link를 사용하여 어셈블리에 대한 참조를 추가했습니다(Interop 형식 포함 속성을 True로 설정). 이는 해당 어셈블리의 interop 유형 정보를 포함하도록 컴파일러에 지시합니다. 그러나 참조한 다른 어셈블리에서도 /reference를 사용하여 해당 어셈블리를 참조하므로 컴파일러에서 해당 어셈블리의 interop 형식 정보를 포함할 수 없습니다(Interop 형식 포함 속성을 False로 설정).

두 어셈블리에 대한 interop 형식 정보를 포함하려면 각 어셈블리에 대한 참조에 대해 /link를 사용합니다(Interop 형식 포함 속성을 True로 설정).

경고를 제거하려면 /reference를 대신 사용할 수 있습니다(Interop 형식 포함 속성을 False로 설정). 이 경우 PIA(주 interop 어셈블리)는 interop 형식 정보를 제공합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericsUsedAcrossAssemblies">
        <source>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">{1}' 어셈블리의 '{0}' 형식에 포함된 interop 형식인 제네릭 형식 인수가 있기 때문에 이 형식을 다른 어셈블리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCanonicalView">
        <source>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">포함된 interop 형식 '{0}'과(와) 일치하는 interop 형식을 찾을 수 없습니다. 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefReturnUnsupported">
        <source>By-reference return type 'ref {0}' is not supported.</source>
        <target state="translated">by-reference 반환 형식 'ref {0}'은(는) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">{1}'에 저장된 '{0}' 모듈 이름은 파일 이름과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">잘못된 모듈 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCompilationOptionValue">
        <source>Invalid '{0}' value: '{1}'.</source>
        <target state="translated">잘못된 '{0}' 값입니다('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAppConfigPath">
        <source>AppConfigPath must be absolute.</source>
        <target state="translated">AppConfigPath는 절대 경로여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</source>
        <target state="translated">{1}' 모듈의 '{0}' 특성은 소스에 나타나는 인스턴스를 위해 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute will be ignored in favor of the instance appearing in source</source>
        <target state="translated">소스에 표시되는 인스턴스를 위해 특성이 무시됨</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">소스 파일에 지정된 '{0}' 특성이 '{1}' 옵션과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FixedBufferTooManyDimensions">
        <source>A fixed buffer may only have one dimension.</source>
        <target state="translated">고정 버퍼에는 1차원만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">참조된 어셈블리 '{0}'에 강력한 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">참조된 어셈블리는 강력한 이름을 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">AssemblySignatureKeyAttribute에 잘못된 시그니처 공개 키가 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">{1}' 모듈에서 내보낸 '{0}' 형식이 이 어셈블리의 주 모듈에서 선언된 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">{1}' 모듈에서 내보낸 '{0}' 형식이 '{3}' 모델에서 내보낸 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">전달된 '{0}' 형식이 이 어셈블리의 주 모듈에서 선언된 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">{1}' 어셈블리로 전달된 '{0}' 형식이 '{3}' 어셈블리로 전달된 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">{1}' 어셈블리로 전달된 '{0}' 형식이 '{3}'에서 내보낸 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">참조된 어셈블리 '{0}'에 다른 '{1}' 문화권 설정이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">참조된 어셈블리의 문화권 설정이 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">알 수 없는 어셈블리는 프로세서의 특정 모듈('{0}')을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">어셈블리 및 '{0}' 모듈은 다른 프로세서를 대상으로 할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">참조된 어셈블리 '{0}'이(가) 다른 프로세서를 대상으로 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">참조된 어셈블리가 다른 프로세서를 대상으로 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">해시를 만드는 동안 암호화 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">{0}' netmodule에 대한 참조가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">{0}' 모듈이 이 어셈블리에 이미 정의되었습니다. 각 모듈에 고유한 파일 이름이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadConfigFile">
        <source>Cannot read config file '{0}' -- '{1}'</source>
        <target state="translated">{0}' 구성 파일을 읽을 수 없습니다. '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">편집의 포함된 형식 '{0}'에 대한 참조가 포함되어 있어 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">현재 디버그 세션 중에 추가되는 '{0}' 멤버는 해당 선언 어셈블리 '{1}' 내에서만 액세스할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">컴파일 옵션 '{0}'과(와) '{1}'을(를) 동시에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">링크된 netmodule 메타데이터는 전체 PE 이미지를 제공해야 합니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPrefer32OnLib">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</source>
        <target state="translated">/platform:anycpu32bitpreferred는 /t:exe, /t:winexe 및 /t:appcontainerexe에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_PathList">
        <source>&lt;path list&gt;</source>
        <target state="translated">&lt;경로 목록&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Text">
        <source>&lt;text&gt;</source>
        <target state="translated">&lt;텍스트&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNullPropagatingOperator">
        <source>null propagating operator</source>
        <target state="translated">null 전파 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedMethod">
        <source>expression-bodied method</source>
        <target state="translated">식 본문 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedProperty">
        <source>expression-bodied property</source>
        <target state="translated">식 본문 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureExpressionBodiedIndexer">
        <source>expression-bodied indexer</source>
        <target state="translated">식 본문 인덱서</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAutoPropertyInitializer">
        <source>auto property initializer</source>
        <target state="translated">자동 속성 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_Namespace1">
        <source>&lt;namespace&gt;</source>
        <target state="translated">&lt;네임스페이스&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefLocalsReturns">
        <source>byref locals and returns</source>
        <target state="translated">byref 지역 및 반환</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureReadOnlyReferences">
        <source>readonly references</source>
        <target state="translated">읽기 전용 참조</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefStructs">
        <source>ref structs</source>
        <target state="translated">ref struct</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationC">
        <source>Compilation (C#): </source>
        <target state="translated">(C#) 컴파일: </target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxNodeIsNotWithinSynt">
        <source>Syntax node is not within syntax tree</source>
        <target state="translated">구문 노드가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">최소 형식 한정자를 제공하려면 위치를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeSemanticModelMust">
        <source>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">최소 형식 한정자를 제공하려면 SyntaxTreeSemanticModel을 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationOf">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">{1} 컴파일에서 '{0}' 형식의 컴파일을 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">구문 트리가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanOnlyInclude">
        <source>Submission can only include script code.</source>
        <target state="translated">스크립트 코드만 포함하여 제출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOne">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">구문 트리를 최대 하나만 제출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWith">
        <source>tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">트리는 SyntaxKind.CompilationUnit을 사용하는 루트 노드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNull">
        <source>Type argument cannot be null</source>
        <target state="translated">형식 인수는 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">형식 인수 수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameConflictForName">
        <source>Name conflict for name {0}</source>
        <target state="translated">{0} 이름에 대한 이름이 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LookupOptionsHasInvalidCombo">
        <source>LookupOptions has an invalid combination of options</source>
        <target state="translated">LookupOptions의 옵션 조합이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemsMustBeNonEmpty">
        <source>items: must be non-empty</source>
        <target state="translated">항목: 비워 두어서는 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseVerbatimIdentifier">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier 또는 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier를 사용하여 식별자 토큰을 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForTokens">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal을 사용하여 문자 리터럴 토큰을 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralForNumeric">
        <source>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</source>
        <target state="translated">Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal을 사용하여 숫자 리터럴 토큰을 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisMethodCanOnlyBeUsedToCreateTokens">
        <source>This method can only be used to create tokens - {0} is not a token kind.</source>
        <target state="translated">이 메서드는 토큰을 만드는 데만 사용할 수 있습니다. {0}은(는) 토큰 종류가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterDefinition">
        <source>Generic parameter is definition when expected to be reference {0}</source>
        <target state="translated">제네릭 매개 변수는 {0} 참조여야 할 때의 정의입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetDeclarationNameMultipleDeclarators">
        <source>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</source>
        <target state="translated">여러 변수 선언자를 포함할 수 있는 선언 노드에 대해 호출된 GetDeclarationName입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeNotPartOfCompilation">
        <source>tree not part of compilation</source>
        <target state="translated">트리는 컴파일의 일부가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree with full span {0}</source>
        <target state="translated">{0} 전체 범위를 사용한 구문 트리 내에 위치가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">{0}' 언어 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name is invalid</source>
        <target state="translated">언어 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedTransparentIdentifierAccess">
        <source>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</source>
        <target state="translated">투명 식별자 멤버가 '{1}'의 '{0}' 필드에 액세스하지 못했습니다. 데이터가 쿼리 패턴 구현에 쿼리되었습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">매개 변수에 고유한 기본값이 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">필드에 고유한 상수 값이 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref">
        <source>Within cref attributes, nested types of generic types should be qualified.</source>
        <target state="translated">cref 특성 내에서 제네릭 형식의 중첩 형식은 정규화되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnqualifiedNestedTypeInCref_Title">
        <source>Within cref attributes, nested types of generic types should be qualified</source>
        <target state="translated">cref 특성 내에서 제네릭 형식의 중첩 형식은 정규화되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotACSharpSymbol">
        <source>Not a C# symbol.</source>
        <target state="translated">C# 기호가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective">
        <source>Unnecessary using directive.</source>
        <target state="translated">불필요한 using 지시문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias">
        <source>Unused extern alias.</source>
        <target state="translated">사용하지 않는 extern 별칭입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">요소는 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_ENV">
        <source>LIB environment variable</source>
        <target state="translated">LIB 환경 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LIB_OPTION">
        <source>/LIB option</source>
        <target state="translated">/LIB 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_REFERENCEPATH_OPTION">
        <source>/REFERENCEPATH option</source>
        <target state="translated">/REFERENCEPATH 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryDoesNotExist">
        <source>directory does not exist</source>
        <target state="translated">디렉터리가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_DirectoryHasInvalidPath">
        <source>path is too long or invalid</source>
        <target state="translated">경로가 너무 길거나 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion">
        <source>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</source>
        <target state="translated">RuntimeMetadataVersion 값을 찾을 수 없습니다. System.Object가 포함된 어셈블리를 찾을 수 없고 옵션을 통해 지정된 RuntimeMetadataVersion 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoRuntimeMetadataVersion_Title">
        <source>No value for RuntimeMetadataVersion found</source>
        <target state="translated">RuntimeMetadataVersion에 대한 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">{0} SemanticModel이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLambda">
        <source>lambda expression</source>
        <target state="translated">람다 식</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion1">
        <source>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 1에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion2">
        <source>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 2에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion3">
        <source>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 3에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion4">
        <source>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 4에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion5">
        <source>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 5에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion6">
        <source>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 6에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7">
        <source>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 7.0에서 사용할 수 없습니다. 언어 버전 {1} 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureIsUnimplemented">
        <source>Feature '{0}' is not implemented in this compiler.</source>
        <target state="translated">이 컴파일러에는 '{0}' 기능이 구현되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VersionExperimental">
        <source>'experimental'</source>
        <target state="translated">'실험적'</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">위치는 구문 트리 범위 내에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">추측한 구문 노드는 현재 컴파일에서 구문 트리에 속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">이론적 의미 체계 모델 연결은 지원되지 않습니다. 비이론적 ParentModel에서 이론적 모델을 만들어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual C# Compiler</source>
        <target state="translated">Microsoft (R) Visual C# 컴파일러</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} 버전 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. All rights reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">지원되는 언어 버전:</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComImportWithInitializers">
        <source>'{0}': a class with the ComImport attribute cannot specify field initializers.</source>
        <target state="translated">'{0}': ComImport 특성이 있는 클래스는 필드 이니셜라이저를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">PDB에 대한 '{0}' 로컬 이름이 너무 깁니다. 줄이거나 /debug 없이 컴파일하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">로컬 이름이 너무 길어서 PDB에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RetNoObjectRequiredLambda">
        <source>Anonymous function converted to a void returning delegate cannot return a value</source>
        <target state="translated">void 반환 대리자로 변환된 익명 함수는 값을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TaskRetNoObjectRequiredLambda">
        <source>Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task&lt;T&gt;'?</source>
        <target state="translated">Task' 반환 대기자로 변환된 비동기 람다 식은 값을 반환할 수 없습니다. 'Task&lt;T&gt;'를 반환하려고 했습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">{0} 분석기 인스턴스는 {1}에서 만들 수 없습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>An analyzer instance cannot be created</source>
        <target state="translated">분석기 인스턴스를 만들 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">{0} 어셈블리에는 분석기가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">어셈블리에는 분석기가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load Analyzer assembly {0} : {1}</source>
        <target state="translated">{0} 분석기 어셈블리를 로드할 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load Analyzer assembly</source>
        <target state="translated">분석기 어셈블리를 로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">ReflectionTypeLoadException로 인해 {0} 분석기 어셈블리에서 일부 형식을 건너뜁니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">{0} ruleset 파일을 읽는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">{0}'에 대한 디버그 정보 읽기 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_OperationCausedStackOverflow">
        <source>Operation caused a stack overflow.</source>
        <target state="translated">작업하는 동안 스택 오버플로가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected">
        <source>Expected identifier or numeric literal.</source>
        <target state="translated">식별자 또는 숫자 리터럴이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IdentifierOrNumericLiteralExpected_Title">
        <source>Expected identifier or numeric literal</source>
        <target state="translated">식별자 또는 숫자 리터럴이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerOnNonAutoProperty">
        <source>Only auto-implemented properties can have initializers.</source>
        <target state="translated">자동 구현 속성만 이니셜라이저를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustHaveGetAccessor">
        <source>Auto-implemented properties must have get accessors.</source>
        <target state="translated">자동 구현 속성은 접근자를 가져와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyMustOverrideSet">
        <source>Auto-implemented properties must override all accessors of the overridden property.</source>
        <target state="translated">자동 구현 속성은 재정의된 속성의 모든 접근자를 재정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStructWithoutExplicitConstructor">
        <source>Structs without explicit constructors cannot contain members with initializers.</source>
        <target state="translated">명시적 생성자가 없는 구조체는 이니셜라이저를 사용하여 멤버를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">인코딩하지 않고 원본 텍스트에 대한 디버그 정보를 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockBodyAndExpressionBody">
        <source>Block bodies and expression bodies cannot both be provided.</source>
        <target state="translated">블록 본문과 식 본문을 둘 다 제공할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchFallOut">
        <source>Control cannot fall out of switch from final case label ('{0}')</source>
        <target state="translated">최종 case 레이블('{0}')의 스위치에서 제어를 이동할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedBoundGenericName">
        <source>Type arguments are not allowed in the nameof operator.</source>
        <target state="translated">nameof 연산자에서는 형식 인수가 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>An expression tree lambda may not contain a null propagating operator.</source>
        <target state="translated">람다 식 트리에는 null 전파 연산자가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DictionaryInitializerInExpressionTree">
        <source>An expression tree lambda may not contain a dictionary initializer.</source>
        <target state="translated">람다 식 트리에는 사전 이니셜라이저가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionCollectionElementInitializerInExpressionTree">
        <source>An extension Add method is not supported for a collection initializer in an expression lambda.</source>
        <target state="translated">람다 식의 컬렉션 이니셜라이저에 대해서는 확장 추가 메서드가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureNameof">
        <source>nameof operator</source>
        <target state="translated">nameof 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDictionaryInitializer">
        <source>dictionary initializer</source>
        <target state="translated">사전 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnclosedExpressionHole">
        <source>Missing close delimiter '}' for interpolated expression started with '{'.</source>
        <target state="translated">{'로 시작하는 보간된 식의 닫는 구분 기호 '}'가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SingleLineCommentInExpressionHole">
        <source>A single-line comment may not be used in an interpolated string.</source>
        <target state="translated">보간된 문자열에는 한 줄로 된 주석을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InsufficientStack">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">식이 너무 길거나 복잡하여 컴파일할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">식에 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubexpressionNotInNameof">
        <source>Sub-expression cannot be used in an argument to nameof.</source>
        <target state="translated">부분식은 nameof에 대한 인수에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AliasQualifiedNameNotAnExpression">
        <source>An alias-qualified name is not an expression.</source>
        <target state="translated">정규화된 별칭 이름은 식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofMethodGroupWithTypeParameters">
        <source>Type parameters are not allowed on a method group as an argument to 'nameof'.</source>
        <target state="translated">형식 매개 변수는 메서드 그룹에서 'nameof'에 대한 인수로 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">SearchCriteria가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">어셈블리 문화권 문자열에는 포함된 NUL 문자가 포함되지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureUsingStatic">
        <source>using static</source>
        <target state="translated">using static</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureInterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">보간된 문자열</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_AwaitInCatchAndFinally">
        <source>await in catch blocks and finally blocks</source>
        <target state="translated">catch 블록 및 finally 블록의 await</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureBinaryLiteral">
        <source>binary literals</source>
        <target state="translated">이진 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureDigitSeparator">
        <source>digit separators</source>
        <target state="translated">숫자 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLocalFunctions">
        <source>local functions</source>
        <target state="translated">로컬 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnescapedCurly">
        <source>A '{0}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">{0}' 문자는 보간된 문자열에서 이중으로 사용하여 이스케이프해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapedCurly">
        <source>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</source>
        <target state="translated">{0}' 문자는 보간된 문자열에서 '{0}{0}'처럼 이중으로 사용하는 방법으로만 이스케이프할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TrailingWhitespaceInFormatSpecifier">
        <source>A format specifier may not contain trailing whitespace.</source>
        <target state="translated">형식 지정자는 후행 공백을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyFormatSpecifier">
        <source>Empty format specifier.</source>
        <target state="translated">형식 지정자가 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorInReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">참조되는 어셈블리 '{0}'에 오류가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOrDeclarationExpected">
        <source>Expression or declaration statement expected.</source>
        <target state="translated">식 또는 선언문이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameofExtensionMethod">
        <source>Extension method groups are not allowed as an argument to 'nameof'.</source>
        <target state="translated">확장 메서드 그룹은 'nameof'에 대한 인수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude">
        <source>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</source>
        <target state="translated">맞춤 값 {0}은(는) {1}보다 커서 큰 형식 문자열로 표시될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedExternAlias_Title">
        <source>Unused extern alias</source>
        <target state="translated">사용하지 않는 extern 별칭</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedUsingDirective_Title">
        <source>Unnecessary using directive</source>
        <target state="translated">불필요한 using 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">ReflectionTypeLoadException으로 인해 실패한 분석기 어셈블리에서 형식 로드를 건너뜀</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AlignmentMagnitude_Title">
        <source>Alignment value has a magnitude that may result in a large formatted string</source>
        <target state="translated">맞춤 값에 큰 형식 문자열로 표시되는 크기가 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">연결에서 생성된 문자열 상수의 길이가 System.Int32.MaxValue를 초과합니다.  문자열을 여러 상수로 분할해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">튜플에는 요소가 두 개 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">디버그 진입점은 현재 컴파일에서 선언된 메서드의 정의여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoadDirectiveOnlyAllowedInScripts">
        <source>#load is only allowed in scripts</source>
        <target state="translated">#load만 스크립트에서 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PPLoadFollowsToken">
        <source>Cannot use #load after first token in file</source>
        <target state="translated">파일에서 첫 토큰 뒤에 #load를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindFile">
        <source>Could not find file.</source>
        <target state="translated">파일을 찾을 수 없습니다.</target>
        <note>File path referenced in source (#load) could not be resolved.</note>
      </trans-unit>
      <trans-unit id="SyntaxTreeFromLoadNoRemoveReplace">
        <source>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</source>
        <target state="translated">SyntaxTree는 #load 지시문에서 생성되었으며 직접 제거하거나 바꿀 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceFileReferencesNotSupported">
        <source>Source file references are not supported.</source>
        <target state="translated">소스 파일 참조는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">pathmap 옵션의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidReal">
        <source>Invalid real literal.</source>
        <target state="translated">실수 리터럴이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCannotBeRefReturning">
        <source>Auto-implemented properties cannot return by reference</source>
        <target state="translated">자동 구현 속성은 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyMustHaveGetAccessor">
        <source>Properties which return by reference must have a get accessor</source>
        <target state="translated">참조로 반환하는 속성에 get 접근자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefPropertyCannotHaveSetAccessor">
        <source>Properties which return by reference cannot have set accessors</source>
        <target state="translated">참조로 반환하는 속성에 set 접근자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantChangeRefReturnOnOverride">
        <source>'{0}' must match by reference return of overridden member '{1}'</source>
        <target state="translated">'{0}'은(는) 재정의된 멤버 '{1}'의 참조에 의한 반환과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustNotHaveRefReturn">
        <source>By-reference returns may only be used in methods that return by reference</source>
        <target state="translated">참조 방식 반환은 참조로 반환하는 메서드에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustHaveRefReturn">
        <source>By-value returns may only be used in methods that return by value</source>
        <target state="translated">By-value 반환은 값으로 반환하는 메서드에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnMustHaveIdentityConversion">
        <source>The return expression must be of type '{0}' because this method returns by reference</source>
        <target state="translated">이 메서드는 참조로 반환하므로 반환 식은 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</source>
        <target state="translated">'{0}'은(는) 인터페이스 멤버 '{1}'을(를) 구현하지 않습니다. '{2}'은(는) 참조에 의한 일치되는 반환 값이 없으므로 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturnRef">
        <source>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</source>
        <target state="translated">{0}'이(가) 참조로 반환되므로 '{0}'의 본문은 반복기 블록이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefReturnExpressionTree">
        <source>Lambda expressions that return by reference cannot be converted to expression trees</source>
        <target state="translated">참조로 반환하는 람다 식을 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</source>
        <target state="translated">람다 식 트리에는 참조로 반환하는 메서드, 속성 또는 인덱서에 대한 호출을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLvalueExpected">
        <source>An expression cannot be used in this context because it may not be passed or returned by reference</source>
        <target state="translated">식은 참조로 전달되거나 반환될 수 없으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal">
        <source>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">{0}'은(는) 참조로 반환될 수 없는 값으로 초기화되었으므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnNonreturnableLocal2">
        <source>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</source>
        <target state="translated">{0}'의 멤버는 참조로 반환될 수 없는 값으로 초기화되었으므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal">
        <source>Cannot return '{0}' by reference because it is read-only</source>
        <target state="translated">{0}'은(는) 읽기 전용이므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnRangeVariable">
        <source>Cannot return the range variable '{0}' by reference</source>
        <target state="translated">범위 변수 '{0}'을(를) 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocalCause">
        <source>Cannot return '{0}' by reference because it is a '{1}'</source>
        <target state="translated">{0}'은(는) '{1}'이므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyLocal2Cause">
        <source>Cannot return fields of '{0}' by reference because it is a '{1}'</source>
        <target state="translated">{0}'의 필드는 '{1}'이므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly">
        <source>A readonly field cannot be returned by writable reference</source>
        <target state="translated">읽기 전용 필드는 쓰기 가능 참조로 반환될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic">
        <source>A static readonly field cannot be returned by writable reference</source>
        <target state="translated">정적 읽기 전용 필드는 쓰기 가능 참조로 반환될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonly2">
        <source>Members of readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">읽기 전용 필드 '{0}'의 멤버는 쓰기 가능 참조로 반환될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnReadonlyStatic2">
        <source>Fields of static readonly field '{0}' cannot be returned by writable reference</source>
        <target state="translated">정적 읽기 전용 필드 '{0}'의 필드는 쓰기 가능 참조로 반환될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter">
        <source>Cannot return a parameter by reference '{0}' because it is not a ref or out parameter</source>
        <target state="translated">{0}' 매개 변수는 ref 또는 out 매개 변수가 아니므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnParameter2">
        <source>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</source>
        <target state="translated">{0}' 매개 변수의 멤버는 ref 또는 out 매개 변수가 아니므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal">
        <source>Cannot return local '{0}' by reference because it is not a ref local</source>
        <target state="translated">{0}' 로컬은 참조 로컬이 아니므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnLocal2">
        <source>Cannot return a member of local '{0}' by reference because it is not a ref local</source>
        <target state="translated">{0}' 로컬의 멤버는 참조 로컬이 아니므로 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturnStructThis">
        <source>Struct members cannot return 'this' or other instance members by reference</source>
        <target state="translated">구조체 멤버는 'this' 또는 다른 인스턴스 멤버를 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeOther">
        <source>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</source>
        <target state="translated">식은 선언 범위 외부의 변수를 간접적으로 노출할 수 있으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeLocal">
        <source>Cannot use local '{0}' in this context because it may expose referenced variables outside of their declaration scope</source>
        <target state="translated">로컬 '{0}'은(는) 선언 범위 외부의 참조 변수를 노출할 수 있으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall">
        <source>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">{0}'의 결과는 선언 범위 외부의 '{1}' 매개 변수에서 참조하는 변수를 노출할 수 있으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeCall2">
        <source>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">{0}' 결과의 멤버는 선언 범위 외부의 '{1}' 매개 변수에서 참조하는 변수를 노출할 수 있으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CallArgMixing">
        <source>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</source>
        <target state="translated">{0}'에 대한 이 인수 조합은 선언 범위 외부의 '{1}' 매개 변수에서 참조하는 변수를 노출할 수 있으므로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedRefEscapeInTernary">
        <source>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</source>
        <target state="translated">ref 조건 연산자의 분기는 호환되지 않는 선언 범위가 포함된 변수를 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EscapeStackAlloc">
        <source>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</source>
        <target state="translated">{0}' 형식 stackalloc 식의 결과는 포함하는 메서드 외부에 노출되는 있으므로 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByValueVariableWithReference">
        <source>Cannot initialize a by-value variable with a reference</source>
        <target state="translated">참조를 사용하여 값 형식 변수를 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializeByReferenceVariableWithValue">
        <source>Cannot initialize a by-reference variable with a value</source>
        <target state="translated">값을 사용하여 참조 형식 변수를 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAssignmentMustHaveIdentityConversion">
        <source>The expression must be of type '{0}' because it is being assigned by reference</source>
        <target state="translated">이 식은 참조로 할당 중이므로 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByReferenceVariableMustBeInitialized">
        <source>A declaration of a by-reference variable must have an initializer</source>
        <target state="translated">by-reference 변수의 선언에 이니셜라이저가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonDelegateCantUseLocal">
        <source>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</source>
        <target state="translated">무명 메서드, 람다 식 또는 쿼리 식에는 참조 로컬 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorLocalType">
        <source>Iterators cannot have by-reference locals</source>
        <target state="translated">반복기에 by-reference 로컬을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncLocalType">
        <source>Async methods cannot have by-reference locals</source>
        <target state="translated">비동기 메서드에 by-reference 로컬을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallAndAwait">
        <source>'await' cannot be used in an expression containing a call to '{0}' because it returns by reference</source>
        <target state="translated">'await'는 참조로 반환되므로 '{0}'에 대한 호출이 포함된 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalAndAwait">
        <source>'await' cannot be used in an expression containing a ref conditional operator</source>
        <target state="translated">'ref 조건 연산자를 포함하는 식에는 'await'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalNeedsTwoRefs">
        <source>Both conditional operator values must be ref values or neither may be a ref value</source>
        <target state="translated">조건 연산자 값은 모두 ref 값이거나 모두 ref 값이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefConditionalDifferentTypes">
        <source>The expression must be of type '{0}' to match the alternative ref value</source>
        <target state="translated">대체 ref 값과 일치하려면 식이 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsLocalFunction">
        <source>An expression tree may not contain a reference to a local function</source>
        <target state="translated">식 트리에는 로컬 함수에 대한 참조를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionParamsParameter">
        <source>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</source>
        <target state="translated">동적 형식의 인수를 로컬 함수 '{1}'의 params 매개 변수 '{0}'에 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">구문 트리가 전송에서 만들어져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</source>
        <target state="translated">프로그램에서 사용하는 사용자 문자열의 결합된 길이가 허용 한도를 초과합니다. 문자열 리터럴의 사용을 줄여 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternNullableType">
        <source>It is not legal to use nullable type '{0}' in a pattern; use the underlying type '{1}' instead.</source>
        <target state="translated">패턴에 nullable 형식 '{0}'을(를) 사용하는 것은 올바르지 않습니다. 대신 기본 형식 '{1}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}.</source>
        <target state="translated">출력 파일을 쓰는 동안 오류가 발생함: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">튜플 요소 이름은 고유해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) {1} 위치에서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) 어떤 위치에서도 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedTypeMemberNotFoundInAssembly">
        <source>Member '{0}' was not found on type '{1}' from assembly '{2}'.</source>
        <target state="translated">어셈블리 '{2}'에서 형식 '{1}'의 멤버 '{0}'이(가) 발견되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureTuples">
        <source>tuples</source>
        <target state="translated">튜플</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingDeconstruct">
        <source>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</source>
        <target state="translated">{1} out 매개 변수 및 void 반환 형식을 사용하는 '{0}' 형식에 대한 적절한 분해 인스턴스 또는 확장 메서드를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructRequiresExpression">
        <source>Deconstruct assignment requires an expression with a type on the right-hand-side.</source>
        <target state="translated">할당을 분해하려면 오른쪽에 형식이 있는 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchExpressionValueExpected">
        <source>The switch expression must be a value; found '{0}'.</source>
        <target state="translated">switch 식은 값이어야 하는데 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongType">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</source>
        <target state="translated">{0}' 형식의 식을 '{1}' 형식의 패턴으로 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">공개 서명이 지정된 경우 '{0}' 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">공개 서명이 지정된 경우 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">옵션 '{0}'은(는) 절대 경로여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionNotTupleCompatible">
        <source>Tuple with {0} elements cannot be converted to type '{1}'.</source>
        <target state="translated">{0}개 요소가 있는 튜플을 '{1}' 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureOutVar">
        <source>out variable declaration</source>
        <target state="translated">출력 변수 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
        <source>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</source>
        <target state="translated">동일한 인수 목록에서 암시적으로 형식화된 출력 변수 '{0}'에 대한 참조는 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
        <source>Cannot infer the type of implicitly-typed out variable '{0}'.</source>
        <target state="translated">암시적으로 형식화된 출력 변수 '{0}'의 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
        <source>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</source>
        <target state="translated">암시적으로 형식화된 분해 변수 '{0}'의 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DiscardTypeInferenceFailed">
        <source>Cannot infer the type of implicitly-typed discard.</source>
        <target state="translated">암시적으로 형식화된 삭제 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructWrongCardinality">
        <source>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</source>
        <target state="translated">{0}' 요소의 튜플을 '{1}' 변수로 분해할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotDeconstructDynamic">
        <source>Cannot deconstruct dynamic objects.</source>
        <target state="translated">동적 개체를 분해할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructTooFewElements">
        <source>Deconstruction must contain at least two variables.</source>
        <target state="translated">분해에는 변수가 두 개 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) 대상 형식 '{1}'에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">튜플 요소 이름은 할당 대상에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a struct.</source>
        <target state="translated">미리 정의된 형식 '{0}'은(는) 구조체여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'new' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'new'는 튜플 형식과 함께 사용할 수 없습니다. 대신 튜플 리터럴 식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeconstructionVarFormDisallowsSpecificType">
        <source>Deconstruction 'var (...)' form disallows a specific type for 'var'.</source>
        <target state="translated">분해 'var (...)' 양식에서는 'var'에 특정 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">컴파일러에서 요구하는 '{0}' 형식을 찾지 못했기 때문에 튜플을 사용하는 클래스 또는 멤버를 정의할 수 없습니다. 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">System.Runtime.CompilerServices.TupleElementNamesAttribute'를 명시적으로 참조할 수 없습니다. 튜플 구문을 사용하여 튜플 이름을 정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsOutVariable">
        <source>An expression tree may not contain an out argument variable declaration.</source>
        <target state="translated">식 트리에는 out 인수 변수 선언을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsDiscard">
        <source>An expression tree may not contain a discard.</source>
        <target state="translated">식 트리에 취소를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsIsMatch">
        <source>An expression tree may not contain an 'is' pattern-matching operator.</source>
        <target state="translated">식 트리에는 'is' 패턴 일치 연산자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleLiteral">
        <source>An expression tree may not contain a tuple literal.</source>
        <target state="translated">식 트리에는 튜플 리터럴을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsTupleConversion">
        <source>An expression tree may not contain a tuple conversion.</source>
        <target state="translated">식 트리에는 튜플 변환을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">/sourcelink 스위치는 PDB를 내보낼 때만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">/embed 스위치는 PDB를 내보낼 때만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">잘못된 계측 종류: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarInvocationLvalueReserved">
        <source>The syntax 'var (...)' as an lvalue is reserved.</source>
        <target state="translated">lvalue인 구문 'var (...)'가 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SemiOrLBraceOrArrowExpected">
        <source>{ or ; or =&gt; expected</source>
        <target state="translated">{ 또는 ; 또는 =&gt; 필요</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ThrowMisplaced">
        <source>A throw expression is not allowed in this context.</source>
        <target state="translated">이 컨텍스트에서는 throw 식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixedDeconstructionUnsupported">
        <source>A deconstruction cannot mix declarations and expressions on the left-hand-side.</source>
        <target state="translated">분해는 왼쪽에 선언과 식을 혼합할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclarationExpressionNotPermitted">
        <source>A declaration is not allowed in this context.</source>
        <target state="translated">이 컨텍스트에서 선언을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustDeclareForeachIteration">
        <source>A foreach loop must declare its iteration variables.</source>
        <target state="translated">foreach 루프는 반복 변수를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesInDeconstruction">
        <source>Tuple element names are not permitted on the left of a deconstruction.</source>
        <target state="translated">분해의 왼쪽에 튜플 요소 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PossibleBadNegCast">
        <source>To cast a negative value, you must enclose the value in parentheses.</source>
        <target state="translated">음의 값을 캐스팅하려면 값을 괄호로 묶어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeContainsThrowExpression">
        <source>An expression tree may not contain a throw-expression.</source>
        <target state="translated">식 트리에는 throw 식이 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">잘못된 어셈블리 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncMethodBuilderTaskProperty">
        <source>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</source>
        <target state="translated">{1}' 형식에 대한 AsyncMethodBuilder로 사용할 '{0}' 형식의 작업 속성은 '{2}' 형식 대신 '{1}' 형식을 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributesInLocalFuncDecl">
        <source>Attributes are not allowed on local function parameters or type parameters</source>
        <target state="translated">특성은 로컬 함수 매개 변수 또는 형식 매개 변수에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">{1}' 어셈블리의 '{0}' 모듈이 여러 어셈블리 '{3}' 및 '{4}'에 '{2}' 형식을 전달하고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternDynamicType">
        <source>It is not legal to use the type 'dynamic' in a pattern.</source>
        <target state="translated">패턴에 'dynamic' 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">제공한 문서 모드가 지원되지 않거나 잘못되었습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">제공된 소스 코드 종류가 지원되지 않거나 잘못되었습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">제공한 언어 버전이 지원되지 않거나 잘못되었습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessingSymbol">
        <source>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</source>
        <target state="translated">전처리 기호의 이름이 잘못되었습니다. '{0}'은(는) 유효한 식별자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_1">
        <source>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 7.1에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_2">
        <source>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</source>
        <target state="translated">{0}' 기능은 C# 7.2에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionCannotHaveLeadingZeroes">
        <source>Specified language version '{0}' cannot have leading zeroes</source>
        <target state="translated">지정된 언어 버전 '{0}'에는 앞에 오는 0을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidAssignment">
        <source>A value of type 'void' may not be assigned.</source>
        <target state="translated">void' 형식의 값을 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}'은(는) 평가 목적으로 제공되며, 이후 업데이트에서 변경되거나 제거될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">형식은 평가 목적으로 제공되며, 이후 업데이트에서 변경되거나 제거될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CompilerAndLanguageVersion">
        <source>Compiler version: '{0}'. Language version: {1}.</source>
        <target state="translated">컴파일러 버전: '{0}'. 언어 버전: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncMain">
        <source>async main</source>
        <target state="translated">비동기 기본</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">튜플 요소 이름 '{0}'이(가) 유추됩니다. 언어 버전 {1} 이상을 사용하여 유추된 이름으로 요소에 액세스하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidInTuple">
        <source>A tuple may not contain a value of type 'void'.</source>
        <target state="translated">튜플에 'void' 형식의 값을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonTaskMainCantBeAsync">
        <source>A void or int returning entry point cannot be async</source>
        <target state="translated">진입점을 반환하는 void 또는 int는 비동기일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PatternWrongGenericTypeInVersion">
        <source>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</source>
        <target state="translated">C# {2}에서는 '{0}' 형식의 식을 '{1}' 형식의 패턴으로 처리할 수 없습니다. 언어 버전 {3} 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction">
        <source>The local function '{0}' is declared but never used</source>
        <target state="translated">로컬 함수 '{0}'이(가) 선언되었지만 사용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreferencedLocalFunction_Title">
        <source>Local function is declared but never used</source>
        <target state="translated">로컬 함수가 선언되었지만 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalFunctionMissingBody">
        <source>Local function '{0}' must declare a body because it is not marked 'static extern'.</source>
        <target state="needs-review-translation">'{0}'은(는) 로컬 함수이므로 항상 본문이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</source>
        <target state="translated">{2}' 어셈블리에서 '{0}' 메서드(토큰 0x{1:X8})의 디버그 정보를 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotCSharpConversion">
        <source>{0} is not a valid C# conversion expression</source>
        <target state="translated">{0}은(는) 유효한 C# 변환 식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DynamicLocalFunctionTypeParameter">
        <source>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</source>
        <target state="translated">유추된 형식 인수가 있는 제네릭 로컬 함수 '{0}'에 동적 형식의 인수를 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureLeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">선행 숫자 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitReservedAttr">
        <source>Do not use '{0}'. This is reserved for compiler usage.</source>
        <target state="translated">{0}'을(를) 사용하지 마세요. 컴파일러 사용을 위해 예약되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeReserved">
        <source>The type name '{0}' is reserved to be used by the compiler.</source>
        <target state="translated">형식 이름 '{0}'은(는) 컴파일러에서 사용하도록 예약되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InExtensionMustBeValueType">
        <source>The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type.</source>
        <target state="translated">'in' 확장 메서드 '{0}'의 첫 번째 매개 변수는 제네릭이 아닌 구체적인 값 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldsInRoStruct">
        <source>Instance fields of readonly structs must be readonly.</source>
        <target state="translated">읽기 전용 구조체의 인스턴스 필드는 읽기 전용이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropsInRoStruct">
        <source>Auto-implemented instance properties in readonly structs must be readonly.</source>
        <target state="translated">읽기 전용 구조체에서 자동으로 구현된 인스턴스 속성은 읽기 전용이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldlikeEventsInRoStruct">
        <source>Field-like events are not allowed in readonly structs.</source>
        <target state="translated">읽기 전용 구조체에는 필드와 유사한 이벤트를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureRefExtensionMethods">
        <source>ref extension methods</source>
        <target state="translated">ref 확장 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StackAllocConversionNotPossible">
        <source>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</source>
        <target state="translated">{0}' 형식 stackalloc 식을 '{1}' 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
        <source>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</source>
        <target state="translated">ref' 확장 메서드 '{0}'의 첫 번째 매개 변수는 값 형식이거나 구조체의 제약을 받는 제네릭 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OutAttrOnInParam">
        <source>An in parameter cannot have the Out attribute.</source>
        <target state="translated">in 매개 변수에는 Out 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
        <source>{0} is not a valid C# compound assignment operation</source>
        <target state="translated">{0}(은)는 유효한 C# 복합 할당 연산이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse">
        <source>Filter expression is a constant 'false', consider removing the catch clause</source>
        <target state="translated">필터 식이 상수 'false'입니다. catch 절을 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalse_Title">
        <source>Filter expression is a constant 'false'</source>
        <target state="translated">필터 식이 상수 'false'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch">
        <source>Filter expression is a constant 'false', consider removing the try-catch block</source>
        <target state="translated">필터 식이 상수 'false'입니다. try-catch 블록을 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FilterIsConstantFalseRedundantTryCatch_Title">
        <source>Filter expression is a constant 'false'. </source>
        <target state="translated">필터 식이 상수 'false'입니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseVoidInArglist">
        <source>__arglist cannot have an argument of void type</source>
        <target state="translated">__arglist에는 void 형식의 인수가 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalInInterpolation">
        <source>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</source>
        <target state="translated">':'은 보간을 끝내므로 조건식을 문자열 보간에 직접 사용할 수 없습니다. 조건식을 괄호를 묶으세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoNotUseFixedBufferAttrOnProperty">
        <source>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</source>
        <target state="translated">속성에서 'System.Runtime.CompilerServices.FixedBuffer' 특성을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FeatureNotAvailableInVersion7_3">
        <source>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</source>
        <target state="translated">'{0}' 기능은 C# 7.3에서 사용할 수 없습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable">
        <source>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</source>
        <target state="translated">Auto 속성의 필드 대상 특성이 언어 버전 {0}에서 지원되지 않습니다. {1} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributesOnBackingFieldsNotAvailable_Title">
        <source>Field-targeted attributes on auto-properties are not supported in this version of the language.</source>
        <target state="translated">Auto 속성의 필드 대상 특성이 이 언어 버전에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FeatureAsyncStreams">
        <source>async streams</source>
        <target state="translated">비동기 스트림</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConvToIAsyncDisp">
        <source>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</source>
        <target state="translated">'{0}': 비동기 using 문에 사용된 형식은 암시적으로 'System.IAsyncDisposable'로 변환할 수 있거나 적합한 'DisposeAsync' 메서드를 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAsyncEnumerator">
        <source>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</source>
        <target state="translated">비동기 foreach의 경우 '{1}'의 반환 형식 '{0}'에 적합한 공용 'MoveNextAsync' 메서드 및 공용 'Current' 속성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleIAsyncEnumOfT">
        <source>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</source>
        <target state="translated">비동기 foreach 문은 '{1}'의 여러 인스턴스화를 구현하므로 '{0}' 형식의 변수에는 foreach 문을 수행할 수 없습니다. 특정 인터페이스 인스턴스화로 캐스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacesCantContainConversionOrEqualityOperators">
        <source>Interfaces cannot contain conversion, equality, or inequality operators</source>
        <target state="translated">인터페이스에는 변환, 같음 또는 같지 않음 연산자가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">대상 런타임이 기본 인터페이스 구현을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</source>
        <target state="translated">대상 런타임이 기본 인터페이스 구현을 지원하지 않으므로 '{0}'이(가) '{2}' 형식의 인터페이스 멤버 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationModifier">
        <source>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</source>
        <target state="translated">C# {1}의 이 항목에는 '{0}' 한정자가 유효하지 않습니다. 언어 버전 '{2}' 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplicitImplementationOfNonPublicInterfaceMember">
        <source>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member.</source>
        <target state="translated">'{0}'은(는) 인터페이스 멤버 '{1}'을(를) 구현하지 않습니다. '{2}'은(는) public이 아닌 멤버를 암시적으로 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MostSpecificImplementationIsNotFound">
        <source>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</source>
        <target state="translated">인터페이스 멤버 '{0}'에 가장 한정적인 구현이 없습니다. '{1}', '{2}' 모두 가장 한정적이지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersionDoesNotSupportDefaultInterfaceImplementationForMember">
        <source>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</source>
        <target state="translated">'{3}' 기능을 C# {4}에서 사용할 수 없으므로 '{0}'이(가) '{2}' 형식의 인터페이스 멤버 '{1}'을(를) 구현할 수 없습니다. 언어 버전 '{5}' 이상을 사용하세요.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>